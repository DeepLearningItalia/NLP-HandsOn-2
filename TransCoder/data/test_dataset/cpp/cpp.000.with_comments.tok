<DOCUMENT_ID="root-mirror/root/tree/master/interpreter/llvm/src/tools/llvm-pdbutil/PrettyExternalSymbolDumper.cpp"> // = = = - ▁ PrettyExternalSymbolDumper . cpp ▁ - - - - - ▁ * - ▁ C + + ▁ * - = = = // ENDCOM // ▁ The ▁ LLVM ▁ Compiler ▁ Infrastructure ENDCOM // ▁ This ▁ file ▁ is ▁ distributed ▁ under ▁ the ▁ University ▁ of ▁ Illinois ▁ Open ▁ Source ENDCOM // ▁ License . ▁ See ▁ LICENSE . TXT ▁ for ▁ details . ENDCOM # include " PrettyExternalSymbolDumper . h " # include " LinePrinter . h " # include " llvm / DebugInfo / PDB / PDBSymbolExe . h " # include " llvm / DebugInfo / PDB / PDBSymbolPublicSymbol . h " # include " llvm / Support / Format . h " using namespace llvm ; using namespace llvm :: pdb ; ExternalSymbolDumper :: ExternalSymbolDumper ( LinePrinter & P ) : PDBSymDumper ( true ) , Printer ( P ) { } void ExternalSymbolDumper :: start ( const PDBSymbolExe & Symbol ) { auto Vars = Symbol . findAllChildren < PDBSymbolPublicSymbol > ( ) ; while ( auto Var = Vars -> getNext ( ) ) Var -> dump ( * this ) ; } void ExternalSymbolDumper :: dump ( const PDBSymbolPublicSymbol & Symbol ) { std :: string LinkageName = Symbol . getName ( ) ; if ( Printer . IsSymbolExcluded ( LinkageName ) ) return ; Printer . NewLine ( ) ; uint64_t Addr = Symbol . getVirtualAddress ( ) ; Printer << " [ " ; WithColor ( Printer , PDB_ColorItem :: Address ) . get ( ) << format_hex ( Addr , 10 ) ; Printer << " ] ▁ " ; WithColor ( Printer , PDB_ColorItem :: Identifier ) . get ( ) << LinkageName ; } </DOCUMENT>
<DOCUMENT_ID="lopezloo/mtasa-blue/tree/master/Client/mods/deathmatch/logic/CCustomData.cpp"> /* * * * * STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ PROJECT : ▁ Multi ▁ Theft ▁ Auto ▁ v1.0 STRNEWLINE ▁ * ▁ ( Shared ▁ logic ▁ for ▁ modifications ) STRNEWLINE ▁ * ▁ LICENSE : ▁ See ▁ LICENSE ▁ in ▁ the ▁ top ▁ level ▁ directory STRNEWLINE ▁ * ▁ FILE : ▁ mods / shared _ logic / CCustomData . cpp STRNEWLINE ▁ * ▁ PURPOSE : ▁ Custom ▁ data ▁ storage ▁ class STRNEWLINE ▁ * STRNEWLINE ▁ * * * * */ # include " StdInc . h " # define DECLARE_PROFILER_SECTION_CCustomData # include " profiler / SharedUtil . Profiler . h " void CCustomData :: Copy ( CCustomData * pCustomData ) { std :: map < std :: string , SCustomData > :: const_iterator iter = pCustomData -> IterBegin ( ) ; for ( ; iter != pCustomData -> IterEnd ( ) ; iter ++ ) { Set ( iter -> first . c_str ( ) , iter -> second . Variable ) ; } } SCustomData * CCustomData :: Get ( const char * szName ) { assert ( szName ) ; std :: map < std :: string , SCustomData > :: iterator it = m_Data . find ( szName ) ; if ( it != m_Data . end ( ) ) return & it -> second ; return NULL ; } void CCustomData :: Set ( const char * szName , const CLuaArgument & Variable , bool bSynchronized ) { assert ( szName ) ; // ▁ Grab ▁ the ▁ item ▁ with ▁ the ▁ given ▁ name ENDCOM SCustomData * pData = Get ( szName ) ; if ( pData ) { // ▁ Update ▁ existing ENDCOM pData -> Variable = Variable ; pData -> bSynchronized = bSynchronized ; } else { // ▁ Add ▁ new ENDCOM SCustomData newData ; newData . Variable = Variable ; newData . bSynchronized = bSynchronized ; m_Data [ szName ] = newData ; } } bool CCustomData :: Delete ( const char * szName ) { // ▁ Find ▁ the ▁ item ▁ and ▁ delete ▁ it ENDCOM std :: map < std :: string , SCustomData > :: iterator it = m_Data . find ( szName ) ; if ( it != m_Data . end ( ) ) { m_Data . erase ( it ) ; return true ; } // ▁ Didn ' t ▁ exist ENDCOM return false ; } </DOCUMENT>
<DOCUMENT_ID="esqudo/cymrucoin/tree/master/src/qt/aboutdialog.cpp"> # include " aboutdialog . h " # include " ui _ aboutdialog . h " # include " clientmodel . h " # include " clientversion . h " // ▁ Copyright ▁ year ▁ ( 2009 - this ) ENDCOM // ▁ Todo : ▁ update ▁ this ▁ when ▁ changing ▁ our ▁ copyright ▁ comments ▁ in ▁ the ▁ source ENDCOM const int ABOUTDIALOG_COPYRIGHT_YEAR = 2014 ; AboutDialog :: AboutDialog ( QWidget * parent ) : QDialog ( parent ) , ui ( new Ui :: AboutDialog ) { ui -> setupUi ( this ) ; // ▁ Set ▁ current ▁ copyright ▁ year ENDCOM ui -> copyrightLabel -> setText ( tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ 2009 - % 1 ▁ " ) . arg ( COPYRIGHT_YEAR ) + tr ( " The ▁ Bitcoin ▁ developers " ) + QString ( " < br > " ) + tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ " ) + tr ( " % 1 ▁ StartJOIN " ) . arg ( ABOUTDIALOG_COPYRIGHT_YEAR ) ) ; } void AboutDialog :: setModel ( ClientModel * model ) { if ( model ) { ui -> versionLabel -> setText ( model -> formatFullVersion ( ) ) ; } } AboutDialog :: ~ AboutDialog ( ) { delete ui ; } void AboutDialog :: on_buttonBox_accepted ( ) { close ( ) ; } </DOCUMENT>
<DOCUMENT_ID="regneq/TrinityCore/tree/master/src/server/game/Miscellaneous/CommonPredicates.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2008-2019 ▁ TrinityCore ▁ < https : // www . trinitycore . org / > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it STRNEWLINE ▁ * ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the STRNEWLINE ▁ * ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your STRNEWLINE ▁ * ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT STRNEWLINE ▁ * ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or STRNEWLINE ▁ * ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for STRNEWLINE ▁ * ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along STRNEWLINE ▁ * ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ */ # include " CommonPredicates . h " # include " Common . h " # include " Unit . h " # include " SharedDefines . h " Trinity :: Predicates :: IsVictimOf :: IsVictimOf ( Unit const * attacker ) : _victim ( attacker ? attacker -> GetVictim ( ) : nullptr ) { } </DOCUMENT>
<DOCUMENT_ID="station7/xbmc/tree/master/xbmc/platform/android/jni/System.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2013 ▁ Team ▁ XBMC STRNEWLINE ▁ * ▁ http : // xbmc . org STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ Program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 , ▁ or ▁ ( at ▁ your ▁ option ) STRNEWLINE ▁ * ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ Program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ XBMC ; ▁ see ▁ the ▁ file ▁ COPYING . ▁ If ▁ not , ▁ see STRNEWLINE ▁ * ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ * STRNEWLINE ▁ */ # include " System . h " # include " jutils / jutils - details . hpp " using namespace jni ; std :: string CJNISystem :: getProperty ( const std :: string & property ) { return jcast < std :: string > ( call_static_method < jhstring > ( " java / lang / System " , " getProperty " , " ( Ljava / lang / String ; ) Ljava / lang / String ; " , jcast < jhstring > ( property ) ) ) ; } std :: string CJNISystem :: getProperty ( const std :: string & property , const std :: string & defaultValue ) { return jcast < std :: string > ( call_static_method < jhstring > ( " java / lang / System " , " getProperty " , " ( Ljava / lang / String ; Ljava / lang / String ; ) Ljava / lang / String ; " , jcast < jhstring > ( property ) , jcast < jhstring > ( defaultValue ) ) ) ; } std :: string CJNISystem :: setProperty ( const std :: string & property , const std :: string & defaultValue ) { return jcast < std :: string > ( call_static_method < jhstring > ( " java / lang / System " , " setProperty " , " ( Ljava / lang / String ; Ljava / lang / String ; ) Ljava / lang / String ; " , jcast < jhstring > ( property ) , jcast < jhstring > ( defaultValue ) ) ) ; } std :: string CJNISystem :: clearProperty ( const std :: string & property ) { return jcast < std :: string > ( call_static_method < jhstring > ( " java / lang / System " , " clearProperty " , " ( Ljava / lang / String ; ) Ljava / lang / String ; " , jcast < jhstring > ( property ) ) ) ; } int64_t CJNISystem :: nanoTime ( ) { return call_static_method < jlong > ( " java / lang / System " , " nanoTime " , " ( ) J " ) ; } </DOCUMENT>
<DOCUMENT_ID="Microsoft/PTVS/tree/master/Python/Tests/GlassTests/PythonTests/Python/StepPythonToNative_IterNext/cpp_mod.cpp"> # pragma optimize ( " " , off ) # include < python . h > struct CppObj { PyObject_HEAD } ; PyObject * CppObj_iternext ( PyObject * self ) { Py_RETURN_NONE ; } PyTypeObject * CppObj_type ( ) { static PyTypeObject t = { PyVarObject_HEAD_INIT ( NULL , 0 ) } ; t . tp_name = " cpp _ mod . CppObj " ; t . tp_basicsize = sizeof CppObj ; t . tp_flags = Py_TPFLAGS_DEFAULT ; t . tp_iternext = CppObj_iternext ; return & t ; } PyMethodDef methods [ ] = { NULL } ; PyTypeObject * types [ ] = { CppObj_type ( ) , NULL } ; </DOCUMENT>
<DOCUMENT_ID="celeron55/clementine/tree/master/3rdparty/libprojectm/Renderer/Pipeline.cpp"> /* STRNEWLINE ▁ * ▁ Pipeline . cpp STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Created ▁ on : ▁ Jun ▁ 17 , ▁ 2008 STRNEWLINE ▁ * ▁ Author : ▁ pete STRNEWLINE ▁ */ # include " Pipeline . hpp " # include " wipemalloc . h " Pipeline :: Pipeline ( ) : staticPerPixel ( false ) , gx ( 0 ) , gy ( 0 ) , blur1n ( 1 ) , blur2n ( 1 ) , blur3n ( 1 ) , blur1x ( 1 ) , blur2x ( 1 ) , blur3x ( 1 ) , blur1ed ( 1 ) { } void Pipeline :: setStaticPerPixel ( int gx , int gy ) { staticPerPixel = true ; this -> gx = gx ; this -> gy = gy ; this -> x_mesh = ( float * * ) wipemalloc ( gx * sizeof ( float * ) ) ; for ( int x = 0 ; x < gx ; x ++ ) { this -> x_mesh [ x ] = ( float * ) wipemalloc ( gy * sizeof ( float ) ) ; } this -> y_mesh = ( float * * ) wipemalloc ( gx * sizeof ( float * ) ) ; for ( int x = 0 ; x < gx ; x ++ ) { this -> y_mesh [ x ] = ( float * ) wipemalloc ( gy * sizeof ( float ) ) ; } } Pipeline :: ~ Pipeline ( ) { if ( staticPerPixel ) { for ( int x = 0 ; x < this -> gx ; x ++ ) { free ( this -> x_mesh [ x ] ) ; free ( this -> y_mesh [ x ] ) ; } free ( x_mesh ) ; free ( y_mesh ) ; } } // void ▁ Pipeline : : Render ( const ▁ BeatDetect ▁ & music , ▁ const ▁ PipelineContext ▁ & context ) { } ENDCOM PixelPoint Pipeline :: PerPixel ( PixelPoint p , const PerPixelContext context ) { return p ; } </DOCUMENT>
<DOCUMENT_ID="Distrotech/xbmc/tree/master/xbmc/android/jni/BaseColumns.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2013 ▁ Team ▁ XBMC STRNEWLINE ▁ * ▁ http : // xbmc . org STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ Program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 , ▁ or ▁ ( at ▁ your ▁ option ) STRNEWLINE ▁ * ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ Program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ XBMC ; ▁ see ▁ the ▁ file ▁ COPYING . ▁ If ▁ not , ▁ see STRNEWLINE ▁ * ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ * STRNEWLINE ▁ */ # include " BaseColumns . h " # include " jutils / jutils - details . hpp " using namespace jni ; std :: string CJNIBaseColumns :: _ID ; std :: string CJNIBaseColumns :: _COUNT ; void CJNIBaseColumns :: PopulateStaticFields ( ) { jhclass clazz = find_class ( " android / provider / BaseColumns " ) ; _ID = ( jcast < std :: string > ( get_static_field < jhstring > ( clazz , " _ ID " ) ) ) ; _COUNT = ( jcast < std :: string > ( get_static_field < jhstring > ( clazz , " _ COUNT " ) ) ) ; } </DOCUMENT>
<DOCUMENT_ID="PKRoma/poedit/tree/master/deps/boost/libs/phoenix/test/container/container_tests8a.cpp"> /* = = = = = STRNEWLINE ▁ Copyright ▁ ( c ) ▁ 2004 ▁ Angus ▁ Leeming STRNEWLINE ▁ Copyright ▁ ( c ) ▁ 2017 ▁ Kohei ▁ Takahashi STRNEWLINE STRNEWLINE ▁ Distributed ▁ under ▁ the ▁ Boost ▁ Software ▁ License , ▁ Version ▁ 1.0 . ▁ ( See ▁ accompanying ▁ STRNEWLINE ▁ file ▁ LICENSE _ 1_0 . txt ▁ or ▁ copy ▁ at ▁ http : // www . boost . org / LICENSE _ 1_0 . txt ) STRNEWLINE = = = = = */ # include " container _ tests . hpp " # include < boost / static_assert . hpp > std :: set < int > const build_set ( ) { typedef std :: set < int > int_set ; typedef std :: vector < int > int_vector ; int_set result ; int_vector const data = build_vector ( ) ; int_vector :: const_iterator it = data . begin ( ) ; int_vector :: const_iterator const end = data . end ( ) ; result . insert ( it , end ) ; return result ; } std :: multiset < int > const build_multiset ( ) { typedef std :: set < int > int_set ; typedef std :: multiset < int > int_multiset ; int_set const data = build_set ( ) ; return int_multiset ( data . begin ( ) , data . end ( ) ) ; } std :: vector < int > const init_vector ( ) { typedef std :: vector < int > int_vector ; int const data [ ] = { - 4 , - 3 , - 2 , - 1 , 0 } ; int_vector :: size_type const data_size = sizeof ( data ) / sizeof ( data [ 0 ] ) ; return int_vector ( data , data + data_size ) ; } std :: vector < int > const build_vector ( ) { typedef std :: vector < int > int_vector ; static int_vector data = init_vector ( ) ; int_vector :: size_type const size = data . size ( ) ; int_vector :: iterator it = data . begin ( ) ; int_vector :: iterator const end = data . end ( ) ; for ( ; it != end ; ++ it ) * it += size ; return data ; } int main ( ) { BOOST_STATIC_ASSERT ( ( ! phx :: stl :: has_mapped_type < std :: multiset < int > > :: value ) ) ; BOOST_STATIC_ASSERT ( ( phx :: stl :: has_key_type < std :: multiset < int > > :: value ) ) ; std :: multiset < int > const data = build_multiset ( ) ; test_begin ( data ) ; test_clear ( data ) ; test_empty ( data ) ; test_end ( data ) ; test_set_erase ( data ) ; test_get_allocator ( data ) ; return boost :: report_errors ( ) ; } </DOCUMENT>
<DOCUMENT_ID="Dmitry-Me/coreclr/tree/master/src/jit/lowerarm.cpp"> // ▁ Licensed ▁ to ▁ the ▁ . NET ▁ Foundation ▁ under ▁ one ▁ or ▁ more ▁ agreements . ENDCOM // ▁ The ▁ . NET ▁ Foundation ▁ licenses ▁ this ▁ file ▁ to ▁ you ▁ under ▁ the ▁ MIT ▁ license . ENDCOM // ▁ See ▁ the ▁ LICENSE ▁ file ▁ in ▁ the ▁ project ▁ root ▁ for ▁ more ▁ information . ENDCOM /* XXXXX STRNEWLINE XXXXX STRNEWLINE XX ▁ XX STRNEWLINE XX ▁ Lowering ▁ for ▁ ARM ▁ XX STRNEWLINE XX ▁ XX STRNEWLINE XX ▁ This ▁ encapsulates ▁ all ▁ the ▁ logic ▁ for ▁ lowering ▁ trees ▁ for ▁ the ▁ ARM ▁ XX STRNEWLINE XX ▁ architecture . ▁ For ▁ a ▁ more ▁ detailed ▁ view ▁ of ▁ what ▁ is ▁ lowering , ▁ please ▁ XX STRNEWLINE XX ▁ take ▁ a ▁ look ▁ at ▁ Lower . cpp ▁ XX STRNEWLINE XX ▁ XX STRNEWLINE XX ▁ XX STRNEWLINE XXXXX STRNEWLINE XXXXX STRNEWLINE */ # include " jitpch . h " # ifdef _MSC_VER # pragma hdrstop # endif # ifndef LEGACY_BACKEND // ▁ This ▁ file ▁ is ▁ ONLY ▁ used ▁ for ▁ the ▁ RyuJIT ▁ backend ▁ that ▁ uses ▁ the ▁ linear ▁ scan ▁ register ▁ allocator ENDCOM // ▁ The ▁ ARM ▁ backend ▁ is ▁ not ▁ yet ▁ implemented , ▁ so ▁ the ▁ methods ▁ here ▁ are ▁ all ▁ NYI . ENDCOM // ▁ TODO - ARM - NYI : ▁ Lowering ▁ for ▁ ARM . ENDCOM # ifdef _TARGET_ARM_ # include " jit . h " # include " sideeffects . h " # include " lower . h " # include " lsra . h " /* ▁ Lowering ▁ of ▁ GT _ CAST ▁ nodes ▁ */ void Lowering :: LowerCast ( GenTree * tree ) { NYI_ARM ( " ARM ▁ Lowering ▁ for ▁ cast " ) ; } void Lowering :: LowerRotate ( GenTreePtr tree ) { NYI_ARM ( " ARM ▁ Lowering ▁ for ▁ ROL ▁ and ▁ ROR " ) ; } void Lowering :: TreeNodeInfoInit ( GenTree * stmt ) { NYI ( " ARM ▁ TreeNodInfoInit " ) ; } // ▁ returns ▁ true ▁ if ▁ the ▁ tree ▁ can ▁ use ▁ the ▁ read - modify - write ▁ memory ▁ instruction ▁ form ENDCOM bool Lowering :: isRMWRegOper ( GenTreePtr tree ) { return false ; } bool Lowering :: IsCallTargetInRange ( void * addr ) { return comp -> codeGen -> validImmForBL ( ( ssize_t ) addr ) ; } // ▁ return ▁ true ▁ if ▁ the ▁ immediate ▁ can ▁ be ▁ folded ▁ into ▁ an ▁ instruction , ▁ for ▁ example ▁ small ▁ enough ▁ and ▁ non - relocatable ENDCOM bool Lowering :: IsContainableImmed ( GenTree * parentNode , GenTree * childNode ) { NYI_ARM ( " ARM ▁ IsContainableImmed " ) ; return false ; } # endif // ▁ _ TARGET _ ARM _ ENDCOM # endif // ▁ ! LEGACY _ BACKEND ENDCOM </DOCUMENT>
<DOCUMENT_ID="hkarim/JUCE-Graph-Component/tree/master/JuceLibraryCode/modules/juce_gui_basics/filebrowser/juce_ImagePreviewComponent.cpp"> /*  STRNEWLINE ▁ = = = = =  STRNEWLINE  STRNEWLINE ▁ This ▁ file ▁ is ▁ part ▁ of ▁ the ▁ JUCE ▁ library .  STRNEWLINE ▁ Copyright ▁ ( c ) ▁ 2015 ▁ - ▁ ROLI ▁ Ltd .  STRNEWLINE  STRNEWLINE ▁ Permission ▁ is ▁ granted ▁ to ▁ use ▁ this ▁ software ▁ under ▁ the ▁ terms ▁ of ▁ either :  STRNEWLINE ▁ a ) ▁ the ▁ GPL ▁ v2 ▁ ( or ▁ any ▁ later ▁ version )  STRNEWLINE ▁ b ) ▁ the ▁ Affero ▁ GPL ▁ v3 STRNEWLINE  STRNEWLINE ▁ Details ▁ of ▁ these ▁ licenses ▁ can ▁ be ▁ found ▁ at : ▁ www . gnu . org / licenses STRNEWLINE  STRNEWLINE ▁ JUCE ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT ▁ ANY STRNEWLINE ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR STRNEWLINE ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details .  STRNEWLINE  STRNEWLINE ▁ - - - - -  STRNEWLINE  STRNEWLINE ▁ To ▁ release ▁ a ▁ closed - source ▁ product ▁ which ▁ uses ▁ JUCE , ▁ commercial ▁ licenses ▁ are STRNEWLINE ▁ available : ▁ visit ▁ www . juce . com ▁ for ▁ more ▁ information .  STRNEWLINE  STRNEWLINE ▁ = = = = =  STRNEWLINE */ ImagePreviewComponent :: ImagePreviewComponent ( ) { } ImagePreviewComponent :: ~ ImagePreviewComponent ( ) { } void ImagePreviewComponent :: getThumbSize ( int & w , int & h ) const { const int availableW = proportionOfWidth ( 0.97f ) ; const int availableH = getHeight ( ) - 13 * 4 ; const double scale = jmin ( 1.0 , availableW / ( double ) w , availableH / ( double ) h ) ; w = roundToInt ( scale * w ) ; h = roundToInt ( scale * h ) ; } void ImagePreviewComponent :: selectedFileChanged ( const File & file ) { if ( fileToLoad != file ) { fileToLoad = file ; startTimer ( 100 ) ; } } void ImagePreviewComponent :: timerCallback ( ) { stopTimer ( ) ; currentThumbnail = Image ( ) ; currentDetails . clear ( ) ; repaint ( ) ; ScopedPointer < FileInputStream > in ( fileToLoad . createInputStream ( ) ) ; if ( in != nullptr ) { if ( ImageFileFormat * const format = ImageFileFormat :: findImageFormatForStream ( * in ) ) { currentThumbnail = format -> decodeImage ( * in ) ; if ( currentThumbnail . isValid ( ) ) { int w = currentThumbnail . getWidth ( ) ; int h = currentThumbnail . getHeight ( ) ; currentDetails << fileToLoad . getFileName ( ) << " \n " << format -> getFormatName ( ) << " \n " << w << " ▁ x ▁ " << h << " ▁ pixels \n " << File :: descriptionOfSizeInBytes ( fileToLoad . getSize ( ) ) ; getThumbSize ( w , h ) ; currentThumbnail = currentThumbnail . rescaled ( w , h ) ; } } } } void ImagePreviewComponent :: paint ( Graphics & g ) { if ( currentThumbnail . isValid ( ) ) { g . setFont ( 13.0f ) ; int w = currentThumbnail . getWidth ( ) ; int h = currentThumbnail . getHeight ( ) ; getThumbSize ( w , h ) ; const int numLines = 4 ; const int totalH = 13 * numLines + h + 4 ; const int y = ( getHeight ( ) - totalH ) / 2 ; g . drawImageWithin ( currentThumbnail , ( getWidth ( ) - w ) / 2 , y , w , h , RectanglePlacement :: centred | RectanglePlacement :: onlyReduceInSize , false ) ; g . drawFittedText ( currentDetails , 0 , y + h + 4 , getWidth ( ) , 100 , Justification :: centredTop , numLines ) ; } } </DOCUMENT>
<DOCUMENT_ID="AshamaneProject/AshamaneCore/tree/master/dep/CascLib/src/CascDecompress.cpp"> /* ▁ CascDecompress . cpp ▁ Copyright ▁ ( c ) ▁ Ladislav ▁ Zezula ▁ 2014 ▁ */ /* ▁ Decompression ▁ functions ▁ */ /* ▁ Date ▁ Ver ▁ Who ▁ Comment ▁ */ /* ▁ 02.05.14 ▁ 1.00 ▁ Lad ▁ The ▁ first ▁ version ▁ of ▁ CascDecompress . cpp ▁ */ # define __CASCLIB_SELF__ # include " CascLib . h " # include " CascCommon . h " // ▁ Public ▁ functions ENDCOM DWORD CascDecompress ( LPBYTE pbOutBuffer , PDWORD pcbOutBuffer , LPBYTE pbInBuffer , DWORD cbInBuffer ) { z_stream z ; // ▁ Stream ▁ information ▁ for ▁ zlib ENDCOM DWORD dwErrCode = ERROR_FILE_CORRUPT ; uInt cbOutBuffer = * pcbOutBuffer ; int nResult ; // ▁ Fill ▁ the ▁ stream ▁ structure ▁ for ▁ zlib ENDCOM z . next_in = pbInBuffer ; z . avail_in = cbInBuffer ; z . total_in = cbInBuffer ; z . next_out = pbOutBuffer ; z . avail_out = cbOutBuffer ; z . total_out = 0 ; z . zalloc = NULL ; z . zfree = NULL ; // ▁ Reset ▁ the ▁ total ▁ number ▁ of ▁ output ▁ bytes ENDCOM cbOutBuffer = 0 ; // ▁ Initialize ▁ the ▁ decompression ▁ structure ENDCOM if ( ( nResult = inflateInit ( & z ) ) == Z_OK ) { // ▁ Call ▁ zlib ▁ to ▁ decompress ▁ the ▁ data ENDCOM nResult = inflate ( & z , Z_NO_FLUSH ) ; if ( nResult == Z_OK || nResult == Z_STREAM_END ) { // ▁ Give ▁ the ▁ size ▁ of ▁ the ▁ uncompressed ▁ data ENDCOM cbOutBuffer = z . total_out ; dwErrCode = ERROR_SUCCESS ; } inflateEnd ( & z ) ; } // ▁ Give ▁ the ▁ caller ▁ the ▁ number ▁ of ▁ bytes ▁ needed ENDCOM pcbOutBuffer [ 0 ] = cbOutBuffer ; return dwErrCode ; } </DOCUMENT>
<DOCUMENT_ID="jobermayr/pcsx2/tree/master/3rdparty/wxwidgets3.0/src/common/filectrlcmn.cpp"> // ▁ Name : ▁ src / common / filectrlcmn . cpp ENDCOM // ▁ Purpose : ▁ Implementation ▁ for ▁ wxFileCtrlBase ▁ and ▁ other ▁ common ▁ functions ▁ used ▁ by ENDCOM // ▁ platform - specific ▁ wxFileCtrl ' s ENDCOM // ▁ Author : ▁ Diaa ▁ M . ▁ Sami ENDCOM // ▁ Created : ▁ 2007-07-07 ENDCOM // ▁ Copyright : ▁ ( c ) ▁ Diaa ▁ M . ▁ Sami ENDCOM // ▁ Licence : ▁ wxWindows ▁ licence ENDCOM # include " wx / wxprec . h " # ifdef __BORLANDC__ # pragma hdrstop # endif # if wxUSE_FILECTRL # include " wx / filectrl . h " # ifndef WX_PRECOMP # include " wx / debug . h " # endif const char wxFileCtrlNameStr [ ] = " wxfilectrl " ; wxDEFINE_EVENT ( wxEVT_FILECTRL_SELECTIONCHANGED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FILEACTIVATED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FOLDERCHANGED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FILTERCHANGED , wxFileCtrlEvent ) ; IMPLEMENT_DYNAMIC_CLASS ( wxFileCtrlEvent , wxCommandEvent ) // ▁ some ▁ helper ▁ functions ENDCOM void GenerateFilterChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FILTERCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetFilterIndex ( fileCtrl -> GetFilterIndex ( ) ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateFolderChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FOLDERCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateSelectionChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_SELECTIONCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wxArrayString filenames ; fileCtrl -> GetFilenames ( filenames ) ; event . SetFiles ( filenames ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateFileActivatedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd , const wxString filename ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FILEACTIVATED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wxArrayString filenames ; if ( filename . empty ( ) ) { fileCtrl -> GetFilenames ( filenames ) ; } else { filenames . Add ( filename ) ; } event . SetFiles ( filenames ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } // ▁ wxFileCtrlEvent ▁ implementation ENDCOM wxString wxFileCtrlEvent :: GetFile ( ) const { wxASSERT_MSG ( ! wxDynamicCast ( GetEventObject ( ) , wxFileCtrl ) -> HasMultipleFileSelection ( ) , wxT ( " Please ▁ use ▁ GetFiles ( ) ▁ to ▁ get ▁ all ▁ files ▁ instead ▁ of ▁ this ▁ function " ) ) ; wxString string ; if ( m_files . Count ( ) != 0 ) string = m_files [ 0 ] ; return string ; } # endif // ▁ wxUSE _ FILECTRL ENDCOM </DOCUMENT>
<DOCUMENT_ID="llvm-mirror/clang/tree/master/unittests/Frontend/CodeGenActionTest.cpp"> // = = = - ▁ unittests / Frontend / CodeGenActionTest . cpp ▁ - - - ▁ FrontendAction ▁ tests ▁ - - = = = // ENDCOM // ▁ Part ▁ of ▁ the ▁ LLVM ▁ Project , ▁ under ▁ the ▁ Apache ▁ License ▁ v2.0 ▁ with ▁ LLVM ▁ Exceptions . ENDCOM // ▁ See ▁ https : // llvm . org / LICENSE . txt ▁ for ▁ license ▁ information . ENDCOM // ▁ SPDX - License - Identifier : ▁ Apache - 2.0 ▁ WITH ▁ LLVM - exception ENDCOM // ▁ Unit ▁ tests ▁ for ▁ CodeGenAction . ENDCOM # include " clang / CodeGen / CodeGenAction . h " # include " clang / Basic / LangStandard . h " # include " clang / CodeGen / BackendUtil . h " # include " clang / Frontend / CompilerInstance . h " # include " clang / Lex / PreprocessorOptions . h " # include " gtest / gtest . h " using namespace llvm ; using namespace clang ; using namespace clang :: frontend ; namespace { class NullCodeGenAction : public CodeGenAction { public : NullCodeGenAction ( llvm :: LLVMContext * _VMContext = nullptr ) : CodeGenAction ( Backend_EmitMCNull , _VMContext ) { } // ▁ The ▁ action ▁ does ▁ not ▁ call ▁ methods ▁ of ▁ ATContext . ENDCOM void ExecuteAction ( ) override { CompilerInstance & CI = getCompilerInstance ( ) ; if ( ! CI . hasPreprocessor ( ) ) return ; if ( ! CI . hasSema ( ) ) CI . createSema ( getTranslationUnitKind ( ) , nullptr ) ; } } ; TEST ( CodeGenTest , TestNullCodeGen ) { auto Invocation = std :: make_shared < CompilerInvocation > ( ) ; Invocation -> getPreprocessorOpts ( ) . addRemappedFile ( " test . cc " , MemoryBuffer :: getMemBuffer ( " " ) . release ( ) ) ; Invocation -> getFrontendOpts ( ) . Inputs . push_back ( FrontendInputFile ( " test . cc " , Language :: CXX ) ) ; Invocation -> getFrontendOpts ( ) . ProgramAction = EmitLLVM ; Invocation -> getTargetOpts ( ) . Triple = " i386 - unknown - linux - gnu " ; CompilerInstance Compiler ; Compiler . setInvocation ( std :: move ( Invocation ) ) ; Compiler . createDiagnostics ( ) ; EXPECT_TRUE ( Compiler . hasDiagnostics ( ) ) ; std :: unique_ptr < FrontendAction > Act ( new NullCodeGenAction ) ; bool Success = Compiler . ExecuteAction ( * Act ) ; EXPECT_TRUE ( Success ) ; } } </DOCUMENT>
<DOCUMENT_ID="Riztazz/trinitycore-m4a/tree/master/src/server/scripts/EasternKingdoms/Stratholme/boss_nerubenkan.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2008-2013 ▁ TrinityCore ▁ < http : // www . trinitycore . org / > STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2006-2009 ▁ ScriptDev2 ▁ < https : // scriptdev2 . svn . sourceforge . net / > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it STRNEWLINE ▁ * ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the STRNEWLINE ▁ * ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your STRNEWLINE ▁ * ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT STRNEWLINE ▁ * ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or STRNEWLINE ▁ * ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for STRNEWLINE ▁ * ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along STRNEWLINE ▁ * ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ */ /* ▁ ScriptData STRNEWLINE SDName : ▁ Boss _ Nerubenkan STRNEWLINE SD % Complete : ▁ 70 STRNEWLINE SDComment : STRNEWLINE SDCategory : ▁ Stratholme STRNEWLINE EndScriptData ▁ */ # include " stdafx . hpp " # include " ScriptMgr . h " # include " ScriptedCreature . h " # include " stratholme . h " enum Spells { SPELL_ENCASINGWEBS = 4962 , SPELL_PIERCEARMOR = 6016 , SPELL_CRYPT_SCARABS = 31602 , SPELL_RAISEUNDEADSCARAB = 17235 } ; class boss_nerubenkan : public CreatureScript { public : boss_nerubenkan ( ) : CreatureScript ( " boss _ nerubenkan " ) { } CreatureAI * GetAI ( Creature * creature ) const { return new boss_nerubenkanAI ( creature ) ; } struct boss_nerubenkanAI : public ScriptedAI { boss_nerubenkanAI ( Creature * creature ) : ScriptedAI ( creature ) { instance = me -> GetInstanceScript ( ) ; } InstanceScript * instance ; uint32 EncasingWebs_Timer ; uint32 PierceArmor_Timer ; uint32 CryptScarabs_Timer ; uint32 RaiseUndeadScarab_Timer ; void Reset ( ) { CryptScarabs_Timer = 3000 ; EncasingWebs_Timer = 7000 ; PierceArmor_Timer = 19000 ; RaiseUndeadScarab_Timer = 3000 ; } void EnterCombat ( Unit * /* who */ ) { } void JustDied ( Unit * /* killer */ ) { if ( instance ) instance -> SetData ( TYPE_NERUB , IN_PROGRESS ) ; } void RaiseUndeadScarab ( Unit * victim ) { if ( Creature * pUndeadScarab = DoSpawnCreature ( 10876 , float ( irand ( - 9 , 9 ) ) , float ( irand ( - 9 , 9 ) ) , 0 , 0 , TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN , 180000 ) ) if ( pUndeadScarab -> AI ( ) ) pUndeadScarab -> AI ( ) -> AttackStart ( victim ) ; } void UpdateAI ( const uint32 diff ) { if ( ! UpdateVictim ( ) ) return ; // EncasingWebs ENDCOM if ( EncasingWebs_Timer <= diff ) { DoCast ( me -> getVictim ( ) , SPELL_ENCASINGWEBS ) ; EncasingWebs_Timer = 30000 ; } else EncasingWebs_Timer -= diff ; // PierceArmor ENDCOM if ( PierceArmor_Timer <= diff ) { if ( urand ( 0 , 3 ) < 2 ) DoCast ( me -> getVictim ( ) , SPELL_PIERCEARMOR ) ; PierceArmor_Timer = 35000 ; } else PierceArmor_Timer -= diff ; // CryptScarabs _ Timer ENDCOM if ( CryptScarabs_Timer <= diff ) { DoCast ( me -> getVictim ( ) , SPELL_CRYPT_SCARABS ) ; CryptScarabs_Timer = 20000 ; } else CryptScarabs_Timer -= diff ; // RaiseUndeadScarab ENDCOM if ( RaiseUndeadScarab_Timer <= diff ) { RaiseUndeadScarab ( me -> getVictim ( ) ) ; RaiseUndeadScarab_Timer = 16000 ; } else RaiseUndeadScarab_Timer -= diff ; DoMeleeAttackIfReady ( ) ; } } ; } ; void AddSC_boss_nerubenkan ( ) { new boss_nerubenkan ( ) ; } </DOCUMENT>
<DOCUMENT_ID="rlewis1988/lean/tree/master/src/library/tactic/smt/util.cpp"> /* STRNEWLINE Copyright ▁ ( c ) ▁ 2016 ▁ Microsoft ▁ Corporation . ▁ All ▁ rights ▁ reserved . STRNEWLINE Released ▁ under ▁ Apache ▁ 2.0 ▁ license ▁ as ▁ described ▁ in ▁ the ▁ file ▁ LICENSE . STRNEWLINE STRNEWLINE Author : ▁ Leonardo ▁ de ▁ Moura STRNEWLINE */ # include " library / annotation . h " # include " library / util . h " # include " library / replace _ visitor . h " # include " library / vm / vm . h " # include " library / tactic / smt / congruence _ closure . h " namespace lean { static name * g_cc_proof_name = nullptr ; static macro_definition * g_cc_proof_macro = nullptr ; class cc_proof_macro_cell : public macro_definition_cell { public : virtual name get_name ( ) const { return * g_cc_proof_name ; } virtual expr check_type ( expr const & e , abstract_type_context & ctx , bool ) const { return mk_eq ( ctx , macro_arg ( e , 0 ) , macro_arg ( e , 1 ) ) ; } virtual optional < expr > expand ( expr const & , abstract_type_context & ) const { /* ▁ This ▁ is ▁ a ▁ temporary / delayed ▁ proof ▁ step . ▁ */ lean_unreachable ( ) ; } virtual void write ( serializer & ) const { /* ▁ This ▁ is ▁ a ▁ temporary / delayed ▁ proof ▁ step . ▁ */ lean_unreachable ( ) ; } virtual bool operator == ( macro_definition_cell const & other ) const { cc_proof_macro_cell const * other_ptr = dynamic_cast < cc_proof_macro_cell const * > ( & other ) ; return other_ptr ; } virtual unsigned hash ( ) const { return 23 ; } } ; /* ▁ Delayed ▁ ( congruence ▁ closure ▁ procedure ) ▁ proof . STRNEWLINE ▁ This ▁ proof ▁ is ▁ a ▁ placeholder ▁ for ▁ the ▁ real ▁ one ▁ that ▁ is ▁ computed ▁ only ▁ if ▁ needed . ▁ */ expr mk_delayed_cc_eq_proof ( expr const & e1 , expr const & e2 ) { expr args [ 2 ] = { e1 , e2 } ; return mk_macro ( * g_cc_proof_macro , 2 , args ) ; } bool is_delayed_cc_eq_proof ( expr const & e ) { return is_macro ( e ) && dynamic_cast < cc_proof_macro_cell const * > ( macro_def ( e ) . raw ( ) ) ; } static name * g_theory_proof = nullptr ; expr mark_cc_theory_proof ( expr const & pr ) { return mk_annotation ( * g_theory_proof , pr ) ; } bool is_cc_theory_proof ( expr const & e ) { return is_annotation ( e , * g_theory_proof ) ; } expr get_cc_theory_proof_arg ( expr const & pr ) { lean_assert ( is_cc_theory_proof ( pr ) ) ; return get_annotation_arg ( pr ) ; } class expand_delayed_cc_proofs_fn : public replace_visitor { congruence_closure const & m_cc ; expr visit_macro ( expr const & e ) { if ( is_delayed_cc_eq_proof ( e ) ) { expr const & lhs = macro_arg ( e , 0 ) ; expr const & rhs = macro_arg ( e , 1 ) ; return * m_cc . get_eq_proof ( lhs , rhs ) ; } else { return replace_visitor :: visit_macro ( e ) ; } } public : expand_delayed_cc_proofs_fn ( congruence_closure const & cc ) : m_cc ( cc ) { } } ; expr expand_delayed_cc_proofs ( congruence_closure const & cc , expr const & e ) { return expand_delayed_cc_proofs_fn ( cc ) ( e ) ; } void initialize_smt_util ( ) { g_cc_proof_name = new name ( " cc _ proof " ) ; g_cc_proof_macro = new macro_definition ( new cc_proof_macro_cell ( ) ) ; g_theory_proof = new name ( " th _ proof " ) ; register_annotation ( * g_theory_proof ) ; } void finalize_smt_util ( ) { delete g_cc_proof_macro ; delete g_cc_proof_name ; delete g_theory_proof ; } } </DOCUMENT>
<DOCUMENT_ID="braska/tdesktop/tree/master/Telegram/SourceFiles/gui/twidget.cpp"> /* STRNEWLINE This ▁ file ▁ is ▁ part ▁ of ▁ Telegram ▁ Desktop , STRNEWLINE the ▁ official ▁ desktop ▁ version ▁ of ▁ Telegram ▁ messaging ▁ app , ▁ see ▁ https : // telegram . org STRNEWLINE STRNEWLINE Telegram ▁ Desktop ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or STRNEWLINE ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE STRNEWLINE It ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE STRNEWLINE Full ▁ license : ▁ https : // github . com / telegramdesktop / tdesktop / blob / master / LICENSE STRNEWLINE Copyright ▁ ( c ) ▁ 2014 ▁ John ▁ Preston , ▁ https : // desktop . telegram . org STRNEWLINE */ # include " stdafx . h " # include " application . h " namespace { void _sendResizeEvents ( QWidget * target ) { QResizeEvent e ( target -> size ( ) , QSize ( ) ) ; QApplication :: sendEvent ( target , & e ) ; const QObjectList children = target -> children ( ) ; for ( int i = 0 ; i < children . size ( ) ; ++ i ) { QWidget * child = static_cast < QWidget * > ( children . at ( i ) ) ; if ( child -> isWidgetType ( ) && ! child -> isWindow ( ) && child -> testAttribute ( Qt :: WA_PendingResizeEvent ) ) { _sendResizeEvents ( child ) ; } } } } void myEnsureResized ( QWidget * target ) { if ( target && ( target -> testAttribute ( Qt :: WA_PendingResizeEvent ) || ! target -> testAttribute ( Qt :: WA_WState_Created ) ) ) { _sendResizeEvents ( target ) ; } } QPixmap myGrab ( QWidget * target , const QRect & rect ) { if ( ! cRetina ( ) ) return target -> grab ( rect ) ; myEnsureResized ( target ) ; qreal dpr = App :: app ( ) -> devicePixelRatio ( ) ; QPixmap result ( rect . size ( ) * dpr ) ; result . setDevicePixelRatio ( dpr ) ; result . fill ( Qt :: transparent ) ; target -> render ( & result , QPoint ( ) , QRegion ( rect ) , QWidget :: DrawWindowBackground | QWidget :: DrawChildren | QWidget :: IgnoreMask ) ; return result ; } </DOCUMENT>
<DOCUMENT_ID="NeuroRoboticTech/AnimatLabPublicSource/tree/master/Libraries/AnimatCarlSimCUDA/CsClassFactory.cpp"> /* * STRNEWLINE \file TABSYMBOL CsClassFactory . cpp STRNEWLINE STRNEWLINE \brief TABSYMBOL Implements ▁ the ▁ class ▁ factory ▁ class . STRNEWLINE * */ # include " StdAfx . h " # include " CsNeuralModule . h " # include " CsNeuronGroup . h " # include " CsSpikeGeneratorGroup . h " # include " CsSynapseGroup . h " # include " CsSynapseOneToOne . h " # include " CsSynapseFull . h " # include " CsSynapseRandom . h " # include " CsSynapseIndividual . h " # include " CsSpikingCurrentSynapse . h " # include " CsFiringRateStimulus . h " # include " CsNeuronDataColumn . h " # include " CsAdapter . h " # include " CsClassFactory . h " namespace AnimatCarlSim { /* * STRNEWLINE \brief TABSYMBOL Default ▁ constructor . STRNEWLINE TABSYMBOL STRNEWLINE \author TABSYMBOL dcofer STRNEWLINE \date TABSYMBOL 3/30/2011 STRNEWLINE * */ CsClassFactory :: CsClassFactory ( ) { } /* * STRNEWLINE \brief TABSYMBOL Destructor . STRNEWLINE STRNEWLINE \author TABSYMBOL dcofer STRNEWLINE \date TABSYMBOL 3/30/2011 STRNEWLINE * */ CsClassFactory :: ~ CsClassFactory ( ) { } Node * CsClassFactory :: CreateNeuron ( std :: string strType , bool bThrowError ) { Node * lpNeuron = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NEURONGROUP " ) lpNeuron = new CsNeuronGroup ; else if ( strType == " SPIKEGENERATORGROUP " ) lpNeuron = new CsSpikeGeneratorGroup ; else { lpNeuron = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Cs_Err_lInvalidNeuronType , Cs_Err_strInvalidNeuronType , " NeuronType " , strType ) ; } return lpNeuron ; } catch ( CStdErrorInfo oError ) { if ( lpNeuron ) delete lpNeuron ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpNeuron ) delete lpNeuron ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } // ▁ * * * * * ▁ Neuron ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM // ▁ * * * * * ▁ Synapse ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM AnimatSim :: Link * CsClassFactory :: CreateSynapse ( std :: string strType , bool bThrowError ) { AnimatSim :: Link * lpSynapse = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " ONETOONESYNAPSE " ) lpSynapse = new CsSynapseOneToOne ; else if ( strType == " FULLSYNAPSE " ) lpSynapse = new CsSynapseFull ; else if ( strType == " RANDOMSYNAPSE " ) lpSynapse = new CsSynapseRandom ; else if ( strType == " INDIVIDUALSYNAPSE " ) lpSynapse = new CsSynapseIndividual ; else if ( strType == " SPIKINGCURRENTSYNAPSE " ) lpSynapse = new CsSpikingCurrentSynapse ; else { lpSynapse = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Cs_Err_lInvalidSynapseType , Cs_Err_strInvalidSynapseType , " SynapseType " , strType ) ; } return lpSynapse ; } catch ( CStdErrorInfo oError ) { if ( lpSynapse ) delete lpSynapse ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpSynapse ) delete lpSynapse ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } // ▁ * * * * * ▁ Synapse ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM // ▁ * * * * * ▁ External ▁ Neural ▁ Module ▁ Conversion ▁ functions ▁ * * * * * ENDCOM NeuralModule * CsClassFactory :: CreateNeuralModule ( std :: string strType , bool bThrowError ) { NeuralModule * lpModule = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " CARLSIMNEURALMODULE " ) lpModule = new CsNeuralModule ; else { lpModule = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidNeuralModuleType , Al_Err_strInvalidNeuralModuleType , " NeuralModule " , strType ) ; } return lpModule ; } catch ( CStdErrorInfo oError ) { if ( lpModule ) delete lpModule ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpModule ) delete lpModule ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } // ▁ * * * * * ▁ Neural ▁ Module ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM // ▁ * * * * * ▁ External ▁ Stimulus ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM ExternalStimulus * CsClassFactory :: CreateExternalStimulus ( std :: string strType , bool bThrowError ) { ExternalStimulus * lpStimulus = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " FIRINGRATE " ) lpStimulus = new CsFiringRateStimulus ; else { lpStimulus = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidExternalStimulusType , Al_Err_strInvalidExternalStimulusType , " ExternalStimulusType " , strType ) ; } return lpStimulus ; } catch ( CStdErrorInfo oError ) { if ( lpStimulus ) delete lpStimulus ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpStimulus ) delete lpStimulus ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } // ▁ * * * * * ▁ External ▁ Stimulus ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM // ▁ * * * * * ▁ DataColumn ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM DataColumn * CsClassFactory :: CreateDataColumn ( std :: string strType , bool bThrowError ) { DataColumn * lpColumn = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NEURONDATACOLUMN " ) lpColumn = new CsNeuronDataColumn ; else { lpColumn = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidDataColumnType , Al_Err_strInvalidDataColumnType , " DataColumnType " , strType ) ; } return lpColumn ; } catch ( CStdErrorInfo oError ) { if ( lpColumn ) delete lpColumn ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpColumn ) delete lpColumn ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } // ▁ * * * * * ▁ DataColumn ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM // ▁ * * * * * ▁ Adapter ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM Adapter * CsClassFactory :: CreateAdapter ( std :: string strType , bool bThrowError ) { Adapter * lpAdapter = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NODETONODE " ) lpAdapter = new CsAdapter ; else if ( strType == " PHYSICALTONODE " ) lpAdapter = new CsAdapter ; else { lpAdapter = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidAdapterType , Al_Err_strInvalidAdapterType , " AdapterType " , strType ) ; } return lpAdapter ; } catch ( CStdErrorInfo oError ) { if ( lpAdapter ) delete lpAdapter ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpAdapter ) delete lpAdapter ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } // ▁ * * * * * ▁ Adpater ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM // ▁ * * * * * ▁ IStdCsClassFactory ▁ functions ▁ * * * * * ENDCOM CStdSerialize * CsClassFactory :: CreateObject ( std :: string strClassType , std :: string strObjectType , bool bThrowError ) { CStdSerialize * lpObject = NULL ; strClassType = Std_ToUpper ( Std_Trim ( strClassType ) ) ; if ( strClassType == " NEURON " ) lpObject = CreateNeuron ( strObjectType , bThrowError ) ; else if ( strClassType == " SYNAPSE " ) lpObject = CreateSynapse ( strObjectType , bThrowError ) ; else if ( strClassType == " NEURALMODULE " ) lpObject = CreateNeuralModule ( strObjectType , bThrowError ) ; else if ( strClassType == " EXTERNALSTIMULUS " ) lpObject = CreateExternalStimulus ( strObjectType , bThrowError ) ; else if ( strClassType == " DATACOLUMN " ) lpObject = CreateDataColumn ( strObjectType , bThrowError ) ; else if ( strClassType == " ADAPTER " ) lpObject = CreateAdapter ( strObjectType , bThrowError ) ; else { lpObject = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Std_Err_lInvalidClassType , Std_Err_strInvalidClassType , " ClassType " , strClassType ) ; } return lpObject ; } // ▁ * * * * * ▁ IStdCsClassFactory ▁ functions ▁ * * * * * ENDCOM } // AnimatCarlSim ENDCOM # ifdef WIN32 extern " C " __declspec ( dllexport ) IStdClassFactory * __cdecl GetStdClassFactory ( ) # else extern " C " IStdClassFactory * GetStdClassFactory ( ) # endif { IStdClassFactory * lpFactory = new CsClassFactory ; return lpFactory ; } </DOCUMENT>
<DOCUMENT_ID="native-m/slmath/tree/master/source/intersect_util.cpp"> # include < slm / intersect_util . h > SLMATH_BEGIN ( ) intersectLineBox_Line :: intersectLineBox_Line ( const vec3 & origin , const vec3 & direction ) : o ( origin ) , d ( direction ) , inv_d ( fabsf ( direction . x ) > FLT_MIN ? 1 . f / direction . x : FLT_MAX , fabsf ( direction . y ) > FLT_MIN ? 1 . f / direction . y : FLT_MAX , fabsf ( direction . z ) > FLT_MIN ? 1 . f / direction . z : FLT_MAX ) , signx ( direction . x < 0 . f ) , signy ( direction . y < 0 . f ) , signz ( direction . z < 0 . f ) { } bool intersectLineTri ( const vec3 & o , const vec3 & d , const vec3 & v0 , const vec3 & v1 , const vec3 & v2 , float * t ) { const vec3 e1 = v1 - v0 ; const vec3 e2 = v2 - v0 ; const vec3 pvec = cross ( d , e2 ) ; const float det = dot ( e1 , pvec ) ; if ( fabsf ( det ) <= FLT_MIN ) return false ; const float invdet = 1 . f / det ; const vec3 tvec = o - v0 ; const float u = dot ( tvec , pvec ) * invdet ; if ( 0 . f > u || 1 . f < u ) return false ; const vec3 qvec = cross ( tvec , e1 ) ; const float v = dot ( d , qvec ) * invdet ; if ( 0 . f > v || 1 . f < u + v ) return false ; const float s = dot ( e2 , qvec ) * invdet ; if ( s < 0 . f || s >= 1 . f ) return false ; if ( t ) * t = s ; assert ( s >= 0 . f && s <= 1 . f ) ; return true ; } bool intersectLineBox ( const intersectLineBox_Line & r , const vec3 * boxminmax ) { const float t0 = 0.0f ; const float t1 = 1.0f ; const int * const sign = & r . signx ; register float tmin , tmax , tymin , tymax , tzmin , tzmax ; tmin = ( boxminmax [ sign [ 0 ] ] . x - r . o . x ) * r . inv_d . x ; tmax = ( boxminmax [ 1 - sign [ 0 ] ] . x - r . o . x ) * r . inv_d . x ; tymin = ( boxminmax [ sign [ 1 ] ] . y - r . o . y ) * r . inv_d . y ; tymax = ( boxminmax [ 1 - sign [ 1 ] ] . y - r . o . y ) * r . inv_d . y ; if ( ( tmin > tymax ) || ( tymin > tmax ) ) return false ; if ( tymin > tmin ) tmin = tymin ; if ( tymax < tmax ) tmax = tymax ; tzmin = ( boxminmax [ sign [ 2 ] ] . z - r . o . z ) * r . inv_d . z ; tzmax = ( boxminmax [ 1 - sign [ 2 ] ] . z - r . o . z ) * r . inv_d . z ; if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false ; if ( tzmin > tmin ) tmin = tzmin ; if ( tzmax < tmax ) tmax = tzmax ; return ( ( tmin < t1 ) && ( tmax > t0 ) ) ; } bool intersectLineBox ( const vec3 & o , const vec3 & d , const vec3 & boxmin , const vec3 & boxmax ) { // ▁ these ▁ could ▁ be ▁ pre - init ▁ per ▁ line ENDCOM intersectLineBox_Line line ( o , d ) ; // ▁ these ▁ could ▁ be ▁ pre - init ▁ per ▁ box ENDCOM const vec3 boxminmax [ 2 ] = { boxmin , boxmax } ; return intersectLineBox ( line , boxminmax ) ; } SLMATH_END ( ) // ▁ This ▁ file ▁ is ▁ part ▁ of ▁ ' slm ' ▁ C + + ▁ library . ▁ Copyright ▁ ( C ) ▁ 2009 ▁ Jani ▁ Kajala ▁ ( kajala @ gmail . com ) . ▁ See ▁ http : // sourceforge . net / projects / slm / ENDCOM </DOCUMENT>
<DOCUMENT_ID="Chilledheart/vbox/tree/master/src/libs/xpcom18a4/nsprpub/pr/src/cplus/rcinrval.cpp"> /* ▁ - * - ▁ Mode : ▁ C + + ; ▁ tab - width : ▁ 4 ; ▁ indent - tabs - mode : ▁ nil ; ▁ c - basic - offset : ▁ 2 ▁ - * - ▁ */ /* ▁ * * * * * ▁ BEGIN ▁ LICENSE ▁ BLOCK ▁ * * * * * STRNEWLINE ▁ * ▁ Version : ▁ MPL ▁ 1.1 / GPL ▁ 2.0 / LGPL ▁ 2.1 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ The ▁ contents ▁ of ▁ this ▁ file ▁ are ▁ subject ▁ to ▁ the ▁ Mozilla ▁ Public ▁ License ▁ Version STRNEWLINE ▁ * ▁ 1.1 ▁ ( the ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with STRNEWLINE ▁ * ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * ▁ http : // www . mozilla . org / MPL / STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Software ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ basis , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTY ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ▁ See ▁ the ▁ License STRNEWLINE ▁ * ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ rights ▁ and ▁ limitations ▁ under ▁ the STRNEWLINE ▁ * ▁ License . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ The ▁ Original ▁ Code ▁ is ▁ the ▁ Netscape ▁ Portable ▁ Runtime ▁ ( NSPR ) . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ The ▁ Initial ▁ Developer ▁ of ▁ the ▁ Original ▁ Code ▁ is STRNEWLINE ▁ * ▁ Netscape ▁ Communications ▁ Corporation . STRNEWLINE ▁ * ▁ Portions ▁ created ▁ by ▁ the ▁ Initial ▁ Developer ▁ are ▁ Copyright ▁ ( C ) ▁ 1998-2000 STRNEWLINE ▁ * ▁ the ▁ Initial ▁ Developer . ▁ All ▁ Rights ▁ Reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Contributor ( s ) : STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Alternatively , ▁ the ▁ contents ▁ of ▁ this ▁ file ▁ may ▁ be ▁ used ▁ under ▁ the ▁ terms ▁ of STRNEWLINE ▁ * ▁ either ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ Version ▁ 2 ▁ or ▁ later ▁ ( the ▁ " GPL " ) , ▁ or STRNEWLINE ▁ * ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ Version ▁ 2.1 ▁ or ▁ later ▁ ( the ▁ " LGPL " ) , STRNEWLINE ▁ * ▁ in ▁ which ▁ case ▁ the ▁ provisions ▁ of ▁ the ▁ GPL ▁ or ▁ the ▁ LGPL ▁ are ▁ applicable ▁ instead STRNEWLINE ▁ * ▁ of ▁ those ▁ above . ▁ If ▁ you ▁ wish ▁ to ▁ allow ▁ use ▁ of ▁ your ▁ version ▁ of ▁ this ▁ file ▁ only STRNEWLINE ▁ * ▁ under ▁ the ▁ terms ▁ of ▁ either ▁ the ▁ GPL ▁ or ▁ the ▁ LGPL , ▁ and ▁ not ▁ to ▁ allow ▁ others ▁ to STRNEWLINE ▁ * ▁ use ▁ your ▁ version ▁ of ▁ this ▁ file ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ MPL , ▁ indicate ▁ your STRNEWLINE ▁ * ▁ decision ▁ by ▁ deleting ▁ the ▁ provisions ▁ above ▁ and ▁ replace ▁ them ▁ with ▁ the ▁ notice STRNEWLINE ▁ * ▁ and ▁ other ▁ provisions ▁ required ▁ by ▁ the ▁ GPL ▁ or ▁ the ▁ LGPL . ▁ If ▁ you ▁ do ▁ not ▁ delete STRNEWLINE ▁ * ▁ the ▁ provisions ▁ above , ▁ a ▁ recipient ▁ may ▁ use ▁ your ▁ version ▁ of ▁ this ▁ file ▁ under STRNEWLINE ▁ * ▁ the ▁ terms ▁ of ▁ any ▁ one ▁ of ▁ the ▁ MPL , ▁ the ▁ GPL ▁ or ▁ the ▁ LGPL . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ * * * * * ▁ END ▁ LICENSE ▁ BLOCK ▁ * * * * * ▁ */ /* STRNEWLINE * * ▁ C + + ▁ interval ▁ times ▁ ( ref : ▁ prinrval . h ) STRNEWLINE * * STRNEWLINE * * ▁ An ▁ interval ▁ is ▁ a ▁ period ▁ of ▁ time . ▁ The ▁ start ▁ of ▁ the ▁ interval ▁ ( epoch ) STRNEWLINE * * ▁ must ▁ be ▁ defined ▁ by ▁ the ▁ application . ▁ The ▁ unit ▁ of ▁ time ▁ of ▁ an ▁ interval STRNEWLINE * * ▁ is ▁ platform ▁ dependent , ▁ therefore ▁ so ▁ is ▁ the ▁ maximum ▁ interval ▁ that ▁ is STRNEWLINE * * ▁ representable . ▁ However , ▁ that ▁ interval ▁ is ▁ never ▁ less ▁ that ▁ ~ 12 ▁ hours . STRNEWLINE */ # include " rcinrval . h " RCInterval :: ~ RCInterval ( ) { } RCInterval :: RCInterval ( RCInterval :: RCReservedInterval special ) : RCBase ( ) { switch ( special ) { case RCInterval :: now : interval = PR_IntervalNow ( ) ; break ; case RCInterval :: no_timeout : interval = PR_INTERVAL_NO_TIMEOUT ; break ; case RCInterval :: no_wait : interval = PR_INTERVAL_NO_WAIT ; break ; default : break ; } } /* ▁ RCInterval : : RCInterval ▁ */ /* ▁ rcinrval . cpp ▁ */ </DOCUMENT>
<DOCUMENT_ID="lthall/Leonard_ardupilot/tree/master/libraries/AP_NavEKF/AP_NavEKF_core_common.cpp"> /* STRNEWLINE ▁ NavEKF _ core _ common ▁ holds ▁ scratch ▁ data ▁ shared ▁ by ▁ EKF2 ▁ and ▁ EKF3 STRNEWLINE STRNEWLINE ▁ This ▁ program ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or STRNEWLINE ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE STRNEWLINE ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE STRNEWLINE ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ along ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ */ # include " AP _ NavEKF _ core _ common . h " NavEKF_core_common :: Matrix24 NavEKF_core_common :: KH ; NavEKF_core_common :: Matrix24 NavEKF_core_common :: KHP ; NavEKF_core_common :: Matrix24 NavEKF_core_common :: nextP ; NavEKF_core_common :: Vector28 NavEKF_core_common :: Kfusion ; /* STRNEWLINE ▁ fill ▁ common ▁ scratch ▁ variables , ▁ for ▁ detecting ▁ re - use ▁ of ▁ variables ▁ between ▁ loops ▁ in ▁ SITL STRNEWLINE ▁ */ void NavEKF_core_common :: fill_scratch_variables ( void ) { # if CONFIG_HAL_BOARD == HAL_BOARD_SITL // ▁ fill ▁ the ▁ common ▁ variables ▁ with ▁ NaN , ▁ so ▁ we ▁ catch ▁ any ▁ cases ▁ in ENDCOM // ▁ SITL ▁ where ▁ they ▁ are ▁ used ▁ without ▁ initialisation . ▁ These ▁ are ▁ all ENDCOM // ▁ supposed ▁ to ▁ be ▁ scratch ▁ variables ▁ that ▁ are ▁ not ▁ used ▁ between ENDCOM // ▁ iterations ENDCOM fill_nanf ( & KH [ 0 ] [ 0 ] , sizeof ( KH ) / sizeof ( float ) ) ; fill_nanf ( & KHP [ 0 ] [ 0 ] , sizeof ( KHP ) / sizeof ( float ) ) ; fill_nanf ( & nextP [ 0 ] [ 0 ] , sizeof ( nextP ) / sizeof ( float ) ) ; fill_nanf ( & Kfusion [ 0 ] , sizeof ( Kfusion ) / sizeof ( float ) ) ; # endif } </DOCUMENT>
<DOCUMENT_ID="erdincay/clamav-devel/tree/master/libclamav/c++/llvm/lib/Target/PowerPC/PPCSelectionDAGInfo.cpp"> // = = = - - ▁ PPCSelectionDAGInfo . cpp ▁ - ▁ PowerPC ▁ SelectionDAG ▁ Info ▁ - - - - - = = = // ENDCOM // ▁ The ▁ LLVM ▁ Compiler ▁ Infrastructure ENDCOM // ▁ This ▁ file ▁ is ▁ distributed ▁ under ▁ the ▁ University ▁ of ▁ Illinois ▁ Open ▁ Source ENDCOM // ▁ License . ▁ See ▁ LICENSE . TXT ▁ for ▁ details . ENDCOM // ▁ This ▁ file ▁ implements ▁ the ▁ PPCSelectionDAGInfo ▁ class . ENDCOM # define DEBUG_TYPE " powerpc - selectiondag - info " # include " PPCTargetMachine . h " using namespace llvm ; PPCSelectionDAGInfo :: PPCSelectionDAGInfo ( const PPCTargetMachine & TM ) : TargetSelectionDAGInfo ( TM ) { } PPCSelectionDAGInfo :: ~ PPCSelectionDAGInfo ( ) { } </DOCUMENT>
<DOCUMENT_ID="pcarrier-packaging/deb-phantomjs/tree/master/src/qt/src/3rdparty/webkit/Source/WebCore/generated/JSSVGPathSegLinetoHorizontalRel.cpp"> /* STRNEWLINE ▁ This ▁ file ▁ is ▁ part ▁ of ▁ the ▁ WebKit ▁ open ▁ source ▁ project . STRNEWLINE ▁ This ▁ file ▁ has ▁ been ▁ generated ▁ by ▁ generate - bindings . pl . ▁ DO ▁ NOT ▁ MODIFY ! STRNEWLINE STRNEWLINE ▁ This ▁ library ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or STRNEWLINE ▁ modify ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Library ▁ General ▁ Public STRNEWLINE ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either STRNEWLINE ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE STRNEWLINE ▁ This ▁ library ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU STRNEWLINE ▁ Library ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE STRNEWLINE ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Library ▁ General ▁ Public ▁ License STRNEWLINE ▁ along ▁ with ▁ this ▁ library ; ▁ see ▁ the ▁ file ▁ COPYING . LIB . ▁ If ▁ not , ▁ write ▁ to STRNEWLINE ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , STRNEWLINE ▁ Boston , ▁ MA ▁ 02110-1301 , ▁ USA . STRNEWLINE */ # include " config . h " # if ENABLE ( SVG ) # include " JSSVGPathSegLinetoHorizontalRel . h " # include " SVGPathSegLinetoHorizontal . h " # include < runtime / Error . h > # include < wtf / GetPtr . h > using namespace JSC ; namespace WebCore { ASSERT_CLASS_FITS_IN_CELL ( JSSVGPathSegLinetoHorizontalRel ) ; /* ▁ Hash ▁ table ▁ */ # if ENABLE ( JIT ) # define THUNK_GENERATOR ( generator ) , generator # else # define THUNK_GENERATOR ( generator ) # endif static const HashTableValue JSSVGPathSegLinetoHorizontalRelTableValues [ 3 ] = { { " x " , DontDelete , ( intptr_t ) static_cast < PropertySlot :: GetValueFunc > ( jsSVGPathSegLinetoHorizontalRelX ) , ( intptr_t ) setJSSVGPathSegLinetoHorizontalRelX THUNK_GENERATOR ( 0 ) } , { " constructor " , DontEnum | ReadOnly , ( intptr_t ) static_cast < PropertySlot :: GetValueFunc > ( jsSVGPathSegLinetoHorizontalRelConstructor ) , ( intptr_t ) 0 THUNK_GENERATOR ( 0 ) } , { 0 , 0 , 0 , 0 THUNK_GENERATOR ( 0 ) } } ; # undef THUNK_GENERATOR static JSC_CONST_HASHTABLE HashTable JSSVGPathSegLinetoHorizontalRelTable = { 5 , 3 , JSSVGPathSegLinetoHorizontalRelTableValues , 0 } ; /* ▁ Hash ▁ table ▁ for ▁ constructor ▁ */ # if ENABLE ( JIT ) # define THUNK_GENERATOR ( generator ) , generator # else # define THUNK_GENERATOR ( generator ) # endif static const HashTableValue JSSVGPathSegLinetoHorizontalRelConstructorTableValues [ 1 ] = { { 0 , 0 , 0 , 0 THUNK_GENERATOR ( 0 ) } } ; # undef THUNK_GENERATOR static JSC_CONST_HASHTABLE HashTable JSSVGPathSegLinetoHorizontalRelConstructorTable = { 1 , 0 , JSSVGPathSegLinetoHorizontalRelConstructorTableValues , 0 } ; class JSSVGPathSegLinetoHorizontalRelConstructor : public DOMConstructorObject { public : JSSVGPathSegLinetoHorizontalRelConstructor ( JSC :: ExecState * , JSC :: Structure * , JSDOMGlobalObject * ) ; virtual bool getOwnPropertySlot ( JSC :: ExecState * , const JSC :: Identifier & , JSC :: PropertySlot & ) ; virtual bool getOwnPropertyDescriptor ( JSC :: ExecState * , const JSC :: Identifier & , JSC :: PropertyDescriptor & ) ; static const JSC :: ClassInfo s_info ; static JSC :: Structure * createStructure ( JSC :: JSGlobalData & globalData , JSC :: JSValue prototype ) { return JSC :: Structure :: create ( globalData , prototype , JSC :: TypeInfo ( JSC :: ObjectType , StructureFlags ) , AnonymousSlotCount , & s_info ) ; } protected : static const unsigned StructureFlags = JSC :: OverridesGetOwnPropertySlot | JSC :: ImplementsHasInstance | DOMConstructorObject :: StructureFlags ; } ; const ClassInfo JSSVGPathSegLinetoHorizontalRelConstructor :: s_info = { " SVGPathSegLinetoHorizontalRelConstructor " , & DOMConstructorObject :: s_info , & JSSVGPathSegLinetoHorizontalRelConstructorTable , 0 } ; JSSVGPathSegLinetoHorizontalRelConstructor :: JSSVGPathSegLinetoHorizontalRelConstructor ( ExecState * exec , Structure * structure , JSDOMGlobalObject * globalObject ) : DOMConstructorObject ( structure , globalObject ) { ASSERT ( inherits ( & s_info ) ) ; putDirect ( exec -> globalData ( ) , exec -> propertyNames ( ) . prototype , JSSVGPathSegLinetoHorizontalRelPrototype :: self ( exec , globalObject ) , DontDelete | ReadOnly ) ; } bool JSSVGPathSegLinetoHorizontalRelConstructor :: getOwnPropertySlot ( ExecState * exec , const Identifier & propertyName , PropertySlot & slot ) { return getStaticValueSlot < JSSVGPathSegLinetoHorizontalRelConstructor , JSDOMWrapper > ( exec , & JSSVGPathSegLinetoHorizontalRelConstructorTable , this , propertyName , slot ) ; } bool JSSVGPathSegLinetoHorizontalRelConstructor :: getOwnPropertyDescriptor ( ExecState * exec , const Identifier & propertyName , PropertyDescriptor & descriptor ) { return getStaticValueDescriptor < JSSVGPathSegLinetoHorizontalRelConstructor , JSDOMWrapper > ( exec , & JSSVGPathSegLinetoHorizontalRelConstructorTable , this , propertyName , descriptor ) ; } /* ▁ Hash ▁ table ▁ for ▁ prototype ▁ */ # if ENABLE ( JIT ) # define THUNK_GENERATOR ( generator ) , generator # else # define THUNK_GENERATOR ( generator ) # endif static const HashTableValue JSSVGPathSegLinetoHorizontalRelPrototypeTableValues [ 1 ] = { { 0 , 0 , 0 , 0 THUNK_GENERATOR ( 0 ) } } ; # undef THUNK_GENERATOR static JSC_CONST_HASHTABLE HashTable JSSVGPathSegLinetoHorizontalRelPrototypeTable = { 1 , 0 , JSSVGPathSegLinetoHorizontalRelPrototypeTableValues , 0 } ; const ClassInfo JSSVGPathSegLinetoHorizontalRelPrototype :: s_info = { " SVGPathSegLinetoHorizontalRelPrototype " , & JSC :: JSObjectWithGlobalObject :: s_info , & JSSVGPathSegLinetoHorizontalRelPrototypeTable , 0 } ; JSObject * JSSVGPathSegLinetoHorizontalRelPrototype :: self ( ExecState * exec , JSGlobalObject * globalObject ) { return getDOMPrototype < JSSVGPathSegLinetoHorizontalRel > ( exec , globalObject ) ; } const ClassInfo JSSVGPathSegLinetoHorizontalRel :: s_info = { " SVGPathSegLinetoHorizontalRel " , & JSSVGPathSeg :: s_info , & JSSVGPathSegLinetoHorizontalRelTable , 0 } ; JSSVGPathSegLinetoHorizontalRel :: JSSVGPathSegLinetoHorizontalRel ( Structure * structure , JSDOMGlobalObject * globalObject , PassRefPtr < SVGPathSegLinetoHorizontalRel > impl ) : JSSVGPathSeg ( structure , globalObject , impl ) { ASSERT ( inherits ( & s_info ) ) ; } JSObject * JSSVGPathSegLinetoHorizontalRel :: createPrototype ( ExecState * exec , JSGlobalObject * globalObject ) { return new ( exec ) JSSVGPathSegLinetoHorizontalRelPrototype ( exec -> globalData ( ) , globalObject , JSSVGPathSegLinetoHorizontalRelPrototype :: createStructure ( exec -> globalData ( ) , JSSVGPathSegPrototype :: self ( exec , globalObject ) ) ) ; } bool JSSVGPathSegLinetoHorizontalRel :: getOwnPropertySlot ( ExecState * exec , const Identifier & propertyName , PropertySlot & slot ) { return getStaticValueSlot < JSSVGPathSegLinetoHorizontalRel , Base > ( exec , & JSSVGPathSegLinetoHorizontalRelTable , this , propertyName , slot ) ; } bool JSSVGPathSegLinetoHorizontalRel :: getOwnPropertyDescriptor ( ExecState * exec , const Identifier & propertyName , PropertyDescriptor & descriptor ) { return getStaticValueDescriptor < JSSVGPathSegLinetoHorizontalRel , Base > ( exec , & JSSVGPathSegLinetoHorizontalRelTable , this , propertyName , descriptor ) ; } JSValue jsSVGPathSegLinetoHorizontalRelX ( ExecState * exec , JSValue slotBase , const Identifier & ) { JSSVGPathSegLinetoHorizontalRel * castedThis = static_cast < JSSVGPathSegLinetoHorizontalRel * > ( asObject ( slotBase ) ) ; UNUSED_PARAM ( exec ) ; SVGPathSegLinetoHorizontalRel * imp = static_cast < SVGPathSegLinetoHorizontalRel * > ( castedThis -> impl ( ) ) ; JSValue result = jsNumber ( imp -> x ( ) ) ; return result ; } JSValue jsSVGPathSegLinetoHorizontalRelConstructor ( ExecState * exec , JSValue slotBase , const Identifier & ) { JSSVGPathSegLinetoHorizontalRel * domObject = static_cast < JSSVGPathSegLinetoHorizontalRel * > ( asObject ( slotBase ) ) ; return JSSVGPathSegLinetoHorizontalRel :: getConstructor ( exec , domObject -> globalObject ( ) ) ; } void JSSVGPathSegLinetoHorizontalRel :: put ( ExecState * exec , const Identifier & propertyName , JSValue value , PutPropertySlot & slot ) { lookupPut < JSSVGPathSegLinetoHorizontalRel , Base > ( exec , propertyName , value , & JSSVGPathSegLinetoHorizontalRelTable , this , slot ) ; } void setJSSVGPathSegLinetoHorizontalRelX ( ExecState * exec , JSObject * thisObject , JSValue value ) { JSSVGPathSegLinetoHorizontalRel * castedThis = static_cast < JSSVGPathSegLinetoHorizontalRel * > ( thisObject ) ; SVGPathSegLinetoHorizontalRel * imp = static_cast < SVGPathSegLinetoHorizontalRel * > ( castedThis -> impl ( ) ) ; imp -> setX ( value . toFloat ( exec ) ) ; } JSValue JSSVGPathSegLinetoHorizontalRel :: getConstructor ( ExecState * exec , JSGlobalObject * globalObject ) { return getDOMConstructor < JSSVGPathSegLinetoHorizontalRelConstructor > ( exec , static_cast < JSDOMGlobalObject * > ( globalObject ) ) ; } } # endif // ▁ ENABLE ( SVG ) ENDCOM </DOCUMENT>
<DOCUMENT_ID="MorcoFreeCode/2015__MorcoEngine3D/tree/master/MorcoEngine3D v0.13/Source/Libraries/glm/Include/detail/glm.cpp"> // / ▁ OpenGL ▁ Mathematics ▁ ( glm . g - truc . net ) ENDCOM // / ▁ Copyright ▁ ( c ) ▁ 2005 ▁ - ▁ 2014 ▁ G - Truc ▁ Creation ▁ ( www . g - truc . net ) ENDCOM // / ▁ Permission ▁ is ▁ hereby ▁ granted , ▁ free ▁ of ▁ charge , ▁ to ▁ any ▁ person ▁ obtaining ▁ a ▁ copy ENDCOM // / ▁ of ▁ this ▁ software ▁ and ▁ associated ▁ documentation ▁ files ▁ ( the ▁ " Software " ) , ▁ to ▁ deal ENDCOM // / ▁ in ▁ the ▁ Software ▁ without ▁ restriction , ▁ including ▁ without ▁ limitation ▁ the ▁ rights ENDCOM // / ▁ to ▁ use , ▁ copy , ▁ modify , ▁ merge , ▁ publish , ▁ distribute , ▁ sublicense , ▁ and / or ▁ sell ENDCOM // / ▁ copies ▁ of ▁ the ▁ Software , ▁ and ▁ to ▁ permit ▁ persons ▁ to ▁ whom ▁ the ▁ Software ▁ is ENDCOM // / ▁ furnished ▁ to ▁ do ▁ so , ▁ subject ▁ to ▁ the ▁ following ▁ conditions : ENDCOM // / ▁ The ▁ above ▁ copyright ▁ notice ▁ and ▁ this ▁ permission ▁ notice ▁ shall ▁ be ▁ included ▁ in ENDCOM // / ▁ all ▁ copies ▁ or ▁ substantial ▁ portions ▁ of ▁ the ▁ Software . ENDCOM // / ▁ THE ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ " AS ▁ IS " , ▁ WITHOUT ▁ WARRANTY ▁ OF ▁ ANY ▁ KIND , ▁ EXPRESS ▁ OR ENDCOM // / ▁ IMPLIED , ▁ INCLUDING ▁ BUT ▁ NOT ▁ LIMITED ▁ TO ▁ THE ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY , ENDCOM // / ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE ▁ AND ▁ NONINFRINGEMENT . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ENDCOM // / ▁ AUTHORS ▁ OR ▁ COPYRIGHT ▁ HOLDERS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ CLAIM , ▁ DAMAGES ▁ OR ▁ OTHER ENDCOM // / ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ AN ▁ ACTION ▁ OF ▁ CONTRACT , ▁ TORT ▁ OR ▁ OTHERWISE , ▁ ARISING ▁ FROM , ENDCOM // / ▁ OUT ▁ OF ▁ OR ▁ IN ▁ CONNECTION ▁ WITH ▁ THE ▁ SOFTWARE ▁ OR ▁ THE ▁ USE ▁ OR ▁ OTHER ▁ DEALINGS ▁ IN ENDCOM // / ▁ THE ▁ SOFTWARE . ENDCOM // / ▁ @ ref ▁ core ENDCOM // / ▁ @ file ▁ glm / glm . cpp ENDCOM // / ▁ @ date ▁ 2013-04-22 ▁ / ▁ 2013-04-22 ENDCOM // / ▁ @ author ▁ Christophe ▁ Riccio ENDCOM # include < glm / glm . hpp > # include < glm / gtc / quaternion . hpp > # include < glm / gtx / dual_quaternion . hpp > namespace glm { namespace detail { // ▁ tvec1 ▁ type ▁ explicit ▁ instantiation ENDCOM /* STRNEWLINE template ▁ struct ▁ tvec1 < uint8 , ▁ lowp > ; STRNEWLINE template ▁ struct ▁ tvec1 < uint16 , ▁ lowp > ; STRNEWLINE template ▁ struct ▁ tvec1 < uint32 , ▁ lowp > ; STRNEWLINE template ▁ struct ▁ tvec1 < uint64 , ▁ lowp > ; STRNEWLINE template ▁ struct ▁ tvec1 < int8 , ▁ lowp > ; STRNEWLINE template ▁ struct ▁ tvec1 < int16 , ▁ lowp > ; STRNEWLINE template ▁ struct ▁ tvec1 < int32 , ▁ lowp > ; STRNEWLINE template ▁ struct ▁ tvec1 < int64 , ▁ lowp > ; STRNEWLINE template ▁ struct ▁ tvec1 < float16 , ▁ lowp > ; STRNEWLINE template ▁ struct ▁ tvec1 < float32 , ▁ lowp > ; STRNEWLINE template ▁ struct ▁ tvec1 < float64 , ▁ lowp > ; STRNEWLINE STRNEWLINE template ▁ struct ▁ tvec1 < uint8 , ▁ mediump > ; STRNEWLINE template ▁ struct ▁ tvec1 < uint16 , ▁ mediump > ; STRNEWLINE template ▁ struct ▁ tvec1 < uint32 , ▁ mediump > ; STRNEWLINE template ▁ struct ▁ tvec1 < uint64 , ▁ mediump > ; STRNEWLINE template ▁ struct ▁ tvec1 < int8 , ▁ mediump > ; STRNEWLINE template ▁ struct ▁ tvec1 < int16 , ▁ mediump > ; STRNEWLINE template ▁ struct ▁ tvec1 < int32 , ▁ mediump > ; STRNEWLINE template ▁ struct ▁ tvec1 < int64 , ▁ mediump > ; STRNEWLINE template ▁ struct ▁ tvec1 < float16 , ▁ mediump > ; STRNEWLINE template ▁ struct ▁ tvec1 < float32 , ▁ mediump > ; STRNEWLINE template ▁ struct ▁ tvec1 < float64 , ▁ mediump > ; STRNEWLINE STRNEWLINE template ▁ struct ▁ tvec1 < uint8 , ▁ highp > ; STRNEWLINE template ▁ struct ▁ tvec1 < uint16 , ▁ highp > ; STRNEWLINE template ▁ struct ▁ tvec1 < uint32 , ▁ highp > ; STRNEWLINE template ▁ struct ▁ tvec1 < uint64 , ▁ highp > ; STRNEWLINE template ▁ struct ▁ tvec1 < int8 , ▁ highp > ; STRNEWLINE template ▁ struct ▁ tvec1 < int16 , ▁ highp > ; STRNEWLINE template ▁ struct ▁ tvec1 < int32 , ▁ highp > ; STRNEWLINE template ▁ struct ▁ tvec1 < int64 , ▁ highp > ; STRNEWLINE template ▁ struct ▁ tvec1 < float16 , ▁ highp > ; STRNEWLINE template ▁ struct ▁ tvec1 < float32 , ▁ highp > ; STRNEWLINE template ▁ struct ▁ tvec1 < float64 , ▁ highp > ; STRNEWLINE */ // ▁ tvec2 ▁ type ▁ explicit ▁ instantiation ENDCOM template struct tvec2 < uint8 , lowp > ; template struct tvec2 < uint16 , lowp > ; template struct tvec2 < uint32 , lowp > ; template struct tvec2 < uint64 , lowp > ; template struct tvec2 < int8 , lowp > ; template struct tvec2 < int16 , lowp > ; template struct tvec2 < int32 , lowp > ; template struct tvec2 < int64 , lowp > ; template struct tvec2 < float32 , lowp > ; template struct tvec2 < float64 , lowp > ; template struct tvec2 < uint8 , mediump > ; template struct tvec2 < uint16 , mediump > ; template struct tvec2 < uint32 , mediump > ; template struct tvec2 < uint64 , mediump > ; template struct tvec2 < int8 , mediump > ; template struct tvec2 < int16 , mediump > ; template struct tvec2 < int32 , mediump > ; template struct tvec2 < int64 , mediump > ; template struct tvec2 < float32 , mediump > ; template struct tvec2 < float64 , mediump > ; template struct tvec2 < uint8 , highp > ; template struct tvec2 < uint16 , highp > ; template struct tvec2 < uint32 , highp > ; template struct tvec2 < uint64 , highp > ; template struct tvec2 < int8 , highp > ; template struct tvec2 < int16 , highp > ; template struct tvec2 < int32 , highp > ; template struct tvec2 < int64 , highp > ; template struct tvec2 < float32 , highp > ; template struct tvec2 < float64 , highp > ; // ▁ tvec3 ▁ type ▁ explicit ▁ instantiation ENDCOM template struct tvec3 < uint8 , lowp > ; template struct tvec3 < uint16 , lowp > ; template struct tvec3 < uint32 , lowp > ; template struct tvec3 < uint64 , lowp > ; template struct tvec3 < int8 , lowp > ; template struct tvec3 < int16 , lowp > ; template struct tvec3 < int32 , lowp > ; template struct tvec3 < int64 , lowp > ; template struct tvec3 < float32 , lowp > ; template struct tvec3 < float64 , lowp > ; template struct tvec3 < uint8 , mediump > ; template struct tvec3 < uint16 , mediump > ; template struct tvec3 < uint32 , mediump > ; template struct tvec3 < uint64 , mediump > ; template struct tvec3 < int8 , mediump > ; template struct tvec3 < int16 , mediump > ; template struct tvec3 < int32 , mediump > ; template struct tvec3 < int64 , mediump > ; template struct tvec3 < float32 , mediump > ; template struct tvec3 < float64 , mediump > ; template struct tvec3 < uint8 , highp > ; template struct tvec3 < uint16 , highp > ; template struct tvec3 < uint32 , highp > ; template struct tvec3 < uint64 , highp > ; template struct tvec3 < int8 , highp > ; template struct tvec3 < int16 , highp > ; template struct tvec3 < int32 , highp > ; template struct tvec3 < int64 , highp > ; template struct tvec3 < float32 , highp > ; template struct tvec3 < float64 , highp > ; // ▁ tvec4 ▁ type ▁ explicit ▁ instantiation ENDCOM template struct tvec4 < uint8 , lowp > ; template struct tvec4 < uint16 , lowp > ; template struct tvec4 < uint32 , lowp > ; template struct tvec4 < uint64 , lowp > ; template struct tvec4 < int8 , lowp > ; template struct tvec4 < int16 , lowp > ; template struct tvec4 < int32 , lowp > ; template struct tvec4 < int64 , lowp > ; template struct tvec4 < float32 , lowp > ; template struct tvec4 < float64 , lowp > ; template struct tvec4 < uint8 , mediump > ; template struct tvec4 < uint16 , mediump > ; template struct tvec4 < uint32 , mediump > ; template struct tvec4 < uint64 , mediump > ; template struct tvec4 < int8 , mediump > ; template struct tvec4 < int16 , mediump > ; template struct tvec4 < int32 , mediump > ; template struct tvec4 < int64 , mediump > ; template struct tvec4 < float32 , mediump > ; template struct tvec4 < float64 , mediump > ; template struct tvec4 < uint8 , highp > ; template struct tvec4 < uint16 , highp > ; template struct tvec4 < uint32 , highp > ; template struct tvec4 < uint64 , highp > ; template struct tvec4 < int8 , highp > ; template struct tvec4 < int16 , highp > ; template struct tvec4 < int32 , highp > ; template struct tvec4 < int64 , highp > ; template struct tvec4 < float32 , highp > ; template struct tvec4 < float64 , highp > ; // ▁ tmat2x2 ▁ type ▁ explicit ▁ instantiation ENDCOM template struct tmat2x2 < float32 , lowp > ; template struct tmat2x2 < float64 , lowp > ; template struct tmat2x2 < float32 , mediump > ; template struct tmat2x2 < float64 , mediump > ; template struct tmat2x2 < float32 , highp > ; template struct tmat2x2 < float64 , highp > ; // ▁ tmat2x3 ▁ type ▁ explicit ▁ instantiation ENDCOM template struct tmat2x3 < float32 , lowp > ; template struct tmat2x3 < float64 , lowp > ; template struct tmat2x3 < float32 , mediump > ; template struct tmat2x3 < float64 , mediump > ; template struct tmat2x3 < float32 , highp > ; template struct tmat2x3 < float64 , highp > ; // ▁ tmat2x4 ▁ type ▁ explicit ▁ instantiation ENDCOM template struct tmat2x4 < float32 , lowp > ; template struct tmat2x4 < float64 , lowp > ; template struct tmat2x4 < float32 , mediump > ; template struct tmat2x4 < float64 , mediump > ; template struct tmat2x4 < float32 , highp > ; template struct tmat2x4 < float64 , highp > ; // ▁ tmat3x2 ▁ type ▁ explicit ▁ instantiation ENDCOM template struct tmat3x2 < float32 , lowp > ; template struct tmat3x2 < float64 , lowp > ; template struct tmat3x2 < float32 , mediump > ; template struct tmat3x2 < float64 , mediump > ; template struct tmat3x2 < float32 , highp > ; template struct tmat3x2 < float64 , highp > ; // ▁ tmat3x3 ▁ type ▁ explicit ▁ instantiation ENDCOM template struct tmat3x3 < float32 , lowp > ; template struct tmat3x3 < float64 , lowp > ; template struct tmat3x3 < float32 , mediump > ; template struct tmat3x3 < float64 , mediump > ; template struct tmat3x3 < float32 , highp > ; template struct tmat3x3 < float64 , highp > ; // ▁ tmat3x4 ▁ type ▁ explicit ▁ instantiation ENDCOM template struct tmat3x4 < float32 , lowp > ; template struct tmat3x4 < float64 , lowp > ; template struct tmat3x4 < float32 , mediump > ; template struct tmat3x4 < float64 , mediump > ; template struct tmat3x4 < float32 , highp > ; template struct tmat3x4 < float64 , highp > ; // ▁ tmat4x2 ▁ type ▁ explicit ▁ instantiation ENDCOM template struct tmat4x2 < float32 , lowp > ; template struct tmat4x2 < float64 , lowp > ; template struct tmat4x2 < float32 , mediump > ; template struct tmat4x2 < float64 , mediump > ; template struct tmat4x2 < float32 , highp > ; template struct tmat4x2 < float64 , highp > ; // ▁ tmat4x3 ▁ type ▁ explicit ▁ instantiation ENDCOM template struct tmat4x3 < float32 , lowp > ; template struct tmat4x3 < float64 , lowp > ; template struct tmat4x3 < float32 , mediump > ; template struct tmat4x3 < float64 , mediump > ; template struct tmat4x3 < float32 , highp > ; template struct tmat4x3 < float64 , highp > ; // ▁ tmat4x4 ▁ type ▁ explicit ▁ instantiation ENDCOM template struct tmat4x4 < float32 , lowp > ; template struct tmat4x4 < float64 , lowp > ; template struct tmat4x4 < float32 , mediump > ; template struct tmat4x4 < float64 , mediump > ; template struct tmat4x4 < float32 , highp > ; template struct tmat4x4 < float64 , highp > ; // ▁ tquat ▁ type ▁ explicit ▁ instantiation ENDCOM template struct tquat < float32 , lowp > ; template struct tquat < float64 , lowp > ; template struct tquat < float32 , mediump > ; template struct tquat < float64 , mediump > ; template struct tquat < float32 , highp > ; template struct tquat < float64 , highp > ; // tdualquat ▁ type ▁ explicit ▁ instantiation ENDCOM template struct tdualquat < float32 , lowp > ; template struct tdualquat < float64 , lowp > ; template struct tdualquat < float32 , mediump > ; template struct tdualquat < float64 , mediump > ; template struct tdualquat < float32 , highp > ; template struct tdualquat < float64 , highp > ; } // namespace ▁ detail ENDCOM } // namespace ▁ glm ENDCOM </DOCUMENT>
<DOCUMENT_ID="krf/kdevelop/tree/master/debuggers/gdb/printers/tests/qmapint.cpp"> # include < QMap > int main ( ) { QMap < int , int > m ; m [ 10 ] = 100 ; m [ 20 ] = 200 ; m [ 30 ] = 300 ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="g3rg/GoldenCheetah/tree/master/src/HrPwPlot.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( c ) ▁ 2011 ▁ Damien ▁ Grauser STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it STRNEWLINE ▁ * ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free STRNEWLINE ▁ * ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) STRNEWLINE ▁ * ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT STRNEWLINE ▁ * ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or STRNEWLINE ▁ * ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for STRNEWLINE ▁ * ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along STRNEWLINE ▁ * ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ▁ 51 STRNEWLINE ▁ * ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , ▁ Boston , ▁ MA ▁ 02110-1301 ▁ USA STRNEWLINE ▁ */ # include " HrPwPlot . h " # include " MainWindow . h " # include " HrPwWindow . h " # include " RideFile . h " # include " RideItem . h " # include " Zones . h " # include " Settings . h " # include " Colors . h " # include < assert . h > # include < qwt_plot_curve . h > # include < qwt_plot_grid . h > # include < qwt_plot_canvas . h > # include < qwt_plot_marker . h > # include < qwt_text . h > # include < qwt_symbol . h > # include < qwt_legend . h > # include < qwt_series_data . h > static inline double max ( double a , double b ) { if ( a > b ) return a ; else return b ; } HrPwPlot :: HrPwPlot ( MainWindow * mainWindow , HrPwWindow * hrPwWindow ) : QwtPlot ( hrPwWindow ) , hrPwWindow ( hrPwWindow ) , mainWindow ( mainWindow ) , bg ( NULL ) , delay ( - 1 ) , minHr ( 50 ) , minWatt ( 50 ) , maxWatt ( 500 ) , settings ( GC_SETTINGS_CO , GC_SETTINGS_APP ) , unit ( settings . value ( GC_UNIT ) ) { setCanvasBackground ( Qt :: white ) ; canvas ( ) -> setFrameStyle ( QFrame :: NoFrame ) ; setXTitle ( ) ; // ▁ Power ▁ ( Watts ) ENDCOM // ▁ Linear ▁ Regression ▁ Curve ENDCOM regCurve = new QwtPlotCurve ( " reg " ) ; regCurve -> setPen ( QPen ( GColor ( CPLOTMARKER ) ) ) ; regCurve -> attach ( this ) ; // ▁ Power ▁ distribution ENDCOM wattsStepCurve = new QwtPlotCurve ( " Power " ) ; wattsStepCurve -> setStyle ( QwtPlotCurve :: Steps ) ; wattsStepCurve -> setRenderHint ( QwtPlotItem :: RenderAntialiased ) ; QColor wattsColor = QColor ( 200 , 200 , 255 ) ; QColor wattsColor2 = QColor ( 100 , 100 , 255 ) ; wattsStepCurve -> setPen ( QPen ( wattsColor2 ) ) ; wattsStepCurve -> setBrush ( QBrush ( wattsColor ) ) ; wattsStepCurve -> attach ( this ) ; // ▁ Hr ▁ distribution ENDCOM hrStepCurve = new QwtPlotCurve ( " Hr " ) ; hrStepCurve -> setStyle ( QwtPlotCurve :: Steps ) ; hrStepCurve -> setRenderHint ( QwtPlotItem :: RenderAntialiased ) ; QColor hrColor = QColor ( 255 , 200 , 200 ) ; QColor hrColor2 = QColor ( 255 , 100 , 100 ) ; hrStepCurve -> setPen ( QPen ( hrColor2 ) ) ; hrStepCurve -> setBrush ( QBrush ( hrColor ) ) ; hrStepCurve -> attach ( this ) ; // ▁ Heart ▁ Rate ▁ Curve ENDCOM hrCurves . resize ( 36 ) ; for ( int i = 0 ; i < 36 ; ++ i ) { hrCurves [ i ] = new QwtPlotCurve ; hrCurves [ i ] -> attach ( this ) ; } // ▁ Grid ENDCOM grid = new QwtPlotGrid ( ) ; grid -> enableX ( false ) ; QPen gridPen ; gridPen . setStyle ( Qt :: DotLine ) ; gridPen . setColor ( GColor ( CPLOTGRID ) ) ; grid -> setPen ( gridPen ) ; grid -> attach ( this ) ; // ▁ axis ▁ markers ENDCOM r_mrk1 = new QwtPlotMarker ; r_mrk2 = new QwtPlotMarker ; r_mrk1 -> attach ( this ) ; r_mrk2 -> attach ( this ) ; shade_zones = true ; } struct DataPoint { double time , hr , watts ; int inter ; DataPoint ( double t , double h , double w , int i ) : time ( t ) , hr ( h ) , watts ( w ) , inter ( i ) { } } ; void HrPwPlot :: setAxisTitle ( int axis , QString label ) { // ▁ setup ▁ the ▁ default ▁ fonts ENDCOM QFont stGiles ; // ▁ hoho ▁ - ▁ Chart ▁ Font ▁ St . ▁ Giles ▁ . . . ▁ ok ▁ you ▁ have ▁ to ▁ be ▁ British ▁ to ▁ get ▁ this ▁ joke ENDCOM stGiles . fromString ( appsettings -> value ( this , GC_FONT_CHARTLABELS , QFont ( ) . toString ( ) ) . toString ( ) ) ; stGiles . setPointSize ( appsettings -> value ( NULL , GC_FONT_CHARTLABELS_SIZE , 8 ) . toInt ( ) ) ; QwtText title ( label ) ; title . setFont ( stGiles ) ; QwtPlot :: setAxisFont ( axis , stGiles ) ; QwtPlot :: setAxisTitle ( axis , title ) ; } void HrPwPlot :: recalc ( ) { if ( timeArray . count ( ) == 0 ) return ; int rideTimeSecs = ( int ) ceil ( timeArray [ arrayLength - 1 ] ) ; if ( rideTimeSecs > 7 * 24 * 60 * 60 ) { return ; } // ▁ Find ▁ Hr ▁ Delay ENDCOM // int ▁ delayori ▁ = ▁ findDelay ( wattsArray , ▁ hrArray , ▁ rideTimeSecs / 5 ) ; ENDCOM // int ▁ delay ▁ = ▁ 0 ; ENDCOM // ▁ - - - - - ▁ smoothing ▁ - - - - - ENDCOM double totalWatts = 0.0 ; double totalHr = 0.0 ; QList < DataPoint * > list ; int i = 0 ; QVector < double > smoothWatts ( rideTimeSecs + 1 ) ; QVector < double > smoothHr ( rideTimeSecs + 1 ) ; QVector < double > smoothTime ( rideTimeSecs + 1 ) ; int decal = 0 ; /* for ▁ ( int ▁ secs ▁ = ▁ 0 ; ▁ ( ( secs ▁ < ▁ smooth ) ▁ & & ▁ ( secs ▁ < ▁ rideTimeSecs ) ) ; ▁ + + secs ) ▁ { STRNEWLINE ▁ smoothWatts [ secs ] ▁ = ▁ 0.0 ; STRNEWLINE ▁ smoothHr [ secs ] ▁ = ▁ 0.0 ; STRNEWLINE ▁ } */ // int ▁ interval ▁ = ▁ 0 ; ENDCOM int smooth = hrPwWindow -> smooth ; for ( int secs = smooth ; secs <= rideTimeSecs ; ++ secs ) { while ( ( i < arrayLength ) && ( timeArray [ i ] <= secs ) ) { DataPoint * dp = new DataPoint ( timeArray [ i ] , hrArray [ i ] , wattsArray [ i ] , interArray [ i ] ) ; totalWatts += wattsArray [ i ] ; totalHr += hrArray [ i ] ; list . append ( dp ) ; ++ i ; } while ( ! list . empty ( ) && ( list . front ( ) -> time < secs - smooth ) ) { DataPoint * dp = list . front ( ) ; list . removeFirst ( ) ; totalWatts -= dp -> watts ; totalHr -= dp -> hr ; delete dp ; } if ( list . empty ( ) ) { ++ decal ; } else { smoothWatts [ secs - decal ] = totalWatts / list . size ( ) ; smoothHr [ secs - decal ] = totalHr / list . size ( ) ; // ▁ Utiliser ▁ interval ▁ du ▁ fichier ENDCOM // if ▁ ( smooth / list . size ( ) > 0 ) ENDCOM // TABSYMBOL interval ▁ = ▁ smooth / list . size ( ) ; ENDCOM } smoothTime [ secs ] = secs / 60.0 ; } rideTimeSecs = rideTimeSecs - decal ; smoothWatts . resize ( rideTimeSecs ) ; smoothHr . resize ( rideTimeSecs ) ; // ▁ Clip ▁ to ▁ max ENDCOM QVector < double > clipWatts ( rideTimeSecs ) ; QVector < double > clipHr ( rideTimeSecs ) ; /* for ▁ ( int ▁ secs ▁ = ▁ 0 ; ▁ secs ▁ < ▁ rideTimeSecs ; ▁ + + secs ) ▁ { STRNEWLINE ▁ clipWatts [ secs ] ▁ = ▁ 0.0 ; STRNEWLINE ▁ clipHr [ secs ] ▁ = ▁ 0.0 ; STRNEWLINE ▁ } */ decal = 0 ; for ( int secs = 0 ; secs < rideTimeSecs ; ++ secs ) { if ( smoothHr [ secs ] >= minHr && smoothWatts [ secs ] >= minWatt && smoothWatts [ secs ] < maxWatt ) { clipWatts [ secs - decal ] = smoothWatts [ secs ] ; clipHr [ secs - decal ] = smoothHr [ secs ] ; } else decal ++ ; } rideTimeSecs = rideTimeSecs - decal ; clipWatts . resize ( rideTimeSecs ) ; clipHr . resize ( rideTimeSecs ) ; // ▁ Find ▁ Hr ▁ Delay ENDCOM if ( delay == - 1 ) delay = hrPwWindow -> findDelay ( clipWatts , clipHr , clipWatts . size ( ) ) ; // ▁ Apply ▁ delay ENDCOM QVector < double > delayWatts ( rideTimeSecs - delay ) ; QVector < double > delayHr ( rideTimeSecs - delay ) ; for ( int secs = 0 ; secs < rideTimeSecs - delay ; ++ secs ) { delayWatts [ secs ] = clipWatts [ secs ] ; delayHr [ secs ] = clipHr [ secs + delay ] ; } rideTimeSecs = rideTimeSecs - delay ; double rpente = hrPwWindow -> pente ( delayWatts , delayHr , delayWatts . size ( ) ) ; double rordonnee = hrPwWindow -> ordonnee ( delayWatts , delayHr , delayWatts . size ( ) ) ; double maxr = hrPwWindow -> corr ( delayWatts , delayHr , delayWatts . size ( ) ) ; // ▁ - - - - - ▁ limit ▁ plotted ▁ points ▁ - - - ENDCOM int intpoints = 10 ; // ▁ could ▁ be ▁ ride ▁ length ▁ dependent ENDCOM int nbpoints = ( int ) floor ( rideTimeSecs / intpoints ) ; QVector < double > plotedWatts ( nbpoints ) ; QVector < double > plotedHr ( nbpoints ) ; for ( int secs = 0 ; secs < nbpoints ; ++ secs ) { plotedWatts [ secs ] = clipWatts [ secs * intpoints ] ; plotedHr [ secs ] = clipHr [ secs * intpoints ] ; } int nbpoints2 = ( int ) floor ( nbpoints / 36 ) + 2 ; double * plotedWattsArray [ 36 ] ; double * plotedHrArray [ 36 ] ; for ( int i = 0 ; i < 36 ; ++ i ) { plotedWattsArray [ i ] = new double [ nbpoints2 ] ; plotedHrArray [ i ] = new double [ nbpoints2 ] ; } for ( int secs = 0 ; secs < nbpoints ; ++ secs ) { for ( int i = 0 ; i < 36 ; ++ i ) { if ( secs >= i * nbpoints2 && secs < ( i + 1 ) * nbpoints2 ) { plotedWattsArray [ i ] [ secs - i * nbpoints2 ] = plotedWatts [ secs - i ] ; plotedHrArray [ i ] [ secs - i * nbpoints2 ] = plotedHr [ secs - i ] ; } } } for ( int i = 0 ; i < 36 ; ++ i ) { if ( nbpoints - i * nbpoints2 > 0 ) { hrCurves [ i ] -> setData ( plotedWattsArray [ i ] , plotedHrArray [ i ] , ( nbpoints - i * nbpoints2 < nbpoints2 ? nbpoints - i * nbpoints2 : nbpoints2 ) ) ; hrCurves [ i ] -> setVisible ( true ) ; } else hrCurves [ i ] -> setVisible ( false ) ; } setAxisScale ( xBottom , 0.0 , maxWatt ) ; setYMax ( ) ; refreshZoneLabels ( ) ; QString labelp ; labelp . setNum ( rpente , ' f ' , 3 ) ; QString labelo ; labelo . setNum ( rordonnee , ' f ' , 1 ) ; QString labelr ; labelr . setNum ( maxr , ' f ' , 3 ) ; QString labeldelay ; labeldelay . setNum ( delay ) ; int power150 = ( int ) floor ( ( 150 - rordonnee ) / rpente ) ; QString labelpower150 ; labelpower150 . setNum ( power150 ) ; QwtText textr = QwtText ( labelp + " * x + " + labelo + " ▁ : ▁ R ▁ " + labelr + " ▁ ( " + labeldelay + " ) ▁ \n ▁ Power @ 150 : " + labelpower150 + " W " ) ; textr . setFont ( QFont ( " Helvetica " , 10 , QFont :: Bold ) ) ; textr . setColor ( Qt :: black ) ; r_mrk1 -> setValue ( 0 , 0 ) ; r_mrk1 -> setLineStyle ( QwtPlotMarker :: VLine ) ; r_mrk1 -> setLabelAlignment ( Qt :: AlignRight | Qt :: AlignTop ) ; r_mrk1 -> setLinePen ( QPen ( Qt :: black , 0 , Qt :: DashDotLine ) ) ; double moyennewatt = hrPwWindow -> moyenne ( clipWatts , clipWatts . size ( ) ) ; r_mrk1 -> setValue ( moyennewatt , 0.0 ) ; r_mrk1 -> setLabel ( textr ) ; r_mrk2 -> setValue ( 0 , 0 ) ; r_mrk2 -> setLineStyle ( QwtPlotMarker :: HLine ) ; r_mrk2 -> setLabelAlignment ( Qt :: AlignRight | Qt :: AlignTop ) ; r_mrk2 -> setLinePen ( QPen ( Qt :: black , 0 , Qt :: DashDotLine ) ) ; double moyennehr = hrPwWindow -> moyenne ( clipHr , clipHr . size ( ) ) ; r_mrk2 -> setValue ( 0.0 , moyennehr ) ; addWattStepCurve ( clipWatts , clipWatts . size ( ) ) ; addHrStepCurve ( clipHr , clipHr . size ( ) ) ; addRegLinCurve ( rpente , rordonnee ) ; setJoinLine ( joinLine ) ; replot ( ) ; } void HrPwPlot :: setYMax ( ) { double ymax = 0 ; QString ylabel = " " ; for ( int i = 0 ; i < 36 ; ++ i ) { if ( hrCurves [ i ] -> isVisible ( ) ) { ymax = max ( ymax , hrCurves [ i ] -> maxYValue ( ) ) ; // ylabel ▁ + = ▁ QString ( ( ylabel ▁ = = ▁ " " ) ▁ ? ▁ " " ▁ : ▁ " ▁ / ▁ " ) ▁ + ▁ " BPM " ; ENDCOM } } setAxisScale ( yLeft , minHr , ymax * 1.2 ) ; setAxisTitle ( yLeft , tr ( " Heart ▁ Rate ( BPM ) " ) ) ; } void HrPwPlot :: addWattStepCurve ( QVector < double > & finalWatts , int nbpoints ) { QMap < double , double > powerHist ; for ( int h = 0 ; h < nbpoints ; ++ h ) { if ( powerHist . contains ( finalWatts [ h ] ) ) powerHist [ finalWatts [ h ] ] += 1 ; else powerHist [ finalWatts [ h ] ] = 1 ; } int maxPower = 500 ; double * array = new double [ maxPower ] ; for ( int i = 0 ; i < maxPower ; ++ i ) array [ i ] = 0.0 ; QMapIterator < double , double > k ( powerHist ) ; while ( k . hasNext ( ) ) { k . next ( ) ; array [ ( int ) round ( k . key ( ) ) ] += k . value ( ) ; } int nbSteps = ( int ) ceil ( ( maxPower - 1 ) / 10 ) ; QVector < double > smoothWattsStep ( nbSteps + 1 ) ; QVector < double > smoothTimeStep ( nbSteps + 1 ) ; int t ; for ( t = 1 ; t < nbSteps ; ++ t ) { int low = t * 10 ; int high = low + 10 ; smoothWattsStep [ t ] = low ; smoothTimeStep [ t ] = minHr ; while ( low < high ) { smoothTimeStep [ t ] += array [ low ++ ] / nbpoints * 300 ; } } smoothTimeStep [ t ] = 0.0 ; smoothWattsStep [ t ] = t * 10 ; wattsStepCurve -> setData ( smoothWattsStep . data ( ) , smoothTimeStep . data ( ) , nbSteps + 1 ) ; } void HrPwPlot :: addHrStepCurve ( QVector < double > & finalHr , int nbpoints ) { QMap < double , double > hrHist ; for ( int h = 0 ; h < nbpoints ; ++ h ) { if ( hrHist . contains ( finalHr [ h ] ) ) hrHist [ finalHr [ h ] ] += 1 ; else hrHist [ finalHr [ h ] ] = 1 ; } int maxHr = 220 ; double * array = new double [ maxHr ] ; for ( int i = 0 ; i < maxHr ; ++ i ) array [ i ] = 0.0 ; QMapIterator < double , double > l ( hrHist ) ; while ( l . hasNext ( ) ) { l . next ( ) ; array [ ( int ) round ( l . key ( ) ) ] += l . value ( ) ; } int nbSteps = ( int ) ceil ( ( maxHr - 1 ) / 2 ) ; QVector < double > smoothHrStep ( nbSteps + 1 ) ; QVector < double > smoothTimeStep2 ( nbSteps + 1 ) ; int t ; for ( t = 1 ; t < nbSteps ; ++ t ) { int low = t * 2 ; int high = low + 2 ; smoothHrStep [ t ] = low ; smoothTimeStep2 [ t ] = 0.0 ; while ( low < high ) { smoothTimeStep2 [ t ] += array [ low ++ ] / nbpoints * 500 ; } } smoothTimeStep2 [ t ] = 0.0 ; smoothHrStep [ t ] = t * 2 ; hrStepCurve -> setData ( smoothTimeStep2 . data ( ) , smoothHrStep . data ( ) , nbSteps + 1 ) ; } void HrPwPlot :: addRegLinCurve ( double rpente , double rordonnee ) { double regWatts [ ] = { 0 , 0 } ; double regHr [ ] = { 0 , 500 } ; regWatts [ 0 ] = regHr [ 0 ] * rpente + rordonnee ; regWatts [ 1 ] = regHr [ 1 ] * rpente + rordonnee ; regCurve -> setData ( regHr , regWatts , 2 ) ; } void HrPwPlot :: setXTitle ( ) { setAxisTitle ( xBottom , tr ( " Power ▁ ( Watts ) " ) ) ; } void HrPwPlot :: setDataFromRide ( RideItem * _rideItem ) { rideItem = _rideItem ; // ▁ ignore ▁ null ▁ / ▁ bad ▁ rides ENDCOM if ( ! _rideItem || ! _rideItem -> ride ( ) ) return ; RideFile * ride = rideItem -> ride ( ) ; const RideFileDataPresent * dataPresent = ride -> areDataPresent ( ) ; int npoints = ride -> dataPoints ( ) . size ( ) ; if ( dataPresent -> watts && dataPresent -> hr ) { wattsArray . resize ( npoints ) ; hrArray . resize ( npoints ) ; timeArray . resize ( npoints ) ; interArray . resize ( npoints ) ; arrayLength = 0 ; // QListIterator < RideFilePoint * > ▁ i ( ride - > dataPoints ( ) ) ; ENDCOM // while ▁ ( i . hasNext ( ) ) ▁ { ENDCOM foreach ( const RideFilePoint * point , ride -> dataPoints ( ) ) { // RideFilePoint ▁ * point ▁ = ▁ i . next ( ) ; ENDCOM if ( ! timeArray . empty ( ) ) timeArray [ arrayLength ] = point -> secs ; if ( ! wattsArray . empty ( ) ) wattsArray [ arrayLength ] = max ( 0 , point -> watts ) ; if ( ! hrArray . empty ( ) ) hrArray [ arrayLength ] = max ( 0 , point -> hr ) ; if ( ! interArray . empty ( ) ) interArray [ arrayLength ] = point -> interval ; ++ arrayLength ; } delay = - 1 ; recalc ( ) ; } } void HrPwPlot :: setJoinLine ( bool value ) { joinLine = value ; for ( int i = 0 ; i < 36 ; ++ i ) { QColor color = QColor ( 255 , 255 , 255 ) ; color . setHsv ( 60 + i * ( 360 / 36 ) , 255 , 255 , 255 ) ; if ( value ) { QwtSymbol sym ; sym . setStyle ( QwtSymbol :: NoSymbol ) ; QPen pen = QPen ( color ) ; pen . setWidth ( 1 ) ; hrCurves [ i ] -> setPen ( pen ) ; hrCurves [ i ] -> setStyle ( QwtPlotCurve :: Lines ) ; hrCurves [ i ] -> setSymbol ( new QwtSymbol ( sym ) ) ; } else { QwtSymbol sym ; sym . setStyle ( QwtSymbol :: Ellipse ) ; sym . setSize ( 5 ) ; sym . setPen ( QPen ( color ) ) ; sym . setBrush ( QBrush ( color ) ) ; hrCurves [ i ] -> setPen ( Qt :: NoPen ) ; hrCurves [ i ] -> setStyle ( QwtPlotCurve :: Dots ) ; hrCurves [ i ] -> setSymbol ( new QwtSymbol ( sym ) ) ; } // hrCurves [ i ] . setRenderHint ( QwtPlotItem : : RenderAntialiased ) ; ENDCOM } } void HrPwPlot :: pointHover ( QwtPlotCurve * curve , int index ) { if ( index >= 0 ) { double yvalue = curve -> sample ( index ) . y ( ) ; double xvalue = curve -> sample ( index ) . x ( ) ; // ▁ output ▁ the ▁ tooltip ENDCOM QString text = QString ( " % 1 ▁ % 2 \n % 3 ▁ % 4" ) . arg ( yvalue , 0 , ' f ' , 0 ) . arg ( this -> axisTitle ( curve -> yAxis ( ) ) . text ( ) ) . arg ( xvalue , 0 , ' f ' , 2 ) . arg ( this -> axisTitle ( curve -> xAxis ( ) ) . text ( ) ) ; // ▁ set ▁ that ▁ text ▁ up ENDCOM tooltip -> setText ( text ) ; } else { tooltip -> setText ( " " ) ; } } /* - - - - - STRNEWLINE ▁ * ▁ Draw ▁ Power ▁ Zone ▁ Shading ▁ on ▁ Background ▁ ( here ▁ to ▁ end ▁ of ▁ source ▁ file ) STRNEWLINE ▁ * - - - - - */ class HrPwPlotBackground : public QwtPlotItem { private : HrPwPlot * parent ; public : HrPwPlotBackground ( HrPwPlot * _parent ) { setZ ( 0.0 ) ; parent = _parent ; } virtual int rtti ( ) const { return QwtPlotItem :: Rtti_PlotUserItem ; } virtual void draw ( QPainter * painter , const QwtScaleMap & xMap , const QwtScaleMap & , const QRectF & rect ) const { RideItem * rideItem = parent -> rideItem ; if ( ! rideItem ) return ; const Zones * zones = rideItem -> zones ; int zone_range = rideItem -> zoneRange ( ) ; if ( parent -> isShadeZones ( ) && zones && ( zone_range >= 0 ) ) { QList < int > zone_lows = zones -> getZoneLows ( zone_range ) ; int num_zones = zone_lows . size ( ) ; if ( num_zones > 0 ) { for ( int z = 0 ; z < num_zones ; z ++ ) { QRectF r = rect ; QColor shading_color = zoneColor ( z , num_zones ) ; shading_color . setHsv ( shading_color . hue ( ) , shading_color . saturation ( ) / 4 , shading_color . value ( ) ) ; r . setLeft ( xMap . transform ( zone_lows [ z ] ) ) ; if ( z + 1 < num_zones ) r . setRight ( xMap . transform ( zone_lows [ z + 1 ] ) ) ; if ( r . left ( ) <= r . right ( ) ) painter -> fillRect ( r , shading_color ) ; } } } } } ; // ▁ Zone ▁ labels ▁ are ▁ drawn ▁ if ▁ power ▁ zone ▁ bands ▁ are ▁ enabled , ▁ automatically ENDCOM // ▁ at ▁ the ▁ center ▁ of ▁ the ▁ plot ENDCOM class HrPwPlotZoneLabel : public QwtPlotItem { private : HrPwPlot * parent ; int zone_number ; double watts ; QwtText text ; public : HrPwPlotZoneLabel ( HrPwPlot * _parent , int _zone_number ) { parent = _parent ; zone_number = _zone_number ; RideItem * rideItem = parent -> rideItem ; if ( ! rideItem ) return ; const Zones * zones = rideItem -> zones ; int zone_range = rideItem -> zoneRange ( ) ; // ▁ create ▁ new ▁ zone ▁ labels ▁ if ▁ we ' re ▁ shading ENDCOM if ( parent -> isShadeZones ( ) && zones && ( zone_range >= 0 ) ) { QList < int > zone_lows = zones -> getZoneLows ( zone_range ) ; QList < QString > zone_names = zones -> getZoneNames ( zone_range ) ; int num_zones = zone_lows . size ( ) ; assert ( zone_names . size ( ) == num_zones ) ; if ( zone_number < num_zones ) { watts = ( ( zone_number + 1 < num_zones ) ? 0.5 * ( zone_lows [ zone_number ] + zone_lows [ zone_number + 1 ] ) : ( ( zone_number > 0 ) ? ( 1.5 * zone_lows [ zone_number ] - 0.5 * zone_lows [ zone_number - 1 ] ) : 2.0 * zone_lows [ zone_number ] ) ) ; text = QwtText ( zone_names [ zone_number ] ) ; text . setFont ( QFont ( " Helvetica " , 24 , QFont :: Bold ) ) ; QColor text_color = zoneColor ( zone_number , num_zones ) ; text_color . setAlpha ( 64 ) ; text . setColor ( text_color ) ; } } setZ ( 1.0 + zone_number / 100.0 ) ; } virtual int rtti ( ) const { return QwtPlotItem :: Rtti_PlotUserItem ; } void draw ( QPainter * painter , const QwtScaleMap & xMap , const QwtScaleMap & , const QRectF & rect ) const { if ( parent -> isShadeZones ( ) ) { int y = ( rect . bottom ( ) + rect . top ( ) ) / 2 ; int x = xMap . transform ( watts ) ; // ▁ the ▁ following ▁ code ▁ based ▁ on ▁ source ▁ for ▁ QwtPlotMarker : : draw ( ) ENDCOM QRect tr ( QPoint ( 0 , 0 ) , text . textSize ( painter -> font ( ) ) . toSize ( ) ) ; tr . moveCenter ( QPoint ( x , y ) ) ; text . draw ( painter , tr ) ; } } } ; int HrPwPlot :: isShadeZones ( ) const { return ( shadeZones && ! wattsArray . empty ( ) ) ; } void HrPwPlot :: setShadeZones ( int x ) { shadeZones = x ; } void HrPwPlot :: refreshZoneLabels ( ) { foreach ( HrPwPlotZoneLabel * label , zoneLabels ) { label -> detach ( ) ; delete label ; } zoneLabels . clear ( ) ; if ( bg ) { bg -> detach ( ) ; delete bg ; bg = NULL ; } if ( rideItem ) { int zone_range = rideItem -> zoneRange ( ) ; const Zones * zones = rideItem -> zones ; // ▁ generate ▁ labels ▁ for ▁ existing ▁ zones ENDCOM if ( zones && ( zone_range >= 0 ) ) { int num_zones = zones -> numZones ( zone_range ) ; for ( int z = 0 ; z < num_zones ; z ++ ) { HrPwPlotZoneLabel * label = new HrPwPlotZoneLabel ( this , z ) ; label -> attach ( this ) ; zoneLabels . append ( label ) ; } } } // ▁ create ▁ a ▁ background ▁ object ▁ for ▁ shading ENDCOM bg = new HrPwPlotBackground ( this ) ; bg -> attach ( this ) ; } </DOCUMENT>
<DOCUMENT_ID="android-ia/platform_external_chromium_org_third_party_WebKit/tree/master/Source/core/dom/PseudoElement.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2012 ▁ Google ▁ Inc . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without STRNEWLINE ▁ * ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions ▁ are STRNEWLINE ▁ * ▁ met : STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ * ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . STRNEWLINE ▁ * ▁ * ▁ Neither ▁ the ▁ name ▁ of ▁ Google ▁ Inc . ▁ nor ▁ the ▁ names ▁ of ▁ its STRNEWLINE ▁ * ▁ contributors ▁ may ▁ be ▁ used ▁ to ▁ endorse ▁ or ▁ promote ▁ products ▁ derived ▁ from STRNEWLINE ▁ * ▁ this ▁ software ▁ without ▁ specific ▁ prior ▁ written ▁ permission . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ THE ▁ COPYRIGHT ▁ HOLDERS ▁ AND ▁ CONTRIBUTORS STRNEWLINE ▁ * ▁ " AS ▁ IS " ▁ AND ▁ ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT STRNEWLINE ▁ * ▁ LIMITED ▁ TO , ▁ THE ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR STRNEWLINE ▁ * ▁ A ▁ PARTICULAR ▁ PURPOSE ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ▁ COPYRIGHT STRNEWLINE ▁ * ▁ OWNER ▁ OR ▁ CONTRIBUTORS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , STRNEWLINE ▁ * ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ ( INCLUDING , ▁ BUT ▁ NOT STRNEWLINE ▁ * ▁ LIMITED ▁ TO , ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES ; ▁ LOSS ▁ OF ▁ USE , STRNEWLINE ▁ * ▁ DATA , ▁ OR ▁ PROFITS ; ▁ OR ▁ BUSINESS ▁ INTERRUPTION ) ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY STRNEWLINE ▁ * ▁ THEORY ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ CONTRACT , ▁ STRICT ▁ LIABILITY , ▁ OR ▁ TORT STRNEWLINE ▁ * ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE STRNEWLINE ▁ * ▁ OF ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . STRNEWLINE ▁ */ # include " config . h " # include " core / dom / PseudoElement . h " # include " core / inspector / InspectorInstrumentation . h " # include " core / rendering / RenderObject . h " # include " core / rendering / RenderQuote . h " # include " core / rendering / style / ContentData . h " namespace blink { const QualifiedName & pseudoElementTagName ( PseudoId pseudoId ) { switch ( pseudoId ) { case AFTER : { DEFINE_STATIC_LOCAL ( QualifiedName , after , ( nullAtom , " < pseudo : after > " , nullAtom ) ) ; return after ; } case BEFORE : { DEFINE_STATIC_LOCAL ( QualifiedName , before , ( nullAtom , " < pseudo : before > " , nullAtom ) ) ; return before ; } case BACKDROP : { DEFINE_STATIC_LOCAL ( QualifiedName , backdrop , ( nullAtom , " < pseudo : backdrop > " , nullAtom ) ) ; return backdrop ; } default : { ASSERT_NOT_REACHED ( ) ; } } DEFINE_STATIC_LOCAL ( QualifiedName , name , ( nullAtom , " < pseudo > " , nullAtom ) ) ; return name ; } String PseudoElement :: pseudoElementNameForEvents ( PseudoId pseudoId ) { DEFINE_STATIC_LOCAL ( const String , after , ( " : : after " ) ) ; DEFINE_STATIC_LOCAL ( const String , before , ( " : : before " ) ) ; switch ( pseudoId ) { case AFTER : return after ; case BEFORE : return before ; default : return emptyString ( ) ; } } PseudoElement :: PseudoElement ( Element * parent , PseudoId pseudoId ) : Element ( pseudoElementTagName ( pseudoId ) , & parent -> document ( ) , CreateElement ) , m_pseudoId ( pseudoId ) { ASSERT ( pseudoId != NOPSEUDO ) ; setParentOrShadowHostNode ( parent ) ; setHasCustomStyleCallbacks ( ) ; } PassRefPtr < RenderStyle > PseudoElement :: customStyleForRenderer ( ) { return parentOrShadowHostElement ( ) -> renderer ( ) -> getCachedPseudoStyle ( m_pseudoId ) ; } void PseudoElement :: dispose ( ) { ASSERT ( parentOrShadowHostElement ( ) ) ; InspectorInstrumentation :: pseudoElementDestroyed ( this ) ; ASSERT ( ! nextSibling ( ) ) ; ASSERT ( ! previousSibling ( ) ) ; detach ( ) ; RefPtrWillBeRawPtr < Element > parent = parentOrShadowHostElement ( ) ; setParentOrShadowHostNode ( 0 ) ; removedFrom ( parent . get ( ) ) ; } void PseudoElement :: attach ( const AttachContext & context ) { ASSERT ( ! renderer ( ) ) ; Element :: attach ( context ) ; RenderObject * renderer = this -> renderer ( ) ; if ( ! renderer ) return ; RenderStyle * style = renderer -> style ( ) ; if ( style -> styleType ( ) != BEFORE && style -> styleType ( ) != AFTER ) return ; ASSERT ( style -> contentData ( ) ) ; for ( const ContentData * content = style -> contentData ( ) ; content ; content = content -> next ( ) ) { RenderObject * child = content -> createRenderer ( document ( ) , style ) ; if ( renderer -> isChildAllowed ( child , style ) ) { renderer -> addChild ( child ) ; if ( child -> isQuote ( ) ) toRenderQuote ( child ) -> attachQuote ( ) ; } else child -> destroy ( ) ; } } bool PseudoElement :: rendererIsNeeded ( const RenderStyle & style ) { return pseudoElementRendererIsNeeded ( & style ) ; } void PseudoElement :: didRecalcStyle ( StyleRecalcChange ) { if ( ! renderer ( ) ) return ; // ▁ The ▁ renderers ▁ inside ▁ pseudo ▁ elements ▁ are ▁ anonymous ▁ so ▁ they ▁ don ' t ▁ get ▁ notified ▁ of ▁ recalcStyle ▁ and ▁ must ▁ have ENDCOM // ▁ the ▁ style ▁ propagated ▁ downward ▁ manually ▁ similar ▁ to ▁ RenderObject : : propagateStyleToAnonymousChildren . ENDCOM RenderObject * renderer = this -> renderer ( ) ; for ( RenderObject * child = renderer -> nextInPreOrder ( renderer ) ; child ; child = child -> nextInPreOrder ( renderer ) ) { // ▁ We ▁ only ▁ manage ▁ the ▁ style ▁ for ▁ the ▁ generated ▁ content ▁ items . ENDCOM if ( ! child -> isText ( ) && ! child -> isQuote ( ) && ! child -> isImage ( ) ) continue ; // ▁ The ▁ style ▁ for ▁ the ▁ RenderTextFragment ▁ for ▁ first ▁ letter ▁ is ▁ managed ▁ by ▁ an ▁ enclosing ▁ block , ▁ not ▁ by ▁ us . ENDCOM if ( child -> style ( ) -> styleType ( ) == FIRST_LETTER ) continue ; child -> setPseudoStyle ( renderer -> style ( ) ) ; } } } // ▁ namespace ENDCOM </DOCUMENT>
<DOCUMENT_ID="SingularityCore/Singularity/tree/master/dep/acelite/ace/Log_Msg_IPC.cpp"> // ▁ $ Id : ▁ Log _ Msg _ IPC . cpp ▁ 91286 ▁ 2010-08-05 ▁ 09:04:31Z ▁ johnnyw ▁ $ ENDCOM # include " ace / Log _ Msg _ IPC . h " # include " ace / Log _ Record . h " # include " ace / CDR _ Stream . h " # include " ace / Truncate . h " ACE_BEGIN_VERSIONED_NAMESPACE_DECL ACE_Log_Msg_IPC :: ACE_Log_Msg_IPC ( void ) { } ACE_Log_Msg_IPC :: ~ ACE_Log_Msg_IPC ( void ) { ( void ) this -> close ( ) ; } int ACE_Log_Msg_IPC :: open ( const ACE_TCHAR * logger_key ) { ACE_LOG_MSG_IPC_CONNECTOR con ; return con . connect ( this -> message_queue_ , ACE_LOG_MSG_IPC_ADDR ( logger_key ) ) ; } int ACE_Log_Msg_IPC :: reset ( void ) { if ( this -> message_queue_ . get_handle ( ) != ACE_INVALID_HANDLE ) { // ▁ If ▁ we ▁ don ' t ▁ do ▁ this , ▁ handles ▁ aren ' t ▁ reused ▁ on ▁ Win32 ▁ and ▁ the ENDCOM // ▁ server ▁ eventually ▁ crashes ! ENDCOM return this -> close ( ) ; } return 0 ; } int ACE_Log_Msg_IPC :: close ( void ) { return this -> message_queue_ . close ( ) ; } ssize_t ACE_Log_Msg_IPC :: log ( ACE_Log_Record & log_record ) { // ▁ Serialize ▁ the ▁ log ▁ record ▁ using ▁ a ▁ CDR ▁ stream , ▁ allocate ▁ enough ENDCOM // ▁ space ▁ for ▁ the ▁ complete ▁ < ACE _ Log _ Record > . ENDCOM size_t const max_payload_size = 4 // ▁ type ENDCOM + 4 // ▁ pid ENDCOM + 12 // ▁ timestamp ENDCOM + 4 // ▁ process ▁ id ENDCOM + 4 // ▁ data ▁ length ENDCOM # if defined ( ACE_USES_WCHAR ) + ( log_record . msg_data_len ( ) * ACE_OutputCDR :: wchar_maxbytes ( ) ) // ▁ message ENDCOM # else + log_record . msg_data_len ( ) // ▁ message ENDCOM # endif + ACE_CDR :: MAX_ALIGNMENT ; // ▁ padding ; ENDCOM // ▁ Insert ▁ contents ▁ of ▁ < log _ record > ▁ into ▁ payload ▁ stream . ENDCOM ACE_OutputCDR payload ( max_payload_size ) ; if ( ! ( payload << log_record ) ) return - 1 ; // ▁ Get ▁ the ▁ number ▁ of ▁ bytes ▁ used ▁ by ▁ the ▁ CDR ▁ stream . ▁ If ▁ it ▁ becomes ▁ desireable ENDCOM // ▁ to ▁ support ▁ payloads ▁ more ▁ than ▁ 4GB , ▁ this ▁ field ▁ will ▁ need ▁ to ▁ be ▁ changed ENDCOM // ▁ to ▁ a ▁ 64 - bit ▁ value . ENDCOM ACE_CDR :: ULong const length = ACE_Utils :: truncate_cast < ACE_CDR :: ULong > ( payload . total_length ( ) ) ; // ▁ Send ▁ a ▁ header ▁ so ▁ the ▁ receiver ▁ can ▁ determine ▁ the ▁ byte ▁ order ▁ and ENDCOM // ▁ size ▁ of ▁ the ▁ incoming ▁ CDR ▁ stream . ENDCOM ACE_OutputCDR header ( ACE_CDR :: MAX_ALIGNMENT + 8 ) ; if ( ! ( header << ACE_OutputCDR :: from_boolean ( ACE_CDR_BYTE_ORDER ) ) ) return - 1 ; // ▁ Store ▁ the ▁ size ▁ of ▁ the ▁ payload ▁ that ▁ follows ENDCOM if ( ! ( header << ACE_CDR :: ULong ( length ) ) ) return - 1 ; // ▁ Use ▁ an ▁ iovec ▁ to ▁ send ▁ both ▁ buffer ▁ and ▁ payload ▁ simultaneously . ENDCOM iovec iov [ 2 ] ; iov [ 0 ] . iov_base = header . begin ( ) -> rd_ptr ( ) ; iov [ 0 ] . iov_len = 8 ; iov [ 1 ] . iov_base = payload . begin ( ) -> rd_ptr ( ) ; iov [ 1 ] . iov_len = length ; # if ( ACE_HAS_STREAM_LOG_MSG_IPC == 1 ) // ▁ Use ▁ the ▁ < putpmsg > ▁ API ▁ if ▁ supported ▁ to ▁ ensure ▁ correct ▁ message ENDCOM // ▁ queueing ▁ according ▁ to ▁ priority . ENDCOM ACE_Str_Buf header_msg ( static_cast < void * > ( header . begin ( ) -> rd_ptr ( ) ) , static_cast < int > ( 8 ) ) ; ACE_Str_Buf payload_msg ( static_cast < void * > ( payload . begin ( ) -> rd_ptr ( ) ) , static_cast < int > ( length ) ) ; return this -> message_queue_ . send ( & header_msg , & payload_msg , static_cast < int > ( log_record . priority ( ) ) , MSG_BAND ) ; # else // ▁ We ' re ▁ running ▁ over ▁ sockets , ▁ so ▁ send ▁ header ▁ and ▁ payload ENDCOM // ▁ efficiently ▁ using ▁ " gather - write " . ENDCOM return this -> message_queue_ . sendv_n ( iov , 2 ) ; # endif /* ▁ ACE _ HAS _ STREAM _ LOG _ MSG _ IPC ▁ */ } ACE_END_VERSIONED_NAMESPACE_DECL </DOCUMENT>
<DOCUMENT_ID="LiveAsynchronousVisualizedArchitecture/lava/tree/master/nuklear/unified.cpp"> # define LAVA_INDEXED_VERTS_IMPL # include " IndexedVerts . h " # include " nanogui / src / screen . cpp " # include " main . cpp " </DOCUMENT>
<DOCUMENT_ID="Voyager1/xbmc/tree/master/xbmc/windowing/rpi/GLContextEGL.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2005-2013 ▁ Team ▁ XBMC STRNEWLINE ▁ * ▁ http : // xbmc . org STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ Program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 , ▁ or ▁ ( at ▁ your ▁ option ) STRNEWLINE ▁ * ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ Program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ XBMC ; ▁ see ▁ the ▁ file ▁ COPYING . ▁ If ▁ not , ▁ see STRNEWLINE ▁ * ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ * STRNEWLINE ▁ */ # include " GLContextEGL . h " # include " guilib / IDirtyRegionSolver . h " # include " settings / AdvancedSettings . h " # include " utils / log . h " CGLContextEGL :: CGLContextEGL ( ) : m_eglDisplay ( EGL_NO_DISPLAY ) , m_eglSurface ( EGL_NO_SURFACE ) , m_eglContext ( EGL_NO_CONTEXT ) , m_eglConfig ( 0 ) { } CGLContextEGL :: ~ CGLContextEGL ( ) { Destroy ( ) ; } bool CGLContextEGL :: CreateDisplay ( EGLDisplay display , EGLint renderable_type , EGLint rendering_api ) { EGLint neglconfigs = 0 ; int major , minor ; EGLint surface_type = EGL_WINDOW_BIT ; // ▁ for ▁ the ▁ non - trivial ▁ dirty ▁ region ▁ modes , ▁ we ▁ need ▁ the ▁ EGL ▁ buffer ▁ to ▁ be ▁ preserved ▁ across ▁ updates ENDCOM if ( g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION || g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION ) surface_type |= EGL_SWAP_BEHAVIOR_PRESERVED_BIT ; EGLint attribs [ ] = { EGL_RED_SIZE , 8 , EGL_GREEN_SIZE , 8 , EGL_BLUE_SIZE , 8 , EGL_ALPHA_SIZE , 8 , EGL_DEPTH_SIZE , 16 , EGL_STENCIL_SIZE , 0 , EGL_SAMPLE_BUFFERS , 0 , EGL_SAMPLES , 0 , EGL_SURFACE_TYPE , surface_type , EGL_RENDERABLE_TYPE , renderable_type , EGL_NONE } ; if ( m_eglDisplay == EGL_NO_DISPLAY ) { m_eglDisplay = eglGetDisplay ( ( EGLNativeDisplayType ) display ) ; } if ( m_eglDisplay == EGL_NO_DISPLAY ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ get ▁ EGL ▁ display " ) ; return false ; } if ( ! eglInitialize ( m_eglDisplay , & major , & minor ) ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ initialize ▁ EGL ▁ display " ) ; return false ; } eglBindAPI ( rendering_api ) ; if ( ! eglChooseConfig ( m_eglDisplay , attribs , & m_eglConfig , 1 , & neglconfigs ) ) { CLog :: Log ( LOGERROR , " Failed ▁ to ▁ query ▁ number ▁ of ▁ EGL ▁ configs " ) ; return false ; } if ( neglconfigs <= 0 ) { CLog :: Log ( LOGERROR , " No ▁ suitable ▁ EGL ▁ configs ▁ found " ) ; return false ; } return true ; } bool CGLContextEGL :: CreateContext ( ) { int client_version = 2 ; const EGLint context_attribs [ ] = { EGL_CONTEXT_CLIENT_VERSION , client_version , EGL_NONE } ; if ( m_eglContext == EGL_NO_CONTEXT ) { m_eglContext = eglCreateContext ( m_eglDisplay , m_eglConfig , EGL_NO_CONTEXT , context_attribs ) ; } if ( m_eglContext == EGL_NO_CONTEXT ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ create ▁ EGL ▁ context " ) ; return false ; } return true ; } bool CGLContextEGL :: BindContext ( ) { if ( ! eglMakeCurrent ( m_eglDisplay , m_eglSurface , m_eglSurface , m_eglContext ) ) { CLog :: Log ( LOGERROR , " Failed ▁ to ▁ make ▁ context ▁ current ▁ % p ▁ % p ▁ % p " , m_eglDisplay , m_eglSurface , m_eglContext ) ; return false ; } return true ; } bool CGLContextEGL :: SurfaceAttrib ( ) { // ▁ for ▁ the ▁ non - trivial ▁ dirty ▁ region ▁ modes , ▁ we ▁ need ▁ the ▁ EGL ▁ buffer ▁ to ▁ be ▁ preserved ▁ across ▁ updates ENDCOM if ( g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION || g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION ) { if ( ( m_eglDisplay == EGL_NO_DISPLAY ) || ( m_eglSurface == EGL_NO_SURFACE ) ) { return false ; } if ( ! eglSurfaceAttrib ( m_eglDisplay , m_eglSurface , EGL_SWAP_BEHAVIOR , EGL_BUFFER_PRESERVED ) ) { CLog :: Log ( LOGDEBUG , " % s : ▁ Could ▁ not ▁ set ▁ EGL _ SWAP _ BEHAVIOR " , __FUNCTION__ ) ; } } return true ; } bool CGLContextEGL :: CreateSurface ( EGLNativeWindowType surface ) { m_eglSurface = eglCreateWindowSurface ( m_eglDisplay , m_eglConfig , surface , nullptr ) ; if ( m_eglSurface == EGL_NO_SURFACE ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ create ▁ EGL ▁ window ▁ surface ▁ % d " , eglGetError ( ) ) ; return false ; } return true ; } void CGLContextEGL :: Destroy ( ) { if ( m_eglContext != EGL_NO_CONTEXT ) { eglDestroyContext ( m_eglDisplay , m_eglContext ) ; eglMakeCurrent ( m_eglDisplay , EGL_NO_SURFACE , EGL_NO_SURFACE , EGL_NO_CONTEXT ) ; m_eglContext = EGL_NO_CONTEXT ; } if ( m_eglSurface != EGL_NO_SURFACE ) { eglDestroySurface ( m_eglDisplay , m_eglSurface ) ; m_eglSurface = EGL_NO_SURFACE ; } if ( m_eglDisplay != EGL_NO_DISPLAY ) { eglTerminate ( m_eglDisplay ) ; m_eglDisplay = EGL_NO_DISPLAY ; } } void CGLContextEGL :: Detach ( ) { if ( m_eglContext != EGL_NO_CONTEXT ) { eglMakeCurrent ( m_eglDisplay , EGL_NO_SURFACE , EGL_NO_SURFACE , EGL_NO_CONTEXT ) ; } if ( m_eglSurface != EGL_NO_SURFACE ) { eglDestroySurface ( m_eglDisplay , m_eglSurface ) ; m_eglSurface = EGL_NO_SURFACE ; } } bool CGLContextEGL :: SetVSync ( bool enable ) { if ( ! eglSwapInterval ( m_eglDisplay , enable ) ) { return false ; } return true ; } void CGLContextEGL :: SwapBuffers ( ) { if ( m_eglDisplay == EGL_NO_DISPLAY || m_eglSurface == EGL_NO_SURFACE ) { return ; } eglSwapBuffers ( m_eglDisplay , m_eglSurface ) ; } </DOCUMENT>
<DOCUMENT_ID="kzhong1991/Flight-AR.Drone-2/tree/master/src/3rdparty/Qt4.8.4/src/3rdparty/webkit/Source/WebCore/platform/graphics/mac/GlyphPageTreeNodeMac.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2006 , ▁ 2007 ▁ Apple ▁ Inc . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without STRNEWLINE ▁ * ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions STRNEWLINE ▁ * ▁ are ▁ met : STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ 1 . ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . ▁ STRNEWLINE ▁ * ▁ 2 . ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in ▁ the STRNEWLINE ▁ * ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the ▁ distribution . ▁ STRNEWLINE ▁ * ▁ 3 . ▁ Neither ▁ the ▁ name ▁ of ▁ Apple ▁ Computer , ▁ Inc . ▁ ( " Apple " ) ▁ nor ▁ the ▁ names ▁ of STRNEWLINE ▁ * ▁ its ▁ contributors ▁ may ▁ be ▁ used ▁ to ▁ endorse ▁ or ▁ promote ▁ products ▁ derived STRNEWLINE ▁ * ▁ from ▁ this ▁ software ▁ without ▁ specific ▁ prior ▁ written ▁ permission . ▁ STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ APPLE ▁ AND ▁ ITS ▁ CONTRIBUTORS ▁ " AS ▁ IS " ▁ AND ▁ ANY STRNEWLINE ▁ * ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ THE ▁ IMPLIED STRNEWLINE ▁ * ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE ▁ ARE STRNEWLINE ▁ * ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ APPLE ▁ OR ▁ ITS ▁ CONTRIBUTORS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY STRNEWLINE ▁ * ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES STRNEWLINE ▁ * ▁ ( INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES ; STRNEWLINE ▁ * ▁ LOSS ▁ OF ▁ USE , ▁ DATA , ▁ OR ▁ PROFITS ; ▁ OR ▁ BUSINESS ▁ INTERRUPTION ) ▁ HOWEVER ▁ CAUSED ▁ AND STRNEWLINE ▁ * ▁ ON ▁ ANY ▁ THEORY ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ CONTRACT , ▁ STRICT ▁ LIABILITY , ▁ OR ▁ TORT STRNEWLINE ▁ * ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE ▁ OF STRNEWLINE ▁ * ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . STRNEWLINE ▁ */ # include " config . h " # include " GlyphPageTreeNode . h " # include " Font . h " # include " SimpleFontData . h " # include " WebCoreSystemInterface . h " # include < ApplicationServices / ApplicationServices . h > namespace WebCore { static bool shouldUseCoreText ( UChar * buffer , unsigned bufferLength , const SimpleFontData * fontData ) { if ( fontData -> platformData ( ) . widthVariant ( ) != RegularWidth || fontData -> hasVerticalGlyphs ( ) ) { // ▁ Ideographs ▁ don ' t ▁ have ▁ a ▁ vertical ▁ variant ▁ or ▁ width ▁ variants . ENDCOM for ( unsigned i = 0 ; i < bufferLength ; ++ i ) { if ( ! Font :: isCJKIdeograph ( buffer [ i ] ) ) return true ; } } return false ; } bool GlyphPage :: fill ( unsigned offset , unsigned length , UChar * buffer , unsigned bufferLength , const SimpleFontData * fontData ) { bool haveGlyphs = false ; if ( ! shouldUseCoreText ( buffer , bufferLength , fontData ) ) { Vector < CGGlyph , 512 > glyphs ( bufferLength ) ; wkGetGlyphsForCharacters ( fontData -> platformData ( ) . cgFont ( ) , buffer , glyphs . data ( ) , bufferLength ) ; for ( unsigned i = 0 ; i < length ; ++ i ) { if ( ! glyphs [ i ] ) setGlyphDataForIndex ( offset + i , 0 , 0 ) ; else { setGlyphDataForIndex ( offset + i , glyphs [ i ] , fontData ) ; haveGlyphs = true ; } } } else { // ▁ We ▁ ask ▁ CoreText ▁ for ▁ possible ▁ vertical ▁ variant ▁ glyphs ENDCOM RetainPtr < CFStringRef > string ( AdoptCF , CFStringCreateWithCharactersNoCopy ( kCFAllocatorDefault , buffer , bufferLength , kCFAllocatorNull ) ) ; RetainPtr < CFAttributedStringRef > attributedString ( AdoptCF , CFAttributedStringCreate ( kCFAllocatorDefault , string . get ( ) , fontData -> getCFStringAttributes ( 0 , fontData -> hasVerticalGlyphs ( ) ? Vertical : Horizontal ) ) ) ; RetainPtr < CTLineRef > line ( AdoptCF , CTLineCreateWithAttributedString ( attributedString . get ( ) ) ) ; CFArrayRef runArray = CTLineGetGlyphRuns ( line . get ( ) ) ; CFIndex runCount = CFArrayGetCount ( runArray ) ; // ▁ Initialize ▁ glyph ▁ entries ENDCOM for ( unsigned index = 0 ; index < length ; ++ index ) setGlyphDataForIndex ( offset + index , 0 , 0 ) ; Vector < CGGlyph , 512 > glyphVector ; Vector < CFIndex , 512 > indexVector ; bool done = false ; // ▁ For ▁ the ▁ CGFont ▁ comparison ▁ in ▁ the ▁ loop , ▁ use ▁ the ▁ CGFont ▁ that ▁ Core ▁ Text ▁ assigns ▁ to ▁ the ▁ CTFont . ▁ This ▁ may ENDCOM // ▁ be ▁ non - CFEqual ▁ to ▁ fontData - > platformData ( ) . cgFont ( ) . ENDCOM RetainPtr < CGFontRef > cgFont ( AdoptCF , CTFontCopyGraphicsFont ( fontData -> platformData ( ) . ctFont ( ) , 0 ) ) ; for ( CFIndex r = 0 ; r < runCount && ! done ; ++ r ) { // ▁ CTLine ▁ could ▁ map ▁ characters ▁ over ▁ multiple ▁ fonts ▁ using ▁ its ▁ own ▁ font ▁ fallback ▁ list . ENDCOM // ▁ We ▁ need ▁ to ▁ pick ▁ runs ▁ that ▁ use ▁ the ▁ exact ▁ font ▁ we ▁ need , ▁ i . e . , ▁ fontData - > platformData ( ) . ctFont ( ) . ENDCOM CTRunRef ctRun = static_cast < CTRunRef > ( CFArrayGetValueAtIndex ( runArray , r ) ) ; ASSERT ( CFGetTypeID ( ctRun ) == CTRunGetTypeID ( ) ) ; CFDictionaryRef attributes = CTRunGetAttributes ( ctRun ) ; CTFontRef runFont = static_cast < CTFontRef > ( CFDictionaryGetValue ( attributes , kCTFontAttributeName ) ) ; RetainPtr < CGFontRef > runCGFont ( AdoptCF , CTFontCopyGraphicsFont ( runFont , 0 ) ) ; // ▁ Use ▁ CGFont ▁ here ▁ as ▁ CFEqual ▁ for ▁ CTFont ▁ counts ▁ all ▁ attributes ▁ for ▁ font . ENDCOM if ( CFEqual ( cgFont . get ( ) , runCGFont . get ( ) ) ) { // ▁ This ▁ run ▁ uses ▁ the ▁ font ▁ we ▁ want . ▁ Extract ▁ glyphs . ENDCOM CFIndex glyphCount = CTRunGetGlyphCount ( ctRun ) ; const CGGlyph * glyphs = CTRunGetGlyphsPtr ( ctRun ) ; if ( ! glyphs ) { glyphVector . resize ( glyphCount ) ; CTRunGetGlyphs ( ctRun , CFRangeMake ( 0 , 0 ) , glyphVector . data ( ) ) ; glyphs = glyphVector . data ( ) ; } const CFIndex * stringIndices = CTRunGetStringIndicesPtr ( ctRun ) ; if ( ! stringIndices ) { indexVector . resize ( glyphCount ) ; CTRunGetStringIndices ( ctRun , CFRangeMake ( 0 , 0 ) , indexVector . data ( ) ) ; stringIndices = indexVector . data ( ) ; } for ( CFIndex i = 0 ; i < glyphCount ; ++ i ) { if ( stringIndices [ i ] >= static_cast < CFIndex > ( length ) ) { done = true ; break ; } if ( glyphs [ i ] ) { setGlyphDataForIndex ( offset + stringIndices [ i ] , glyphs [ i ] , fontData ) ; haveGlyphs = true ; } } } } } return haveGlyphs ; } } // ▁ namespace ▁ WebCore ENDCOM </DOCUMENT>
<DOCUMENT_ID="pokowaka/xbmc/tree/master/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbumCompilations.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2005-2013 ▁ Team ▁ XBMC STRNEWLINE ▁ * ▁ http : // xbmc . org STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ Program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 , ▁ or ▁ ( at ▁ your ▁ option ) STRNEWLINE ▁ * ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ Program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ XBMC ; ▁ see ▁ the ▁ file ▁ COPYING . ▁ If ▁ not , ▁ see STRNEWLINE ▁ * ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ * STRNEWLINE ▁ */ # include " DirectoryNodeAlbumCompilations . h " # include " QueryParams . h " # include " music / MusicDatabase . h " using namespace XFILE :: MUSICDATABASEDIRECTORY ; CDirectoryNodeAlbumCompilations :: CDirectoryNodeAlbumCompilations ( const std :: string & strName , CDirectoryNode * pParent ) : CDirectoryNode ( NODE_TYPE_ALBUM_COMPILATIONS , strName , pParent ) { } NODE_TYPE CDirectoryNodeAlbumCompilations :: GetChildType ( ) const { if ( GetName ( ) == " - 1" ) return NODE_TYPE_ALBUM_COMPILATIONS_SONGS ; return NODE_TYPE_SONG ; } std :: string CDirectoryNodeAlbumCompilations :: GetLocalizedName ( ) const { if ( GetID ( ) == - 1 ) return g_localizeStrings . Get ( 15102 ) ; // ▁ All ▁ Albums ENDCOM CMusicDatabase db ; if ( db . Open ( ) ) return db . GetAlbumById ( GetID ( ) ) ; return " " ; } bool CDirectoryNodeAlbumCompilations :: GetContent ( CFileItemList & items ) const { CMusicDatabase musicdatabase ; if ( ! musicdatabase . Open ( ) ) return false ; CQueryParams params ; CollectQueryParams ( params ) ; bool bSuccess = musicdatabase . GetCompilationAlbums ( BuildPath ( ) , items ) ; musicdatabase . Close ( ) ; return bSuccess ; } </DOCUMENT>
<DOCUMENT_ID="ThomasXBMC/XCSoar/tree/master/src/Engine/Task/Computer/DistanceStatComputer.cpp"> /* ▁ Copyright _ License ▁ { STRNEWLINE STRNEWLINE ▁ XCSoar ▁ Glide ▁ Computer ▁ - ▁ http : // www . xcsoar . org / STRNEWLINE ▁ Copyright ▁ ( C ) ▁ 2000-2015 ▁ The ▁ XCSoar ▁ Project STRNEWLINE ▁ A ▁ detailed ▁ list ▁ of ▁ copyright ▁ holders ▁ can ▁ be ▁ found ▁ in ▁ the ▁ file ▁ " AUTHORS " . STRNEWLINE STRNEWLINE ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or STRNEWLINE ▁ modify ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 STRNEWLINE ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE STRNEWLINE ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE STRNEWLINE ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software STRNEWLINE ▁ Foundation , ▁ Inc . , ▁ 59 ▁ Temple ▁ Place ▁ - ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 , ▁ USA . STRNEWLINE } STRNEWLINE ▁ */ # include " DistanceStatComputer . hpp " # include " Task / Stats / DistanceStat . hpp " void DistanceStatComputer :: CalcSpeed ( DistanceStat & data , fixed time ) { if ( positive ( time ) && data . IsDefined ( ) ) data . speed = data . GetDistance ( ) / time ; else data . speed = fixed ( 0 ) ; } </DOCUMENT>
<DOCUMENT_ID="daedalus/iodoom3/tree/master/neo/tools/materialeditor/MaterialDocManager.cpp"> /* STRNEWLINE = = = = = STRNEWLINE STRNEWLINE Doom ▁ 3 ▁ GPL ▁ Source ▁ Code STRNEWLINE Copyright ▁ ( C ) ▁ 1999-2011 ▁ id ▁ Software ▁ LLC , ▁ a ▁ ZeniMax ▁ Media ▁ company . ▁ STRNEWLINE STRNEWLINE This ▁ file ▁ is ▁ part ▁ of ▁ the ▁ Doom ▁ 3 ▁ GPL ▁ Source ▁ Code ▁ ( ? Doom ▁ 3 ▁ Source ▁ Code ? ) . ▁ STRNEWLINE STRNEWLINE Doom ▁ 3 ▁ Source ▁ Code ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or STRNEWLINE ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE STRNEWLINE Doom ▁ 3 ▁ Source ▁ Code ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE STRNEWLINE You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE along ▁ with ▁ Doom ▁ 3 ▁ Source ▁ Code . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE STRNEWLINE In ▁ addition , ▁ the ▁ Doom ▁ 3 ▁ Source ▁ Code ▁ is ▁ also ▁ subject ▁ to ▁ certain ▁ additional ▁ terms . ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ these ▁ additional ▁ terms ▁ immediately ▁ following ▁ the ▁ terms ▁ and ▁ conditions ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ which ▁ accompanied ▁ the ▁ Doom ▁ 3 ▁ Source ▁ Code . ▁ If ▁ not , ▁ please ▁ request ▁ a ▁ copy ▁ in ▁ writing ▁ from ▁ id ▁ Software ▁ at ▁ the ▁ address ▁ below . STRNEWLINE STRNEWLINE If ▁ you ▁ have ▁ questions ▁ concerning ▁ this ▁ license ▁ or ▁ the ▁ applicable ▁ additional ▁ terms , ▁ you ▁ may ▁ contact ▁ in ▁ writing ▁ id ▁ Software ▁ LLC , ▁ c / o ▁ ZeniMax ▁ Media ▁ Inc . , ▁ Suite ▁ 120 , ▁ Rockville , ▁ Maryland ▁ 20850 ▁ USA . STRNEWLINE STRNEWLINE = = = = = STRNEWLINE */ # include " . . / . . / idlib / precompiled . h " # pragma hdrstop # include " MaterialDocManager . h " # include " MaterialView . h " /* * STRNEWLINE * ▁ Constructor ▁ for ▁ MaterialDocManager . STRNEWLINE */ MaterialDocManager :: MaterialDocManager ( void ) { currentMaterial = NULL ; cutMaterial = false ; } /* * STRNEWLINE * ▁ Destructor ▁ for ▁ MaterialDocManager . STRNEWLINE */ MaterialDocManager :: ~ MaterialDocManager ( void ) { UnRegisterAllMaterialViews ( ) ; ClearUndo ( ) ; ClearRedo ( ) ; } /* * STRNEWLINE * ▁ Registers ▁ an ▁ object ▁ to ▁ receive ▁ notifications ▁ about ▁ changes ▁ made ▁ to ▁ materials . STRNEWLINE * ▁ @ param ▁ view ▁ The ▁ object ▁ that ▁ would ▁ like ▁ to ▁ receive ▁ material ▁ notifications . STRNEWLINE */ void MaterialDocManager :: RegisterMaterialView ( MaterialView * view ) { ASSERT ( view ) ; UnRegisterMaterialView ( view ) ; materialViews . Append ( view ) ; // Notify ▁ the ▁ view ▁ of ▁ myself ENDCOM view -> SetMaterialDocManager ( this ) ; } /* * STRNEWLINE * ▁ Tells ▁ the ▁ MaterialDocManager ▁ to ▁ stop ▁ sending ▁ notifications ▁ to ▁ a ▁ view . STRNEWLINE * ▁ @ param ▁ view ▁ The ▁ view ▁ that ▁ no ▁ longer ▁ wants ▁ notifications . STRNEWLINE */ void MaterialDocManager :: UnRegisterMaterialView ( MaterialView * view ) { ASSERT ( view ) ; materialViews . Remove ( view ) ; // Remove ▁ the ▁ reference ▁ to ▁ myself ENDCOM view -> SetMaterialDocManager ( NULL ) ; } /* * STRNEWLINE * ▁ Unregisters ▁ all ▁ of ▁ the ▁ views ▁ that ▁ are ▁ registered ▁ to ▁ get ▁ material ▁ change STRNEWLINE * ▁ notifications . STRNEWLINE */ void MaterialDocManager :: UnRegisterAllMaterialViews ( ) { // Remove ▁ the ▁ reference ▁ to ▁ myself ENDCOM int c = materialViews . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { materialViews [ i ] -> SetMaterialDocManager ( NULL ) ; } materialViews . Clear ( ) ; } /* * STRNEWLINE * ▁ Tells ▁ the ▁ MaterialDocManager ▁ which ▁ material ▁ has ▁ been ▁ selected ▁ for ▁ editing . STRNEWLINE * ▁ @ param ▁ material ▁ The ▁ material ▁ that ▁ has ▁ been ▁ selected . STRNEWLINE */ void MaterialDocManager :: SetSelectedMaterial ( idMaterial * material ) { bool change = false ; // Do ▁ we ▁ need ▁ to ▁ change ▁ the ▁ material ENDCOM if ( material ) { if ( currentMaterial ) { if ( strcmp ( material -> GetName ( ) , currentMaterial -> renderMaterial -> GetName ( ) ) ) { change = true ; } } else { change = true ; } } else { if ( currentMaterial ) { change = true ; } } // Now ▁ make ▁ the ▁ change ENDCOM if ( change ) { if ( currentMaterial ) { // Delete ▁ the ▁ material ▁ unless ▁ it ▁ has ▁ been ▁ changed ENDCOM if ( ! inProgressMaterials . Get ( currentMaterial -> name . c_str ( ) ) ) { delete currentMaterial ; currentMaterial = NULL ; } } MaterialDoc * * tempDoc ; if ( material && inProgressMaterials . Get ( material -> GetName ( ) , & tempDoc ) ) { currentMaterial = * tempDoc ; } else { currentMaterial = CreateMaterialDoc ( material ) ; } NotifyViews ( currentMaterial , SELECTION_CHANGE ) ; } } /* * STRNEWLINE * ▁ Returns ▁ true ▁ if ▁ the ▁ specified ▁ file ▁ needs ▁ to ▁ be ▁ applied ▁ and ▁ false ▁ otherwise . STRNEWLINE */ bool MaterialDocManager :: DoesFileNeedApply ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) && ( * pDoc ) -> applyWaiting ) return true ; } return false ; } /* * STRNEWLINE * ▁ Returns ▁ true ▁ if ▁ any ▁ material ▁ needs ▁ to ▁ be ▁ applied . STRNEWLINE */ bool MaterialDocManager :: DoesAnyNeedApply ( ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ( * pDoc ) -> applyWaiting ) return true ; } return false ; } /* * STRNEWLINE * ▁ Returns ▁ true ▁ if ▁ the ▁ specified ▁ file ▁ has ▁ been ▁ modified . STRNEWLINE */ bool MaterialDocManager :: IsFileModified ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) return true ; } return false ; } /* * STRNEWLINE * ▁ Returns ▁ true ▁ if ▁ any ▁ material ▁ has ▁ been ▁ modified . STRNEWLINE */ bool MaterialDocManager :: IsAnyModified ( ) { return ( inProgressMaterials . Num ( ) > 0 ) ; } /* * STRNEWLINE * ▁ Adds ▁ a ▁ material . STRNEWLINE * ▁ @ param ▁ name ▁ The ▁ name ▁ of ▁ the ▁ material . STRNEWLINE * ▁ @ param ▁ filename ▁ The ▁ file ▁ to ▁ place ▁ the ▁ material ▁ in . STRNEWLINE * ▁ @ param ▁ sourceText ▁ The ▁ initial ▁ material ▁ definition . STRNEWLINE * ▁ @ param ▁ addUndo ▁ Can ▁ this ▁ operation ▁ be ▁ undone . STRNEWLINE */ void MaterialDocManager :: AddMaterial ( const char * name , const char * filename , const char * sourceText , bool addUndo ) { if ( addUndo ) { AddMaterialModifier * mod = new AddMaterialModifier ( this , name , filename ) ; AddMaterialUndoModifier ( mod ) ; } MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> modified = true ; idMaterial * rendMat = ( idMaterial * ) declManager -> CreateNewDecl ( DECL_MATERIAL , name , filename ) ; if ( sourceText ) { rendMat -> SetText ( sourceText ) ; } newDoc -> SetRenderMaterial ( rendMat , true , sourceText ? true : false ) ; inProgressMaterials . Set ( newDoc -> name . c_str ( ) , newDoc ) ; NotifyViews ( newDoc , MATERIAL_ADD ) ; // Force ▁ an ▁ apply ▁ so ▁ the ▁ text ▁ will ▁ be ▁ generated ▁ to ▁ match ▁ the ▁ new ▁ file ENDCOM newDoc -> applyWaiting = true ; newDoc -> ApplyMaterialChanges ( ) ; } /* * STRNEWLINE * ▁ Used ▁ to ▁ redo ▁ an ▁ add ▁ material ▁ and ▁ undo ▁ a ▁ delete ▁ material . ▁ STRNEWLINE * ▁ The ▁ undo ▁ for ▁ adding ▁ a ▁ material ▁ deletes ▁ the ▁ material . ▁ Instead ▁ of ▁ adding ▁ a ▁ completely STRNEWLINE * ▁ new ▁ material ▁ RedoAddMaterial ▁ finds ▁ the ▁ one ▁ that ▁ was ▁ just ▁ deleted ▁ and ▁ uses ▁ that . ▁ STRNEWLINE * ▁ @ param ▁ name ▁ The ▁ name ▁ of ▁ the ▁ material ▁ that ▁ was ▁ added / deleted . STRNEWLINE * ▁ @ param ▁ clearData ▁ Should ▁ the ▁ material ▁ definition ▁ be ▁ reset ▁ to ▁ the ▁ default ▁ definition . STRNEWLINE */ void MaterialDocManager :: RedoAddMaterial ( const char * name , bool clearData ) { MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> modified = true ; idMaterial * rendMat = const_cast < idMaterial * > ( declManager -> FindMaterial ( name , false ) ) ; if ( clearData ) { rendMat -> SetText ( rendMat -> DefaultDefinition ( ) ) ; } newDoc -> SetRenderMaterial ( rendMat , true , true ) ; inProgressMaterials . Set ( newDoc -> name . c_str ( ) , newDoc ) ; NotifyViews ( newDoc , MATERIAL_ADD ) ; // Force ▁ an ▁ apply ▁ so ▁ the ▁ text ▁ will ▁ be ▁ generated ▁ to ▁ match ▁ the ▁ new ▁ file ENDCOM newDoc -> applyWaiting = true ; newDoc -> ApplyMaterialChanges ( ) ; } /* * STRNEWLINE * ▁ Deletes ▁ a ▁ material . STRNEWLINE * ▁ @ param ▁ material ▁ The ▁ material ▁ to ▁ be ▁ deleted . STRNEWLINE * ▁ @ param ▁ addUndo ▁ Can ▁ this ▁ operation ▁ be ▁ undone . STRNEWLINE */ void MaterialDocManager :: DeleteMaterial ( MaterialDoc * material , bool addUndo ) { assert ( material ) ; // This ▁ will ▁ just ▁ flag ▁ for ▁ delete . ▁ The ▁ actual ▁ delete ▁ will ▁ happen ▁ during ▁ the ▁ save ENDCOM material -> Delete ( ) ; if ( addUndo ) { DeleteMaterialModifier * mod = new DeleteMaterialModifier ( this , material -> name ) ; AddMaterialUndoModifier ( mod ) ; } NotifyViews ( material , MATERIAL_DELETE ) ; } /* * STRNEWLINE * ▁ Applys ▁ changes ▁ to ▁ a ▁ material . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ to ▁ be ▁ applied . STRNEWLINE */ void MaterialDocManager :: ApplyMaterial ( MaterialDoc * materialDoc ) { assert ( materialDoc ) ; materialDoc -> ApplyMaterialChanges ( ) ; } /* * STRNEWLINE * ▁ Applies ▁ all ▁ materials ▁ in ▁ the ▁ specified ▁ filename . STRNEWLINE * ▁ @ param ▁ filename ▁ The ▁ file ▁ to ▁ apply . STRNEWLINE */ void MaterialDocManager :: ApplyFile ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) ( * pDoc ) -> ApplyMaterialChanges ( ) ; } } /* * STRNEWLINE * ▁ Applies ▁ all ▁ materials ▁ that ▁ have ▁ been ▁ changed . STRNEWLINE */ void MaterialDocManager :: ApplyAll ( ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; ( * pDoc ) -> ApplyMaterialChanges ( ) ; } } /* * STRNEWLINE * ▁ Saves ▁ a ▁ single ▁ material . STRNEWLINE * ▁ @ param ▁ material ▁ The ▁ material ▁ to ▁ save . STRNEWLINE */ void MaterialDocManager :: SaveMaterial ( MaterialDoc * material ) { assert ( material ) ; material -> Save ( ) ; } /* * STRNEWLINE * ▁ Saves ▁ all ▁ materials ▁ in ▁ the ▁ specified ▁ file . STRNEWLINE * ▁ @ param ▁ filename ▁ The ▁ file ▁ to ▁ save . STRNEWLINE */ void MaterialDocManager :: SaveFile ( const char * filename ) { for ( int i = inProgressMaterials . Num ( ) - 1 ; i >= 0 ; i -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) ( * pDoc ) -> Save ( ) ; } // Notify ▁ everyone ENDCOM NotifyViews ( NULL , MATERIAL_SAVE_FILE , filename ) ; } /* * STRNEWLINE * ▁ Saves ▁ all ▁ materials ▁ that ▁ have ▁ been ▁ changed . STRNEWLINE */ void MaterialDocManager :: SaveAllMaterials ( ) { for ( int i = inProgressMaterials . Num ( ) - 1 ; i >= 0 ; i -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; ( * pDoc ) -> Save ( ) ; } } /* * STRNEWLINE * ▁ Reloads ▁ a ▁ specified ▁ file . STRNEWLINE * ▁ @ param ▁ filename ▁ The ▁ file ▁ to ▁ reload . STRNEWLINE */ void MaterialDocManager :: ReloadFile ( const char * filename ) { declManager -> ReloadFile ( filename , true ) ; // purge ▁ the ▁ changes ▁ of ▁ any ▁ in ▁ progress ▁ materials ENDCOM for ( int j = inProgressMaterials . Num ( ) - 1 ; j >= 0 ; j -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( j ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) { ( * pDoc ) -> SetRenderMaterial ( ( * pDoc ) -> renderMaterial ) ; inProgressMaterials . Remove ( ( * pDoc ) -> name ) ; } } // Reparse ▁ the ▁ current ▁ material ENDCOM if ( currentMaterial ) { currentMaterial -> SetRenderMaterial ( currentMaterial -> renderMaterial ) ; // Trigger ▁ all ▁ the ▁ views ▁ to ▁ refresh ENDCOM NotifyViews ( currentMaterial , SELECTION_CHANGE ) ; } NotifyViews ( NULL , FILE_RELOAD , filename ) ; } /* * STRNEWLINE * ▁ Creates ▁ a ▁ MaterialDoc ▁ object ▁ for ▁ the ▁ specified ▁ material ▁ name . ▁ If ▁ a ▁ MaterialDoc ▁ STRNEWLINE * ▁ object ▁ already ▁ exists ▁ then ▁ it ▁ is ▁ used . STRNEWLINE * ▁ @ param ▁ materialName ▁ The ▁ name ▁ of ▁ the ▁ material ▁ for ▁ which ▁ to ▁ create ▁ a ▁ MaterialDoc ▁ object . STRNEWLINE */ MaterialDoc * MaterialDocManager :: CreateMaterialDoc ( const char * materialName ) { const idMaterial * material = declManager -> FindMaterial ( materialName ) ; return CreateMaterialDoc ( const_cast < idMaterial * > ( material ) ) ; } /* * STRNEWLINE * ▁ Creates ▁ a ▁ MaterialDoc ▁ object ▁ for ▁ the ▁ specified ▁ material . ▁ If ▁ a ▁ MaterialDoc ▁ STRNEWLINE * ▁ object ▁ already ▁ exists ▁ then ▁ it ▁ is ▁ used . STRNEWLINE * ▁ @ param ▁ material ▁ The ▁ material ▁ for ▁ which ▁ to ▁ create ▁ a ▁ MaterialDoc ▁ object . STRNEWLINE */ MaterialDoc * MaterialDocManager :: CreateMaterialDoc ( idMaterial * material ) { MaterialDoc * existingDoc = GetInProgressDoc ( material ) ; if ( existingDoc ) { return existingDoc ; } if ( currentMaterial && material && ! currentMaterial -> name . Icmp ( material -> GetName ( ) ) ) { return currentMaterial ; } if ( material ) { MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> SetRenderMaterial ( material ) ; return newDoc ; } return NULL ; } /* * STRNEWLINE * ▁ Checks ▁ the ▁ current ▁ list ▁ of ▁ in ▁ progress ▁ MaterialDoc ▁ objects ▁ to ▁ see ▁ if STRNEWLINE * ▁ a ▁ MaterialDoc ▁ object ▁ already ▁ exists . STRNEWLINE * ▁ @ param ▁ material ▁ The ▁ material ▁ to ▁ check ▁ for . STRNEWLINE */ MaterialDoc * MaterialDocManager :: GetInProgressDoc ( idMaterial * material ) { if ( material ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! ( * pDoc ) -> name . Icmp ( material -> GetName ( ) ) ) return * pDoc ; } } return NULL ; } /* * STRNEWLINE * ▁ Prepares ▁ a ▁ material ▁ for ▁ a ▁ copy / cut ▁ and ▁ paste ▁ operations . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ to ▁ copy . STRNEWLINE * ▁ @ param ▁ cut ▁ Is ▁ this ▁ a ▁ cut ▁ operation . STRNEWLINE */ void MaterialDocManager :: CopyMaterial ( MaterialDoc * materialDoc , bool cut ) { cutMaterial = cut ; if ( materialDoc ) copyMaterial = materialDoc -> name ; else ClearCopy ( ) ; } /* * STRNEWLINE * ▁ Clears ▁ the ▁ copy ▁ buffer ▁ for ▁ a ▁ material . STRNEWLINE */ void MaterialDocManager :: ClearCopy ( ) { copyMaterial . Empty ( ) ; } /* * STRNEWLINE * ▁ Returns ▁ true ▁ if ▁ there ▁ is ▁ a ▁ material ▁ in ▁ the ▁ copy ▁ buffer . STRNEWLINE */ bool MaterialDocManager :: IsCopyMaterial ( ) { return ( copyMaterial . Length ( ) ) ? true : false ; } /* * STRNEWLINE * ▁ Returns ▁ the ▁ name ▁ of ▁ the ▁ material ▁ in ▁ the ▁ copy ▁ buffer . STRNEWLINE */ idStr MaterialDocManager :: GetCopyMaterialName ( ) { return copyMaterial ; } /* * STRNEWLINE * ▁ Performs ▁ a ▁ material ▁ paste ▁ operation ▁ for ▁ a ▁ material ▁ in ▁ the ▁ copy ▁ buffer . STRNEWLINE * ▁ @ param ▁ name ▁ The ▁ new ▁ name ▁ for ▁ the ▁ material ▁ that ▁ is ▁ being ▁ copied . STRNEWLINE * ▁ @ param ▁ filename ▁ The ▁ file ▁ to ▁ paste ▁ the ▁ material ▁ in . STRNEWLINE */ void MaterialDocManager :: PasteMaterial ( const char * name , const char * filename ) { if ( ! IsCopyMaterial ( ) ) { return ; } // Apply ▁ the ▁ material ▁ if ▁ there ▁ are ▁ some ▁ changes ENDCOM MaterialDoc * copyMat = CreateMaterialDoc ( copyMaterial ) ; if ( copyMat -> applyWaiting ) { copyMat -> ApplyMaterialChanges ( ) ; } // Paste ▁ the ▁ material ENDCOM idMaterial * material = copyMat -> renderMaterial ; // Add ▁ a ▁ material ▁ with ▁ the ▁ existing ▁ source ▁ text ENDCOM char * declText = ( char * ) _alloca ( material -> GetTextLength ( ) + 1 ) ; material -> GetText ( declText ) ; AddMaterial ( name , filename , declText , ! cutMaterial ) ; // If ▁ this ▁ is ▁ a ▁ cut ▁ then ▁ remove ▁ the ▁ original ENDCOM if ( cutMaterial ) { MaterialDoc * cutMaterial = CreateMaterialDoc ( material ) ; DeleteMaterial ( cutMaterial , false ) ; MoveMaterialModifier * mod = new MoveMaterialModifier ( this , name , filename , copyMaterial ) ; AddMaterialUndoModifier ( mod ) ; ClearCopy ( ) ; } } /* * STRNEWLINE * ▁ Prepares ▁ a ▁ material ▁ stage ▁ for ▁ a ▁ copy / paste ▁ operation . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ materialDoc ▁ that ▁ contains ▁ the ▁ stage ▁ to ▁ be ▁ copied . STRNEWLINE * ▁ @ param ▁ stageNum ▁ the ▁ stage ▁ to ▁ copy . STRNEWLINE */ void MaterialDocManager :: CopyStage ( MaterialDoc * materialDoc , int stageNum ) { assert ( materialDoc ) ; copyStageMaterial = materialDoc -> name ; copyStage = materialDoc -> GetStage ( stageNum ) ; idStr stageName = copyStage . stageData . GetString ( " name " ) ; } /* * STRNEWLINE * ▁ Clears ▁ the ▁ copy ▁ buffer ▁ for ▁ copied ▁ stages . STRNEWLINE */ void MaterialDocManager :: ClearCopyStage ( ) { copyStageMaterial . Empty ( ) ; copyStage . stageData . Clear ( ) ; } /* * STRNEWLINE * ▁ Returns ▁ true ▁ if ▁ there ▁ is ▁ a ▁ stage ▁ in ▁ the ▁ copy ▁ buffer . STRNEWLINE */ bool MaterialDocManager :: IsCopyStage ( ) { return ( copyStageMaterial . Length ( ) ) ? true : false ; } /* * STRNEWLINE * ▁ Performs ▁ a ▁ paste ▁ operation ▁ of ▁ the ▁ stage ▁ in ▁ the ▁ copy ▁ buffer . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ materialDoc ▁ to ▁ paste ▁ the ▁ stage ▁ in . STRNEWLINE */ void MaterialDocManager :: PasteStage ( MaterialDoc * materialDoc ) { assert ( materialDoc ) ; int stageType = copyStage . stageData . GetInt ( " stagetype " ) ; // Create ▁ a ▁ new ▁ stage ▁ and ▁ copy ▁ the ▁ data ENDCOM materialDoc -> AddStage ( stageType , copyStage . stageData . GetString ( " name " ) ) ; materialDoc -> SetData ( materialDoc -> GetStageCount ( ) - 1 , & copyStage . stageData ) ; } /* * STRNEWLINE * ▁ Returns ▁ information ▁ about ▁ the ▁ stage ▁ in ▁ the ▁ copy ▁ buffer . STRNEWLINE * ▁ @ param ▁ type ▁ Holds ▁ the ▁ type ▁ of ▁ the ▁ stage ▁ in ▁ the ▁ copy ▁ buffer . STRNEWLINE * ▁ @ param ▁ name ▁ Hold ▁ the ▁ name ▁ of ▁ the ▁ stage ▁ in ▁ the ▁ copy ▁ buffer . STRNEWLINE */ void MaterialDocManager :: GetCopyStageInfo ( int & type , idStr & name ) { if ( IsCopyStage ( ) ) { type = copyStage . stageData . GetInt ( " stagetype " ) ; name = copyStage . stageData . GetString ( " name " ) ; } } /* * STRNEWLINE * ▁ Performs ▁ the ▁ first ▁ available ▁ undo ▁ operation . STRNEWLINE */ void MaterialDocManager :: Undo ( ) { if ( IsUndoAvailable ( ) ) { MaterialModifier * mod = undoModifiers [ undoModifiers . Num ( ) - 1 ] ; undoModifiers . RemoveIndex ( undoModifiers . Num ( ) - 1 ) ; mod -> Undo ( ) ; // Add ▁ this ▁ modifier ▁ to ▁ the ▁ redo ▁ list ENDCOM AddMaterialRedoModifier ( mod ) ; } } /* * STRNEWLINE * ▁ Returns ▁ true ▁ if ▁ an ▁ undo ▁ operation ▁ is ▁ available . STRNEWLINE */ bool MaterialDocManager :: IsUndoAvailable ( ) { return ( undoModifiers . Num ( ) > 0 ) ; } /* * STRNEWLINE * ▁ Clears ▁ the ▁ entire ▁ undo ▁ buffer . STRNEWLINE */ void MaterialDocManager :: ClearUndo ( ) { int c = undoModifiers . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { delete undoModifiers [ i ] ; } undoModifiers . Clear ( ) ; } /* * STRNEWLINE * ▁ Performs ▁ the ▁ first ▁ available ▁ redo ▁ operation . STRNEWLINE */ void MaterialDocManager :: Redo ( ) { if ( IsRedoAvailable ( ) ) { MaterialModifier * mod = redoModifiers [ redoModifiers . Num ( ) - 1 ] ; redoModifiers . RemoveIndex ( redoModifiers . Num ( ) - 1 ) ; mod -> Redo ( ) ; // Done ▁ with ▁ the ▁ mod ▁ because ▁ the ▁ redo ▁ process ▁ will ▁ set ▁ ENDCOM // attributes ▁ and ▁ create ▁ the ▁ appropriate ▁ redo ▁ modifier ENDCOM AddMaterialUndoModifier ( mod , false ) ; } } /* * STRNEWLINE * ▁ Returns ▁ true ▁ if ▁ a ▁ redo ▁ operation ▁ is ▁ available . STRNEWLINE */ bool MaterialDocManager :: IsRedoAvailable ( ) { return ( redoModifiers . Num ( ) > 0 ) ; } /* * STRNEWLINE * ▁ Clears ▁ the ▁ redo ▁ buffer . STRNEWLINE */ void MaterialDocManager :: ClearRedo ( ) { int c = redoModifiers . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { delete redoModifiers [ i ] ; } redoModifiers . Clear ( ) ; } /* * STRNEWLINE * ▁ Adds ▁ an ▁ undo ▁ operation ▁ to ▁ the ▁ undo ▁ buffer . STRNEWLINE * ▁ @ param ▁ mod ▁ The ▁ MaterialModifier ▁ object ▁ that ▁ contains ▁ the ▁ undo ▁ data . STRNEWLINE * ▁ @ param ▁ clearRedo ▁ Should ▁ we ▁ clear ▁ the ▁ redo ▁ buffer . STRNEWLINE */ void MaterialDocManager :: AddMaterialUndoModifier ( MaterialModifier * mod , bool clearRedo ) { undoModifiers . Append ( mod ) ; while ( undoModifiers . Num ( ) > MAX_UNDOREDO ) { undoModifiers . RemoveIndex ( 0 ) ; } if ( clearRedo ) { ClearRedo ( ) ; } } /* * STRNEWLINE * ▁ Adds ▁ a ▁ redo ▁ operation ▁ to ▁ the ▁ redo ▁ buffer . STRNEWLINE * ▁ @ param ▁ mod ▁ The ▁ MaterialModifier ▁ object ▁ that ▁ contains ▁ the ▁ redo ▁ data . STRNEWLINE */ void MaterialDocManager :: AddMaterialRedoModifier ( MaterialModifier * mod ) { redoModifiers . Append ( mod ) ; while ( redoModifiers . Num ( ) > MAX_UNDOREDO ) { redoModifiers . RemoveIndex ( 0 ) ; } } /* * STRNEWLINE * ▁ Searches ▁ for ▁ a ▁ material ▁ that ▁ matches ▁ the ▁ specified ▁ search ▁ data . STRNEWLINE * ▁ @ param ▁ name ▁ The ▁ name ▁ of ▁ the ▁ material ▁ to ▁ search . STRNEWLINE * ▁ @ param ▁ searchData ▁ The ▁ search ▁ parameters . STRNEWLINE * ▁ @ param ▁ checkName ▁ If ▁ true ▁ then ▁ the ▁ name ▁ of ▁ the ▁ material ▁ will ▁ be ▁ checked ▁ along ▁ with ▁ the ▁ material ▁ text . STRNEWLINE */ bool MaterialDocManager :: FindMaterial ( const char * name , MaterialSearchData_t * searchData , bool checkName ) { // Fast ▁ way ▁ of ▁ finding ▁ the ▁ material ▁ without ▁ parsing ENDCOM const idMaterial * material = static_cast < const idMaterial * > ( declManager -> FindDeclWithoutParsing ( DECL_MATERIAL , name , false ) ) ; if ( material ) { int findPos ; if ( checkName ) { // Check ▁ the ▁ name ENDCOM idStr name = material -> GetName ( ) ; findPos = name . Find ( searchData -> searchText , false ) ; if ( findPos != - 1 ) { return true ; } } // Skip ▁ to ▁ the ▁ open ▁ braket ▁ so ▁ the ▁ name ▁ is ▁ not ▁ checked ENDCOM char * declText = ( char * ) _alloca ( material -> GetTextLength ( ) + 1 ) ; material -> GetText ( declText ) ; idStr text = declText ; int start = text . Find ( " { " ) ; if ( start != - 1 ) { text = text . Right ( text . Length ( ) - start ) ; } findPos = text . Find ( searchData -> searchText , false ) ; if ( findPos != - 1 ) { // Todo : ▁ Include ▁ match ▁ whole ▁ word ENDCOM return true ; } } return false ; } /* * STRNEWLINE * ▁ Returns ▁ a ▁ unique ▁ material ▁ name ▁ given ▁ a ▁ base ▁ name . ▁ This ▁ is ▁ used ▁ to ▁ resolve ▁ materials ▁ with ▁ the ▁ same ▁ name . STRNEWLINE * ▁ @ param ▁ name ▁ The ▁ base ▁ name ▁ of ▁ the ▁ material . STRNEWLINE */ idStr MaterialDocManager :: GetUniqueMaterialName ( idStr name ) { int num = 0 ; while ( 1 ) { idStr testName ; if ( num == 0 ) testName = name ; else testName = va ( " % s % d " , name . c_str ( ) , num ) ; const idMaterial * mat = declManager -> FindMaterial ( testName . c_str ( ) , false ) ; if ( ! mat ) { return testName ; } else { // We ▁ can ▁ reuse ▁ delete ▁ material ▁ names ENDCOM if ( mat -> GetTextLength ( ) < 1 ) return testName ; } num ++ ; } } /* * STRNEWLINE * ▁ Notifies ▁ all ▁ registered ▁ views ▁ of ▁ a ▁ material ▁ event . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ been ▁ affected . STRNEWLINE * ▁ @ param ▁ notifyType ▁ The ▁ type ▁ of ▁ event ▁ that ▁ has ▁ occured . STRNEWLINE * ▁ @ param ▁ . . . ▁ Notification ▁ specific ▁ data . ▁ See ▁ MaterialView . STRNEWLINE */ void MaterialDocManager :: NotifyViews ( MaterialDoc * materialDoc , int notifyType , ... ) { va_list argptr ; int c = materialViews . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { va_start ( argptr , notifyType ) ; switch ( notifyType ) { case SELECTION_CHANGE : materialViews [ i ] -> MV_OnMaterialSelectionChange ( materialDoc ) ; break ; case MATERIAL_CHANGE : materialViews [ i ] -> MV_OnMaterialChange ( materialDoc ) ; break ; case MATERIAL_APPLY : materialViews [ i ] -> MV_OnMaterialApply ( materialDoc ) ; break ; case MATERIAL_SAVE : materialViews [ i ] -> MV_OnMaterialSaved ( materialDoc ) ; break ; case MATERIAL_SAVE_FILE : materialViews [ i ] -> MV_OnMaterialSaveFile ( va_arg ( argptr , const char * ) ) ; break ; case MATERIAL_ADD : materialViews [ i ] -> MV_OnMaterialAdd ( materialDoc ) ; break ; case MATERIAL_DELETE : materialViews [ i ] -> MV_OnMaterialDelete ( materialDoc ) ; break ; case MATERIAL_ADD_STAGE : materialViews [ i ] -> MV_OnMaterialStageAdd ( materialDoc , va_arg ( argptr , int ) ) ; break ; case MATERIAL_DELETE_STAGE : materialViews [ i ] -> MV_OnMaterialStageDelete ( materialDoc , va_arg ( argptr , int ) ) ; break ; case MATERIAL_MOVE_STAGE : { int from = va_arg ( argptr , int ) ; int to = va_arg ( argptr , int ) ; materialViews [ i ] -> MV_OnMaterialStageMove ( materialDoc , from , to ) ; } break ; case MATERIAL_ATTRIBUTE_CHANGE : { int stage = va_arg ( argptr , int ) ; const char * attribName = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnMaterialAttributeChanged ( materialDoc , stage , attribName ) ; } break ; case MATERIAL_NAME_CHANGE : { const char * oldName = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnMaterialNameChanged ( materialDoc , oldName ) ; } break ; case FILE_RELOAD : { const char * filename = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnFileReload ( filename ) ; } break ; } va_end ( argptr ) ; } } /* * STRNEWLINE * ▁ Called ▁ when ▁ a ▁ material ▁ has ▁ been ▁ edited ▁ and ▁ notifies ▁ all ▁ views ▁ of ▁ the ▁ change . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ changed . STRNEWLINE */ void MaterialDocManager :: MaterialChanged ( MaterialDoc * materialDoc ) { // Make ▁ sure ▁ this ▁ material ▁ is ▁ in ▁ our ▁ list ▁ of ▁ changed ▁ materials ENDCOM if ( ! inProgressMaterials . Get ( materialDoc -> name . c_str ( ) ) ) { inProgressMaterials . Set ( materialDoc -> name . c_str ( ) , materialDoc ) ; } // Notify ▁ everyone ENDCOM NotifyViews ( materialDoc , MATERIAL_CHANGE ) ; } /* * STRNEWLINE * ▁ Called ▁ when ▁ a ▁ material ▁ has ▁ been ▁ applied ▁ and ▁ notifies ▁ all ▁ views ▁ of ▁ the ▁ apply . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ been ▁ applied . STRNEWLINE */ void MaterialDocManager :: MaterialApplied ( MaterialDoc * materialDoc ) { // Notify ▁ everyone ENDCOM NotifyViews ( materialDoc , MATERIAL_APPLY ) ; } /* * STRNEWLINE * ▁ Called ▁ when ▁ a ▁ material ▁ has ▁ been ▁ saved ▁ and ▁ notifies ▁ all ▁ views ▁ of ▁ the ▁ save . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ been ▁ saved . STRNEWLINE */ void MaterialDocManager :: MaterialSaved ( MaterialDoc * materialDoc ) { MaterialDoc * * tempDoc ; if ( inProgressMaterials . Get ( materialDoc -> name . c_str ( ) , & tempDoc ) ) { idStr name = materialDoc -> name . c_str ( ) ; // Remove ▁ this ▁ file ▁ from ▁ our ▁ in ▁ progress ▁ list ENDCOM inProgressMaterials . Remove ( name . c_str ( ) ) ; // Notify ▁ everyone ENDCOM NotifyViews ( materialDoc , MATERIAL_SAVE ) ; if ( materialDoc != currentMaterial ) delete materialDoc ; } } /* * STRNEWLINE * ▁ Called ▁ when ▁ a ▁ material ▁ name ▁ has ▁ been ▁ changed ▁ and ▁ notifies ▁ all ▁ views ▁ of ▁ the ▁ change . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ changed . STRNEWLINE */ void MaterialDocManager :: MaterialNameChanged ( const char * oldName , MaterialDoc * materialDoc ) { MaterialDoc * * tempDoc ; if ( inProgressMaterials . Get ( oldName , & tempDoc ) ) { inProgressMaterials . Set ( materialDoc -> name , * tempDoc ) ; inProgressMaterials . Remove ( oldName ) ; } NotifyViews ( materialDoc , MATERIAL_NAME_CHANGE , oldName ) ; } /* * STRNEWLINE * ▁ Called ▁ when ▁ a ▁ stage ▁ is ▁ added ▁ and ▁ notifies ▁ all ▁ views ▁ of ▁ the ▁ addition . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ changed . STRNEWLINE * ▁ @ param ▁ stageNum ▁ The ▁ stage ▁ that ▁ was ▁ added . STRNEWLINE */ void MaterialDocManager :: StageAdded ( MaterialDoc * materialDoc , int stageNum ) { // Notify ▁ everyone ENDCOM NotifyViews ( materialDoc , MATERIAL_ADD_STAGE , stageNum ) ; } /* * STRNEWLINE * ▁ Called ▁ when ▁ a ▁ stage ▁ has ▁ been ▁ deleted ▁ and ▁ notifies ▁ all ▁ views ▁ of ▁ the ▁ change . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ changed . STRNEWLINE * ▁ @ param ▁ stageNum ▁ The ▁ stage ▁ that ▁ was ▁ deleted . STRNEWLINE */ void MaterialDocManager :: StageDeleted ( MaterialDoc * materialDoc , int stageNum ) { // Notify ▁ everyone ENDCOM NotifyViews ( materialDoc , MATERIAL_DELETE_STAGE , stageNum ) ; } /* * STRNEWLINE * ▁ Called ▁ when ▁ a ▁ stage ▁ has ▁ been ▁ movied ▁ and ▁ notifies ▁ all ▁ views ▁ of ▁ the ▁ change . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ changed . STRNEWLINE * ▁ @ param ▁ from ▁ The ▁ original ▁ position ▁ of ▁ the ▁ stage . STRNEWLINE * ▁ @ param ▁ to ▁ The ▁ new ▁ position ▁ of ▁ the ▁ stage . STRNEWLINE */ void MaterialDocManager :: StageMoved ( MaterialDoc * materialDoc , int from , int to ) { // Notify ▁ everyone ENDCOM NotifyViews ( materialDoc , MATERIAL_MOVE_STAGE , from , to ) ; } /* * STRNEWLINE * ▁ Called ▁ when ▁ a ▁ material ▁ attribute ▁ has ▁ been ▁ edited ▁ and ▁ notifies ▁ all ▁ views ▁ of ▁ the ▁ change . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ changed . STRNEWLINE * ▁ @ param ▁ stage ▁ The ▁ stage ▁ that ▁ contains ▁ the ▁ changed ▁ attribute . STRNEWLINE * ▁ @ param ▁ attribName ▁ The ▁ name ▁ of ▁ the ▁ attribute ▁ that ▁ changed . STRNEWLINE */ void MaterialDocManager :: AttributeChanged ( MaterialDoc * materialDoc , int stage , const char * attribName ) { // Notify ▁ everyone ENDCOM NotifyViews ( materialDoc , MATERIAL_ATTRIBUTE_CHANGE , stage , attribName ) ; } </DOCUMENT>
<DOCUMENT_ID="quang-ha/lammps/tree/master/lib/kokkos/core/src/eti/OpenMP/Kokkos_OpenMP_ViewCopyETIInst_int64_t_double_LayoutStride_Rank3.cpp"> // @ HEADER ENDCOM // ▁ Kokkos ▁ v . ▁ 2.0 ENDCOM // ▁ Copyright ▁ ( 2014 ) ▁ Sandia ▁ Corporation ENDCOM // ▁ Under ▁ the ▁ terms ▁ of ▁ Contract ▁ DE - AC04-94AL85000 ▁ with ▁ Sandia ▁ Corporation , ENDCOM // ▁ the ▁ U . S . ▁ Government ▁ retains ▁ certain ▁ rights ▁ in ▁ this ▁ software . ENDCOM // ▁ Kokkos ▁ is ▁ licensed ▁ under ▁ 3 - clause ▁ BSD ▁ terms ▁ of ▁ use : ENDCOM // ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without ENDCOM // ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions ▁ are ENDCOM // ▁ met : ENDCOM // ▁ 1 . ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright ENDCOM // ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . ENDCOM // ▁ 2 . ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright ENDCOM // ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in ▁ the ENDCOM // ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the ▁ distribution . ENDCOM // ▁ 3 . ▁ Neither ▁ the ▁ name ▁ of ▁ the ▁ Corporation ▁ nor ▁ the ▁ names ▁ of ▁ the ENDCOM // ▁ contributors ▁ may ▁ be ▁ used ▁ to ▁ endorse ▁ or ▁ promote ▁ products ▁ derived ▁ from ENDCOM // ▁ this ▁ software ▁ without ▁ specific ▁ prior ▁ written ▁ permission . ENDCOM // ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ SANDIA ▁ CORPORATION ▁ " AS ▁ IS " ▁ AND ▁ ANY ENDCOM // ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ THE ENDCOM // ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ENDCOM // ▁ PURPOSE ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ SANDIA ▁ CORPORATION ▁ OR ▁ THE ENDCOM // ▁ CONTRIBUTORS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , ▁ SPECIAL , ENDCOM // ▁ EXEMPLARY , ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ ( INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ENDCOM // ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES ; ▁ LOSS ▁ OF ▁ USE , ▁ DATA , ▁ OR ENDCOM // ▁ PROFITS ; ▁ OR ▁ BUSINESS ▁ INTERRUPTION ) ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY ▁ THEORY ▁ OF ENDCOM // ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ CONTRACT , ▁ STRICT ▁ LIABILITY , ▁ OR ▁ TORT ▁ ( INCLUDING ENDCOM // ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE ▁ OF ▁ THIS ENDCOM // ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . ENDCOM // ▁ Questions ? ▁ Contact ▁ Christian ▁ R . ▁ Trott ▁ ( crtrott @ sandia . gov ) ENDCOM // @ HEADER ENDCOM # define KOKKOS_IMPL_COMPILING_LIBRARY true # include < Kokkos_Core . hpp > namespace Kokkos { namespace Impl { KOKKOS_IMPL_VIEWCOPY_ETI_INST ( double * * * , LayoutStride , LayoutRight , OpenMP , int64_t ) KOKKOS_IMPL_VIEWCOPY_ETI_INST ( double * * * , LayoutStride , LayoutLeft , OpenMP , int64_t ) KOKKOS_IMPL_VIEWCOPY_ETI_INST ( double * * * , LayoutStride , LayoutStride , OpenMP , int64_t ) KOKKOS_IMPL_VIEWFILL_ETI_INST ( double * * * , LayoutStride , OpenMP , int64_t ) } } </DOCUMENT>
<DOCUMENT_ID="atidot3/Orizon-510/tree/master/src/server/authserver/Main.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2008-2012 ▁ TrinityCore ▁ < http : // www . trinitycore . org / > STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2005-2009 ▁ MaNGOS ▁ < http : // getmangos . com / > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it STRNEWLINE ▁ * ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the STRNEWLINE ▁ * ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your STRNEWLINE ▁ * ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT STRNEWLINE ▁ * ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or STRNEWLINE ▁ * ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for STRNEWLINE ▁ * ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along STRNEWLINE ▁ * ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ */ /* * STRNEWLINE * ▁ @ file ▁ main . cpp STRNEWLINE * ▁ @ brief ▁ Authentication ▁ Server ▁ main ▁ program STRNEWLINE * STRNEWLINE * ▁ This ▁ file ▁ contains ▁ the ▁ main ▁ program ▁ for ▁ the STRNEWLINE * ▁ authentication ▁ server STRNEWLINE */ # include < ace / Dev_Poll_Reactor . h > # include < ace / TP_Reactor . h > # include < ace / ACE . h > # include < ace / Sig_Handler . h > # include < openssl / opensslv . h > # include < openssl / crypto . h > # include " Common . h " # include " Database / DatabaseEnv . h " # include " Configuration / Config . h " # include " Log . h " # include " SystemConfig . h " # include " Util . h " # include " SignalHandler . h " # include " RealmList . h " # include " RealmAcceptor . h " # ifndef _TRINITY_REALM_CONFIG # define _TRINITY_REALM_CONFIG " authserver . conf " # endif bool StartDB ( ) ; void StopDB ( ) ; bool stopEvent = false ; // ▁ Setting ▁ it ▁ to ▁ true ▁ stops ▁ the ▁ server ENDCOM LoginDatabaseWorkerPool LoginDatabase ; // ▁ Accessor ▁ to ▁ the ▁ auth ▁ server ▁ database ENDCOM // / ▁ Handle ▁ authserver ' s ▁ termination ▁ signals ENDCOM class AuthServerSignalHandler : public Trinity :: SignalHandler { public : virtual void HandleSignal ( int SigNum ) { switch ( SigNum ) { case SIGINT : case SIGTERM : stopEvent = true ; break ; } } } ; // / ▁ Print ▁ out ▁ the ▁ usage ▁ string ▁ for ▁ this ▁ program ▁ on ▁ the ▁ console . ENDCOM void usage ( const char * prog ) { sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Usage : ▁ \n ▁ % s ▁ [ < options > ] \n " " ▁ ▁ ▁ ▁ - c ▁ config _ file ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ use ▁ config _ file ▁ as ▁ configuration ▁ file \n " , prog ) ; } // / ▁ Launch ▁ the ▁ auth ▁ server ENDCOM extern int main ( int argc , char * * argv ) { // ▁ Command ▁ line ▁ parsing ▁ to ▁ get ▁ the ▁ configuration ▁ file ▁ name ENDCOM char const * cfg_file = _TRINITY_REALM_CONFIG ; int c = 1 ; while ( c < argc ) { if ( strcmp ( argv [ c ] , " - c " ) == 0 ) { if ( ++ c >= argc ) { printf ( " Runtime - Error : ▁ - c ▁ option ▁ requires ▁ an ▁ input ▁ argument \n " ) ; usage ( argv [ 0 ] ) ; return 1 ; } else cfg_file = argv [ c ] ; } ++ c ; } if ( ! ConfigMgr :: Load ( cfg_file ) ) { printf ( " Invalid ▁ or ▁ missing ▁ configuration ▁ file ▁ : ▁ % s \n " , cfg_file ) ; printf ( " Verify ▁ that ▁ the ▁ file ▁ exists ▁ and ▁ has ▁ \ ' [ authserver ] \ ' ▁ written ▁ in ▁ the ▁ top ▁ of ▁ the ▁ file ! \n " ) ; return 1 ; } sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " % s ▁ ( authserver ) " , _FULLVERSION ) ; sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " < Ctrl - C > ▁ to ▁ stop . \n " ) ; sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Using ▁ configuration ▁ file ▁ % s . " , cfg_file ) ; sLog -> outWarn ( LOG_FILTER_AUTHSERVER , " % s ▁ ( Library : ▁ % s ) " , OPENSSL_VERSION_TEXT , SSLeay_version ( SSLEAY_VERSION ) ) ; # if defined ( ACE_HAS_EVENT_POLL ) || defined ( ACE_HAS_DEV_POLL ) ACE_Reactor :: instance ( new ACE_Reactor ( new ACE_Dev_Poll_Reactor ( ACE :: max_handles ( ) , 1 ) , 1 ) , true ) ; # else ACE_Reactor :: instance ( new ACE_Reactor ( new ACE_TP_Reactor ( ) , true ) , true ) ; # endif sLog -> outDebug ( LOG_FILTER_AUTHSERVER , " Max ▁ allowed ▁ open ▁ files ▁ is ▁ % d " , ACE :: max_handles ( ) ) ; // ▁ authserver ▁ PID ▁ file ▁ creation ENDCOM std :: string pidfile = ConfigMgr :: GetStringDefault ( " PidFile " , " " ) ; if ( ! pidfile . empty ( ) ) { uint32 pid = CreatePIDFile ( pidfile ) ; if ( ! pid ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Cannot ▁ create ▁ PID ▁ file ▁ % s . \n " , pidfile . c_str ( ) ) ; return 1 ; } sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Daemon ▁ PID : ▁ % u \n " , pid ) ; } // ▁ Initialize ▁ the ▁ database ▁ connection ENDCOM if ( ! StartDB ( ) ) return 1 ; sLog -> SetRealmID ( 0 ) ; // ▁ ensure ▁ we ' ve ▁ set ▁ realm ▁ to ▁ 0 ▁ ( authserver ▁ realmid ) ENDCOM // ▁ Get ▁ the ▁ list ▁ of ▁ realms ▁ for ▁ the ▁ server ENDCOM sRealmList -> Initialize ( ConfigMgr :: GetIntDefault ( " RealmsStateUpdateDelay " , 20 ) ) ; if ( sRealmList -> size ( ) == 0 ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " No ▁ valid ▁ realms ▁ specified . " ) ; return 1 ; } // ▁ Launch ▁ the ▁ listening ▁ network ▁ socket ENDCOM RealmAcceptor acceptor ; int32 rmport = ConfigMgr :: GetIntDefault ( " RealmServerPort " , 3724 ) ; if ( rmport < 0 || rmport > 0xFFFF ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Specified ▁ port ▁ out ▁ of ▁ allowed ▁ range ▁ ( 1-65535 ) " ) ; return 1 ; } std :: string bind_ip = ConfigMgr :: GetStringDefault ( " BindIP " , "0.0.0.0" ) ; ACE_INET_Addr bind_addr ( uint16 ( rmport ) , bind_ip . c_str ( ) ) ; if ( acceptor . open ( bind_addr , ACE_Reactor :: instance ( ) , ACE_NONBLOCK ) == - 1 ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Auth ▁ server ▁ can ▁ not ▁ bind ▁ to ▁ % s : % d " , bind_ip . c_str ( ) , rmport ) ; return 1 ; } // ▁ Initialise ▁ the ▁ signal ▁ handlers ENDCOM AuthServerSignalHandler SignalINT , SignalTERM ; // ▁ Register ▁ authservers ' s ▁ signal ▁ handlers ENDCOM ACE_Sig_Handler Handler ; Handler . register_handler ( SIGINT , & SignalINT ) ; Handler . register_handler ( SIGTERM , & SignalTERM ) ; // / - ▁ Handle ▁ affinity ▁ for ▁ multiple ▁ processors ▁ and ▁ process ▁ priority ▁ on ▁ Windows ENDCOM # ifdef _WIN32 { HANDLE hProcess = GetCurrentProcess ( ) ; uint32 Aff = ConfigMgr :: GetIntDefault ( " UseProcessors " , 0 ) ; if ( Aff > 0 ) { ULONG_PTR appAff ; ULONG_PTR sysAff ; if ( GetProcessAffinityMask ( hProcess , & appAff , & sysAff ) ) { ULONG_PTR curAff = Aff & appAff ; // ▁ remove ▁ non ▁ accessible ▁ processors ENDCOM if ( ! curAff ) sLog -> outError ( LOG_FILTER_AUTHSERVER , " Processors ▁ marked ▁ in ▁ UseProcessors ▁ bitmask ▁ ( hex ) ▁ % x ▁ not ▁ accessible ▁ for ▁ authserver . ▁ Accessible ▁ processors ▁ bitmask ▁ ( hex ) : ▁ % x " , Aff , appAff ) ; else if ( SetProcessAffinityMask ( hProcess , curAff ) ) sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Using ▁ processors ▁ ( bitmask , ▁ hex ) : ▁ % x " , curAff ) ; else sLog -> outError ( LOG_FILTER_AUTHSERVER , " Can ' t ▁ set ▁ used ▁ processors ▁ ( hex ) : ▁ % x " , curAff ) ; } } bool Prio = ConfigMgr :: GetBoolDefault ( " ProcessPriority " , false ) ; if ( Prio ) { if ( SetPriorityClass ( hProcess , HIGH_PRIORITY_CLASS ) ) sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " The ▁ auth ▁ server ▁ process ▁ priority ▁ class ▁ has ▁ been ▁ set ▁ to ▁ HIGH " ) ; else sLog -> outError ( LOG_FILTER_AUTHSERVER , " Can ' t ▁ set ▁ auth ▁ server ▁ process ▁ priority ▁ class . " ) ; } } # endif // ▁ maximum ▁ counter ▁ for ▁ next ▁ ping ENDCOM uint32 numLoops = ( ConfigMgr :: GetIntDefault ( " MaxPingTime " , 30 ) * ( MINUTE * 1000000 / 100000 ) ) ; uint32 loopCounter = 0 ; // ▁ Wait ▁ for ▁ termination ▁ signal ENDCOM while ( ! stopEvent ) { // ▁ dont ▁ move ▁ this ▁ outside ▁ the ▁ loop , ▁ the ▁ reactor ▁ will ▁ modify ▁ it ENDCOM ACE_Time_Value interval ( 0 , 100000 ) ; if ( ACE_Reactor :: instance ( ) -> run_reactor_event_loop ( interval ) == - 1 ) break ; if ( ( ++ loopCounter ) == numLoops ) { loopCounter = 0 ; sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Ping ▁ MySQL ▁ to ▁ keep ▁ connection ▁ alive " ) ; LoginDatabase . KeepAlive ( ) ; } } // ▁ Close ▁ the ▁ Database ▁ Pool ▁ and ▁ library ENDCOM StopDB ( ) ; sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Halting ▁ process . . . " ) ; return 0 ; } // / ▁ Initialize ▁ connection ▁ to ▁ the ▁ database ENDCOM bool StartDB ( ) { MySQL :: Library_Init ( ) ; std :: string dbstring = ConfigMgr :: GetStringDefault ( " LoginDatabaseInfo " , " " ) ; if ( dbstring . empty ( ) ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Database ▁ not ▁ specified " ) ; return false ; } int32 worker_threads = ConfigMgr :: GetIntDefault ( " LoginDatabase . WorkerThreads " , 1 ) ; if ( worker_threads < 1 || worker_threads > 32 ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Improper ▁ value ▁ specified ▁ for ▁ LoginDatabase . WorkerThreads , ▁ defaulting ▁ to ▁ 1 . " ) ; worker_threads = 1 ; } int32 synch_threads = ConfigMgr :: GetIntDefault ( " LoginDatabase . SynchThreads " , 1 ) ; if ( synch_threads < 1 || synch_threads > 32 ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Improper ▁ value ▁ specified ▁ for ▁ LoginDatabase . SynchThreads , ▁ defaulting ▁ to ▁ 1 . " ) ; synch_threads = 1 ; } // ▁ NOTE : ▁ While ▁ authserver ▁ is ▁ singlethreaded ▁ you ▁ should ▁ keep ▁ synch _ threads ▁ = = ▁ 1 . ▁ Increasing ▁ it ▁ is ▁ just ▁ silly ▁ since ▁ only ▁ 1 ▁ will ▁ be ▁ used ▁ ever . ENDCOM if ( ! LoginDatabase . Open ( dbstring . c_str ( ) , uint8 ( worker_threads ) , uint8 ( synch_threads ) ) ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Cannot ▁ connect ▁ to ▁ database " ) ; return false ; } sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Started ▁ auth ▁ database ▁ connection ▁ pool . " ) ; sLog -> EnableDBAppenders ( ) ; return true ; } // / ▁ Close ▁ the ▁ connection ▁ to ▁ the ▁ database ENDCOM void StopDB ( ) { LoginDatabase . Close ( ) ; MySQL :: Library_End ( ) ; } </DOCUMENT>
<DOCUMENT_ID="mantidproject/cxxtest/tree/master/cxxtest/TestTracker.cpp"> /* STRNEWLINE - - - - - STRNEWLINE ▁ CxxTest : ▁ A ▁ lightweight ▁ C + + ▁ unit ▁ testing ▁ library . STRNEWLINE ▁ Copyright ▁ ( c ) ▁ 2008 ▁ Sandia ▁ Corporation . STRNEWLINE ▁ This ▁ software ▁ is ▁ distributed ▁ under ▁ the ▁ LGPL ▁ License ▁ v3 STRNEWLINE ▁ For ▁ more ▁ information , ▁ see ▁ the ▁ COPYING ▁ file ▁ in ▁ the ▁ top ▁ CxxTest ▁ directory . STRNEWLINE ▁ Under ▁ the ▁ terms ▁ of ▁ Contract ▁ DE - AC04-94AL85000 ▁ with ▁ Sandia ▁ Corporation , STRNEWLINE ▁ the ▁ U . S . ▁ Government ▁ retains ▁ certain ▁ rights ▁ in ▁ this ▁ software . STRNEWLINE - - - - - STRNEWLINE */ # ifndef __cxxtest__TestTracker_cpp__ # define __cxxtest__TestTracker_cpp__ # include < cxxtest / TestTracker . h > namespace CxxTest { bool TestTracker :: _created = false ; bool TestTracker :: print_tracing = false ; TestTracker :: TestTracker ( ) { if ( ! _created ) { initialize ( ) ; setListener ( 0 ) ; _created = true ; } } TestTracker :: ~ TestTracker ( ) { } TestTracker & TestTracker :: tracker ( ) { static TestTracker theTracker ; return theTracker ; } void TestTracker :: initialize ( ) { _warnings = 0 ; _skippedTests = 0 ; _testSkipped = false ; _failedTests = 0 ; _testFailedAsserts = 0 ; _suiteFailedTests = 0 ; _failedSuites = 0 ; _world = 0 ; _suite = 0 ; _test = 0 ; } const TestDescription * TestTracker :: fixTest ( const TestDescription * d ) const { return d ? d : & dummyTest ( ) ; } const SuiteDescription * TestTracker :: fixSuite ( const SuiteDescription * d ) const { return d ? d : & dummySuite ( ) ; } const WorldDescription * TestTracker :: fixWorld ( const WorldDescription * d ) const { return d ? d : & dummyWorld ( ) ; } const TestDescription & TestTracker :: dummyTest ( ) const { return dummySuite ( ) . testDescription ( 0 ) ; } const SuiteDescription & TestTracker :: dummySuite ( ) const { return dummyWorld ( ) . suiteDescription ( 0 ) ; } const WorldDescription & TestTracker :: dummyWorld ( ) const { return _dummyWorld ; } void TestTracker :: setListener ( TestListener * l ) { _l = l ? l : & _dummyListener ; } void TestTracker :: enterWorld ( const WorldDescription & wd ) { setWorld ( & wd ) ; _warnings = _skippedTests = _failedTests = _testFailedAsserts = _suiteFailedTests = _failedSuites = 0 ; _testSkipped = false ; _l -> enterWorld ( wd ) ; } void TestTracker :: enterSuite ( const SuiteDescription & sd ) { setSuite ( & sd ) ; _testFailedAsserts = _suiteFailedTests = 0 ; _testSkipped = false ; _l -> enterSuite ( sd ) ; } void TestTracker :: enterTest ( const TestDescription & td ) { setTest ( & td ) ; _testFailedAsserts = false ; _testSkipped = false ; _l -> enterTest ( td ) ; } void TestTracker :: leaveTest ( const TestDescription & td ) { _l -> leaveTest ( td ) ; setTest ( 0 ) ; } void TestTracker :: leaveSuite ( const SuiteDescription & sd ) { _l -> leaveSuite ( sd ) ; setSuite ( 0 ) ; } void TestTracker :: leaveWorld ( const WorldDescription & wd ) { _l -> leaveWorld ( wd ) ; setWorld ( 0 ) ; } void TestTracker :: trace ( const char * file , int line , const char * expression ) { _l -> trace ( file , line , expression ) ; } void TestTracker :: warning ( const char * file , int line , const char * expression ) { countWarning ( ) ; _l -> warning ( file , line , expression ) ; } void TestTracker :: skippedTest ( const char * file , int line , const char * expression ) { countSkipped ( ) ; _testSkipped = true ; _l -> skippedTest ( file , line , expression ) ; } void TestTracker :: failedTest ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedTest ( file , line , expression ) ; } void TestTracker :: failedAssert ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedAssert ( file , line , expression ) ; } void TestTracker :: failedAssertEquals ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertEquals ( file , line , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertSameData ( const char * file , int line , const char * xStr , const char * yStr , const char * sizeStr , const void * x , const void * y , unsigned size ) { countFailure ( ) ; _l -> failedAssertSameData ( file , line , xStr , yStr , sizeStr , x , y , size ) ; } void TestTracker :: failedAssertDelta ( const char * file , int line , const char * xStr , const char * yStr , const char * dStr , const char * x , const char * y , const char * d ) { countFailure ( ) ; _l -> failedAssertDelta ( file , line , xStr , yStr , dStr , x , y , d ) ; } void TestTracker :: failedAssertDiffers ( const char * file , int line , const char * xStr , const char * yStr , const char * value ) { countFailure ( ) ; _l -> failedAssertDiffers ( file , line , xStr , yStr , value ) ; } void TestTracker :: failedAssertLessThan ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertLessThan ( file , line , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertLessThanEquals ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertLessThanEquals ( file , line , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertPredicate ( const char * file , int line , const char * predicate , const char * xStr , const char * x ) { countFailure ( ) ; _l -> failedAssertPredicate ( file , line , predicate , xStr , x ) ; } void TestTracker :: failedAssertRelation ( const char * file , int line , const char * relation , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertRelation ( file , line , relation , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertThrows ( const char * file , int line , const char * expression , const char * type , bool otherThrown ) { countFailure ( ) ; _l -> failedAssertThrows ( file , line , expression , type , otherThrown ) ; } void TestTracker :: failedAssertThrowsNot ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedAssertThrowsNot ( file , line , expression ) ; } void TestTracker :: failedAssertSameFiles ( const char * file , int line , const char * file1 , const char * file2 , const char * explanation ) { countFailure ( ) ; _l -> failedAssertSameFiles ( file , line , file1 , file2 , explanation ) ; } void TestTracker :: setWorld ( const WorldDescription * w ) { _world = fixWorld ( w ) ; setSuite ( 0 ) ; } void TestTracker :: setSuite ( const SuiteDescription * s ) { _suite = fixSuite ( s ) ; setTest ( 0 ) ; } void TestTracker :: setTest ( const TestDescription * t ) { _test = fixTest ( t ) ; } void TestTracker :: countWarning ( ) { ++ _warnings ; } void TestTracker :: countSkipped ( ) { ++ _skippedTests ; } void TestTracker :: countFailure ( ) { if ( ++ _testFailedAsserts == 1 ) { ++ _failedTests ; if ( ++ _suiteFailedTests == 1 ) { ++ _failedSuites ; } } } } # endif // ▁ _ _ cxxtest _ _ TestTracker _ cpp _ _ ENDCOM </DOCUMENT>
<DOCUMENT_ID="wakashige/TrinityCore/tree/master/src/server/scripts/EasternKingdoms/zone_arathi_highlands.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2008-2015 ▁ TrinityCore ▁ < http : // www . trinitycore . org / > STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2006-2009 ▁ ScriptDev2 ▁ < https : // scriptdev2 . svn . sourceforge . net / > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it STRNEWLINE ▁ * ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the STRNEWLINE ▁ * ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your STRNEWLINE ▁ * ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT STRNEWLINE ▁ * ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or STRNEWLINE ▁ * ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for STRNEWLINE ▁ * ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along STRNEWLINE ▁ * ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ */ /* ▁ ScriptData STRNEWLINE SDName : ▁ Arathi ▁ Highlands STRNEWLINE SD % Complete : ▁ 100 STRNEWLINE SDComment : ▁ Quest ▁ support : ▁ 665 STRNEWLINE SDCategory : ▁ Arathi ▁ Highlands STRNEWLINE EndScriptData ▁ */ /* ▁ ContentData STRNEWLINE npc _ professor _ phizzlethorpe STRNEWLINE EndContentData ▁ */ # include " ScriptMgr . h " # include " ScriptedCreature . h " # include " ScriptedEscortAI . h " # include " Player . h " /* # # # # # STRNEWLINE # # ▁ npc _ professor _ phizzlethorpe STRNEWLINE # # # # # */ enum ProfessorPhizzlethorpe { // ▁ Yells ENDCOM SAY_PROGRESS_1 = 0 , SAY_PROGRESS_2 = 1 , SAY_PROGRESS_3 = 2 , EMOTE_PROGRESS_4 = 3 , SAY_AGGRO = 4 , SAY_PROGRESS_5 = 5 , SAY_PROGRESS_6 = 6 , SAY_PROGRESS_7 = 7 , EMOTE_PROGRESS_8 = 8 , SAY_PROGRESS_9 = 9 , EVENT_SAY_3 = 1 , EVENT_SAY_6 = 2 , EVENT_SAY_8 = 3 , // ▁ Quests ENDCOM QUEST_SUNKEN_TREASURE = 665 , QUEST_GOGGLE_BOGGLE = 26050 , // ▁ Creatures ENDCOM NPC_VENGEFUL_SURGE = 2776 , FACTION_SUNKEN_TREASURE = 113 } ; class npc_professor_phizzlethorpe : public CreatureScript { public : npc_professor_phizzlethorpe ( ) : CreatureScript ( " npc _ professor _ phizzlethorpe " ) { } struct npc_professor_phizzlethorpeAI : public npc_escortAI { npc_professor_phizzlethorpeAI ( Creature * creature ) : npc_escortAI ( creature ) { } void WaypointReached ( uint32 waypointId ) override { Player * player = GetPlayerForEscort ( ) ; if ( ! player ) return ; switch ( waypointId ) { case 6 : Talk ( SAY_PROGRESS_2 , player ) ; events . ScheduleEvent ( EVENT_SAY_3 , 3000 ) ; break ; case 8 : Talk ( EMOTE_PROGRESS_4 ) ; me -> SummonCreature ( NPC_VENGEFUL_SURGE , - 2065.505f , - 2136.88f , 22.20362f , 1.0f , TEMPSUMMON_CORPSE_DESPAWN , 0 ) ; me -> SummonCreature ( NPC_VENGEFUL_SURGE , - 2059.249f , - 2134.88f , 21.51582f , 1.0f , TEMPSUMMON_CORPSE_DESPAWN , 0 ) ; break ; case 11 : Talk ( SAY_PROGRESS_5 , player ) ; events . ScheduleEvent ( EVENT_SAY_6 , 11000 ) ; break ; case 17 : Talk ( SAY_PROGRESS_7 , player ) ; events . ScheduleEvent ( EVENT_SAY_8 , 6000 ) ; break ; } } void JustSummoned ( Creature * summoned ) override { summoned -> AI ( ) -> AttackStart ( me ) ; } void EnterCombat ( Unit * /* who */ ) override { Talk ( SAY_AGGRO ) ; } void sQuestAccept ( Player * player , Quest const * quest ) override { if ( quest -> GetQuestId ( ) == QUEST_SUNKEN_TREASURE ) { Talk ( SAY_PROGRESS_1 , player ) ; npc_escortAI :: Start ( false , false , player -> GetGUID ( ) , quest ) ; me -> setFaction ( FACTION_SUNKEN_TREASURE ) ; } } void UpdateAI ( uint32 diff ) override { Player * player = GetPlayerForEscort ( ) ; if ( ! player ) return ; events . Update ( diff ) ; while ( uint32 event = events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_SAY_3 : Talk ( SAY_PROGRESS_3 , player ) ; break ; case EVENT_SAY_6 : Talk ( SAY_PROGRESS_6 , player ) ; SetRun ( ) ; break ; case EVENT_SAY_8 : Talk ( EMOTE_PROGRESS_8 ) ; Talk ( SAY_PROGRESS_9 , player ) ; player -> GroupEventHappens ( QUEST_GOGGLE_BOGGLE , me ) ; break ; } } npc_escortAI :: UpdateAI ( diff ) ; } EventMap events ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return new npc_professor_phizzlethorpeAI ( creature ) ; } } ; void AddSC_arathi_highlands ( ) { new npc_professor_phizzlethorpe ( ) ; } </DOCUMENT>
<DOCUMENT_ID="dominik-th/xbmc/tree/master/xbmc/ApplicationPlayer.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2005-2013 ▁ Team ▁ XBMC STRNEWLINE ▁ * ▁ http : // xbmc . org STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ Program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 , ▁ or ▁ ( at ▁ your ▁ option ) STRNEWLINE ▁ * ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ Program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ XBMC ; ▁ see ▁ the ▁ file ▁ COPYING . ▁ If ▁ not , ▁ see STRNEWLINE ▁ * ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ * STRNEWLINE ▁ */ # include " ApplicationPlayer . h " # include " cores / IPlayer . h " # include " Application . h " # include " settings / MediaSettings . h " CApplicationPlayer :: CApplicationPlayer ( ) { m_iPlayerOPSeq = 0 ; m_eCurrentPlayer = EPC_NONE ; } std :: shared_ptr < IPlayer > CApplicationPlayer :: GetInternal ( ) const { CSingleLock lock ( m_player_lock ) ; return m_pPlayer ; } void CApplicationPlayer :: ClosePlayer ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { CloseFile ( ) ; // ▁ we ▁ need ▁ to ▁ do ▁ this ▁ directly ▁ on ▁ the ▁ member ENDCOM CSingleLock lock ( m_player_lock ) ; m_pPlayer . reset ( ) ; } } void CApplicationPlayer :: CloseFile ( bool reopen ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { ++ m_iPlayerOPSeq ; player -> CloseFile ( reopen ) ; } } void CApplicationPlayer :: ClosePlayerGapless ( PLAYERCOREID newCore ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( ! player ) return ; bool gaplessSupported = ( m_eCurrentPlayer == EPC_DVDPLAYER || m_eCurrentPlayer == EPC_PAPLAYER ) ; gaplessSupported = gaplessSupported && ( m_eCurrentPlayer == newCore ) ; if ( ! gaplessSupported ) { ClosePlayer ( ) ; } else { // ▁ XXX : ▁ we ▁ had ▁ to ▁ stop ▁ the ▁ previous ▁ playing ▁ item , ▁ it ▁ was ▁ done ▁ in ▁ dvdplayer : : OpenFile . ENDCOM // ▁ but ▁ in ▁ paplayer : : OpenFile , ▁ it ▁ sometimes ▁ just ▁ fade ▁ in ▁ without ▁ call ▁ CloseFile . ENDCOM // ▁ but ▁ if ▁ we ▁ do ▁ not ▁ stop ▁ it , ▁ we ▁ can ▁ not ▁ distingush ▁ callbacks ▁ from ▁ previous ENDCOM // ▁ item ▁ and ▁ current ▁ item , ▁ it ▁ will ▁ confused ▁ us ▁ then ▁ we ▁ can ▁ not ▁ make ▁ correct ▁ delay ENDCOM // ▁ callback ▁ after ▁ the ▁ starting ▁ state . ENDCOM CloseFile ( true ) ; } } void CApplicationPlayer :: CreatePlayer ( PLAYERCOREID newCore , IPlayerCallback & callback ) { CSingleLock lock ( m_player_lock ) ; if ( ! m_pPlayer ) { m_eCurrentPlayer = newCore ; m_pPlayer . reset ( CPlayerCoreFactory :: Get ( ) . CreatePlayer ( newCore , callback ) ) ; } } PlayBackRet CApplicationPlayer :: OpenFile ( const CFileItem & item , const CPlayerOptions & options ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; PlayBackRet iResult = PLAYBACK_FAIL ; if ( player ) { // ▁ op ▁ seq ▁ for ▁ detect ▁ cancel ▁ ( CloseFile ▁ be ▁ called ▁ or ▁ OpenFile ▁ be ▁ called ▁ again ) ▁ during ▁ OpenFile . ENDCOM unsigned int startingSeq = ++ m_iPlayerOPSeq ; iResult = player -> OpenFile ( item , options ) ? PLAYBACK_OK : PLAYBACK_FAIL ; // ▁ check ▁ whether ▁ the ▁ OpenFile ▁ was ▁ canceled ▁ by ▁ either ▁ CloseFile ▁ or ▁ another ▁ OpenFile . ENDCOM if ( m_iPlayerOPSeq != startingSeq ) iResult = PLAYBACK_CANCELED ; } return iResult ; } bool CApplicationPlayer :: HasPlayer ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return player != NULL ; } int CApplicationPlayer :: GetChapter ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapter ( ) ; else return - 1 ; } int CApplicationPlayer :: GetChapterCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapterCount ( ) ; else return 0 ; } void CApplicationPlayer :: GetChapterName ( std :: string & strChapterName , int chapterIdx ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetChapterName ( strChapterName , chapterIdx ) ; } int64_t CApplicationPlayer :: GetChapterPos ( int chapterIdx ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapterPos ( chapterIdx ) ; return - 1 ; } bool CApplicationPlayer :: HasAudio ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> HasAudio ( ) ) ; } bool CApplicationPlayer :: HasVideo ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> HasVideo ( ) ) ; } int CApplicationPlayer :: GetPreferredPlaylist ( ) const { if ( IsPlayingVideo ( ) ) return PLAYLIST_VIDEO ; if ( IsPlayingAudio ( ) ) return PLAYLIST_MUSIC ; return PLAYLIST_NONE ; } bool CApplicationPlayer :: IsPaused ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsPaused ( ) ) ; } bool CApplicationPlayer :: IsPlaying ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsPlaying ( ) ) ; } bool CApplicationPlayer :: IsPausedPlayback ( ) const { return ( IsPlaying ( ) && IsPaused ( ) ) ; } bool CApplicationPlayer :: IsPlayingAudio ( ) const { return ( IsPlaying ( ) && ! HasVideo ( ) && HasAudio ( ) ) ; } bool CApplicationPlayer :: IsPlayingVideo ( ) const { return ( IsPlaying ( ) && HasVideo ( ) ) ; } void CApplicationPlayer :: Pause ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> Pause ( ) ; } bool CApplicationPlayer :: ControlsVolume ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> ControlsVolume ( ) ) ; } void CApplicationPlayer :: SetMute ( bool bOnOff ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetMute ( bOnOff ) ; } void CApplicationPlayer :: SetVolume ( float volume ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetVolume ( volume ) ; } void CApplicationPlayer :: Seek ( bool bPlus , bool bLargeStep , bool bChapterOverride ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> Seek ( bPlus , bLargeStep , bChapterOverride ) ; } void CApplicationPlayer :: SeekPercentage ( float fPercent ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SeekPercentage ( fPercent ) ; } bool CApplicationPlayer :: IsPassthrough ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsPassthrough ( ) ) ; } bool CApplicationPlayer :: CanSeek ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanSeek ( ) ) ; } bool CApplicationPlayer :: SeekScene ( bool bPlus ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SeekScene ( bPlus ) ) ; } void CApplicationPlayer :: SeekTime ( int64_t iTime ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SeekTime ( iTime ) ; } void CApplicationPlayer :: SeekTimeRelative ( int64_t iTime ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { // ▁ use ▁ relative ▁ seeking ▁ if ▁ implemented ▁ by ▁ player ENDCOM if ( ! player -> SeekTimeRelative ( iTime ) ) { int64_t abstime = player -> GetTime ( ) + iTime ; player -> SeekTime ( abstime ) ; } } } std :: string CApplicationPlayer :: GetPlayingTitle ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetPlayingTitle ( ) ; else return " " ; } int64_t CApplicationPlayer :: GetTime ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetTime ( ) ; else return 0 ; } int64_t CApplicationPlayer :: GetDisplayTime ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetDisplayTime ( ) ; else return 0 ; } bool CApplicationPlayer :: IsCaching ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsCaching ( ) ) ; } bool CApplicationPlayer :: IsInMenu ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsInMenu ( ) ) ; } bool CApplicationPlayer :: HasMenu ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> HasMenu ( ) ) ; } int CApplicationPlayer :: GetCacheLevel ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetCacheLevel ( ) ; else return 0 ; } int CApplicationPlayer :: GetSubtitleCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetSubtitleCount ( ) ; else return 0 ; } int CApplicationPlayer :: GetAudioStream ( ) { if ( ! m_audioStreamUpdate . IsTimePast ( ) ) return m_iAudioStream ; std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { m_iAudioStream = player -> GetAudioStream ( ) ; m_audioStreamUpdate . Set ( 1000 ) ; return m_iAudioStream ; } else return 0 ; } int CApplicationPlayer :: GetSubtitle ( ) { if ( ! m_subtitleStreamUpdate . IsTimePast ( ) ) return m_iSubtitleStream ; std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { m_iSubtitleStream = player -> GetSubtitle ( ) ; m_subtitleStreamUpdate . Set ( 1000 ) ; return m_iSubtitleStream ; } else return 0 ; } bool CApplicationPlayer :: GetSubtitleVisible ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> GetSubtitleVisible ( ) ) ; } bool CApplicationPlayer :: CanRecord ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanRecord ( ) ) ; } bool CApplicationPlayer :: CanPause ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanPause ( ) ) ; } bool CApplicationPlayer :: IsRecording ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsRecording ( ) ) ; } TextCacheStruct_t * CApplicationPlayer :: GetTeletextCache ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetTeletextCache ( ) ; else return NULL ; } int64_t CApplicationPlayer :: GetTotalTime ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetTotalTime ( ) ; else return 0 ; } float CApplicationPlayer :: GetPercentage ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetPercentage ( ) ; else return 0.0 ; } float CApplicationPlayer :: GetCachePercentage ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetCachePercentage ( ) ; else return 0.0 ; } void CApplicationPlayer :: ToFFRW ( int iSpeed ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> ToFFRW ( iSpeed ) ; } void CApplicationPlayer :: DoAudioWork ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> DoAudioWork ( ) ; } std :: string CApplicationPlayer :: GetPlayerState ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetPlayerState ( ) ; else return " " ; } bool CApplicationPlayer :: QueueNextFile ( const CFileItem & file ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> QueueNextFile ( file ) ) ; } bool CApplicationPlayer :: GetStreamDetails ( CStreamDetails & details ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> GetStreamDetails ( details ) ) ; } bool CApplicationPlayer :: SetPlayerState ( const std :: string & state ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SetPlayerState ( state ) ) ; } void CApplicationPlayer :: OnNothingToQueueNotify ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OnNothingToQueueNotify ( ) ; } void CApplicationPlayer :: GetVideoStreamInfo ( SPlayerVideoStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetVideoStreamInfo ( info ) ; } void CApplicationPlayer :: GetAudioStreamInfo ( int index , SPlayerAudioStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioStreamInfo ( index , info ) ; } bool CApplicationPlayer :: OnAction ( const CAction & action ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> OnAction ( action ) ) ; } bool CApplicationPlayer :: Record ( bool bOnOff ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> Record ( bOnOff ) ) ; } int CApplicationPlayer :: GetAudioStreamCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetAudioStreamCount ( ) ; else return 0 ; } void CApplicationPlayer :: SetAudioStream ( int iStream ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetAudioStream ( iStream ) ; m_iAudioStream = iStream ; m_audioStreamUpdate . Set ( 1000 ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_AudioStream = iStream ; } } void CApplicationPlayer :: GetSubtitleStreamInfo ( int index , SPlayerSubtitleStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetSubtitleStreamInfo ( index , info ) ; } void CApplicationPlayer :: SetSubtitle ( int iStream ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetSubtitle ( iStream ) ; m_iSubtitleStream = iStream ; m_subtitleStreamUpdate . Set ( 1000 ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_SubtitleStream = iStream ; } } void CApplicationPlayer :: SetSubtitleVisible ( bool bVisible ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetSubtitleVisible ( bVisible ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_SubtitleOn = bVisible ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_SubtitleStream = player -> GetSubtitle ( ) ; } } void CApplicationPlayer :: AddSubtitle ( const std :: string & strSubPath ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> AddSubtitle ( strSubPath ) ; } void CApplicationPlayer :: SetSubTitleDelay ( float fValue ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetSubTitleDelay ( fValue ) ; } void CApplicationPlayer :: SetAVDelay ( float fValue ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetAVDelay ( fValue ) ; } void CApplicationPlayer :: SetDynamicRangeCompression ( long drc ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetDynamicRangeCompression ( drc ) ; } bool CApplicationPlayer :: SwitchChannel ( const PVR :: CPVRChannelPtr & channel ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SwitchChannel ( channel ) ) ; } void CApplicationPlayer :: LoadPage ( int p , int sp , unsigned char * buffer ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> LoadPage ( p , sp , buffer ) ; } void CApplicationPlayer :: GetAudioCapabilities ( std :: vector < int > & audioCaps ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioCapabilities ( audioCaps ) ; } void CApplicationPlayer :: GetSubtitleCapabilities ( std :: vector < int > & subCaps ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetSubtitleCapabilities ( subCaps ) ; } void CApplicationPlayer :: GetAudioInfo ( std :: string & strAudioInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioInfo ( strAudioInfo ) ; } void CApplicationPlayer :: GetVideoInfo ( std :: string & strVideoInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetVideoInfo ( strVideoInfo ) ; } void CApplicationPlayer :: GetGeneralInfo ( std :: string & strVideoInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetGeneralInfo ( strVideoInfo ) ; } int CApplicationPlayer :: SeekChapter ( int iChapter ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> SeekChapter ( iChapter ) ; else return 0 ; } void CApplicationPlayer :: GetRenderFeatures ( std :: vector < int > & renderFeatures ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetRenderFeatures ( renderFeatures ) ; } void CApplicationPlayer :: GetDeinterlaceMethods ( std :: vector < int > & deinterlaceMethods ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetDeinterlaceMethods ( deinterlaceMethods ) ; } void CApplicationPlayer :: GetDeinterlaceModes ( std :: vector < int > & deinterlaceModes ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetDeinterlaceModes ( deinterlaceModes ) ; } void CApplicationPlayer :: GetScalingMethods ( std :: vector < int > & scalingMethods ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetScalingMethods ( scalingMethods ) ; } void CApplicationPlayer :: SetPlaySpeed ( int iSpeed , bool bApplicationMuted ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( ! player ) return ; if ( ! IsPlayingAudio ( ) && ! IsPlayingVideo ( ) ) return ; if ( m_iPlaySpeed == iSpeed ) return ; if ( ! CanSeek ( ) ) return ; if ( IsPaused ( ) ) { if ( ( ( m_iPlaySpeed > 1 ) && ( iSpeed > m_iPlaySpeed ) ) || ( ( m_iPlaySpeed < - 1 ) && ( iSpeed < m_iPlaySpeed ) ) ) { iSpeed = m_iPlaySpeed ; // ▁ from ▁ pause ▁ to ▁ ff / rw , ▁ do ▁ previous ▁ ff / rw ▁ speed ENDCOM } Pause ( ) ; } m_iPlaySpeed = iSpeed ; ToFFRW ( m_iPlaySpeed ) ; // ▁ if ▁ player ▁ has ▁ volume ▁ control , ▁ set ▁ it . ENDCOM if ( ControlsVolume ( ) ) { if ( m_iPlaySpeed == 1 ) { // ▁ restore ▁ volume ENDCOM player -> SetVolume ( g_application . GetVolume ( false ) ) ; } else { // ▁ mute ▁ volume ENDCOM player -> SetVolume ( VOLUME_MINIMUM ) ; } player -> SetMute ( bApplicationMuted ) ; } } int CApplicationPlayer :: GetPlaySpeed ( ) const { return m_iPlaySpeed ; } </DOCUMENT>
<DOCUMENT_ID="sunblithe/qt-everywhere-opensource-src-4.7.1/tree/master/src/gui/kernel/qeventdispatcher_x11.cpp"> /* * * * * STRNEWLINE * * STRNEWLINE * * ▁ Copyright ▁ ( C ) ▁ 2010 ▁ Nokia ▁ Corporation ▁ and / or ▁ its ▁ subsidiary ( - ies ) . STRNEWLINE * * ▁ All ▁ rights ▁ reserved . STRNEWLINE * * ▁ Contact : ▁ Nokia ▁ Corporation ▁ ( qt - info @ nokia . com ) STRNEWLINE * * STRNEWLINE * * ▁ This ▁ file ▁ is ▁ part ▁ of ▁ the ▁ QtGui ▁ module ▁ of ▁ the ▁ Qt ▁ Toolkit . STRNEWLINE * * STRNEWLINE * * ▁ $ QT _ BEGIN _ LICENSE : LGPL $ STRNEWLINE * * ▁ Commercial ▁ Usage STRNEWLINE * * ▁ Licensees ▁ holding ▁ valid ▁ Qt ▁ Commercial ▁ licenses ▁ may ▁ use ▁ this ▁ file ▁ in STRNEWLINE * * ▁ accordance ▁ with ▁ the ▁ Qt ▁ Commercial ▁ License ▁ Agreement ▁ provided ▁ with ▁ the STRNEWLINE * * ▁ Software ▁ or , ▁ alternatively , ▁ in ▁ accordance ▁ with ▁ the ▁ terms ▁ contained ▁ in STRNEWLINE * * ▁ a ▁ written ▁ agreement ▁ between ▁ you ▁ and ▁ Nokia . STRNEWLINE * * STRNEWLINE * * ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ Usage STRNEWLINE * * ▁ Alternatively , ▁ this ▁ file ▁ may ▁ be ▁ used ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser STRNEWLINE * * ▁ General ▁ Public ▁ License ▁ version ▁ 2.1 ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software STRNEWLINE * * ▁ Foundation ▁ and ▁ appearing ▁ in ▁ the ▁ file ▁ LICENSE . LGPL ▁ included ▁ in ▁ the STRNEWLINE * * ▁ packaging ▁ of ▁ this ▁ file . ▁ Please ▁ review ▁ the ▁ following ▁ information ▁ to STRNEWLINE * * ▁ ensure ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ version ▁ 2.1 ▁ requirements STRNEWLINE * * ▁ will ▁ be ▁ met : ▁ http : // www . gnu . org / licenses / old - licenses / lgpl - 2.1 . html . STRNEWLINE * * STRNEWLINE * * ▁ In ▁ addition , ▁ as ▁ a ▁ special ▁ exception , ▁ Nokia ▁ gives ▁ you ▁ certain ▁ additional STRNEWLINE * * ▁ rights . ▁ These ▁ rights ▁ are ▁ described ▁ in ▁ the ▁ Nokia ▁ Qt ▁ LGPL ▁ Exception STRNEWLINE * * ▁ version ▁ 1.1 , ▁ included ▁ in ▁ the ▁ file ▁ LGPL _ EXCEPTION . txt ▁ in ▁ this ▁ package . STRNEWLINE * * STRNEWLINE * * ▁ GNU ▁ General ▁ Public ▁ License ▁ Usage STRNEWLINE * * ▁ Alternatively , ▁ this ▁ file ▁ may ▁ be ▁ used ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU STRNEWLINE * * ▁ General ▁ Public ▁ License ▁ version ▁ 3.0 ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software STRNEWLINE * * ▁ Foundation ▁ and ▁ appearing ▁ in ▁ the ▁ file ▁ LICENSE . GPL ▁ included ▁ in ▁ the STRNEWLINE * * ▁ packaging ▁ of ▁ this ▁ file . ▁ Please ▁ review ▁ the ▁ following ▁ information ▁ to STRNEWLINE * * ▁ ensure ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ version ▁ 3.0 ▁ requirements ▁ will ▁ be STRNEWLINE * * ▁ met : ▁ http : // www . gnu . org / copyleft / gpl . html . STRNEWLINE * * STRNEWLINE * * ▁ If ▁ you ▁ have ▁ questions ▁ regarding ▁ the ▁ use ▁ of ▁ this ▁ file , ▁ please ▁ contact STRNEWLINE * * ▁ Nokia ▁ at ▁ qt - info @ nokia . com . STRNEWLINE * * ▁ $ QT _ END _ LICENSE $ STRNEWLINE * * STRNEWLINE * * * * */ # include " qeventdispatcher _ x11 _ p . h " # include " qapplication . h " # include " qx11info _ x11 . h " # include " qt _ x11 _ p . h " # include < private / qeventdispatcher_unix_p . h > QT_BEGIN_NAMESPACE class QEventDispatcherX11Private : public QEventDispatcherUNIXPrivate { Q_DECLARE_PUBLIC ( QEventDispatcherX11 ) public : inline QEventDispatcherX11Private ( ) : xfd ( - 1 ) { } int xfd ; QList < XEvent > queuedUserInputEvents ; } ; QEventDispatcherX11 :: QEventDispatcherX11 ( QObject * parent ) : QEventDispatcherUNIX ( * new QEventDispatcherX11Private , parent ) { } QEventDispatcherX11 :: ~ QEventDispatcherX11 ( ) { } bool QEventDispatcherX11 :: processEvents ( QEventLoop :: ProcessEventsFlags flags ) { Q_D ( QEventDispatcherX11 ) ; d -> interrupt = false ; QApplication :: sendPostedEvents ( ) ; ulong marker = XNextRequest ( X11 -> display ) ; int nevents = 0 ; do { while ( ! d -> interrupt ) { XEvent event ; if ( ! ( flags & QEventLoop :: ExcludeUserInputEvents ) && ! d -> queuedUserInputEvents . isEmpty ( ) ) { // ▁ process ▁ a ▁ pending ▁ user ▁ input ▁ event ENDCOM event = d -> queuedUserInputEvents . takeFirst ( ) ; } else if ( XEventsQueued ( X11 -> display , QueuedAlready ) ) { // ▁ process ▁ events ▁ from ▁ the ▁ X ▁ server ENDCOM XNextEvent ( X11 -> display , & event ) ; if ( flags & QEventLoop :: ExcludeUserInputEvents ) { // ▁ queue ▁ user ▁ input ▁ events ENDCOM switch ( event . type ) { case ButtonPress : case ButtonRelease : case MotionNotify : case XKeyPress : case XKeyRelease : case EnterNotify : case LeaveNotify : d -> queuedUserInputEvents . append ( event ) ; continue ; case ClientMessage : // ▁ only ▁ keep ▁ the ▁ wm _ take _ focus ▁ and ENDCOM // ▁ _ qt _ scrolldone ▁ protocols , ▁ queue ▁ all ▁ other ENDCOM // ▁ client ▁ messages ENDCOM if ( event . xclient . format == 32 ) { if ( event . xclient . message_type == ATOM ( WM_PROTOCOLS ) && ( Atom ) event . xclient . data . l [ 0 ] == ATOM ( WM_TAKE_FOCUS ) ) { break ; } else if ( event . xclient . message_type == ATOM ( _QT_SCROLL_DONE ) ) { break ; } } d -> queuedUserInputEvents . append ( event ) ; continue ; default : break ; } } } else { // ▁ no ▁ event ▁ to ▁ process ENDCOM break ; } // ▁ send ▁ through ▁ event ▁ filter ENDCOM if ( filterEvent ( & event ) ) continue ; nevents ++ ; if ( qApp -> x11ProcessEvent ( & event ) == 1 ) return true ; if ( event . xany . serial >= marker ) { if ( XEventsQueued ( X11 -> display , QueuedAfterFlush ) ) flags &= ~ QEventLoop :: WaitForMoreEvents ; goto out ; } } } while ( ! d -> interrupt && XEventsQueued ( X11 -> display , QueuedAfterFlush ) ) ; out : if ( ! d -> interrupt ) { const uint exclude_all = QEventLoop :: ExcludeSocketNotifiers | QEventLoop :: X11ExcludeTimers | QEventLoop :: WaitForMoreEvents ; if ( nevents > 0 && ( ( uint ) flags & exclude_all ) == exclude_all ) { QApplication :: sendPostedEvents ( ) ; return nevents > 0 ; } // ▁ return ▁ true ▁ if ▁ we ▁ handled ▁ events , ▁ false ▁ otherwise ENDCOM return QEventDispatcherUNIX :: processEvents ( flags ) || ( nevents > 0 ) ; } return nevents > 0 ; } bool QEventDispatcherX11 :: hasPendingEvents ( ) { extern uint qGlobalPostedEventsCount ( ) ; // ▁ from ▁ qapplication . cpp ENDCOM return ( qGlobalPostedEventsCount ( ) || XPending ( X11 -> display ) ) ; } void QEventDispatcherX11 :: flush ( ) { XFlush ( X11 -> display ) ; } void QEventDispatcherX11 :: startingUp ( ) { Q_D ( QEventDispatcherX11 ) ; d -> xfd = XConnectionNumber ( X11 -> display ) ; } void QEventDispatcherX11 :: closingDown ( ) { Q_D ( QEventDispatcherX11 ) ; d -> xfd = - 1 ; } int QEventDispatcherX11 :: select ( int nfds , fd_set * readfds , fd_set * writefds , fd_set * exceptfds , timeval * timeout ) { Q_D ( QEventDispatcherX11 ) ; if ( d -> xfd > 0 ) { nfds = qMax ( nfds - 1 , d -> xfd ) + 1 ; FD_SET ( d -> xfd , readfds ) ; } return QEventDispatcherUNIX :: select ( nfds , readfds , writefds , exceptfds , timeout ) ; } QT_END_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="StevenBlack/phantomjs/tree/master/src/qt/qtwebkit/Source/WebCore/platform/audio/AudioFIFO.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2012 ▁ Google ▁ Inc . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without STRNEWLINE ▁ * ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions STRNEWLINE ▁ * ▁ are ▁ met : STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ 1 . ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . STRNEWLINE ▁ * ▁ 2 . ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in ▁ the STRNEWLINE ▁ * ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the ▁ distribution . STRNEWLINE ▁ * ▁ 3 . ▁ Neither ▁ the ▁ name ▁ of ▁ Apple ▁ Computer , ▁ Inc . ▁ ( " Apple " ) ▁ nor ▁ the ▁ names ▁ of STRNEWLINE ▁ * ▁ its ▁ contributors ▁ may ▁ be ▁ used ▁ to ▁ endorse ▁ or ▁ promote ▁ products ▁ derived STRNEWLINE ▁ * ▁ from ▁ this ▁ software ▁ without ▁ specific ▁ prior ▁ written ▁ permission . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ APPLE ▁ AND ▁ ITS ▁ CONTRIBUTORS ▁ " AS ▁ IS " ▁ AND ▁ ANY STRNEWLINE ▁ * ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ THE ▁ IMPLIED STRNEWLINE ▁ * ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE ▁ ARE STRNEWLINE ▁ * ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ APPLE ▁ OR ▁ ITS ▁ CONTRIBUTORS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY STRNEWLINE ▁ * ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES STRNEWLINE ▁ * ▁ ( INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES ; STRNEWLINE ▁ * ▁ LOSS ▁ OF ▁ USE , ▁ DATA , ▁ OR ▁ PROFITS ; ▁ OR ▁ BUSINESS ▁ INTERRUPTION ) ▁ HOWEVER ▁ CAUSED ▁ AND STRNEWLINE ▁ * ▁ ON ▁ ANY ▁ THEORY ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ CONTRACT , ▁ STRICT ▁ LIABILITY , ▁ OR ▁ TORT STRNEWLINE ▁ * ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE ▁ OF STRNEWLINE ▁ * ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . STRNEWLINE ▁ */ # include " config . h " # if ENABLE ( WEB_AUDIO ) # include " AudioFIFO . h " namespace WebCore { AudioFIFO :: AudioFIFO ( unsigned numberOfChannels , size_t fifoLength ) : m_fifoAudioBus ( AudioBus :: create ( numberOfChannels , fifoLength ) ) , m_fifoLength ( fifoLength ) , m_framesInFifo ( 0 ) , m_readIndex ( 0 ) , m_writeIndex ( 0 ) { } void AudioFIFO :: consume ( AudioBus * destination , size_t framesToConsume ) { bool isGood = destination && ( framesToConsume <= m_fifoLength ) && ( framesToConsume <= m_framesInFifo ) && ( destination -> length ( ) >= framesToConsume ) ; ASSERT ( isGood ) ; if ( ! isGood ) return ; // ▁ Copy ▁ the ▁ requested ▁ number ▁ of ▁ samples ▁ to ▁ the ▁ destination . ENDCOM size_t part1Length ; size_t part2Length ; findWrapLengths ( m_readIndex , framesToConsume , part1Length , part2Length ) ; size_t numberOfChannels = m_fifoAudioBus -> numberOfChannels ( ) ; for ( size_t channelIndex = 0 ; channelIndex < numberOfChannels ; ++ channelIndex ) { float * destinationData = destination -> channel ( channelIndex ) -> mutableData ( ) ; const float * sourceData = m_fifoAudioBus -> channel ( channelIndex ) -> data ( ) ; bool isCopyGood = ( ( m_readIndex < m_fifoLength ) && ( m_readIndex + part1Length ) <= m_fifoLength && ( part1Length <= destination -> length ( ) ) && ( part1Length + part2Length ) <= destination -> length ( ) ) ; ASSERT ( isCopyGood ) ; if ( ! isCopyGood ) return ; memcpy ( destinationData , sourceData + m_readIndex , part1Length * sizeof ( * sourceData ) ) ; // ▁ Handle ▁ wrap ▁ around ▁ of ▁ the ▁ FIFO , ▁ if ▁ needed . ENDCOM if ( part2Length ) memcpy ( destinationData + part1Length , sourceData , part2Length * sizeof ( * sourceData ) ) ; } m_readIndex = updateIndex ( m_readIndex , framesToConsume ) ; ASSERT ( m_framesInFifo >= framesToConsume ) ; m_framesInFifo -= framesToConsume ; } void AudioFIFO :: push ( const AudioBus * sourceBus ) { // ▁ Copy ▁ the ▁ sourceBus ▁ into ▁ the ▁ FIFO ▁ buffer . ENDCOM bool isGood = sourceBus && ( m_framesInFifo + sourceBus -> length ( ) <= m_fifoLength ) ; if ( ! isGood ) return ; size_t sourceLength = sourceBus -> length ( ) ; size_t part1Length ; size_t part2Length ; findWrapLengths ( m_writeIndex , sourceLength , part1Length , part2Length ) ; size_t numberOfChannels = m_fifoAudioBus -> numberOfChannels ( ) ; for ( size_t channelIndex = 0 ; channelIndex < numberOfChannels ; ++ channelIndex ) { float * destination = m_fifoAudioBus -> channel ( channelIndex ) -> mutableData ( ) ; const float * source = sourceBus -> channel ( channelIndex ) -> data ( ) ; bool isCopyGood = ( ( m_writeIndex < m_fifoLength ) && ( m_writeIndex + part1Length ) <= m_fifoLength && part2Length < m_fifoLength && part1Length + part2Length <= sourceLength ) ; ASSERT ( isCopyGood ) ; if ( ! isCopyGood ) return ; memcpy ( destination + m_writeIndex , source , part1Length * sizeof ( * destination ) ) ; // ▁ Handle ▁ wrap ▁ around ▁ of ▁ the ▁ FIFO , ▁ if ▁ needed . ENDCOM if ( part2Length ) memcpy ( destination , source + part1Length , part2Length * sizeof ( * destination ) ) ; } m_framesInFifo += sourceLength ; ASSERT ( m_framesInFifo <= m_fifoLength ) ; m_writeIndex = updateIndex ( m_writeIndex , sourceLength ) ; } void AudioFIFO :: findWrapLengths ( size_t index , size_t size , size_t & part1Length , size_t & part2Length ) { ASSERT_WITH_SECURITY_IMPLICATION ( index < m_fifoLength && size <= m_fifoLength ) ; if ( index < m_fifoLength && size <= m_fifoLength ) { if ( index + size > m_fifoLength ) { // ▁ Need ▁ to ▁ wrap . ▁ Figure ▁ out ▁ the ▁ length ▁ of ▁ each ▁ piece . ENDCOM part1Length = m_fifoLength - index ; part2Length = size - part1Length ; } else { // ▁ No ▁ wrap ▁ needed . ENDCOM part1Length = size ; part2Length = 0 ; } } else { // ▁ Invalid ▁ values ▁ for ▁ index ▁ or ▁ size . ▁ Set ▁ the ▁ part ▁ lengths ▁ to ▁ zero ▁ so ▁ nothing ▁ is ▁ copied . ENDCOM part1Length = 0 ; part2Length = 0 ; } } } // ▁ namespace ▁ WebCore ENDCOM # endif // ▁ ENABLE ( WEB _ AUDIO ) ENDCOM </DOCUMENT>
<DOCUMENT_ID="cristal/Patch/tree/master/dep/acelite/ace/Parse_Node.cpp"> // ▁ $ Id : ▁ Parse _ Node . cpp ▁ 91368 ▁ 2010-08-16 ▁ 13:03:34Z ▁ mhengstmengel ▁ $ ENDCOM # include " ace / Parse _ Node . h " # if ( ACE_USES_CLASSIC_SVC_CONF == 1 ) # include " ace / Service _ Config . h " # include " ace / Service _ Repository . h " # include " ace / Service _ Types . h " # include " ace / Task . h " # include " ace / DLL . h " # include " ace / ACE . h " # include " ace / OS _ NS _ string . h " # include " ace / ARGV . h " # include < list > ACE_BEGIN_VERSIONED_NAMESPACE_DECL ACE_ALLOC_HOOK_DEFINE ( ACE_Stream_Node ) // ▁ Provide ▁ the ▁ class ▁ hierarchy ▁ that ▁ defines ▁ the ▁ parse ▁ tree ▁ of ▁ Service ENDCOM // ▁ Nodes . ENDCOM void ACE_Stream_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Stream _ Node : : dump " ) ; # endif /* ▁ ACE _ HAS _ DUMP ▁ */ } void ACE_Stream_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Stream _ Node : : apply " ) ; const ACE_Service_Type * sst = this -> node_ -> record ( config ) ; if ( sst == 0 ) const_cast < ACE_Static_Node * > ( this -> node_ ) -> apply ( config , yyerrno ) ; if ( yyerrno != 0 ) return ; sst = this -> node_ -> record ( config ) ; ACE_Stream_Type * st = dynamic_cast < ACE_Stream_Type * > ( const_cast < ACE_Service_Type_Impl * > ( sst -> type ( ) ) ) ; // ▁ The ▁ modules ▁ were ▁ linked ▁ as ▁ popped ▁ off ▁ the ▁ yacc ▁ stack , ▁ so ▁ they ' re ▁ in ENDCOM // ▁ reverse ▁ order ▁ from ▁ the ▁ way ▁ they ▁ should ▁ be ▁ pushed ▁ onto ▁ the ▁ stream . ENDCOM // ▁ So ▁ traverse ▁ mods _ ▁ and ▁ and ▁ reverse ▁ the ▁ list , ▁ then ▁ iterate ▁ over ▁ it ▁ to ▁ push ENDCOM // ▁ the ▁ modules ▁ in ▁ the ▁ stream ▁ in ▁ the ▁ correct ▁ order . ENDCOM std :: list < const ACE_Static_Node * > mod_list ; const ACE_Static_Node * module ; for ( module = dynamic_cast < const ACE_Static_Node * > ( this -> mods_ ) ; module != 0 ; module = dynamic_cast < ACE_Static_Node * > ( module -> link ( ) ) ) mod_list . push_front ( module ) ; std :: list < const ACE_Static_Node * > :: const_iterator iter ; for ( iter = mod_list . begin ( ) ; iter != mod_list . end ( ) ; ++ iter ) { module = * iter ; ACE_ARGV args ( module -> parameters ( ) ) ; const ACE_Service_Type * mst = module -> record ( config ) ; if ( mst == 0 ) const_cast < ACE_Static_Node * > ( module ) -> apply ( config , yyerrno ) ; if ( yyerrno != 0 ) { if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " dynamic ▁ initialization ▁ failed ▁ for ▁ Module ▁ % s \n " ) , module -> name ( ) ) ) ; } ++ yyerrno ; continue ; // ▁ Don ' t ▁ try ▁ anything ▁ else ▁ with ▁ this ▁ one ENDCOM } ACE_Module_Type const * const mt1 = static_cast < ACE_Module_Type const * > ( module -> record ( config ) -> type ( ) ) ; ACE_Module_Type * mt = const_cast < ACE_Module_Type * > ( mt1 ) ; if ( st -> push ( mt ) == - 1 ) { if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " dynamic ▁ initialization ▁ failed ▁ for ▁ Stream ▁ % s \n " ) , this -> node_ -> name ( ) ) ) ; } ++ yyerrno ; } } # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ( % P | % t ) ▁ Did ▁ stream ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> node_ -> name ( ) , yyerrno ) ) ; # endif /* ▁ ACE _ NLOGGING ▁ */ } ACE_ALLOC_HOOK_DEFINE ( ACE_Parse_Node ) void ACE_Parse_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Parse _ Node : : dump " ) ; # endif /* ▁ ACE _ HAS _ DUMP ▁ */ } const ACE_TCHAR * ACE_Parse_Node :: name ( void ) const { ACE_TRACE ( " ACE _ Parse _ Node : : name " ) ; return this -> name_ ; } ACE_Parse_Node * ACE_Parse_Node :: link ( void ) const { ACE_TRACE ( " ACE _ Parse _ Node : : link " ) ; return this -> next_ ; } void ACE_Parse_Node :: link ( ACE_Parse_Node * n ) { ACE_TRACE ( " ACE _ Parse _ Node : : link " ) ; // ▁ Find ▁ the ▁ last ▁ list ▁ entry ▁ ( if ▁ any ) ▁ . . . ENDCOM ACE_Parse_Node * t = this ; while ( t -> next_ != 0 ) t = t -> next_ ; // ▁ . . . ▁ and ▁ insert ▁ n ▁ there . ENDCOM t -> next_ = n ; } ACE_Stream_Node :: ACE_Stream_Node ( const ACE_Static_Node * str_ops , const ACE_Parse_Node * str_mods ) : ACE_Parse_Node ( ( str_ops == 0 ? ACE_TEXT ( " < unknown > " ) : str_ops -> name ( ) ) ) , node_ ( str_ops ) , mods_ ( str_mods ) { ACE_TRACE ( " ACE _ Stream _ Node : : ACE _ Stream _ Node " ) ; } ACE_Stream_Node :: ~ ACE_Stream_Node ( void ) { ACE_TRACE ( " ACE _ Stream _ Node : : ~ ACE _ Stream _ Node " ) ; ACE_Static_Node * n = const_cast < ACE_Static_Node * > ( this -> node_ ) ; delete n ; ACE_Parse_Node * m = const_cast < ACE_Parse_Node * > ( this -> mods_ ) ; delete m ; } ACE_Parse_Node :: ACE_Parse_Node ( void ) : name_ ( 0 ) , next_ ( 0 ) { ACE_TRACE ( " ACE _ Parse _ Node : : ACE _ Parse _ Node " ) ; } ACE_Parse_Node :: ACE_Parse_Node ( const ACE_TCHAR * nm ) : name_ ( ACE :: strnew ( nm ) ) , next_ ( 0 ) { ACE_TRACE ( " ACE _ Parse _ Node : : ACE _ Parse _ Node " ) ; } void ACE_Parse_Node :: print ( void ) const { ACE_TRACE ( " ACE _ Parse _ Node : : print " ) ; ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " svc ▁ = ▁ % s \n " ) , this -> name ( ) ) ) ; if ( this -> next_ ) this -> next_ -> print ( ) ; } ACE_Parse_Node :: ~ ACE_Parse_Node ( void ) { ACE_TRACE ( " ACE _ Parse _ Node : : ~ ACE _ Parse _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> name_ ) ; delete this -> next_ ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Suspend_Node ) void ACE_Suspend_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Suspend _ Node : : dump " ) ; # endif /* ▁ ACE _ HAS _ DUMP ▁ */ } ACE_Suspend_Node :: ACE_Suspend_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Suspend _ Node : : ACE _ Suspend _ Node " ) ; } ACE_Suspend_Node :: ~ ACE_Suspend_Node ( void ) { } ACE_ALLOC_HOOK_DEFINE ( ACE_Resume_Node ) void ACE_Resume_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Resume _ Node : : dump " ) ; # endif /* ▁ ACE _ HAS _ DUMP ▁ */ } ACE_Resume_Node :: ACE_Resume_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Resume _ Node : : ACE _ Resume _ Node " ) ; } ACE_Resume_Node :: ~ ACE_Resume_Node ( void ) { } void ACE_Suspend_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Suspend _ Node : : apply " ) ; if ( config -> suspend ( this -> name ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ suspend ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # endif /* ▁ ACE _ NLOGGING ▁ */ } void ACE_Resume_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Resume _ Node : : apply " ) ; if ( config -> resume ( this -> name ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ resume ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # endif /* ▁ ACE _ NLOGGING ▁ */ } ACE_ALLOC_HOOK_DEFINE ( ACE_Remove_Node ) void ACE_Remove_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Remove _ Node : : dump " ) ; # endif /* ▁ ACE _ HAS _ DUMP ▁ */ } ACE_Remove_Node :: ACE_Remove_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Remove _ Node : : ACE _ Remove _ Node " ) ; } ACE_Remove_Node :: ~ ACE_Remove_Node ( void ) { } void ACE_Remove_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Remove _ Node : : apply " ) ; if ( config -> remove ( this -> name ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Remove _ Node : : apply " ) ACE_TEXT ( " ▁ - ▁ did ▁ remove ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # endif /* ▁ ACE _ NLOGGING ▁ */ } ACE_Dynamic_Node :: ACE_Dynamic_Node ( ACE_Service_Type_Factory const * stf , ACE_TCHAR * parms ) : ACE_Static_Node ( stf -> name ( ) , parms ) , factory_ ( stf ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : ACE _ Dynamic _ Node " ) ; } void ACE_Dynamic_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : apply " ) ; if ( config -> initialize ( this -> factory_ . get ( ) , this -> parameters ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Dynamic _ Node : : apply " ) ACE_TEXT ( " ▁ - ▁ Did ▁ dynamic ▁ on ▁ % s ▁ ( yyerrno = % d ) \n " ) , this -> name ( ) , yyerrno ) ) ; # endif /* ▁ ACE _ NLOGGING ▁ */ } ACE_ALLOC_HOOK_DEFINE ( ACE_Dynamic_Node ) void ACE_Dynamic_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Dynamic _ Node : : dump " ) ; # endif /* ▁ ACE _ HAS _ DUMP ▁ */ } ACE_Dynamic_Node :: ~ ACE_Dynamic_Node ( void ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : ~ ACE _ Dynamic _ Node " ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Static_Node ) void ACE_Static_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Static _ Node : : dump " ) ; # endif /* ▁ ACE _ HAS _ DUMP ▁ */ } ACE_Static_Node :: ACE_Static_Node ( const ACE_TCHAR * nm , ACE_TCHAR * params ) : ACE_Parse_Node ( nm ) , parameters_ ( ACE :: strnew ( params ) ) { ACE_TRACE ( " ACE _ Static _ Node : : ACE _ Static _ Node " ) ; } const ACE_Service_Type * ACE_Static_Node :: record ( const ACE_Service_Gestalt * config ) const { ACE_TRACE ( " ACE _ Static _ Node : : record " ) ; ACE_Service_Type * sr = 0 ; if ( config -> find ( this -> name ( ) , ( const ACE_Service_Type * * ) & sr ) == - 1 ) return 0 ; return sr ; } ACE_TCHAR * ACE_Static_Node :: parameters ( void ) const { ACE_TRACE ( " ACE _ Static _ Node : : parameters " ) ; return this -> parameters_ ; } void ACE_Static_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Static _ Node : : apply " ) ; if ( config -> initialize ( this -> name ( ) , this -> parameters ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Static _ Node : : apply ▁ - " ) ACE_TEXT ( " ▁ Did ▁ static ▁ on ▁ % s ▁ ( yyerrno = % d ) \n " ) , this -> name ( ) , yyerrno ) ) ; # endif /* ▁ ACE _ NLOGGING ▁ */ } ACE_Static_Node :: ~ ACE_Static_Node ( void ) { ACE_TRACE ( " ACE _ Static _ Node : : ~ ACE _ Static _ Node " ) ; delete [ ] this -> parameters_ ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Location_Node ) void ACE_Location_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Location _ Node : : dump " ) ; # endif /* ▁ ACE _ HAS _ DUMP ▁ */ } ACE_Location_Node :: ACE_Location_Node ( void ) : pathname_ ( 0 ) , dll_ ( ) , symbol_ ( 0 ) { ACE_TRACE ( " ACE _ Location _ Node : : ACE _ Location _ Node " ) ; } ACE_Location_Node :: ~ ACE_Location_Node ( void ) { ACE_TRACE ( " ACE _ Location _ Node : : ~ ACE _ Location _ Node " ) ; } const ACE_DLL & ACE_Location_Node :: dll ( void ) { return this -> dll_ ; } const ACE_TCHAR * ACE_Location_Node :: pathname ( void ) const { ACE_TRACE ( " ACE _ Location _ Node : : pathname " ) ; return this -> pathname_ ; } void ACE_Location_Node :: pathname ( const ACE_TCHAR * p ) { ACE_TRACE ( " ACE _ Location _ Node : : pathname " ) ; this -> pathname_ = p ; } int ACE_Location_Node :: dispose ( void ) const { ACE_TRACE ( " ACE _ Location _ Node : : dispose " ) ; return this -> must_delete_ ; } int ACE_Location_Node :: open_dll ( int & yyerrno ) { ACE_TRACE ( " ACE _ Location _ Node : : open _ dll " ) ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ LN : : open _ dll ▁ - ▁ path = % s \n " ) , this -> pathname ( ) ) ) ; # endif /* ▁ ACE _ NLOGGING ▁ */ if ( - 1 == this -> dll_ . open ( this -> pathname ( ) ) ) { ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_TCHAR * errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ LN : : open _ dll ▁ - ▁ Failed ▁ to ▁ open ▁ % s : ▁ % s \n " ) , this -> pathname ( ) , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } # endif /* ▁ ACE _ NLOGGING ▁ */ return - 1 ; } return 0 ; } void ACE_Location_Node :: set_symbol ( void * s ) { ACE_TRACE ( " ACE _ Location _ Node : : set _ symbol " ) ; this -> symbol_ = s ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Object_Node ) void ACE_Object_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Object _ Node : : dump " ) ; # endif /* ▁ ACE _ HAS _ DUMP ▁ */ } ACE_Object_Node :: ACE_Object_Node ( const ACE_TCHAR * path , const ACE_TCHAR * obj_name ) : object_name_ ( ACE :: strnew ( obj_name ) ) { ACE_TRACE ( " ACE _ Object _ Node : : ACE _ Object _ Node " ) ; this -> pathname ( ACE :: strnew ( path ) ) ; this -> must_delete_ = 0 ; } void * ACE_Object_Node :: symbol ( ACE_Service_Gestalt * , int & yyerrno , ACE_Service_Object_Exterminator * ) { ACE_TRACE ( " ACE _ Object _ Node : : symbol " ) ; if ( this -> open_dll ( yyerrno ) == 0 ) { ACE_TCHAR * object_name = const_cast < ACE_TCHAR * > ( this -> object_name_ ) ; this -> symbol_ = this -> dll_ . symbol ( object_name ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_TCHAR * errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ DLL : : symbol ▁ - " ) ACE_TEXT ( " ▁ Failed ▁ for ▁ object ▁ % s : ▁ % s \n " ) , object_name , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } # endif /* ▁ ACE _ NLOGGING ▁ */ return 0 ; } return this -> symbol_ ; } return 0 ; } ACE_Object_Node :: ~ ACE_Object_Node ( void ) { ACE_TRACE ( " ACE _ Object _ Node : : ~ ACE _ Object _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> object_name_ ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Function_Node ) void ACE_Function_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Function _ Node : : dump " ) ; # endif /* ▁ ACE _ HAS _ DUMP ▁ */ } ACE_Function_Node :: ACE_Function_Node ( const ACE_TCHAR * path , const ACE_TCHAR * func_name ) : function_name_ ( make_func_name ( func_name ) ) { ACE_TRACE ( " ACE _ Function _ Node : : ACE _ Function _ Node " ) ; this -> pathname ( ACE :: strnew ( path ) ) ; this -> must_delete_ = 1 ; } ACE_TCHAR * ACE_Function_Node :: make_func_name ( ACE_TCHAR const * func_name ) { // ▁ Preprocessor ▁ symbols ▁ will ▁ not ▁ be ▁ expanded ▁ if ▁ they ▁ are ENDCOM // ▁ stringified . ▁ Force ▁ the ▁ preprocessor ▁ to ▁ expand ▁ them ▁ during ▁ the ENDCOM // ▁ argument ▁ prescan ▁ by ▁ calling ▁ a ▁ macro ▁ that ▁ itself ▁ calls ▁ another ENDCOM // ▁ that ▁ performs ▁ the ▁ actual ▁ stringification . ENDCOM # if defined ( ACE_HAS_VERSIONED_NAMESPACE ) && ACE_HAS_VERSIONED_NAMESPACE == 1 # define ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING_IMPL ( NAME ) # NAME # define ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING ( NAME ) ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING_IMPL ( NAME ) # define ACE_VERSIONED_NAMESPACE_NAME_STRING ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING ( ACE_VERSIONED_NAMESPACE_NAME ) // ▁ Check ▁ if ▁ function ▁ is ▁ using ▁ the ▁ ACE ▁ naming ▁ convention . ▁ If ▁ so , ENDCOM // ▁ it ▁ is ▁ likely ▁ that ▁ the ▁ ACE ▁ factory ▁ function ▁ macros ENDCOM // ▁ ( e . g . ▁ ACE _ FACTORY _ DECLARE ) ▁ were ▁ used ▁ to ▁ declare ▁ and ▁ define ▁ it , ▁ so ENDCOM // ▁ mangle ▁ the ▁ function ▁ name ▁ to ▁ include ▁ the ▁ ACE ▁ versioned ▁ namespace ENDCOM // ▁ name ▁ as ▁ is ▁ done ▁ in ▁ the ▁ ACE ▁ macros . ▁ Otherwise , ▁ leave ▁ the ▁ function ENDCOM // ▁ name ▁ as ▁ is . ENDCOM static ACE_TCHAR const make_prefix [ ] = ACE_TEXT ( " _ make _ " ) ; static size_t const make_prefix_len = sizeof ( make_prefix ) / sizeof ( make_prefix [ 0 ] ) - 1 ; if ( ACE_OS :: strncmp ( make_prefix , func_name , make_prefix_len ) == 0 ) { static ACE_TCHAR const versioned_namespace_name [ ] = ACE_TEXT ( ACE_VERSIONED_NAMESPACE_NAME_STRING ) ACE_TEXT ( " _ " ) ; // ▁ Null ▁ terminator ▁ included ▁ in ▁ versioned _ namespace _ name _ len ▁ since ENDCOM // ▁ it ▁ is ▁ static ▁ constant . ENDCOM static size_t const versioned_namespace_name_len = sizeof ( versioned_namespace_name ) / sizeof ( versioned_namespace_name [ 0 ] ) ; size_t const len = ACE_OS :: strlen ( func_name ) + versioned_namespace_name_len ; // ▁ + ▁ 1 ; ▁ // ▁ Null ▁ terminator . ENDCOM ACE_TCHAR * mangled_func_name ; ACE_NEW_RETURN ( mangled_func_name , ACE_TCHAR [ len ] , 0 ) ; ACE_Auto_Basic_Array_Ptr < ACE_TCHAR > safe ( mangled_func_name ) ; ACE_OS :: snprintf ( mangled_func_name , len , ACE_TEXT ( " % s % s % s " ) , make_prefix , versioned_namespace_name , func_name + make_prefix_len ) ; return safe . release ( ) ; } # endif /* ▁ ACE _ HAS _ VERSIONED _ NAMESPACE ▁ = = ▁ 1 ▁ */ return ACE :: strnew ( func_name ) ; } void * ACE_Function_Node :: symbol ( ACE_Service_Gestalt * , int & yyerrno , ACE_Service_Object_Exterminator * gobbler ) { typedef ACE_Service_Object * ( * ACE_Service_Factory_Ptr ) ( ACE_Service_Object_Exterminator * ) ; ACE_TRACE ( " ACE _ Function _ Node : : symbol " ) ; if ( this -> open_dll ( yyerrno ) == 0 ) { this -> symbol_ = 0 ; // ▁ Locate ▁ the ▁ factory ▁ function ▁ < function _ name > ▁ in ▁ the ▁ shared ENDCOM // ▁ object . ENDCOM ACE_TCHAR * const function_name = const_cast < ACE_TCHAR * > ( this -> function_name_ ) ; void * const func_p = this -> dll_ . symbol ( function_name ) ; if ( func_p == 0 ) { ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_TCHAR * const errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " DLL : : symbol ▁ failed ▁ for ▁ function ▁ % s : ▁ " ) ACE_TEXT ( " % s \n " ) , function_name , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } # endif /* ▁ ACE _ NLOGGING ▁ */ return 0 ; } # if defined ( ACE_OPENVMS ) && ( ! defined ( __INITIAL_POINTER_SIZE ) || ( __INITIAL_POINTER_SIZE < 64 ) ) int const temp_p = reinterpret_cast < int > ( func_p ) ; # else intptr_t const temp_p = reinterpret_cast < intptr_t > ( func_p ) ; # endif ACE_Service_Factory_Ptr func = reinterpret_cast < ACE_Service_Factory_Ptr > ( temp_p ) ; // ▁ Invoke ▁ the ▁ factory ▁ function ▁ and ▁ record ▁ it ' s ▁ return ▁ value . ENDCOM this -> symbol_ = ( * func ) ( gobbler ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " % p \n " ) , this -> function_name_ ) ) ; } return 0 ; } } return this -> symbol_ ; } ACE_Function_Node :: ~ ACE_Function_Node ( void ) { ACE_TRACE ( " ACE _ Function _ Node : : ~ ACE _ Function _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( function_name_ ) ; delete [ ] const_cast < ACE_TCHAR * > ( pathname_ ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Dummy_Node ) void ACE_Dummy_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Dummy _ Node : : dump " ) ; # endif /* ▁ ACE _ HAS _ DUMP ▁ */ } ACE_Dummy_Node :: ACE_Dummy_Node ( const ACE_Static_Node * static_node , const ACE_Parse_Node * str_mods ) : ACE_Parse_Node ( static_node -> name ( ) ) , node_ ( static_node ) , mods_ ( str_mods ) { ACE_TRACE ( " ACE _ Dummy _ Node : : ACE _ Dummy _ Node " ) ; } void ACE_Dummy_Node :: apply ( ACE_Service_Gestalt * , int & yyerrno ) { ACE_TRACE ( " ACE _ Dummy _ Node : : apply " ) ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ operations ▁ on ▁ stream ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # else ACE_UNUSED_ARG ( yyerrno ) ; # endif /* ▁ ACE _ NLOGGING ▁ */ } ACE_Dummy_Node :: ~ ACE_Dummy_Node ( void ) { ACE_TRACE ( " ACE _ Dummy _ Node : : ~ ACE _ Dummy _ Node " ) ; ACE_Static_Node * n = const_cast < ACE_Static_Node * > ( this -> node_ ) ; delete n ; ACE_Parse_Node * m = const_cast < ACE_Parse_Node * > ( this -> mods_ ) ; delete m ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Static_Function_Node ) void ACE_Static_Function_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Static _ Function _ Node : : dump " ) ; # endif /* ▁ ACE _ HAS _ DUMP ▁ */ } ACE_Static_Function_Node :: ACE_Static_Function_Node ( const ACE_TCHAR * func_name ) : function_name_ ( ACE :: strnew ( func_name ) ) { ACE_TRACE ( " ACE _ Static _ Function _ Node : : ACE _ Static _ Function _ Node " ) ; this -> must_delete_ = 1 ; } void * ACE_Static_Function_Node :: symbol ( ACE_Service_Gestalt * config , int & yyerrno , ACE_Service_Object_Exterminator * gobbler ) { ACE_TRACE ( " ACE _ Static _ Function _ Node : : symbol " ) ; this -> symbol_ = 0 ; // ▁ Locate ▁ the ▁ factory ▁ function ▁ < function _ name > ▁ in ▁ the ▁ statically ENDCOM // ▁ linked ▁ svcs . ENDCOM ACE_Static_Svc_Descriptor * ssd = 0 ; if ( config -> find_static_svc_descriptor ( this -> function_name_ , & ssd ) == - 1 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ( % P | % t ) ▁ No ▁ static ▁ service ▁ " ) ACE_TEXT ( " registered ▁ for ▁ function ▁ % s \n " ) , this -> function_name_ ) ) ; } return 0 ; } if ( ssd -> alloc_ == 0 ) { ++ yyerrno ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ( % P | % t ) ▁ No ▁ static ▁ service ▁ factory ▁ " ) ACE_TEXT ( " function ▁ registered ▁ for ▁ function ▁ % s \n " ) , this -> function_name_ ) ) ; } return 0 ; } } // ▁ Invoke ▁ the ▁ factory ▁ function ▁ and ▁ record ▁ it ' s ▁ return ▁ value . ENDCOM this -> symbol_ = ( * ssd -> alloc_ ) ( gobbler ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " % p \n " ) , this -> function_name_ ) ) ; } return 0 ; } return this -> symbol_ ; } ACE_Static_Function_Node :: ~ ACE_Static_Function_Node ( void ) { ACE_TRACE ( " ACE _ Static _ Function _ Node : : ~ ACE _ Static _ Function _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> function_name_ ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Service_Type_Factory ) ACE_Service_Type_Factory :: ACE_Service_Type_Factory ( ACE_TCHAR const * name , int type , ACE_Location_Node * location , int active ) : name_ ( name ) , type_ ( type ) , location_ ( location ) , is_active_ ( active ) { } ACE_Service_Type_Factory :: ~ ACE_Service_Type_Factory ( void ) { } ACE_Service_Type * ACE_Service_Type_Factory :: make_service_type ( ACE_Service_Gestalt * cfg ) const { ACE_TRACE ( " ACE _ Service _ Type _ Factory : : make _ service _ type " ) ; u_int const flags = ACE_Service_Type :: DELETE_THIS | ( this -> location_ -> dispose ( ) == 0 ? 0 : ACE_Service_Type :: DELETE_OBJ ) ; int yyerrno = 0 ; ACE_Service_Object_Exterminator gobbler = 0 ; void * sym = this -> location_ -> symbol ( cfg , yyerrno , & gobbler ) ; if ( sym != 0 ) { ACE_Service_Type_Impl * stp = ACE_Service_Config :: create_service_type_impl ( this -> name ( ) , this -> type_ , sym , flags , gobbler ) ; if ( stp == 0 ) ++ yyerrno ; ACE_Service_Type * tmp = 0 ; ACE_NEW_RETURN ( tmp , ACE_Service_Type ( this -> name ( ) , stp , this -> location_ -> dll ( ) , this -> is_active_ ) , 0 ) ; return tmp ; } # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Unable ▁ to ▁ create ▁ " ) ACE_TEXT ( " service ▁ object ▁ for ▁ % s \n " ) , this -> name ( ) ) ) ; } # endif ++ yyerrno ; return 0 ; } ACE_TCHAR const * ACE_Service_Type_Factory :: name ( void ) const { return name_ . c_str ( ) ; } ACE_END_VERSIONED_NAMESPACE_DECL # endif /* ▁ ACE _ USES _ CLASSIC _ SVC _ CONF ▁ = = ▁ 1 ▁ */ </DOCUMENT>
<DOCUMENT_ID="tjaffri/msiot-samples/tree/master/AllJoyn/Samples/ZWaveAdapter/open-zwave/cpp/src/command_classes/UserCode.cpp"> // TABSYMBOL UserCode . cpp ENDCOM // TABSYMBOL Implementation ▁ of ▁ the ▁ Z - Wave ▁ COMMAND _ CLASS _ USER _ CODE ENDCOM // TABSYMBOL Copyright ▁ ( c ) ▁ 2012 ▁ Greg ▁ Satz ▁ < satz @ iranger . com > ENDCOM // TABSYMBOL SOFTWARE ▁ NOTICE ▁ AND ▁ LICENSE ENDCOM // TABSYMBOL This ▁ file ▁ is ▁ part ▁ of ▁ OpenZWave . ENDCOM // TABSYMBOL OpenZWave ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM // TABSYMBOL it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ as ▁ published ENDCOM // TABSYMBOL by ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ENDCOM // TABSYMBOL or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM // TABSYMBOL OpenZWave ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM // TABSYMBOL but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM // TABSYMBOL MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM // TABSYMBOL GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM // TABSYMBOL You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ENDCOM // TABSYMBOL along ▁ with ▁ OpenZWave . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . ENDCOM # include " tinyxml . h " # include " command _ classes / CommandClasses . h " # include " command _ classes / UserCode . h " # include " Node . h " # include " Options . h " # include " platform / Log . h " # include " value _ classes / ValueByte . h " # include " value _ classes / ValueRaw . h " using namespace OpenZWave ; enum UserCodeCmd { UserCodeCmd_Set = 0x01 , UserCodeCmd_Get = 0x02 , UserCodeCmd_Report = 0x03 , UserNumberCmd_Get = 0x04 , UserNumberCmd_Report = 0x05 } ; enum { UserCodeIndex_Refresh = 254 , UserCodeIndex_Count = 255 } ; const uint8 UserCodeLength = 10 ; // ▁ < UserCode : : UserCode > ENDCOM // ▁ Constructor ENDCOM UserCode :: UserCode ( uint32 const _homeId , uint8 const _nodeId ) : CommandClass ( _homeId , _nodeId ) , m_queryAll ( false ) , m_currentCode ( 0 ) , m_userCodeCount ( 0 ) , m_refreshUserCodes ( false ) { SetStaticRequest ( StaticRequest_Values ) ; memset ( m_userCodesStatus , 0xff , sizeof ( m_userCodesStatus ) ) ; Options :: Get ( ) -> GetOptionAsBool ( " RefreshAllUserCodes " , & m_refreshUserCodes ) ; } // ▁ < UserCode : : ReadXML > ENDCOM // ▁ Class ▁ specific ▁ configuration ENDCOM void UserCode :: ReadXML ( TiXmlElement const * _ccElement ) { int32 intVal ; CommandClass :: ReadXML ( _ccElement ) ; if ( TIXML_SUCCESS == _ccElement -> QueryIntAttribute ( " codes " , & intVal ) ) { m_userCodeCount = intVal ; } } // ▁ < UserCode : : WriteXML > ENDCOM // ▁ Class ▁ specific ▁ configuration ENDCOM void UserCode :: WriteXML ( TiXmlElement * _ccElement ) { char str [ 32 ] ; CommandClass :: WriteXML ( _ccElement ) ; snprintf ( str , sizeof ( str ) , " % d " , m_userCodeCount ) ; _ccElement -> SetAttribute ( " codes " , str ) ; } // ▁ < UserCode : : RequestState > ENDCOM // ▁ Nothing ▁ to ▁ do ▁ for ▁ UserCode ENDCOM bool UserCode :: RequestState ( uint32 const _requestFlags , uint8 const _instance , Driver :: MsgQueue const _queue ) { bool requests = false ; if ( ( _requestFlags & RequestFlag_Static ) && HasStaticRequest ( StaticRequest_Values ) ) { requests |= RequestValue ( _requestFlags , UserCodeIndex_Count , _instance , _queue ) ; } if ( _requestFlags & RequestFlag_Session ) { if ( m_userCodeCount > 0 ) { m_queryAll = true ; m_currentCode = 1 ; requests |= RequestValue ( _requestFlags , m_currentCode , _instance , _queue ) ; } } return requests ; } // ▁ < UserCode : : RequestValue > ENDCOM // ▁ Nothing ▁ to ▁ do ▁ for ▁ UserCode ENDCOM bool UserCode :: RequestValue ( uint32 const _requestFlags , uint8 const _userCodeIdx , uint8 const _instance , Driver :: MsgQueue const _queue ) { if ( _instance != 1 ) { // ▁ This ▁ command ▁ class ▁ doesn ' t ▁ work ▁ with ▁ multiple ▁ instances ENDCOM return false ; } if ( ! IsGetSupported ( ) ) { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " UserNumberCmd _ Get ▁ Not ▁ Supported ▁ on ▁ this ▁ node " ) ; return false ; } if ( _userCodeIdx == UserCodeIndex_Count ) { // ▁ Get ▁ number ▁ of ▁ supported ▁ user ▁ codes . ENDCOM Msg * msg = new Msg ( " UserNumberCmd _ Get " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true , true , FUNC_ID_APPLICATION_COMMAND_HANDLER , GetCommandClassId ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 2 ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserNumberCmd_Get ) ; msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , _queue ) ; return true ; } if ( _userCodeIdx == 0 ) { Log :: Write ( LogLevel_Warning , GetNodeId ( ) , " UserCodeCmd _ Get ▁ with ▁ Index ▁ 0 ▁ not ▁ Supported " ) ; return false ; } Msg * msg = new Msg ( " UserCodeCmd _ Get " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true , true , FUNC_ID_APPLICATION_COMMAND_HANDLER , GetCommandClassId ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 3 ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserCodeCmd_Get ) ; msg -> Append ( _userCodeIdx ) ; msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , _queue ) ; return true ; } // ▁ < UserCode : : HandleMsg > ENDCOM // ▁ Handle ▁ a ▁ message ▁ from ▁ the ▁ Z - Wave ▁ network ENDCOM bool UserCode :: HandleMsg ( uint8 const * _data , uint32 const _length , uint32 const _instance ) { if ( UserNumberCmd_Report == ( UserCodeCmd ) _data [ 0 ] ) { m_userCodeCount = _data [ 1 ] ; if ( m_userCodeCount > 254 ) { // ▁ Make ▁ space ▁ for ▁ code ▁ count . ENDCOM m_userCodeCount = 254 ; } ClearStaticRequest ( StaticRequest_Values ) ; if ( m_userCodeCount == 0 ) { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Number ▁ report ▁ from ▁ node ▁ % d : ▁ Not ▁ supported " , GetNodeId ( ) ) ; } else { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Number ▁ report ▁ from ▁ node ▁ % d : ▁ Supported ▁ Codes ▁ % d ▁ ( % d ) " , GetNodeId ( ) , m_userCodeCount , _data [ 1 ] ) ; } if ( ValueByte * value = static_cast < ValueByte * > ( GetValue ( _instance , UserCodeIndex_Count ) ) ) { value -> OnValueRefreshed ( m_userCodeCount ) ; value -> Release ( ) ; } if ( Node * node = GetNodeUnsafe ( ) ) { uint8 data [ UserCodeLength ] ; memset ( data , 0 , UserCodeLength ) ; for ( uint8 i = 0 ; i <= m_userCodeCount ; i ++ ) { char str [ 16 ] ; if ( i == 0 ) { snprintf ( str , sizeof ( str ) , " Enrollment ▁ Code " ) ; node -> CreateValueRaw ( ValueID :: ValueGenre_User , GetCommandClassId ( ) , _instance , i , str , " " , true , false , data , UserCodeLength , 0 ) ; } else { snprintf ( str , sizeof ( str ) , " Code ▁ % d : " , i ) ; node -> CreateValueRaw ( ValueID :: ValueGenre_User , GetCommandClassId ( ) , _instance , i , str , " " , false , false , data , UserCodeLength , 0 ) ; } } } return true ; } else if ( UserCodeCmd_Report == ( UserCodeCmd ) _data [ 0 ] ) { int i = _data [ 1 ] ; if ( ValueRaw * value = static_cast < ValueRaw * > ( GetValue ( _instance , i ) ) ) { uint8 data [ UserCodeLength ] ; uint8 size = _length - 4 ; if ( size > UserCodeLength ) { Log :: Write ( LogLevel_Warning , GetNodeId ( ) , " User ▁ Code ▁ length ▁ % d ▁ is ▁ larger ▁ then ▁ maximum ▁ % d " , size , UserCodeLength ) ; size = UserCodeLength ; } m_userCodesStatus [ i ] = _data [ 2 ] ; memcpy ( data , & _data [ 3 ] , size ) ; value -> OnValueRefreshed ( data , size ) ; value -> Release ( ) ; } Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Code ▁ Report ▁ from ▁ node ▁ % d ▁ for ▁ User ▁ Code ▁ % d ▁ ( % s ) " , GetNodeId ( ) , i , CodeStatus ( _data [ 2 ] ) . c_str ( ) ) ; if ( m_queryAll && i == m_currentCode ) { if ( m_refreshUserCodes || ( _data [ 2 ] != UserCode_Available ) ) { if ( ++ i <= m_userCodeCount ) { m_currentCode = i ; RequestValue ( 0 , m_currentCode , _instance , Driver :: MsgQueue_Query ) ; } else { m_queryAll = false ; /* ▁ we ▁ might ▁ have ▁ reset ▁ this ▁ as ▁ part ▁ of ▁ the ▁ RefreshValues ▁ Button ▁ Value ▁ */ Options :: Get ( ) -> GetOptionAsBool ( " RefreshAllUserCodes " , & m_refreshUserCodes ) ; } } else { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Not ▁ Requesting ▁ additional ▁ UserCode ▁ Slots ▁ as ▁ RefreshAllUserCodes ▁ is ▁ false , ▁ and ▁ slot ▁ % d ▁ is ▁ available " , i ) ; m_queryAll = false ; } } return true ; } return false ; } // ▁ < UserCode : : SetValue > ENDCOM // ▁ Set ▁ a ▁ User ▁ Code ▁ value ENDCOM bool UserCode :: SetValue ( Value const & _value ) { if ( ( ValueID :: ValueType_Raw == _value . GetID ( ) . GetType ( ) ) && ( _value . GetID ( ) . GetIndex ( ) < UserCodeIndex_Refresh ) ) { ValueRaw const * value = static_cast < ValueRaw const * > ( & _value ) ; uint8 * s = value -> GetValue ( ) ; uint8 len = value -> GetLength ( ) ; if ( len > UserCodeLength ) { return false ; } m_userCodesStatus [ value -> GetID ( ) . GetIndex ( ) ] = UserCode_Occupied ; Msg * msg = new Msg ( " UserCodeCmd _ Set " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true ) ; msg -> SetInstance ( this , _value . GetID ( ) . GetInstance ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 4 + len ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserCodeCmd_Set ) ; msg -> Append ( value -> GetID ( ) . GetIndex ( ) ) ; msg -> Append ( UserCode_Occupied ) ; for ( uint8 i = 0 ; i < len ; i ++ ) { msg -> Append ( s [ i ] ) ; } msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , Driver :: MsgQueue_Send ) ; return true ; } if ( ( ValueID :: ValueType_Button == _value . GetID ( ) . GetType ( ) ) && ( _value . GetID ( ) . GetIndex ( ) == UserCodeIndex_Refresh ) ) { m_refreshUserCodes = true ; m_currentCode = 1 ; m_queryAll = true ; RequestValue ( 0 , m_currentCode , _value . GetID ( ) . GetInstance ( ) , Driver :: MsgQueue_Query ) ; return true ; } return false ; } // ▁ < UserCode : : CreateVars > ENDCOM // ▁ Create ▁ the ▁ values ▁ managed ▁ by ▁ this ▁ command ▁ class ENDCOM void UserCode :: CreateVars ( uint8 const _instance ) { if ( Node * node = GetNodeUnsafe ( ) ) { node -> CreateValueByte ( ValueID :: ValueGenre_System , GetCommandClassId ( ) , _instance , UserCodeIndex_Count , " Code ▁ Count " , " " , true , false , 0 , 0 ) ; node -> CreateValueButton ( ValueID :: ValueGenre_System , GetCommandClassId ( ) , _instance , UserCodeIndex_Refresh , " Refresh ▁ All ▁ UserCodes " , 0 ) ; } } </DOCUMENT>
<DOCUMENT_ID="fahhem/mbed-os/tree/master/targets/TARGET_NUVOTON/TARGET_M451/device/TOOLCHAIN_ARM_STD/sys.cpp"> /* ▁ mbed ▁ Microcontroller ▁ Library ▁ - ▁ stackheap STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2009-2011 ▁ ARM ▁ Limited . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Setup ▁ a ▁ fixed ▁ single ▁ stack / heap ▁ memory ▁ model , STRNEWLINE ▁ * ▁ between ▁ the ▁ top ▁ of ▁ the ▁ RW / ZI ▁ region ▁ and ▁ the ▁ stackpointer STRNEWLINE ▁ */ # ifdef __cplusplus extern " C " { # endif # include < rt_misc . h > # include < stdint . h > extern char Image$$ARM_LIB_STACK$$ZI$$Limit [ ] ; extern char Image$$ARM_LIB_HEAP$$Base [ ] ; extern char Image$$ARM_LIB_HEAP$$ZI$$Limit [ ] ; extern __value_in_regs struct __initial_stackheap __user_setup_stackheap ( uint32_t R0 , uint32_t R1 , uint32_t R2 , uint32_t R3 ) { struct __initial_stackheap r ; r . heap_base = ( uint32_t ) Image$$ARM_LIB_HEAP$$Base ; r . heap_limit = ( uint32_t ) Image$$ARM_LIB_HEAP$$ZI$$Limit ; return r ; } # ifdef __cplusplus } # endif </DOCUMENT>
<DOCUMENT_ID="dandan94/OpenGLTest/tree/master/finalOpenGL/HelloGLFW/lib/boost_1_59_0/libs/lexical_cast/test/lexical_cast_iterator_range_test.cpp"> // ▁ Unit ▁ test ▁ for ▁ boost : : lexical _ cast . ENDCOM // ▁ See ▁ http : // www . boost . org ▁ for ▁ most ▁ recent ▁ version , ▁ including ▁ documentation . ENDCOM // ▁ Copyright ▁ Antony ▁ Polukhin , ▁ 2012 . ENDCOM // ▁ Distributed ▁ under ▁ the ▁ Boost ENDCOM // ▁ Software ▁ License , ▁ Version ▁ 1.0 . ▁ ( See ▁ accompanying ▁ file ENDCOM // ▁ LICENSE _ 1_0 . txt ▁ or ▁ copy ▁ at ▁ http : // www . boost . org / LICENSE _ 1_0 . txt ) . ENDCOM # include < boost / config . hpp > # if defined ( __INTEL_COMPILER ) # pragma warning ( disable : 193 383 488 981 1418 1419 ) # elif defined ( BOOST_MSVC ) # pragma warning ( disable : 4097 4100 4121 4127 4146 4244 4245 4511 4512 4701 4800 ) # endif # include < boost / lexical_cast . hpp > # include < boost / test / unit_test . hpp > # include < boost / range / iterator_range . hpp > using namespace boost ; # if defined ( BOOST_NO_STRINGSTREAM ) || defined ( BOOST_NO_STD_WSTRING ) # define BOOST_LCAST_NO_WCHAR_T # endif # if ! defined ( BOOST_NO_CXX11_CHAR16_T ) && ! defined ( BOOST_NO_CXX11_UNICODE_LITERALS ) && ! defined ( _LIBCPP_VERSION ) # define BOOST_LC_RUNU16 # endif # if ! defined ( BOOST_NO_CXX11_CHAR32_T ) && ! defined ( BOOST_NO_CXX11_UNICODE_LITERALS ) && ! defined ( _LIBCPP_VERSION ) # define BOOST_LC_RUNU32 # endif struct class_with_user_defined_sream_operators { int i ; operator int ( ) const { return i ; } } ; template < class CharT > inline std :: basic_istream < CharT > & operator >> ( std :: basic_istream < CharT > & istr , class_with_user_defined_sream_operators & rhs ) { return istr >> rhs . i ; } template < class RngT > void do_test_iterator_range_impl ( const RngT & rng ) { BOOST_CHECK_EQUAL ( lexical_cast < int > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < int > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned int > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned int > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < short > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < short > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned short > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned short > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < long int > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < long int > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned long int > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned long int > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; # ifdef BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng . begin ( ) , rng . size ( ) ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng ) , 1.0 ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng . begin ( ) , rng . size ( ) ) , 1.0 ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng ) , 1.0L ) ; BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng . begin ( ) , rng . size ( ) ) , 1.0L ) ; # endif BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( rng ) , 1 ) ; # endif # if defined ( BOOST_HAS_LONG_LONG ) BOOST_CHECK_EQUAL ( lexical_cast < boost :: ulong_long_type > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: ulong_long_type > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: long_long_type > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: long_long_type > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; # elif defined ( BOOST_HAS_MS_INT64 ) BOOST_CHECK_EQUAL ( lexical_cast < unsigned __int64 > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned __int64 > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < __int64 > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < __int64 > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; # endif } template < class CharT > void test_it_range_using_any_chars ( CharT * one , CharT * eleven ) { typedef CharT test_char_type ; // ▁ Zero ▁ terminated ENDCOM iterator_range < test_char_type * > rng1 ( one , one + 1 ) ; do_test_iterator_range_impl ( rng1 ) ; iterator_range < const test_char_type * > crng1 ( one , one + 1 ) ; do_test_iterator_range_impl ( crng1 ) ; // ▁ Non ▁ zero ▁ terminated ENDCOM iterator_range < test_char_type * > rng2 ( eleven , eleven + 1 ) ; do_test_iterator_range_impl ( rng2 ) ; iterator_range < const test_char_type * > crng2 ( eleven , eleven + 1 ) ; do_test_iterator_range_impl ( crng2 ) ; } template < class CharT > void test_it_range_using_char ( CharT * one , CharT * eleven ) { typedef CharT test_char_type ; iterator_range < test_char_type * > rng1 ( one , one + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( rng1 ) , "1" ) ; iterator_range < const test_char_type * > crng1 ( one , one + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( crng1 ) , "1" ) ; iterator_range < test_char_type * > rng2 ( eleven , eleven + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( rng2 ) , "1" ) ; iterator_range < const test_char_type * > crng2 ( eleven , eleven + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( crng2 ) , "1" ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng1 ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng1 ) , 1.0 ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng1 ) , 1.0L ) ; # endif BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( rng1 ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( crng2 ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( crng2 ) , 1.0 ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS BOOST_CHECK_EQUAL ( lexical_cast < long double > ( crng2 ) , 1.0L ) ; # endif BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( crng2 ) , 1 ) ; # ifndef BOOST_LCAST_NO_WCHAR_T BOOST_CHECK ( lexical_cast < std :: wstring > ( rng1 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( crng1 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( rng2 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( crng2 ) == L " 1" ) ; # endif # if defined ( BOOST_LC_RUNU16 ) && defined ( BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES ) typedef std :: basic_string < char16_t > my_char16_string ; BOOST_CHECK ( lexical_cast < my_char16_string > ( rng1 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( crng1 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( rng2 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( crng2 ) == u " 1" ) ; # endif # if defined ( BOOST_LC_RUNU32 ) && defined ( BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES ) typedef std :: basic_string < char32_t > my_char32_string ; BOOST_CHECK ( lexical_cast < my_char32_string > ( rng1 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( crng1 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( rng2 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( crng2 ) == U " 1" ) ; # endif } void test_char_iterator_ranges ( ) { typedef char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; } void test_unsigned_char_iterator_ranges ( ) { typedef unsigned char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; } void test_signed_char_iterator_ranges ( ) { typedef signed char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; } void test_wchar_iterator_ranges ( ) { # ifndef BOOST_LCAST_NO_WCHAR_T typedef wchar_t test_char_type ; test_char_type data1 [ ] = L " 1" ; test_char_type data2 [ ] = L " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; # endif BOOST_CHECK ( true ) ; } void test_char16_iterator_ranges ( ) { # if defined ( BOOST_LC_RUNU16 ) typedef char16_t test_char_type ; test_char_type data1 [ ] = u " 1" ; test_char_type data2 [ ] = u " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; # endif BOOST_CHECK ( true ) ; } void test_char32_iterator_ranges ( ) { # if defined ( BOOST_LC_RUNU32 ) typedef char32_t test_char_type ; test_char_type data1 [ ] = U " 1" ; test_char_type data2 [ ] = U " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; # endif BOOST_CHECK ( true ) ; } unit_test :: test_suite * init_unit_test_suite ( int , char * [ ] ) { unit_test :: test_suite * suite = BOOST_TEST_SUITE ( " lexical _ cast . ▁ Testing ▁ conversions ▁ using ▁ iterator _ range < > " ) ; suite -> add ( BOOST_TEST_CASE ( & test_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_unsigned_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_signed_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_wchar_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_char16_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_char32_iterator_ranges ) ) ; return suite ; } </DOCUMENT>
<DOCUMENT_ID="BenKeyFSI/poedit/tree/master/deps/boost/libs/wave/test/testwave/testfiles/t_6_044.cpp"> /* = = = = = STRNEWLINE ▁ Boost . Wave : ▁ A ▁ Standard ▁ compliant ▁ C + + ▁ preprocessor ▁ library STRNEWLINE ▁ http : // www . boost . org / STRNEWLINE STRNEWLINE ▁ Copyright ▁ ( c ) ▁ 2001-2012 ▁ Hartmut ▁ Kaiser . ▁ Distributed ▁ under ▁ the ▁ Boost STRNEWLINE ▁ Software ▁ License , ▁ Version ▁ 1.0 . ▁ ( See ▁ accompanying ▁ file STRNEWLINE ▁ LICENSE _ 1_0 . txt ▁ or ▁ copy ▁ at ▁ http : // www . boost . org / LICENSE _ 1_0 . txt ) STRNEWLINE STRNEWLINE ▁ The ▁ tests ▁ included ▁ in ▁ this ▁ file ▁ were ▁ initially ▁ taken ▁ from ▁ the ▁ mcpp ▁ V2.5 STRNEWLINE ▁ preprocessor ▁ validation ▁ suite ▁ and ▁ were ▁ modified ▁ to ▁ fit ▁ into ▁ the ▁ Boost . Wave ▁ STRNEWLINE ▁ unit ▁ test ▁ requirements . STRNEWLINE ▁ The ▁ original ▁ files ▁ of ▁ the ▁ mcpp ▁ preprocessor ▁ are ▁ distributed ▁ under ▁ the ▁ STRNEWLINE ▁ license ▁ reproduced ▁ at ▁ the ▁ end ▁ of ▁ this ▁ file . STRNEWLINE = = = = = */ // ▁ Tests ▁ error ▁ reporting : ▁ The ▁ # # ▁ operator ▁ shall ▁ not ▁ occur ▁ at ▁ the ▁ beginning ▁ or ▁ at ▁ ENDCOM // ▁ the ▁ end ▁ of ▁ replacement ▁ list ▁ for ▁ either ▁ form ▁ of ▁ macro ▁ ENDCOM // ▁ definition . ENDCOM // ▁ 23.3 : ▁ In ▁ object - like ▁ macro ▁ ( left ) . ENDCOM # define CON ## name // E ▁ t _ 6_044 . cpp ( 24 ) : ▁ error : ▁ ill ▁ formed ▁ preprocessing ▁ operator : ▁ concat ▁ ( ' # # ' ) ENDCOM CON /* - STRNEWLINE ▁ * ▁ Copyright ▁ ( c ) ▁ 1998 , ▁ 2002-2005 ▁ Kiyoshi ▁ Matsui ▁ < kmatsui @ t3 . rim . or . jp > STRNEWLINE ▁ * ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without STRNEWLINE ▁ * ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions STRNEWLINE ▁ * ▁ are ▁ met : STRNEWLINE ▁ * ▁ 1 . ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . STRNEWLINE ▁ * ▁ 2 . ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in ▁ the STRNEWLINE ▁ * ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the ▁ distribution . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ THE ▁ AUTHOR ▁ ` ` AS ▁ IS ' ' ▁ AND STRNEWLINE ▁ * ▁ ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ THE STRNEWLINE ▁ * ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE STRNEWLINE ▁ * ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ▁ AUTHOR ▁ BE ▁ LIABLE STRNEWLINE ▁ * ▁ FOR ▁ ANY ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR ▁ CONSEQUENTIAL STRNEWLINE ▁ * ▁ DAMAGES ▁ ( INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS STRNEWLINE ▁ * ▁ OR ▁ SERVICES ; ▁ LOSS ▁ OF ▁ USE , ▁ DATA , ▁ OR ▁ PROFITS ; ▁ OR ▁ BUSINESS ▁ INTERRUPTION ) STRNEWLINE ▁ * ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY ▁ THEORY ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ CONTRACT , ▁ STRICT STRNEWLINE ▁ * ▁ LIABILITY , ▁ OR ▁ TORT ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) ▁ ARISING ▁ IN ▁ ANY ▁ WAY STRNEWLINE ▁ * ▁ OUT ▁ OF ▁ THE ▁ USE ▁ OF ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ OF STRNEWLINE ▁ * ▁ SUCH ▁ DAMAGE . STRNEWLINE ▁ */ </DOCUMENT>
<DOCUMENT_ID="NickelMedia/phantomjs/tree/master/src/qt/qtbase/config.tests/unix/evdev/evdev.cpp"> /* * * * * STRNEWLINE * * STRNEWLINE * * ▁ Copyright ▁ ( C ) ▁ 2014 ▁ Digia ▁ Plc ▁ and / or ▁ its ▁ subsidiary ( - ies ) . STRNEWLINE * * ▁ Contact : ▁ http : // www . qt - project . org / legal STRNEWLINE * * STRNEWLINE * * ▁ This ▁ file ▁ is ▁ part ▁ of ▁ the ▁ config . tests ▁ of ▁ the ▁ Qt ▁ Toolkit . STRNEWLINE * * STRNEWLINE * * ▁ $ QT _ BEGIN _ LICENSE : LGPL21 $ STRNEWLINE * * ▁ Commercial ▁ License ▁ Usage STRNEWLINE * * ▁ Licensees ▁ holding ▁ valid ▁ commercial ▁ Qt ▁ licenses ▁ may ▁ use ▁ this ▁ file ▁ in STRNEWLINE * * ▁ accordance ▁ with ▁ the ▁ commercial ▁ license ▁ agreement ▁ provided ▁ with ▁ the STRNEWLINE * * ▁ Software ▁ or , ▁ alternatively , ▁ in ▁ accordance ▁ with ▁ the ▁ terms ▁ contained ▁ in STRNEWLINE * * ▁ a ▁ written ▁ agreement ▁ between ▁ you ▁ and ▁ Digia . ▁ For ▁ licensing ▁ terms ▁ and STRNEWLINE * * ▁ conditions ▁ see ▁ http : // qt . digia . com / licensing . ▁ For ▁ further ▁ information STRNEWLINE * * ▁ use ▁ the ▁ contact ▁ form ▁ at ▁ http : // qt . digia . com / contact - us . STRNEWLINE * * STRNEWLINE * * ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ Usage STRNEWLINE * * ▁ Alternatively , ▁ this ▁ file ▁ may ▁ be ▁ used ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser STRNEWLINE * * ▁ General ▁ Public ▁ License ▁ version ▁ 2.1 ▁ or ▁ version ▁ 3 ▁ as ▁ published ▁ by ▁ the ▁ Free STRNEWLINE * * ▁ Software ▁ Foundation ▁ and ▁ appearing ▁ in ▁ the ▁ file ▁ LICENSE . LGPLv21 ▁ and STRNEWLINE * * ▁ LICENSE . LGPLv3 ▁ included ▁ in ▁ the ▁ packaging ▁ of ▁ this ▁ file . ▁ Please ▁ review ▁ the STRNEWLINE * * ▁ following ▁ information ▁ to ▁ ensure ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License STRNEWLINE * * ▁ requirements ▁ will ▁ be ▁ met : ▁ https : // www . gnu . org / licenses / lgpl . html ▁ and STRNEWLINE * * ▁ http : // www . gnu . org / licenses / old - licenses / lgpl - 2.1 . html . STRNEWLINE * * STRNEWLINE * * ▁ In ▁ addition , ▁ as ▁ a ▁ special ▁ exception , ▁ Digia ▁ gives ▁ you ▁ certain ▁ additional STRNEWLINE * * ▁ rights . ▁ These ▁ rights ▁ are ▁ described ▁ in ▁ the ▁ Digia ▁ Qt ▁ LGPL ▁ Exception STRNEWLINE * * ▁ version ▁ 1.1 , ▁ included ▁ in ▁ the ▁ file ▁ LGPL _ EXCEPTION . txt ▁ in ▁ this ▁ package . STRNEWLINE * * STRNEWLINE * * ▁ $ QT _ END _ LICENSE $ STRNEWLINE * * STRNEWLINE * * * * */ # include < linux / input . h > # include < linux / kd . h > enum { e1 = ABS_PRESSURE , e2 = ABS_X , e3 = REL_X , e4 = SYN_REPORT , } ; int main ( ) { :: input_event buf [ 32 ] ; ( void ) buf ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="keichan100yen/ode-ext/tree/master/boost/libs/config/test/no_std_allocator_fail.cpp"> // ▁ This ▁ file ▁ was ▁ automatically ▁ generated ▁ on ▁ Fri ▁ Dec ▁ 03 ▁ 18:04:02 ▁ 2004 ENDCOM // ▁ by ▁ libs / config / tools / generate . cpp ENDCOM // ▁ Copyright ▁ John ▁ Maddock ▁ 2002-4 . ENDCOM // ▁ Use , ▁ modification ▁ and ▁ distribution ▁ are ▁ subject ▁ to ▁ the ▁ ENDCOM // ▁ Boost ▁ Software ▁ License , ▁ Version ▁ 1.0 . ▁ ( See ▁ accompanying ▁ file ▁ ENDCOM // ▁ LICENSE _ 1_0 . txt ▁ or ▁ copy ▁ at ▁ http : // www . boost . org / LICENSE _ 1_0 . txt ) ENDCOM // ▁ See ▁ http : // www . boost . org / libs / config ▁ for ▁ the ▁ most ▁ recent ▁ version . ENDCOM // ▁ Test ▁ file ▁ for ▁ macro ▁ BOOST _ NO _ STD _ ALLOCATOR ENDCOM // ▁ This ▁ file ▁ should ▁ not ▁ compile , ▁ if ▁ it ▁ does ▁ then ENDCOM // ▁ BOOST _ NO _ STD _ ALLOCATOR ▁ should ▁ not ▁ be ▁ defined . ENDCOM // ▁ See ▁ file ▁ boost _ no _ std _ allocator . ipp ▁ for ▁ details ENDCOM // ▁ Must ▁ not ▁ have ▁ BOOST _ ASSERT _ CONFIG ▁ set ; ▁ it ▁ defeats ENDCOM // ▁ the ▁ objective ▁ of ▁ this ▁ file : ENDCOM # ifdef BOOST_ASSERT_CONFIG # undef BOOST_ASSERT_CONFIG # endif # include < boost / config . hpp > # include " test . hpp " # ifdef BOOST_NO_STD_ALLOCATOR # include " boost _ no _ std _ allocator . ipp " # else # error " this ▁ file ▁ should ▁ not ▁ compile " # endif int main ( int , char * [ ] ) { return boost_no_std_allocator :: test ( ) ; } </DOCUMENT>
<DOCUMENT_ID="LiquidShockGames/bongobucks/tree/master/src/qt/sendcoinsdialog.cpp"> # include " sendcoinsdialog . h " # include " ui _ sendcoinsdialog . h " # include " walletmodel . h " # include " bitcoinunits . h " # include " addressbookpage . h " # include " optionsmodel . h " # include " sendcoinsentry . h " # include " guiutil . h " # include " askpassphrasedialog . h " # include < QMessageBox > # include < QLocale > # include < QTextDocument > # include < QScrollBar > SendCoinsDialog :: SendCoinsDialog ( QWidget * parent ) : QDialog ( parent ) , ui ( new Ui :: SendCoinsDialog ) , model ( 0 ) { ui -> setupUi ( this ) ; # ifdef Q_WS_MAC // ▁ Icons ▁ on ▁ push ▁ buttons ▁ are ▁ very ▁ uncommon ▁ on ▁ Mac ENDCOM ui -> addButton -> setIcon ( QIcon ( ) ) ; ui -> clearButton -> setIcon ( QIcon ( ) ) ; ui -> sendButton -> setIcon ( QIcon ( ) ) ; # endif addEntry ( ) ; connect ( ui -> addButton , SIGNAL ( clicked ( ) ) , this , SLOT ( addEntry ( ) ) ) ; connect ( ui -> clearButton , SIGNAL ( clicked ( ) ) , this , SLOT ( clear ( ) ) ) ; fNewRecipientAllowed = true ; } void SendCoinsDialog :: setModel ( WalletModel * model ) { this -> model = model ; for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { entry -> setModel ( model ) ; } } if ( model && model -> getOptionsModel ( ) ) { setBalance ( model -> getBalance ( ) , model -> getUnconfirmedBalance ( ) , model -> getImmatureBalance ( ) ) ; connect ( model , SIGNAL ( balanceChanged ( qint64 , qint64 , qint64 ) ) , this , SLOT ( setBalance ( qint64 , qint64 , qint64 ) ) ) ; connect ( model -> getOptionsModel ( ) , SIGNAL ( displayUnitChanged ( int ) ) , this , SLOT ( updateDisplayUnit ( ) ) ) ; } } SendCoinsDialog :: ~ SendCoinsDialog ( ) { delete ui ; } void SendCoinsDialog :: on_sendButton_clicked ( ) { QList < SendCoinsRecipient > recipients ; bool valid = true ; if ( ! model ) return ; for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { if ( entry -> validate ( ) ) { recipients . append ( entry -> getValue ( ) ) ; } else { valid = false ; } } } if ( ! valid || recipients . isEmpty ( ) ) { return ; } // ▁ Format ▁ confirmation ▁ message ENDCOM QStringList formatted ; foreach ( const SendCoinsRecipient & rcp , recipients ) { formatted . append ( tr ( " < b > % 1 < / b > ▁ to ▁ % 2 ▁ ( %3 ) " ) . arg ( BitcoinUnits :: formatWithUnit ( BitcoinUnits :: BTC , rcp . amount ) , Qt :: escape ( rcp . label ) , rcp . address ) ) ; } fNewRecipientAllowed = false ; QMessageBox :: StandardButton retval = QMessageBox :: question ( this , tr ( " Confirm ▁ send ▁ coins " ) , tr ( " Are ▁ you ▁ sure ▁ you ▁ want ▁ to ▁ send ▁ % 1 ? " ) . arg ( formatted . join ( tr ( " ▁ and ▁ " ) ) ) , QMessageBox :: Yes | QMessageBox :: Cancel , QMessageBox :: Cancel ) ; if ( retval != QMessageBox :: Yes ) { fNewRecipientAllowed = true ; return ; } WalletModel :: UnlockContext ctx ( model -> requestUnlock ( ) ) ; if ( ! ctx . isValid ( ) ) { // ▁ Unlock ▁ wallet ▁ was ▁ cancelled ENDCOM fNewRecipientAllowed = true ; return ; } WalletModel :: SendCoinsReturn sendstatus = model -> sendCoins ( recipients ) ; switch ( sendstatus . status ) { case WalletModel :: InvalidAddress : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ recepient ▁ address ▁ is ▁ not ▁ valid , ▁ please ▁ recheck . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: InvalidAmount : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ amount ▁ to ▁ pay ▁ must ▁ be ▁ larger ▁ than ▁ 0 . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: AmountExceedsBalance : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ amount ▁ exceeds ▁ your ▁ balance . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: AmountWithFeeExceedsBalance : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ total ▁ exceeds ▁ your ▁ balance ▁ when ▁ the ▁ % 1 ▁ transaction ▁ fee ▁ is ▁ included . " ) . arg ( BitcoinUnits :: formatWithUnit ( BitcoinUnits :: BTC , sendstatus . fee ) ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: DuplicateAddress : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " Duplicate ▁ address ▁ found , ▁ can ▁ only ▁ send ▁ to ▁ each ▁ address ▁ once ▁ per ▁ send ▁ operation . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: TransactionCreationFailed : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " Error : ▁ Transaction ▁ creation ▁ failed . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: TransactionCommitFailed : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " Error : ▁ The ▁ transaction ▁ was ▁ rejected . ▁ This ▁ might ▁ happen ▁ if ▁ some ▁ of ▁ the ▁ coins ▁ in ▁ your ▁ wallet ▁ were ▁ already ▁ spent , ▁ such ▁ as ▁ if ▁ you ▁ used ▁ a ▁ copy ▁ of ▁ wallet . dat ▁ and ▁ coins ▁ were ▁ spent ▁ in ▁ the ▁ copy ▁ but ▁ not ▁ marked ▁ as ▁ spent ▁ here . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: Aborted : // ▁ User ▁ aborted , ▁ nothing ▁ to ▁ do ENDCOM break ; case WalletModel :: OK : accept ( ) ; break ; } fNewRecipientAllowed = true ; } void SendCoinsDialog :: clear ( ) { // ▁ Remove ▁ entries ▁ until ▁ only ▁ one ▁ left ENDCOM while ( ui -> entries -> count ( ) ) { delete ui -> entries -> takeAt ( 0 ) -> widget ( ) ; } addEntry ( ) ; updateRemoveEnabled ( ) ; ui -> sendButton -> setDefault ( true ) ; } void SendCoinsDialog :: reject ( ) { clear ( ) ; } void SendCoinsDialog :: accept ( ) { clear ( ) ; } SendCoinsEntry * SendCoinsDialog :: addEntry ( ) { SendCoinsEntry * entry = new SendCoinsEntry ( this ) ; entry -> setModel ( model ) ; ui -> entries -> addWidget ( entry ) ; connect ( entry , SIGNAL ( removeEntry ( SendCoinsEntry * ) ) , this , SLOT ( removeEntry ( SendCoinsEntry * ) ) ) ; updateRemoveEnabled ( ) ; // ▁ Focus ▁ the ▁ field , ▁ so ▁ that ▁ entry ▁ can ▁ start ▁ immediately ENDCOM entry -> clear ( ) ; entry -> setFocus ( ) ; ui -> scrollAreaWidgetContents -> resize ( ui -> scrollAreaWidgetContents -> sizeHint ( ) ) ; QCoreApplication :: instance ( ) -> processEvents ( ) ; QScrollBar * bar = ui -> scrollArea -> verticalScrollBar ( ) ; if ( bar ) bar -> setSliderPosition ( bar -> maximum ( ) ) ; return entry ; } void SendCoinsDialog :: updateRemoveEnabled ( ) { // ▁ Remove ▁ buttons ▁ are ▁ enabled ▁ as ▁ soon ▁ as ▁ there ▁ is ▁ more ▁ than ▁ one ▁ send - entry ENDCOM bool enabled = ( ui -> entries -> count ( ) > 1 ) ; for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { entry -> setRemoveEnabled ( enabled ) ; } } setupTabChain ( 0 ) ; } void SendCoinsDialog :: removeEntry ( SendCoinsEntry * entry ) { delete entry ; updateRemoveEnabled ( ) ; } QWidget * SendCoinsDialog :: setupTabChain ( QWidget * prev ) { for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { prev = entry -> setupTabChain ( prev ) ; } } QWidget :: setTabOrder ( prev , ui -> addButton ) ; QWidget :: setTabOrder ( ui -> addButton , ui -> sendButton ) ; return ui -> sendButton ; } void SendCoinsDialog :: pasteEntry ( const SendCoinsRecipient & rv ) { if ( ! fNewRecipientAllowed ) return ; SendCoinsEntry * entry = 0 ; // ▁ Replace ▁ the ▁ first ▁ entry ▁ if ▁ it ▁ is ▁ still ▁ unused ENDCOM if ( ui -> entries -> count ( ) == 1 ) { SendCoinsEntry * first = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( 0 ) -> widget ( ) ) ; if ( first -> isClear ( ) ) { entry = first ; } } if ( ! entry ) { entry = addEntry ( ) ; } entry -> setValue ( rv ) ; } bool SendCoinsDialog :: handleURI ( const QString & uri ) { SendCoinsRecipient rv ; // ▁ URI ▁ has ▁ to ▁ be ▁ valid ENDCOM if ( GUIUtil :: parseBitcoinURI ( uri , & rv ) ) { pasteEntry ( rv ) ; return true ; } return false ; } void SendCoinsDialog :: setBalance ( qint64 balance , qint64 unconfirmedBalance , qint64 immatureBalance ) { Q_UNUSED ( unconfirmedBalance ) ; Q_UNUSED ( immatureBalance ) ; if ( ! model || ! model -> getOptionsModel ( ) ) return ; int unit = model -> getOptionsModel ( ) -> getDisplayUnit ( ) ; ui -> labelBalance -> setText ( BitcoinUnits :: formatWithUnit ( unit , balance ) ) ; } void SendCoinsDialog :: updateDisplayUnit ( ) { if ( model && model -> getOptionsModel ( ) ) { // ▁ Update ▁ labelBalance ▁ with ▁ the ▁ current ▁ balance ▁ and ▁ the ▁ current ▁ unit ENDCOM ui -> labelBalance -> setText ( BitcoinUnits :: formatWithUnit ( model -> getOptionsModel ( ) -> getDisplayUnit ( ) , model -> getBalance ( ) ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="LEEluoman/MazeScrnSave/tree/master/MazeScrnSave/Maze.cpp"> # include " Maze . h " # include < set > # include < vector > # include < algorithm > using namespace std ; CMaze :: CMaze ( int nWidth , int nHeight , int nCellWidth , int nCellHeight , bool bCopyScreen ) { m_nCounter = 0 ; m_nWidth = nWidth ; m_nHeight = nHeight ; m_nCellWidth = nCellWidth ; m_nCellHeight = nCellHeight ; m_nCols = m_nWidth / m_nCellWidth - 1 ; m_nRows = m_nHeight / m_nCellHeight - 1 ; m_nOffsetX = ( m_nWidth - m_nCols * m_nCellWidth ) / 2 ; m_nOffsetY = ( m_nHeight - m_nRows * m_nCellHeight ) / 2 ; m_bReDrawBeforeGenerate = FALSE ; m_bAllowNonSolution = FALSE ; m_bFlashPath = TRUE ; // ▁ m _ nOffsetX ▁ = ▁ 2 ; ENDCOM // ▁ m _ nOffsetY ▁ = ▁ 2 ; ENDCOM HDC hScreenDc = GetDC ( NULL ) ; m_hWorkDc = CreateCompatibleDC ( NULL ) ; m_hWorkBmp = CreateCompatibleBitmap ( hScreenDc , m_nWidth , m_nHeight ) ; m_hOldBmp = SelectObject ( m_hWorkDc , ( HGDIOBJ ) m_hWorkBmp ) ; m_hOldPen = SelectObject ( m_hWorkDc , m_mazeColor . GetPen ( clWall ) ) ; if ( bCopyScreen ) { BitBlt ( m_hWorkDc , 0 , 0 , m_nWidth , m_nHeight , hScreenDc , 0 , 0 , SRCCOPY ) ; } ReleaseDC ( NULL , hScreenDc ) ; RECT rect = { 0 , 0 , m_nWidth , m_nHeight } ; FillRect ( m_hWorkDc , & rect , m_mazeColor . GetBrush ( clBackGround ) ) ; if ( m_nCols > 0 && m_nRows > 0 ) { m_cells = new CMazeCell [ m_nCols * m_nRows ] ; InitializeCells ( ) ; ResetAndReDrawAllCells ( ) ; m_state = MS_INITIALIZED ; } else { m_state = MS_ERROR ; m_cells = NULL ; } } CMaze :: ~ CMaze ( void ) { SelectObject ( m_hWorkDc , m_hOldPen ) ; SelectObject ( m_hWorkDc , m_hOldBmp ) ; DeleteDC ( m_hWorkDc ) ; DeleteObject ( m_hWorkBmp ) ; if ( m_cells != NULL ) { delete [ ] m_cells ; } } CMazeCell * CMaze :: GetCell ( int i , int j ) { if ( i < 0 || j < 0 || i >= m_nCols || j >= m_nRows ) { return NULL ; } return & m_cells [ j * m_nCols + i ] ; } void CMaze :: InitializeCells ( ) { for ( int i = 0 ; i < m_nCols ; ++ i ) { for ( int j = 0 ; j < m_nRows ; ++ j ) { CMazeCell * pCell = GetCell ( i , j ) ; pCell -> SetParent ( this , i , j ) ; } } } void CMaze :: ReDrawSides ( ) { int nPicWidth = m_nCols * m_nCellWidth ; int nPicHeight = m_nRows * m_nCellHeight ; MoveToEx ( m_hWorkDc , m_nOffsetX , m_nOffsetY , NULL ) ; LineTo ( m_hWorkDc , m_nOffsetX + nPicWidth , m_nOffsetY ) ; LineTo ( m_hWorkDc , m_nOffsetX + nPicWidth , m_nOffsetY + nPicHeight ) ; LineTo ( m_hWorkDc , m_nOffsetX , m_nOffsetY + nPicHeight ) ; LineTo ( m_hWorkDc , m_nOffsetX , m_nOffsetY ) ; } void CMaze :: ResetAllCells ( ) { for ( int i = 0 ; i < m_nCols ; ++ i ) { for ( int j = 0 ; j < m_nRows ; ++ j ) { CMazeCell * pCell = GetCell ( i , j ) ; pCell -> Reset ( ) ; } } } void CMaze :: ResetAndReDrawAllCells ( ) { for ( int i = 0 ; i < m_nCols ; ++ i ) { for ( int j = 0 ; j < m_nRows ; ++ j ) { CMazeCell * pCell = GetCell ( i , j ) ; pCell -> Reset ( ) ; pCell -> ReDraw ( ) ; } } ReDrawSides ( ) ; } void CMaze :: ReDrawAllCells ( ) { for ( int i = 0 ; i < m_nCols ; ++ i ) { for ( int j = 0 ; j < m_nRows ; ++ j ) { CMazeCell * pCell = GetCell ( i , j ) ; pCell -> ReDraw ( ) ; } } ReDrawSides ( ) ; } void CMaze :: Next ( BOOL bDelay ) { DWORD dwDelayValue = 0 ; switch ( m_state ) { case MS_INITIALIZED : m_cellGenerating = GetRandomCell ( ) ; m_cellStack . Init ( ) ; m_cellStack . Push ( m_cellGenerating ) ; m_cellGenerating -> m_bGenerated = true ; ChangeState ( MS_GENERATING ) ; break ; case MS_GENERATING : if ( m_cellStack . IsEmpty ( ) ) { ChangeState ( MS_GENERATED ) ; } else { bool bGetNewCell = false ; CMazeCell * pTopCell = m_cellStack . Top ( ) ; pTopCell -> ReDraw ( ) ; pTopCell -> GoGenerate ( & bGetNewCell ) ; if ( bGetNewCell ) { // dwDelayValue ▁ = ▁ 1 ; ENDCOM } } break ; case MS_GENERATED : // ▁ Ëæ » ú ´ òÂÒÒ » Ð © Ç½Ãæ ENDCOM if ( m_bAllowNonSolution && m_nRows * m_nCols >= 10 && m_nCols > 1 && m_nRows > 1 ) { int nRightWallsCount = ( m_nCols - 1 ) * m_nRows ; int nBottomWallsCount = ( m_nRows - 1 ) * m_nCols ; int nWallsCount = nRightWallsCount + nBottomWallsCount ; int nChangedWallsCount = nWallsCount * 2 / 100 ; set < int > setChangedWalls ; vector < int > vectorChangedWalls ; if ( nChangedWallsCount > 100 ) { // ▁ µ ÷ ÕûµÄÇ½Ãæ² » ÒË¹ý ¶ à £ ¬ · ñÔò × ÜÊÇÎÞ½â ENDCOM nChangedWallsCount = 100 ; } while ( ( int ) setChangedWalls . size ( ) < nChangedWallsCount ) { setChangedWalls . insert ( BigRand ( ) % nWallsCount ) ; } vectorChangedWalls . assign ( setChangedWalls . begin ( ) , setChangedWalls . end ( ) ) ; random_shuffle ( vectorChangedWalls . begin ( ) , vectorChangedWalls . end ( ) ) ; for ( int i = 0 ; i < nChangedWallsCount ; ++ i ) { int nOffset = vectorChangedWalls . at ( i ) ; if ( nOffset < nRightWallsCount ) { int nRow = nOffset / ( m_nCols - 1 ) ; int nCol = nOffset % ( m_nCols - 1 ) ; CMazeCell * pCell = GetCell ( nCol , nRow ) ; pCell -> SetWall ( DIR_RIGHT , ! pCell -> GetWall ( DIR_RIGHT ) ) ; } else { nOffset -= nRightWallsCount ; int nRow = nOffset / m_nCols ; int nCol = nOffset % m_nCols ; CMazeCell * pCell = GetCell ( nCol , nRow ) ; pCell -> SetWall ( DIR_BOTTOM , ! pCell -> GetWall ( DIR_BOTTOM ) ) ; } } } ReDrawAllCells ( ) ; ChangeState ( MS_SETTING ) ; break ; case MS_SETTING : if ( true ) { int nCounter = GetCounter ( ) ; if ( nCounter == 0 ) { if ( rand ( ) % 5 == 0 ) { int bx [ ] = { 0 , 0 , 1 , 1 } ; int by [ ] = { 0 , 1 , 0 , 1 } ; int ex [ ] = { 1 , 1 , 0 , 0 } ; int ey [ ] = { 1 , 0 , 1 , 0 } ; int offset = rand ( ) % 4 ; m_cellBegin = GetCell ( ( GetCols ( ) - 1 ) * bx [ offset ] , ( GetRows ( ) - 1 ) * by [ offset ] ) ; m_cellEnd = GetCell ( ( GetCols ( ) - 1 ) * ex [ offset ] , ( GetRows ( ) - 1 ) * ey [ offset ] ) ; } else { m_cellBegin = GetRandomCell ( ) ; do { m_cellEnd = GetRandomCell ( ) ; } while ( m_cellEnd == m_cellBegin ) ; } m_cellBegin -> m_bIsBegin = true ; m_cellEnd -> m_bIsEnd = true ; } else if ( nCounter < 19 ) { m_cellBegin -> m_bIsBegin = ! m_cellBegin -> m_bIsBegin ; m_cellBegin -> ReDraw ( ) ; dwDelayValue = 55 ; } else if ( nCounter < 37 ) { m_cellEnd -> m_bIsEnd = ! m_cellEnd -> m_bIsEnd ; m_cellEnd -> ReDraw ( ) ; dwDelayValue = 55 ; } else { ChangeState ( MS_SET ) ; } } break ; case MS_SET : m_cellStack . Init ( ) ; m_cellStack . Push ( m_cellBegin ) ; m_cellBegin -> m_bVisited = true ; ChangeState ( MS_RESOLVING ) ; break ; case MS_RESOLVING : if ( m_cellStack . IsEmpty ( ) ) { ChangeState ( MS_RESOLVEFAILED ) ; } else { bool bGetNewCell = false ; CMazeCell * pTopCell = m_cellStack . Top ( ) ; pTopCell -> ReDraw ( ) ; if ( pTopCell == m_cellEnd ) { ChangeState ( MS_RESOLVED ) ; break ; } pTopCell -> GoResolve ( & bGetNewCell ) ; if ( bGetNewCell ) { // dwDelayValue ▁ = ▁ 1 ; ENDCOM } } dwDelayValue = 10 ; break ; case MS_RESOLVED : { int nCounter = GetCounter ( ) ; if ( nCounter > 5 ) { if ( m_bReDrawBeforeGenerate ) { ResetAndReDrawAllCells ( ) ; } else { ResetAllCells ( ) ; } ChangeState ( MS_INITIALIZED ) ; } else { if ( m_bFlashPath ) { COLORREF cl = m_mazeColor . GetColor ( clVisited ) ; m_mazeColor . SetColor ( clVisited , GetReverseColor ( cl ) ) ; ReDrawAllCells ( ) ; } dwDelayValue = 500 ; } } break ; case MS_RESOLVEFAILED : dwDelayValue = 3000 ; if ( m_bReDrawBeforeGenerate ) { ResetAndReDrawAllCells ( ) ; } else { ResetAllCells ( ) ; } ChangeState ( MS_INITIALIZED ) ; case MS_PAUSED : break ; case MS_ERROR : break ; default : break ; } if ( bDelay && dwDelayValue > 0 ) { Sleep ( dwDelayValue ) ; } } HDC CMaze :: GetDc ( ) const { return m_hWorkDc ; } CMazeColor & CMaze :: GetColorManager ( ) { return m_mazeColor ; } MazeState CMaze :: GetState ( ) const { return m_state ; } CMazeCell * CMaze :: GetRandomCell ( ) { return GetCell ( rand ( ) % m_nCols , rand ( ) % m_nRows ) ; } void CMaze :: MakeRandomBeginAndEndCell ( ) { m_cellBegin = GetRandomCell ( ) ; m_cellEnd = GetRandomCell ( ) ; while ( m_cellEnd == m_cellBegin ) { m_cellEnd = GetRandomCell ( ) ; } } int CMaze :: GetWidth ( ) const { return m_nWidth ; } int CMaze :: GetHeight ( ) const { return m_nHeight ; } int CMaze :: GetCellWidth ( ) const { return m_nCellWidth ; } int CMaze :: GetCellHeight ( ) const { return m_nCellHeight ; } int CMaze :: GetRows ( ) const { return m_nRows ; } int CMaze :: GetCols ( ) const { return m_nCols ; } int CMaze :: GetOffsetX ( ) const { return m_nOffsetX ; } int CMaze :: GetOffsetY ( ) const { return m_nOffsetY ; } CMazeCellStack & CMaze :: GetCellStack ( ) { return m_cellStack ; } void CMaze :: ChangeState ( MazeState state ) { if ( m_state != state ) { m_state = state ; m_nCounter = 0 ; } } int CMaze :: GetCounter ( ) { return m_nCounter ++ ; } int CMaze :: BigRand ( ) { return ( ( ( rand ( ) % 0x100 ) << 0 ) | ( ( rand ( ) % 0x100 ) << 8 ) | ( ( rand ( ) % 0x100 ) << 16 ) | ( ( rand ( ) % 0x100 ) << 24 ) ) & ( ( unsigned ) - 1 >> 1 ) ; } COLORREF CMaze :: GetReverseColor ( COLORREF cl ) { return RGB ( ~ GetRValue ( cl ) , ~ GetGValue ( cl ) , ~ GetBValue ( cl ) ) ; } void CMaze :: SetReDrawBeforeGenerate ( BOOL bReDrawBeforeGenerate ) { m_bReDrawBeforeGenerate = bReDrawBeforeGenerate ; } void CMaze :: SetAllowNonSolution ( BOOL bAllowNonSolution ) { m_bAllowNonSolution = bAllowNonSolution ; } void CMaze :: SetFlashPath ( BOOL bFlashPath ) { m_bFlashPath = bFlashPath ; } void CMaze :: UpdateColors ( ) { SelectObject ( m_hWorkDc , m_mazeColor . GetPen ( clWall ) ) ; } void CMaze :: Restart ( ) { if ( m_bReDrawBeforeGenerate ) { ResetAndReDrawAllCells ( ) ; } else { ResetAllCells ( ) ; } ChangeState ( MS_INITIALIZED ) ; } </DOCUMENT>
<DOCUMENT_ID="Eagle-X/folly/tree/master/folly/test/IPAddressBenchmark.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ 2015 ▁ Facebook , ▁ Inc . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ # include < folly / IPAddress . h > # include < glog / logging . h > # include < folly / Benchmark . h > using namespace folly ; using std :: string ; BENCHMARK ( ipv4_to_string_inet_ntop , iters ) { folly :: IPAddressV4 ipv4Addr ( "127.0.0.1" ) ; in_addr ip = ipv4Addr . toAddr ( ) ; char outputString [ INET_ADDRSTRLEN ] = { 0 } ; while ( iters -- ) { const char * val = inet_ntop ( AF_INET , & ip , outputString , sizeof ( outputString ) ) ; } } BENCHMARK_RELATIVE ( ipv4_to_fully_qualified , iters ) { IPAddressV4 ip ( "127.0.0.1" ) ; while ( iters -- ) { string outputString = ip . toFullyQualified ( ) ; } } BENCHMARK_DRAW_LINE ( ) BENCHMARK ( ipv6_to_string_inet_ntop , iters ) { IPAddressV6 ipv6Addr ( " F1E0:0ACE : FB94:7ADF : 22E8:6DE6:9672:3725" ) ; in6_addr ip = ipv6Addr . toAddr ( ) ; char outputString [ INET6_ADDRSTRLEN ] = { 0 } ; bool checkResult = ( iters == 1 ) ; while ( iters -- ) { const char * val = inet_ntop ( AF_INET6 , & ip , outputString , sizeof ( outputString ) ) ; } } BENCHMARK_RELATIVE ( ipv6_to_fully_qualified , iters ) { IPAddressV6 ip ( " F1E0:0ACE : FB94:7ADF : 22E8:6DE6:9672:3725" ) ; string outputString ; while ( iters -- ) { outputString = ip . toFullyQualified ( ) ; } } // ▁ Benchmark ▁ results ▁ on ▁ Intel ▁ Xeon ▁ CPU ▁ E5-2660 ▁ @ ▁ 2.20GHz ENDCOM // ▁ folly / test / IPAddressBenchmark . cpp ▁ relative ▁ time / iter ▁ iters / s ENDCOM // ▁ ipv4 _ to _ string _ inet _ ntop ▁ 237.87ns ▁ 4.20M ENDCOM // ▁ ipv4 _ to _ fully _ qualified ▁ 362.31 % ▁ 65.65ns ▁ 15.23M ENDCOM // ▁ ipv6 _ to _ string _ inet _ ntop ▁ 768.60ns ▁ 1.30M ENDCOM // ▁ ipv6 _ to _ fully _ qualified ▁ 821.81 % ▁ 93.53ns ▁ 10.69M ENDCOM int main ( int argc , char * argv [ ] ) { gflags :: ParseCommandLineFlags ( & argc , & argv , true ) ; runBenchmarks ( ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="liuchuo/LeetCode-practice/tree/master/C++/079. Word Search.cpp"> 79. Word Search Given a 2D board and a word , find if the word exists in the grid . The word can be constructed from letters of sequentially adjacent cell , where " adjacent " cells are those horizontally or vertically neighboring . The same letter cell may not be used more than once . For example , Given board = [ [ ' A ' , ' B ' , ' C ' , ' E ' ] , [ ' S ' , ' F ' , ' C ' , ' S ' ] , [ ' A ' , ' D ' , ' E ' , ' E ' ] ] word = " ABCCED " , -> returns true , word = " SEE " , -> returns true , word = " ABCB " , -> returns false . 题目大意：给一个char型二维数组和一个word字符串，寻找网格中是否含有word字符串，只能通过相邻（垂直或者水平）的格子连接～ 分析：对于二维数组中的每一个点都开始遍历，如果当前点的字母正好等于word [ 0 ] 就进入dfs，设立flag标记是否找到，设立visit标记是否访问： 首先令起始节点visit [ j ] [ k ] 标记为已经访问过，接着dfs，如果flag为true直接return，如果当前index正好为word的最后一个字符下标就标记flag为true，return 。 从四个方向开始对结点进行深度优先搜索，首先要保证搜索的结点满足：1 . 是合法的在网格之内的 2 . 未被访问过 3 . 当前字符与要找的word [ index + 1 ] 相同 。 满足则标记visit [ tx ] [ ty ] = true , 且dfs tx和ty以及index + 1 ， 两个dfs后要把他重新置为false ～ 这样最后返回flag的值即为是否能找到的结果～ class Solution { private : bool flag = false ; vector < vector < bool >> visit ; vector < vector < char >> board ; string word = " " ; int dir [ 4 ] [ 2 ] = { { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } } ; int m , n ; public : bool exist ( vector < vector < char >> & board , string word ) { if ( board . size ( ) == 0 ) return word == " " ; m = board . size ( ) , n = board [ 0 ] . size ( ) ; this -> word = word ; this -> board = board ; visit . resize ( m , vector < bool > ( n ) ) ; for ( int j = 0 ; j < m ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( board [ j ] [ k ] == word [ 0 ] ) { visit [ j ] [ k ] = true ; dfs ( j , k , 0 ) ; visit [ j ] [ k ] = false ; } } } return flag ; } void dfs ( int x , int y , int index ) { if ( flag == true ) return ; if ( index == word . length ( ) - 1 ) { flag = true ; return ; } for ( int i = 0 ; i < 4 ; i ++ ) { int tx = x + dir [ i ] [ 0 ] , ty = y + dir [ i ] [ 1 ] ; if ( tx >= 0 && tx < m && ty >= 0 && ty < n && board [ tx ] [ ty ] == word [ index + 1 ] && visit [ tx ] [ ty ] == false ) { visit [ tx ] [ ty ] = true ; dfs ( tx , ty , index + 1 ) ; visit [ tx ] [ ty ] = false ; } } } } ; </DOCUMENT>
<DOCUMENT_ID="imAArtist/simIr/tree/master/Data/singleFile/code_721.cpp"> int candy ( vector < int > & ratings ) { int size = ratings . size ( ) ; if ( size <= 1 ) return size ; vector < int > num ( size , 1 ) ; for ( int i = 1 ; i < size ; i ++ ) { if ( ratings [ i ] > ratings [ i - 1 ] ) num [ i ] = num [ i - 1 ] + 1 ; } for ( int i = size - 1 ; i > 0 ; i -- ) { if ( ratings [ i - 1 ] > ratings [ i ] ) num [ i - 1 ] = max ( num [ i ] + 1 , num [ i - 1 ] ) ; } int result = 0 ; for ( int i = 0 ; i < size ; i ++ ) { result += num [ i ] ; // ▁ cout < < num [ i ] < < " ▁ " ; ENDCOM } return result ; } 1 , 3 , 3 , 3 , 21 , 2 , 1 , 2 , 1public int candy ( int [ ] ratings ) { int len = ratings . length ; int [ ] candy = new int [ len ] ; candy [ 0 ] = 1 ; for ( int i = 1 ; i < len ; ++ i ) { if ( ratings [ i ] > ratings [ i - 1 ] ) { candy [ i ] = candy [ i - 1 ] + 1 ; } else { candy [ i ] = 1 ; } } int total = candy [ len - 1 ] ; for ( int i = len - 2 ; i >= 0 ; -- i ) { if ( ratings [ i ] > ratings [ i + 1 ] && candy [ i ] <= candy [ i + 1 ] ) { candy [ i ] = candy [ i + 1 ] + 1 ; } total += candy [ i ] ; } return total ; } </DOCUMENT>
<DOCUMENT_ID="peak3d/inputstream.adaptive/tree/master/lib/libbento4/Core/Ap4.cpp"> /* * * * * STRNEWLINE | STRNEWLINE | ▁ AP4 ▁ - ▁ Main ▁ Header STRNEWLINE | STRNEWLINE | ▁ Copyright ▁ 2002-2008 ▁ Axiomatic ▁ Systems , ▁ LLC STRNEWLINE | STRNEWLINE | STRNEWLINE | ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Bento4 / AP4 ▁ ( MP4 ▁ Atom ▁ Processing ▁ Library ) . STRNEWLINE | STRNEWLINE | ▁ Unless ▁ you ▁ have ▁ obtained ▁ Bento4 ▁ under ▁ a ▁ difference ▁ license , STRNEWLINE | ▁ this ▁ version ▁ of ▁ Bento4 ▁ is ▁ Bento4 | GPL . STRNEWLINE | ▁ Bento4 | GPL ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE | ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE | ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 , ▁ or ▁ ( at ▁ your ▁ option ) STRNEWLINE | ▁ any ▁ later ▁ version . STRNEWLINE | STRNEWLINE | ▁ Bento4 | GPL ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE | ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE | ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE | ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE | STRNEWLINE | ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE | ▁ along ▁ with ▁ Bento4 | GPL ; ▁ see ▁ the ▁ file ▁ COPYING . ▁ If ▁ not , ▁ write ▁ to ▁ the STRNEWLINE | ▁ Free ▁ Software ▁ Foundation , ▁ 59 ▁ Temple ▁ Place ▁ - ▁ Suite ▁ 330 , ▁ Boston , ▁ MA STRNEWLINE | ▁ 02111-1307 , ▁ USA . STRNEWLINE | STRNEWLINE ▁ * * * * */ /* - - - - - STRNEWLINE | ▁ includes STRNEWLINE + - - - - - */ # include " Ap4 . h " /* - - - - - STRNEWLINE | ▁ AP4 : : AP4 STRNEWLINE + - - - - - */ // ▁ this ▁ constructor ▁ can ▁ be ▁ used ▁ to ▁ detect ▁ if ▁ the ▁ platform ' s ▁ loader ENDCOM // ▁ correctly ▁ constructs ▁ static ▁ C + + ▁ objects ENDCOM static AP4 AP4_LoaderCheck ; AP4 :: AP4 ( ) : m_ConstructedByLoader ( true ) { } /* - - - - - STRNEWLINE | ▁ AP4 : : Initialize STRNEWLINE + - - - - - */ AP4_Result AP4 :: Initialize ( ) { AP4_Result result = AP4_SUCCESS ; # if defined ( AP4_CONFIG_CONSTRUCT_STATICS_ON_INITIALIZE ) if ( ! AP4_DefaultAtomFactory :: Instance . m_Initialized ) { result = AP4_DefaultAtomFactory :: Instance . Initialize ( ) ; if ( AP4_FAILED ( result ) ) return result ; } if ( ! AP4_DefaultBlockCipherFactory :: Instance . m_Initialized ) { result = AP4_DefaultBlockCipherFactory :: Instance . Initialize ( ) ; if ( AP4_FAILED ( result ) ) return result ; } if ( ! AP4_MetaData :: Initialized ( ) ) { AP4_MetaData :: Initialize ( ) ; } # endif return result ; } /* - - - - - STRNEWLINE | ▁ AP4 _ Terminate STRNEWLINE + - - - - - */ AP4_Result AP4 :: Terminate ( ) { # if defined ( AP4_CONFIG_DESTRUCT_STATICS_ON_TERMINATE ) if ( ! AP4_LoaderCheck . m_ConstructedByLoader ) { if ( AP4_DefaultAtomFactory :: Instance . m_Initialized ) { AP4_DefaultAtomFactory :: Instance . ~ AP4_DefaultAtomFactory ( ) ; } if ( AP4_DefaultBlockCipherFactory :: Instance . m_Initialized ) { AP4_DefaultBlockCipherFactory :: Instance . ~ AP4_DefaultBlockCipherFactory ( ) ; } if ( AP4_MetaData :: Initialized ( ) ) { AP4_MetaData :: UnInitialize ( ) ; } } # endif return AP4_SUCCESS ; } </DOCUMENT>
<DOCUMENT_ID="babymannen/theforgottenserver-7.4/tree/master/src/items.cpp"> /* * STRNEWLINE ▁ * ▁ The ▁ Forgotten ▁ Server ▁ - ▁ a ▁ free ▁ and ▁ open - source ▁ MMORPG ▁ server ▁ emulator STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2016 ▁ Mark ▁ Samman ▁ < mark . samman @ gmail . com > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or STRNEWLINE ▁ * ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along STRNEWLINE ▁ * ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , STRNEWLINE ▁ * ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , ▁ Boston , ▁ MA ▁ 02110-1301 ▁ USA . STRNEWLINE ▁ */ # include " otpch . h " # include " items . h " # include " spells . h " # include " movement . h " # include " weapons . h " # include " pugicast . h " uint32_t Items :: dwMajorVersion = 0 ; uint32_t Items :: dwMinorVersion = 0 ; uint32_t Items :: dwBuildNumber = 0 ; extern MoveEvents * g_moveEvents ; extern Weapons * g_weapons ; ItemType :: ItemType ( ) : group ( ITEM_GROUP_NONE ) , type ( ITEM_TYPE_NONE ) , id ( 0 ) , clientId ( 0 ) , stackable ( false ) , isAnimation ( false ) , weight ( 0 ) , levelDoor ( 0 ) , decayTime ( 0 ) , wieldInfo ( 0 ) , minReqLevel ( 0 ) , minReqMagicLevel ( 0 ) , charges ( 0 ) , maxHitChance ( - 1 ) , decayTo ( - 1 ) , attack ( 0 ) , defense ( 0 ) , extraDefense ( 0 ) , armor ( 0 ) , rotateTo ( 0 ) , runeMagLevel ( 0 ) , runeLevel ( 0 ) , combatType ( COMBAT_NONE ) , transformToOnUse ( 0 ) , transformToFree ( 0 ) , destroyTo ( 0 ) , maxTextLen ( 0 ) , writeOnceItemId ( 0 ) , transformEquipTo ( 0 ) , transformDeEquipTo ( 0 ) , maxItems ( 8 ) , slotPosition ( SLOTP_HAND ) , speed ( 0 ) , wareId ( 0 ) , magicEffect ( CONST_ME_NONE ) , bedPartnerDir ( DIRECTION_NONE ) , weaponType ( WEAPON_NONE ) , ammoType ( AMMO_NONE ) , shootType ( CONST_ANI_NONE ) , corpseType ( RACE_NONE ) , fluidSource ( FLUID_NONE ) , floorChange ( 0 ) , alwaysOnTopOrder ( 0 ) , lightLevel ( 0 ) , lightColor ( 0 ) , shootRange ( 1 ) , hitChance ( 0 ) , forceUse ( false ) , hasHeight ( false ) , walkStack ( true ) , blockSolid ( false ) , blockPickupable ( false ) , blockProjectile ( false ) , blockPathFind ( false ) , allowPickupable ( false ) , showDuration ( false ) , showCharges ( false ) , showAttributes ( false ) , replaceable ( true ) , pickupable ( false ) , rotatable ( false ) , useable ( false ) , moveable ( false ) , alwaysOnTop ( false ) , canReadText ( false ) , canWriteText ( false ) , isVertical ( false ) , isHorizontal ( false ) , isHangable ( false ) , allowDistRead ( false ) , lookThrough ( false ) , stopTime ( false ) , showCount ( true ) { } Items :: Items ( ) { items . reserve ( 20000 ) ; } Items :: ~ Items ( ) { clear ( ) ; } void Items :: clear ( ) { items . clear ( ) ; } bool Items :: reload ( ) { clear ( ) ; loadFromOtb ( " data / items / items . otb " ) ; if ( ! loadFromXml ( ) ) { return false ; } g_moveEvents -> reload ( ) ; g_weapons -> reload ( ) ; g_weapons -> loadDefaults ( ) ; return true ; } FILELOADER_ERRORS Items :: loadFromOtb ( const std :: string & file ) { FileLoader f ; if ( ! f . openFile ( file . c_str ( ) , " OTBI " ) ) { return f . getError ( ) ; } uint32_t type ; NODE node = f . getChildNode ( NO_NODE , type ) ; PropStream props ; if ( f . getProps ( node , props ) ) { // 4 ▁ byte ▁ flags ENDCOM // attributes ENDCOM // 0x01 ▁ = ▁ version ▁ data ENDCOM uint32_t flags ; if ( ! props . read < uint32_t > ( flags ) ) { return ERROR_INVALID_FORMAT ; } uint8_t attr ; if ( ! props . read < uint8_t > ( attr ) ) { return ERROR_INVALID_FORMAT ; } if ( attr == ROOT_ATTR_VERSION ) { uint16_t datalen ; if ( ! props . read < uint16_t > ( datalen ) ) { return ERROR_INVALID_FORMAT ; } if ( datalen != sizeof ( VERSIONINFO ) ) { return ERROR_INVALID_FORMAT ; } VERSIONINFO vi ; if ( ! props . read ( vi ) ) { return ERROR_INVALID_FORMAT ; } Items :: dwMajorVersion = vi . dwMajorVersion ; // items ▁ otb ▁ format ▁ file ▁ version ENDCOM Items :: dwMinorVersion = vi . dwMinorVersion ; // client ▁ version ENDCOM Items :: dwBuildNumber = vi . dwBuildNumber ; // revision ENDCOM } } if ( Items :: dwMajorVersion == 0xFFFFFFFF ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromOtb ] ▁ items . otb ▁ using ▁ generic ▁ client ▁ version . " << std :: endl ; } else if ( Items :: dwMajorVersion > 2 ) { std :: cout << " New ▁ version ▁ detected , ▁ an ▁ older ▁ version ▁ of ▁ items . otb ▁ is ▁ required . " << std :: endl ; return ERROR_INVALID_FORMAT ; } else if ( Items :: dwMinorVersion < CLIENT_VERSION_740 ) { std :: cout << " A ▁ newer ▁ version ▁ of ▁ items . otb ▁ is ▁ required . " << std :: endl ; return ERROR_INVALID_FORMAT ; } node = f . getChildNode ( node , type ) ; while ( node != NO_NODE ) { PropStream stream ; if ( ! f . getProps ( node , stream ) ) { return f . getError ( ) ; } uint32_t flags ; if ( ! stream . read < uint32_t > ( flags ) ) { return ERROR_INVALID_FORMAT ; } uint16_t serverId = 0 ; uint16_t clientId = 0 ; uint16_t speed = 0 ; uint16_t wareId = 0 ; uint8_t lightLevel = 0 ; uint8_t lightColor = 0 ; uint8_t alwaysOnTopOrder = 0 ; uint8_t attrib ; while ( stream . read < uint8_t > ( attrib ) ) { uint16_t datalen ; if ( ! stream . read < uint16_t > ( datalen ) ) { return ERROR_INVALID_FORMAT ; } switch ( attrib ) { case ITEM_ATTR_SERVERID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( serverId ) ) { return ERROR_INVALID_FORMAT ; } if ( serverId > 20000 && serverId < 20100 ) { serverId -= 20000 ; } break ; } case ITEM_ATTR_CLIENTID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( clientId ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_SPEED : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( speed ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_LIGHT2 : { if ( datalen != sizeof ( lightBlock2 ) ) { return ERROR_INVALID_FORMAT ; } lightBlock2 lb2 ; if ( ! stream . read ( lb2 ) ) { return ERROR_INVALID_FORMAT ; } lightLevel = static_cast < uint8_t > ( lb2 . lightLevel ) ; lightColor = static_cast < uint8_t > ( lb2 . lightColor ) ; break ; } case ITEM_ATTR_TOPORDER : { if ( datalen != sizeof ( uint8_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint8_t > ( alwaysOnTopOrder ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_WAREID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( wareId ) ) { return ERROR_INVALID_FORMAT ; } break ; } default : { // skip ▁ unknown ▁ attributes ENDCOM if ( ! stream . skip ( datalen ) ) { return ERROR_INVALID_FORMAT ; } break ; } } } reverseItemMap . emplace ( clientId , serverId ) ; // ▁ store ▁ the ▁ found ▁ item ENDCOM if ( serverId >= items . size ( ) ) { items . resize ( serverId + 1 ) ; } ItemType & iType = items [ serverId ] ; iType . group = static_cast < itemgroup_t > ( type ) ; switch ( type ) { case ITEM_GROUP_CONTAINER : iType . type = ITEM_TYPE_CONTAINER ; break ; case ITEM_GROUP_DOOR : // not ▁ used ENDCOM iType . type = ITEM_TYPE_DOOR ; break ; case ITEM_GROUP_MAGICFIELD : // not ▁ used ENDCOM iType . type = ITEM_TYPE_MAGICFIELD ; break ; case ITEM_GROUP_TELEPORT : // not ▁ used ENDCOM iType . type = ITEM_TYPE_TELEPORT ; break ; case ITEM_GROUP_NONE : case ITEM_GROUP_GROUND : case ITEM_GROUP_SPLASH : case ITEM_GROUP_FLUID : case ITEM_GROUP_CHARGES : case ITEM_GROUP_DEPRECATED : break ; default : return ERROR_INVALID_FORMAT ; } iType . blockSolid = hasBitSet ( FLAG_BLOCK_SOLID , flags ) ; iType . blockProjectile = hasBitSet ( FLAG_BLOCK_PROJECTILE , flags ) ; iType . blockPathFind = hasBitSet ( FLAG_BLOCK_PATHFIND , flags ) ; iType . hasHeight = hasBitSet ( FLAG_HAS_HEIGHT , flags ) ; iType . useable = hasBitSet ( FLAG_USEABLE , flags ) ; iType . pickupable = hasBitSet ( FLAG_PICKUPABLE , flags ) ; iType . moveable = hasBitSet ( FLAG_MOVEABLE , flags ) ; iType . stackable = hasBitSet ( FLAG_STACKABLE , flags ) ; iType . alwaysOnTop = hasBitSet ( FLAG_ALWAYSONTOP , flags ) ; iType . isVertical = hasBitSet ( FLAG_VERTICAL , flags ) ; iType . isHorizontal = hasBitSet ( FLAG_HORIZONTAL , flags ) ; iType . isHangable = hasBitSet ( FLAG_HANGABLE , flags ) ; iType . allowDistRead = hasBitSet ( FLAG_ALLOWDISTREAD , flags ) ; iType . rotatable = hasBitSet ( FLAG_ROTATABLE , flags ) ; iType . canReadText = hasBitSet ( FLAG_READABLE , flags ) ; iType . lookThrough = hasBitSet ( FLAG_LOOKTHROUGH , flags ) ; // ▁ iType . walkStack ▁ = ▁ ! hasBitSet ( FLAG _ FULLTILE , ▁ flags ) ; ENDCOM iType . forceUse = hasBitSet ( FLAG_FORCEUSE , flags ) ; iType . id = serverId ; iType . clientId = clientId ; iType . speed = speed ; iType . lightLevel = lightLevel ; iType . lightColor = lightColor ; iType . wareId = wareId ; iType . alwaysOnTopOrder = alwaysOnTopOrder ; node = f . getNextNode ( node , type ) ; } items . shrink_to_fit ( ) ; return ERROR_NONE ; } bool Items :: loadFromXml ( ) { pugi :: xml_document doc ; pugi :: xml_parse_result result = doc . load_file ( " data / items / items . xml " ) ; if ( ! result ) { printXMLError ( " Error ▁ - ▁ Items : : loadFromXml " , " data / items / items . xml " , result ) ; return false ; } for ( auto itemNode : doc . child ( " items " ) . children ( ) ) { pugi :: xml_attribute idAttribute = itemNode . attribute ( " id " ) ; if ( idAttribute ) { parseItemNode ( itemNode , pugi :: cast < uint16_t > ( idAttribute . value ( ) ) ) ; continue ; } pugi :: xml_attribute fromIdAttribute = itemNode . attribute ( " fromid " ) ; if ( ! fromIdAttribute ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromXml ] ▁ No ▁ item ▁ id ▁ found " << std :: endl ; continue ; } pugi :: xml_attribute toIdAttribute = itemNode . attribute ( " toid " ) ; if ( ! toIdAttribute ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromXml ] ▁ fromid ▁ ( " << fromIdAttribute . value ( ) << " ) ▁ without ▁ toid " << std :: endl ; continue ; } uint16_t id = pugi :: cast < uint16_t > ( fromIdAttribute . value ( ) ) ; uint16_t toId = pugi :: cast < uint16_t > ( toIdAttribute . value ( ) ) ; while ( id <= toId ) { parseItemNode ( itemNode , id ++ ) ; } } return true ; } void Items :: parseItemNode ( const pugi :: xml_node & itemNode , uint16_t id ) { if ( id > 20000 && id < 20100 ) { id -= 20000 ; if ( id >= items . size ( ) ) { items . resize ( id + 1 ) ; } ItemType & iType = items [ id ] ; iType . id = id ; } ItemType & it = getItemType ( id ) ; if ( it . id == 0 ) { return ; } it . name = itemNode . attribute ( " name " ) . as_string ( ) ; pugi :: xml_attribute articleAttribute = itemNode . attribute ( " article " ) ; if ( articleAttribute ) { it . article = articleAttribute . as_string ( ) ; } pugi :: xml_attribute pluralAttribute = itemNode . attribute ( " plural " ) ; if ( pluralAttribute ) { it . pluralName = pluralAttribute . as_string ( ) ; } for ( auto attributeNode : itemNode . children ( ) ) { pugi :: xml_attribute keyAttribute = attributeNode . attribute ( " key " ) ; if ( ! keyAttribute ) { continue ; } pugi :: xml_attribute valueAttribute = attributeNode . attribute ( " value " ) ; if ( ! valueAttribute ) { continue ; } std :: string tmpStrValue = asLowerCaseString ( keyAttribute . as_string ( ) ) ; if ( tmpStrValue == " type " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " key " ) { it . type = ITEM_TYPE_KEY ; } else if ( tmpStrValue == " magicfield " ) { it . type = ITEM_TYPE_MAGICFIELD ; } else if ( tmpStrValue == " container " ) { it . group = ITEM_GROUP_CONTAINER ; it . type = ITEM_TYPE_CONTAINER ; } else if ( tmpStrValue == " depot " ) { it . type = ITEM_TYPE_DEPOT ; } else if ( tmpStrValue == " mailbox " ) { it . type = ITEM_TYPE_MAILBOX ; } else if ( tmpStrValue == " trashholder " ) { it . type = ITEM_TYPE_TRASHHOLDER ; } else if ( tmpStrValue == " teleport " ) { it . type = ITEM_TYPE_TELEPORT ; } else if ( tmpStrValue == " door " ) { it . type = ITEM_TYPE_DOOR ; } else if ( tmpStrValue == " bed " ) { it . type = ITEM_TYPE_BED ; } else if ( tmpStrValue == " rune " ) { it . type = ITEM_TYPE_RUNE ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ type : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " description " ) { it . description = valueAttribute . as_string ( ) ; } else if ( tmpStrValue == " runespellname " ) { it . runeSpellName = valueAttribute . as_string ( ) ; } else if ( tmpStrValue == " weight " ) { it . weight = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showcount " ) { it . showCount = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " armor " ) { it . armor = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " defense " ) { it . defense = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " extradef " ) { it . extraDefense = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " attack " ) { it . attack = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " rotateto " ) { it . rotateTo = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " moveable " || tmpStrValue == " movable " ) { it . moveable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " blockprojectile " ) { it . blockProjectile = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " allowpickupable " || tmpStrValue == " pickupable " ) { it . allowPickupable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " floorchange " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " down " ) { it . floorChange = TILESTATE_FLOORCHANGE_DOWN ; } else if ( tmpStrValue == " north " ) { it . floorChange = TILESTATE_FLOORCHANGE_NORTH ; } else if ( tmpStrValue == " south " ) { it . floorChange = TILESTATE_FLOORCHANGE_SOUTH ; } else if ( tmpStrValue == " southalt " ) { it . floorChange = TILESTATE_FLOORCHANGE_SOUTH_ALT ; } else if ( tmpStrValue == " west " ) { it . floorChange = TILESTATE_FLOORCHANGE_WEST ; } else if ( tmpStrValue == " east " ) { it . floorChange = TILESTATE_FLOORCHANGE_EAST ; } else if ( tmpStrValue == " eastalt " ) { it . floorChange = TILESTATE_FLOORCHANGE_EAST_ALT ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ floorChange : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " corpsetype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " venom " ) { it . corpseType = RACE_VENOM ; } else if ( tmpStrValue == " blood " ) { it . corpseType = RACE_BLOOD ; } else if ( tmpStrValue == " undead " ) { it . corpseType = RACE_UNDEAD ; } else if ( tmpStrValue == " fire " ) { it . corpseType = RACE_FIRE ; } else if ( tmpStrValue == " energy " ) { it . corpseType = RACE_ENERGY ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ corpseType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " containersize " ) { it . maxItems = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fluidsource " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " water " ) { it . fluidSource = FLUID_WATER ; } else if ( tmpStrValue == " blood " ) { it . fluidSource = FLUID_BLOOD ; } else if ( tmpStrValue == " beer " ) { it . fluidSource = FLUID_BEER ; } else if ( tmpStrValue == " slime " ) { it . fluidSource = FLUID_SLIME ; } else if ( tmpStrValue == " lemonade " ) { it . fluidSource = FLUID_LEMONADE ; } else if ( tmpStrValue == " milk " ) { it . fluidSource = FLUID_MILK ; } else if ( tmpStrValue == " mana " ) { it . fluidSource = FLUID_MANA ; } else if ( tmpStrValue == " life " ) { it . fluidSource = FLUID_LIFE ; } else if ( tmpStrValue == " oil " ) { it . fluidSource = FLUID_OIL ; } else if ( tmpStrValue == " urine " ) { it . fluidSource = FLUID_URINE ; } else if ( tmpStrValue == " coconut " ) { it . fluidSource = FLUID_COCONUTMILK ; } else if ( tmpStrValue == " wine " ) { it . fluidSource = FLUID_WINE ; } else if ( tmpStrValue == " mud " ) { it . fluidSource = FLUID_MUD ; } else if ( tmpStrValue == " fruitjuice " ) { it . fluidSource = FLUID_FRUITJUICE ; } else if ( tmpStrValue == " lava " ) { it . fluidSource = FLUID_LAVA ; } else if ( tmpStrValue == " rum " ) { it . fluidSource = FLUID_RUM ; } else if ( tmpStrValue == " swamp " ) { it . fluidSource = FLUID_SWAMP ; } else if ( tmpStrValue == " tea " ) { it . fluidSource = FLUID_TEA ; } else if ( tmpStrValue == " mead " ) { it . fluidSource = FLUID_MEAD ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ fluidSource : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " readable " ) { it . canReadText = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " writeable " ) { it . canWriteText = valueAttribute . as_bool ( ) ; it . canReadText = it . canWriteText ; } else if ( tmpStrValue == " maxtextlen " ) { it . maxTextLen = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " writeonceitemid " ) { it . writeOnceItemId = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " weapontype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " sword " ) { it . weaponType = WEAPON_SWORD ; } else if ( tmpStrValue == " club " ) { it . weaponType = WEAPON_CLUB ; } else if ( tmpStrValue == " axe " ) { it . weaponType = WEAPON_AXE ; } else if ( tmpStrValue == " shield " ) { it . weaponType = WEAPON_SHIELD ; } else if ( tmpStrValue == " distance " ) { it . weaponType = WEAPON_DISTANCE ; } else if ( tmpStrValue == " wand " ) { it . weaponType = WEAPON_WAND ; } else if ( tmpStrValue == " ammunition " ) { it . weaponType = WEAPON_AMMO ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ weaponType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " slottype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " head " ) { it . slotPosition |= SLOTP_HEAD ; } else if ( tmpStrValue == " body " ) { it . slotPosition |= SLOTP_ARMOR ; } else if ( tmpStrValue == " legs " ) { it . slotPosition |= SLOTP_LEGS ; } else if ( tmpStrValue == " feet " ) { it . slotPosition |= SLOTP_FEET ; } else if ( tmpStrValue == " backpack " ) { it . slotPosition |= SLOTP_BACKPACK ; } else if ( tmpStrValue == " two - handed " ) { it . slotPosition |= SLOTP_TWO_HAND ; } else if ( tmpStrValue == " right - hand " ) { it . slotPosition &= ~ SLOTP_LEFT ; } else if ( tmpStrValue == " left - hand " ) { it . slotPosition &= ~ SLOTP_RIGHT ; } else if ( tmpStrValue == " necklace " ) { it . slotPosition |= SLOTP_NECKLACE ; } else if ( tmpStrValue == " ring " ) { it . slotPosition |= SLOTP_RING ; } else if ( tmpStrValue == " ammo " ) { it . slotPosition |= SLOTP_AMMO ; } else if ( tmpStrValue == " hand " ) { it . slotPosition |= SLOTP_HAND ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ slotType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " ammotype " ) { it . ammoType = getAmmoType ( valueAttribute . as_string ( ) ) ; if ( it . ammoType == AMMO_NONE ) { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ ammoType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " shoottype " ) { ShootType_t shoot = getShootType ( valueAttribute . as_string ( ) ) ; if ( shoot != CONST_ANI_NONE ) { it . shootType = shoot ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ shootType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " effect " ) { MagicEffectClasses effect = getMagicEffect ( valueAttribute . as_string ( ) ) ; if ( effect != CONST_ME_NONE ) { it . magicEffect = effect ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ effect : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " range " ) { it . shootRange = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " stopduration " ) { it . stopTime = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " decayto " ) { it . decayTo = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " transformequipto " ) { it . transformEquipTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " transformdeequipto " ) { it . transformDeEquipTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " duration " ) { it . decayTime = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showduration " ) { it . showDuration = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " charges " ) { it . charges = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showcharges " ) { it . showCharges = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " showattributes " ) { it . showAttributes = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " hitchance " ) { it . hitChance = std :: min < int8_t > ( 100 , std :: max < int8_t > ( - 100 , pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ) ) ; } else if ( tmpStrValue == " maxhitchance " ) { it . maxHitChance = std :: min < uint32_t > ( 100 , pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " invisible " ) { it . getAbilities ( ) . invisible = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " speed " ) { it . getAbilities ( ) . speed = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " healthgain " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . healthGain = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " healthticks " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . healthTicks = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " managain " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . manaGain = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manaticks " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . manaTicks = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manashield " ) { it . getAbilities ( ) . manaShield = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " skillsword " ) { it . getAbilities ( ) . skills [ SKILL_SWORD ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillaxe " ) { it . getAbilities ( ) . skills [ SKILL_AXE ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillclub " ) { it . getAbilities ( ) . skills [ SKILL_CLUB ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skilldist " ) { it . getAbilities ( ) . skills [ SKILL_DISTANCE ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillfish " ) { it . getAbilities ( ) . skills [ SKILL_FISHING ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillshield " ) { it . getAbilities ( ) . skills [ SKILL_SHIELD ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillfist " ) { it . getAbilities ( ) . skills [ SKILL_FIST ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxhitpoints " ) { it . getAbilities ( ) . stats [ STAT_MAXHITPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxhitpointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAXHITPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxmanapoints " ) { it . getAbilities ( ) . stats [ STAT_MAXMANAPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxmanapointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAXMANAPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " magicpoints " || tmpStrValue == " magiclevelpoints " ) { it . getAbilities ( ) . stats [ STAT_MAGICPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " magicpointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAGICPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentenergy " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentfire " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentpoison " || tmpStrValue == " fieldabsorpercentearth " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentall " || tmpStrValue == " absorbpercentallelements " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; for ( size_t i = 0 ; i < COMBAT_COUNT ; ++ i ) { abilities . absorbPercent [ i ] += value ; } } else if ( tmpStrValue == " absorbpercentelements " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += value ; } else if ( tmpStrValue == " absorbpercentmagic " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += value ; } else if ( tmpStrValue == " absorbpercentenergy " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentfire " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentpoison " || tmpStrValue == " absorbpercentearth " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentlifedrain " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_LIFEDRAIN ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentmanadrain " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_MANADRAIN ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentphysical " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_PHYSICALDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercenthealing " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_HEALING ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentundefined " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_UNDEFINEDDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " suppressdrunk " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_DRUNK ; } } else if ( tmpStrValue == " suppressenergy " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_ENERGY ; } } else if ( tmpStrValue == " suppressfire " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_FIRE ; } } else if ( tmpStrValue == " suppresspoison " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_POISON ; } } else if ( tmpStrValue == " suppressphysical " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_BLEEDING ; } } else if ( tmpStrValue == " field " ) { it . group = ITEM_GROUP_MAGICFIELD ; it . type = ITEM_TYPE_MAGICFIELD ; CombatType_t combatType = COMBAT_NONE ; ConditionDamage * conditionDamage = nullptr ; tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " fire " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_FIRE ) ; combatType = COMBAT_FIREDAMAGE ; } else if ( tmpStrValue == " energy " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_ENERGY ) ; combatType = COMBAT_ENERGYDAMAGE ; } else if ( tmpStrValue == " poison " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_POISON ) ; combatType = COMBAT_EARTHDAMAGE ; } else if ( tmpStrValue == " physical " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_BLEEDING ) ; combatType = COMBAT_PHYSICALDAMAGE ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ field ▁ value : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } if ( combatType != COMBAT_NONE ) { it . combatType = combatType ; it . conditionDamage . reset ( conditionDamage ) ; uint32_t ticks = 0 ; int32_t damage = 0 ; int32_t start = 0 ; int32_t count = 1 ; for ( auto subAttributeNode : attributeNode . children ( ) ) { pugi :: xml_attribute subKeyAttribute = subAttributeNode . attribute ( " key " ) ; if ( ! subKeyAttribute ) { continue ; } pugi :: xml_attribute subValueAttribute = subAttributeNode . attribute ( " value " ) ; if ( ! subValueAttribute ) { continue ; } tmpStrValue = asLowerCaseString ( subKeyAttribute . as_string ( ) ) ; if ( tmpStrValue == " ticks " ) { ticks = pugi :: cast < uint32_t > ( subValueAttribute . value ( ) ) ; } else if ( tmpStrValue == " count " ) { count = std :: max < int32_t > ( 1 , pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " start " ) { start = std :: max < int32_t > ( 0 , pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " damage " ) { damage = - pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ; if ( start > 0 ) { std :: list < int32_t > damageList ; ConditionDamage :: generateDamageList ( damage , start , damageList ) ; for ( int32_t damageValue : damageList ) { conditionDamage -> addDamage ( 1 , ticks , - damageValue ) ; } start = 0 ; } else { conditionDamage -> addDamage ( count , ticks , damage ) ; } } } conditionDamage -> setParam ( CONDITION_PARAM_FIELD , 1 ) ; if ( conditionDamage -> getTotalDamage ( ) > 0 ) { conditionDamage -> setParam ( CONDITION_PARAM_FORCEUPDATE , 1 ) ; } } } else if ( tmpStrValue == " replaceable " ) { it . replaceable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " partnerdirection " ) { it . bedPartnerDir = getDirection ( valueAttribute . as_string ( ) ) ; } else if ( tmpStrValue == " leveldoor " ) { it . levelDoor = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " sleeper " ) { uint16_t value = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; it . transformToOnUse = value ; ItemType & other = getItemType ( value ) ; if ( other . transformToFree == 0 ) { other . transformToFree = it . id ; } if ( it . transformToOnUse == 0 ) { it . transformToOnUse = value ; } } else if ( tmpStrValue == " transformto " ) { it . transformToFree = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " destroyto " ) { it . destroyTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " elementearth " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_EARTHDAMAGE ; } else if ( tmpStrValue == " elementfire " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_FIREDAMAGE ; } else if ( tmpStrValue == " elementenergy " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_ENERGYDAMAGE ; } else if ( tmpStrValue == " walkstack " ) { it . walkStack = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " blocking " ) { it . blockSolid = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " allowdistread " ) { it . allowDistRead = booleanString ( valueAttribute . as_string ( ) ) ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ key ▁ value : ▁ " << keyAttribute . as_string ( ) << std :: endl ; } } // check ▁ bed ▁ items ENDCOM if ( ( it . transformToFree != 0 || it . transformToOnUse != 0 || it . transformToOnUse != 0 ) && it . type != ITEM_TYPE_BED ) { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Item ▁ " << it . id << " ▁ is ▁ not ▁ set ▁ as ▁ a ▁ bed - type " << std :: endl ; } } ItemType & Items :: getItemType ( size_t id ) { if ( id < items . size ( ) ) { return items [ id ] ; } return items . front ( ) ; } const ItemType & Items :: getItemType ( size_t id ) const { if ( id < items . size ( ) ) { return items [ id ] ; } return items . front ( ) ; } const ItemType & Items :: getItemIdByClientId ( uint16_t spriteId ) const { auto it = reverseItemMap . find ( spriteId ) ; if ( it != reverseItemMap . end ( ) ) { return getItemType ( it -> second ) ; } return items . front ( ) ; } uint16_t Items :: getItemIdByName ( const std :: string & name ) { if ( name . empty ( ) ) { return 0 ; } const char * itemName = name . c_str ( ) ; for ( size_t i = 100 , size = items . size ( ) ; i < size ; ++ i ) { if ( strcasecmp ( itemName , items [ i ] . name . c_str ( ) ) == 0 ) { return i ; } } return 0 ; } </DOCUMENT>
<DOCUMENT_ID="m039/Void/tree/master/third-party/void-boost/libs/config/test/has_part_alloc_fail.cpp"> // ▁ This ▁ file ▁ was ▁ automatically ▁ generated ▁ on ▁ Fri ▁ Dec ▁ 03 ▁ 18:04:00 ▁ 2004 ENDCOM // ▁ by ▁ libs / config / tools / generate . cpp ENDCOM // ▁ Copyright ▁ John ▁ Maddock ▁ 2002-4 . ENDCOM // ▁ Use , ▁ modification ▁ and ▁ distribution ▁ are ▁ subject ▁ to ▁ the ▁ ENDCOM // ▁ Boost ▁ Software ▁ License , ▁ Version ▁ 1.0 . ▁ ( See ▁ accompanying ▁ file ▁ ENDCOM // ▁ LICENSE _ 1_0 . txt ▁ or ▁ copy ▁ at ▁ http : // www . boost . org / LICENSE _ 1_0 . txt ) ENDCOM // ▁ See ▁ http : // www . boost . org / libs / config ▁ for ▁ the ▁ most ▁ recent ▁ version . ENDCOM // ▁ Test ▁ file ▁ for ▁ macro ▁ BOOST _ HAS _ PARTIAL _ STD _ ALLOCATOR ENDCOM // ▁ This ▁ file ▁ should ▁ not ▁ compile , ▁ if ▁ it ▁ does ▁ then ENDCOM // ▁ BOOST _ HAS _ PARTIAL _ STD _ ALLOCATOR ▁ should ▁ be ▁ defined . ENDCOM // ▁ See ▁ file ▁ boost _ has _ part _ alloc . ipp ▁ for ▁ details ENDCOM // ▁ Must ▁ not ▁ have ▁ BOOST _ ASSERT _ CONFIG ▁ set ; ▁ it ▁ defeats ENDCOM // ▁ the ▁ objective ▁ of ▁ this ▁ file : ENDCOM # ifdef BOOST_ASSERT_CONFIG # undef BOOST_ASSERT_CONFIG # endif # include < boost / config . hpp > # include " test . hpp " # ifndef BOOST_HAS_PARTIAL_STD_ALLOCATOR # include " boost _ has _ part _ alloc . ipp " # else # error " this ▁ file ▁ should ▁ not ▁ compile " # endif int main ( int , char * [ ] ) { return boost_has_partial_std_allocator :: test ( ) ; } </DOCUMENT>
<DOCUMENT_ID="grokys/coreclr/tree/master/src/vm/common.cpp"> // ▁ Copyright ▁ ( c ) ▁ Microsoft . ▁ All ▁ rights ▁ reserved . ENDCOM // ▁ Licensed ▁ under ▁ the ▁ MIT ▁ license . ▁ See ▁ LICENSE ▁ file ▁ in ▁ the ▁ project ▁ root ▁ for ▁ full ▁ license ▁ information . ENDCOM # include " common . h " </DOCUMENT>
<DOCUMENT_ID="phamelin/ardupilot/tree/master/libraries/AP_Frsky_Telem/AP_Frsky_Telem.cpp"> /* STRNEWLINE STRNEWLINE ▁ Inspired ▁ by ▁ work ▁ done ▁ here ▁ https : // github . com / PX4 / Firmware / tree / master / src / drivers / frsky _ telemetry ▁ from ▁ Stefan ▁ Rado ▁ < px4 @ sradonia . net > STRNEWLINE STRNEWLINE ▁ This ▁ program ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or STRNEWLINE ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE STRNEWLINE ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE STRNEWLINE ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ along ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE */ /* ▁ STRNEWLINE ▁ FRSKY ▁ Telemetry ▁ library STRNEWLINE */ # include " AP _ Frsky _ Telem . h " # include < AP_InertialSensor / AP_InertialSensor . h > # include < GCS_MAVLink / GCS . h > # include < stdio . h > extern const AP_HAL :: HAL & hal ; ObjectArray < mavlink_statustext_t > AP_Frsky_Telem :: _statustext_queue ( FRSKY_TELEM_PAYLOAD_STATUS_CAPACITY ) ; // constructor ENDCOM AP_Frsky_Telem :: AP_Frsky_Telem ( AP_AHRS & ahrs , const AP_BattMonitor & battery , const RangeFinder & rng ) : _ahrs ( ahrs ) , _battery ( battery ) , _rng ( rng ) { } /* STRNEWLINE ▁ * ▁ init ▁ - ▁ perform ▁ required ▁ initialisation STRNEWLINE ▁ */ void AP_Frsky_Telem :: init ( const AP_SerialManager & serial_manager , const uint8_t mav_type , const uint32_t * ap_valuep ) { // ▁ check ▁ for ▁ protocol ▁ configured ▁ for ▁ a ▁ serial ▁ port ▁ - ▁ only ▁ the ▁ first ▁ serial ▁ port ▁ with ▁ one ▁ of ▁ these ▁ protocols ▁ will ▁ then ▁ run ▁ ( cannot ▁ have ▁ FrSky ▁ on ▁ multiple ▁ serial ▁ ports ) ENDCOM if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_D , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_D ; // ▁ FrSky ▁ D ▁ protocol ▁ ( D - receivers ) ENDCOM } else if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_SPort , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_SPort ; // ▁ FrSky ▁ SPort ▁ protocol ▁ ( X - receivers ) ENDCOM } else if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough ; // ▁ FrSky ▁ SPort ▁ and ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocols ▁ ( X - receivers ) ENDCOM // ▁ make ▁ frsky _ telemetry ▁ available ▁ to ▁ GCS _ MAVLINK ▁ ( used ▁ to ▁ queue ▁ statustext ▁ messages ▁ from ▁ GCS _ MAVLINK ) ENDCOM gcs ( ) . register_frsky_telemetry_callback ( this ) ; // ▁ add ▁ firmware ▁ and ▁ frame ▁ info ▁ to ▁ message ▁ queue ENDCOM if ( _frame_string == nullptr ) { queue_message ( MAV_SEVERITY_INFO , AP :: fwversion ( ) . fw_string ) ; } else { char firmware_buf [ MAVLINK_MSG_STATUSTEXT_FIELD_TEXT_LEN + 1 ] ; snprintf ( firmware_buf , sizeof ( firmware_buf ) , " % s ▁ % s " , AP :: fwversion ( ) . fw_string , _frame_string ) ; queue_message ( MAV_SEVERITY_INFO , firmware_buf ) ; } // ▁ save ▁ main ▁ parameters ▁ locally ENDCOM _params . mav_type = mav_type ; // ▁ frame ▁ type ▁ ( see ▁ MAV _ TYPE ▁ in ▁ Mavlink ▁ definition ▁ file ▁ common . h ) ENDCOM if ( ap_valuep == nullptr ) { // ▁ ap ▁ bit - field ENDCOM _ap . value = 0x2000 ; // ▁ set ▁ " initialised " ▁ to ▁ 1 ▁ for ▁ rover ▁ and ▁ plane ENDCOM _ap . valuep = & _ap . value ; } else { _ap . valuep = ap_valuep ; } } if ( _port != nullptr ) { hal . scheduler -> register_io_process ( FUNCTOR_BIND_MEMBER ( & AP_Frsky_Telem :: tick , void ) ) ; // ▁ we ▁ don ' t ▁ want ▁ flow ▁ control ▁ for ▁ either ▁ protocol ENDCOM _port -> set_flow_control ( AP_HAL :: UARTDriver :: FLOW_CONTROL_DISABLE ) ; } } /* STRNEWLINE ▁ * ▁ send ▁ telemetry ▁ data STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ void AP_Frsky_Telem :: send_SPort_Passthrough ( void ) { int16_t numc ; numc = _port -> available ( ) ; // ▁ check ▁ if ▁ available ▁ is ▁ negative ENDCOM if ( numc < 0 ) { return ; } // ▁ this ▁ is ▁ the ▁ constant ▁ for ▁ hub ▁ data ▁ frame ENDCOM if ( _port -> txspace ( ) < 19 ) { return ; } // ▁ keep ▁ only ▁ the ▁ last ▁ two ▁ bytes ▁ of ▁ the ▁ data ▁ found ▁ in ▁ the ▁ serial ▁ buffer , ▁ as ▁ we ▁ shouldn ' t ▁ respond ▁ to ▁ old ▁ poll ▁ requests ENDCOM uint8_t prev_byte = 0 ; for ( int16_t i = 0 ; i < numc ; i ++ ) { prev_byte = _passthrough . new_byte ; _passthrough . new_byte = _port -> read ( ) ; } if ( ( prev_byte == START_STOP_SPORT ) && ( _passthrough . new_byte == SENSOR_ID_28 ) ) { // ▁ byte ▁ 0x7E ▁ is ▁ the ▁ header ▁ of ▁ each ▁ poll ▁ request ENDCOM if ( _passthrough . send_attiandrng ) { // ▁ skip ▁ other ▁ data , ▁ send ▁ attitude ▁ ( roll , ▁ pitch ) ▁ and ▁ range ▁ only ▁ this ▁ iteration ENDCOM _passthrough . send_attiandrng = false ; // ▁ next ▁ iteration , ▁ check ▁ if ▁ we ▁ should ▁ send ▁ something ▁ other ENDCOM } else { // ▁ send ▁ other ▁ sensor ▁ data ▁ if ▁ it ' s ▁ time ▁ for ▁ them , ▁ and ▁ reset ▁ the ▁ corresponding ▁ timer ▁ if ▁ sent ENDCOM _passthrough . send_attiandrng = true ; // ▁ next ▁ iteration , ▁ send ▁ attitude ▁ b / c ▁ it ▁ needs ▁ frequent ▁ updates ▁ to ▁ remain ▁ smooth ENDCOM uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - _passthrough . params_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 7 , calc_param ( ) ) ; _passthrough . params_timer = AP_HAL :: millis ( ) ; return ; } // ▁ build ▁ message ▁ queue ▁ for ▁ sensor _ status _ flags ENDCOM check_sensor_status_flags ( ) ; // ▁ build ▁ message ▁ queue ▁ for ▁ ekf _ status ENDCOM check_ekf_status ( ) ; // ▁ if ▁ there ' s ▁ any ▁ message ▁ in ▁ the ▁ queue , ▁ start ▁ sending ▁ them ▁ chunk ▁ by ▁ chunk ; ▁ three ▁ times ▁ each ▁ chunk ENDCOM if ( get_next_msg_chunk ( ) ) { send_uint32 ( DIY_FIRST_ID , _msg_chunk . chunk ) ; return ; } if ( ( now - _passthrough . ap_status_timer ) >= 500 ) { if ( ( ( * _ap . valuep ) & AP_INITIALIZED_FLAG ) > 0 ) { // ▁ send ▁ ap ▁ status ▁ only ▁ once ▁ vehicle ▁ has ▁ been ▁ initialised ENDCOM send_uint32 ( DIY_FIRST_ID + 1 , calc_ap_status ( ) ) ; _passthrough . ap_status_timer = AP_HAL :: millis ( ) ; } return ; } if ( ( now - _passthrough . batt_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 3 , calc_batt ( 0 ) ) ; _passthrough . batt_timer = AP_HAL :: millis ( ) ; return ; } if ( _battery . num_instances ( ) > 1 ) { if ( ( now - _passthrough . batt_timer2 ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 8 , calc_batt ( 1 ) ) ; _passthrough . batt_timer2 = AP_HAL :: millis ( ) ; return ; } } if ( ( now - _passthrough . gps_status_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 2 , calc_gps_status ( ) ) ; _passthrough . gps_status_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . home_timer ) >= 500 ) { send_uint32 ( DIY_FIRST_ID + 4 , calc_home ( ) ) ; _passthrough . home_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . velandyaw_timer ) >= 500 ) { send_uint32 ( DIY_FIRST_ID + 5 , calc_velandyaw ( ) ) ; _passthrough . velandyaw_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . gps_latlng_timer ) >= 1000 ) { send_uint32 ( GPS_LONG_LATI_FIRST_ID , calc_gps_latlng ( & _passthrough . send_latitude ) ) ; // ▁ gps ▁ latitude ▁ or ▁ longitude ENDCOM if ( ! _passthrough . send_latitude ) { // ▁ we ' ve ▁ cycled ▁ and ▁ sent ▁ one ▁ each ▁ of ▁ longitude ▁ then ▁ latitude , ▁ so ▁ reset ▁ the ▁ timer ENDCOM _passthrough . gps_latlng_timer = AP_HAL :: millis ( ) ; } return ; } } // ▁ if ▁ nothing ▁ else ▁ needed ▁ to ▁ be ▁ sent , ▁ send ▁ attitude ▁ ( roll , ▁ pitch ) ▁ and ▁ range ▁ data ENDCOM send_uint32 ( DIY_FIRST_ID + 6 , calc_attiandrng ( ) ) ; } } /* STRNEWLINE ▁ * ▁ send ▁ telemetry ▁ data STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ void AP_Frsky_Telem :: send_SPort ( void ) { int16_t numc ; numc = _port -> available ( ) ; // ▁ check ▁ if ▁ available ▁ is ▁ negative ENDCOM if ( numc < 0 ) { return ; } // ▁ this ▁ is ▁ the ▁ constant ▁ for ▁ hub ▁ data ▁ frame ENDCOM if ( _port -> txspace ( ) < 19 ) { return ; } for ( int16_t i = 0 ; i < numc ; i ++ ) { int16_t readbyte = _port -> read ( ) ; if ( _SPort . sport_status == false ) { if ( readbyte == START_STOP_SPORT ) { _SPort . sport_status = true ; } } else { switch ( readbyte ) { case SENSOR_ID_FAS : switch ( _SPort . fas_call ) { case 0 : send_uint32 ( DATA_ID_FUEL , ( uint16_t ) roundf ( _battery . capacity_remaining_pct ( ) ) ) ; // ▁ send ▁ battery ▁ remaining ENDCOM break ; case 1 : send_uint32 ( DATA_ID_VFAS , ( uint16_t ) roundf ( _battery . voltage ( ) * 10.0f ) ) ; // ▁ send ▁ battery ▁ voltage ENDCOM break ; case 2 : send_uint32 ( DATA_ID_CURRENT , ( uint16_t ) roundf ( _battery . current_amps ( ) * 10.0f ) ) ; // ▁ send ▁ current ▁ consumption ENDCOM break ; } if ( _SPort . fas_call ++ > 2 ) _SPort . fas_call = 0 ; break ; case SENSOR_ID_GPS : switch ( _SPort . gps_call ) { case 0 : calc_gps_position ( ) ; // ▁ gps ▁ data ▁ is ▁ not ▁ recalculated ▁ until ▁ all ▁ of ▁ it ▁ has ▁ been ▁ sent ENDCOM send_uint32 ( DATA_ID_GPS_LAT_BP , _gps . latdddmm ) ; // ▁ send ▁ gps ▁ lattitude ▁ degree ▁ and ▁ minute ▁ integer ▁ part ENDCOM break ; case 1 : send_uint32 ( DATA_ID_GPS_LAT_AP , _gps . latmmmm ) ; // ▁ send ▁ gps ▁ lattitude ▁ minutes ▁ decimal ▁ part ENDCOM break ; case 2 : send_uint32 ( DATA_ID_GPS_LAT_NS , _gps . lat_ns ) ; // ▁ send ▁ gps ▁ North ▁ / ▁ South ▁ information ENDCOM break ; case 3 : send_uint32 ( DATA_ID_GPS_LONG_BP , _gps . londddmm ) ; // ▁ send ▁ gps ▁ longitude ▁ degree ▁ and ▁ minute ▁ integer ▁ part ENDCOM break ; case 4 : send_uint32 ( DATA_ID_GPS_LONG_AP , _gps . lonmmmm ) ; // ▁ send ▁ gps ▁ longitude ▁ minutes ▁ decimal ▁ part ENDCOM break ; case 5 : send_uint32 ( DATA_ID_GPS_LONG_EW , _gps . lon_ew ) ; // ▁ send ▁ gps ▁ East ▁ / ▁ West ▁ information ENDCOM break ; case 6 : send_uint32 ( DATA_ID_GPS_SPEED_BP , _gps . speed_in_meter ) ; // ▁ send ▁ gps ▁ speed ▁ integer ▁ part ENDCOM break ; case 7 : send_uint32 ( DATA_ID_GPS_SPEED_AP , _gps . speed_in_centimeter ) ; // ▁ send ▁ gps ▁ speed ▁ decimal ▁ part ENDCOM break ; case 8 : send_uint32 ( DATA_ID_GPS_ALT_BP , _gps . alt_gps_meters ) ; // ▁ send ▁ gps ▁ altitude ▁ integer ▁ part ENDCOM break ; case 9 : send_uint32 ( DATA_ID_GPS_ALT_AP , _gps . alt_gps_cm ) ; // ▁ send ▁ gps ▁ altitude ▁ decimals ENDCOM break ; case 10 : send_uint32 ( DATA_ID_GPS_COURS_BP , ( uint16_t ) ( ( _ahrs . yaw_sensor / 100 ) % 360 ) ) ; // ▁ send ▁ heading ▁ in ▁ degree ▁ based ▁ on ▁ AHRS ▁ and ▁ not ▁ GPS ENDCOM break ; } if ( _SPort . gps_call ++ > 10 ) _SPort . gps_call = 0 ; break ; case SENSOR_ID_VARIO : switch ( _SPort . vario_call ) { case 0 : calc_nav_alt ( ) ; // ▁ nav ▁ altitude ▁ is ▁ not ▁ recalculated ▁ until ▁ all ▁ of ▁ it ▁ has ▁ been ▁ sent ENDCOM send_uint32 ( DATA_ID_BARO_ALT_BP , _gps . alt_nav_meters ) ; // ▁ send ▁ altitude ▁ integer ▁ part ENDCOM break ; case 1 : send_uint32 ( DATA_ID_BARO_ALT_AP , _gps . alt_nav_cm ) ; // ▁ send ▁ altitude ▁ decimal ▁ part ENDCOM break ; } if ( _SPort . vario_call ++ > 1 ) _SPort . vario_call = 0 ; break ; case SENSOR_ID_SP2UR : switch ( _SPort . various_call ) { case 0 : send_uint32 ( DATA_ID_TEMP2 , ( uint16_t ) ( AP :: gps ( ) . num_sats ( ) * 10 + AP :: gps ( ) . status ( ) ) ) ; // ▁ send ▁ GPS ▁ status ▁ and ▁ number ▁ of ▁ satellites ▁ as ▁ num _ sats * 10 ▁ + ▁ status ▁ ( to ▁ fit ▁ into ▁ a ▁ uint8 _ t ) ENDCOM break ; case 1 : send_uint32 ( DATA_ID_TEMP1 , _ap . control_mode ) ; // ▁ send ▁ flight ▁ mode ENDCOM break ; } if ( _SPort . various_call ++ > 1 ) _SPort . various_call = 0 ; break ; } _SPort . sport_status = false ; } } } /* STRNEWLINE ▁ * ▁ send ▁ frame1 ▁ and ▁ frame2 ▁ telemetry ▁ data STRNEWLINE ▁ * ▁ one ▁ frame ▁ ( frame1 ) ▁ is ▁ sent ▁ every ▁ 200ms ▁ with ▁ baro ▁ alt , ▁ nb ▁ sats , ▁ batt ▁ volts ▁ and ▁ amp , ▁ control _ mode STRNEWLINE ▁ * ▁ a ▁ second ▁ frame ▁ ( frame2 ) ▁ is ▁ sent ▁ every ▁ second ▁ ( 1000ms ) ▁ with ▁ gps ▁ position ▁ data , ▁ and ▁ ahrs . yaw _ sensor ▁ heading ▁ ( instead ▁ of ▁ GPS ▁ heading ) STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ D ▁ protocol ▁ ( D - receivers ) STRNEWLINE ▁ */ void AP_Frsky_Telem :: send_D ( void ) { uint32_t now = AP_HAL :: millis ( ) ; // ▁ send ▁ frame1 ▁ every ▁ 200ms ENDCOM if ( now - _D . last_200ms_frame >= 200 ) { _D . last_200ms_frame = now ; send_uint16 ( DATA_ID_TEMP2 , ( uint16_t ) ( AP :: gps ( ) . num_sats ( ) * 10 + AP :: gps ( ) . status ( ) ) ) ; // ▁ send ▁ GPS ▁ status ▁ and ▁ number ▁ of ▁ satellites ▁ as ▁ num _ sats * 10 ▁ + ▁ status ▁ ( to ▁ fit ▁ into ▁ a ▁ uint8 _ t ) ENDCOM send_uint16 ( DATA_ID_TEMP1 , _ap . control_mode ) ; // ▁ send ▁ flight ▁ mode ENDCOM send_uint16 ( DATA_ID_FUEL , ( uint16_t ) roundf ( _battery . capacity_remaining_pct ( ) ) ) ; // ▁ send ▁ battery ▁ remaining ENDCOM send_uint16 ( DATA_ID_VFAS , ( uint16_t ) roundf ( _battery . voltage ( ) * 10.0f ) ) ; // ▁ send ▁ battery ▁ voltage ENDCOM send_uint16 ( DATA_ID_CURRENT , ( uint16_t ) roundf ( _battery . current_amps ( ) * 10.0f ) ) ; // ▁ send ▁ current ▁ consumption ENDCOM calc_nav_alt ( ) ; send_uint16 ( DATA_ID_BARO_ALT_BP , _gps . alt_nav_meters ) ; // ▁ send ▁ nav ▁ altitude ▁ integer ▁ part ENDCOM send_uint16 ( DATA_ID_BARO_ALT_AP , _gps . alt_nav_cm ) ; // ▁ send ▁ nav ▁ altitude ▁ decimal ▁ part ENDCOM } // ▁ send ▁ frame2 ▁ every ▁ second ENDCOM if ( now - _D . last_1000ms_frame >= 1000 ) { _D . last_1000ms_frame = now ; send_uint16 ( DATA_ID_GPS_COURS_BP , ( uint16_t ) ( ( _ahrs . yaw_sensor / 100 ) % 360 ) ) ; // ▁ send ▁ heading ▁ in ▁ degree ▁ based ▁ on ▁ AHRS ▁ and ▁ not ▁ GPS ENDCOM calc_gps_position ( ) ; if ( AP :: gps ( ) . status ( ) >= 3 ) { send_uint16 ( DATA_ID_GPS_LAT_BP , _gps . latdddmm ) ; // ▁ send ▁ gps ▁ lattitude ▁ degree ▁ and ▁ minute ▁ integer ▁ part ENDCOM send_uint16 ( DATA_ID_GPS_LAT_AP , _gps . latmmmm ) ; // ▁ send ▁ gps ▁ lattitude ▁ minutes ▁ decimal ▁ part ENDCOM send_uint16 ( DATA_ID_GPS_LAT_NS , _gps . lat_ns ) ; // ▁ send ▁ gps ▁ North ▁ / ▁ South ▁ information ENDCOM send_uint16 ( DATA_ID_GPS_LONG_BP , _gps . londddmm ) ; // ▁ send ▁ gps ▁ longitude ▁ degree ▁ and ▁ minute ▁ integer ▁ part ENDCOM send_uint16 ( DATA_ID_GPS_LONG_AP , _gps . lonmmmm ) ; // ▁ send ▁ gps ▁ longitude ▁ minutes ▁ decimal ▁ part ENDCOM send_uint16 ( DATA_ID_GPS_LONG_EW , _gps . lon_ew ) ; // ▁ send ▁ gps ▁ East ▁ / ▁ West ▁ information ENDCOM send_uint16 ( DATA_ID_GPS_SPEED_BP , _gps . speed_in_meter ) ; // ▁ send ▁ gps ▁ speed ▁ integer ▁ part ENDCOM send_uint16 ( DATA_ID_GPS_SPEED_AP , _gps . speed_in_centimeter ) ; // ▁ send ▁ gps ▁ speed ▁ decimal ▁ part ENDCOM send_uint16 ( DATA_ID_GPS_ALT_BP , _gps . alt_gps_meters ) ; // ▁ send ▁ gps ▁ altitude ▁ integer ▁ part ENDCOM send_uint16 ( DATA_ID_GPS_ALT_AP , _gps . alt_gps_cm ) ; // ▁ send ▁ gps ▁ altitude ▁ decimal ▁ part ENDCOM } } } /* STRNEWLINE ▁ * ▁ tick ▁ - ▁ main ▁ call ▁ to ▁ send ▁ data ▁ to ▁ the ▁ receiver ▁ ( called ▁ by ▁ scheduler ▁ at ▁ 1kHz ) STRNEWLINE ▁ */ void AP_Frsky_Telem :: tick ( void ) { // ▁ check ▁ UART ▁ has ▁ been ▁ initialised ENDCOM if ( ! _initialised_uart ) { // ▁ initialise ▁ uart ▁ ( this ▁ must ▁ be ▁ called ▁ from ▁ within ▁ tick ▁ b / c ▁ the ▁ UART ▁ begin ▁ must ▁ be ▁ called ▁ from ▁ the ▁ same ▁ thread ▁ as ▁ it ▁ is ▁ used ▁ from ) ENDCOM if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { // ▁ FrSky ▁ D ▁ protocol ▁ ( D - receivers ) ENDCOM _port -> begin ( AP_SERIALMANAGER_FRSKY_D_BAUD , AP_SERIALMANAGER_FRSKY_BUFSIZE_RX , AP_SERIALMANAGER_FRSKY_BUFSIZE_TX ) ; } else { // ▁ FrSky ▁ SPort ▁ and ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocols ▁ ( X - receivers ) ENDCOM _port -> begin ( AP_SERIALMANAGER_FRSKY_SPORT_BAUD , AP_SERIALMANAGER_FRSKY_BUFSIZE_RX , AP_SERIALMANAGER_FRSKY_BUFSIZE_TX ) ; } _initialised_uart = true ; // ▁ true ▁ when ▁ we ▁ have ▁ detected ▁ the ▁ protocol ▁ and ▁ UART ▁ has ▁ been ▁ initialised ENDCOM } if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { // ▁ FrSky ▁ D ▁ protocol ▁ ( D - receivers ) ENDCOM send_D ( ) ; } else if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_SPort ) { // ▁ FrSky ▁ SPort ▁ protocol ▁ ( X - receivers ) ENDCOM send_SPort ( ) ; } else if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough ) { // ▁ FrSky ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocol ▁ ( X - receivers ) ENDCOM send_SPort_Passthrough ( ) ; } } /* ▁ STRNEWLINE ▁ * ▁ build ▁ up ▁ the ▁ frame ' s ▁ crc STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ void AP_Frsky_Telem :: calc_crc ( uint8_t byte ) { _crc += byte ; // 0-1FF ENDCOM _crc += _crc >> 8 ; // 0-100 ENDCOM _crc &= 0xFF ; } /* STRNEWLINE ▁ * ▁ send ▁ the ▁ frame ' s ▁ crc ▁ at ▁ the ▁ end ▁ of ▁ the ▁ frame STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ void AP_Frsky_Telem :: send_crc ( void ) { send_byte ( 0xFF - _crc ) ; _crc = 0 ; } /* STRNEWLINE ▁ send ▁ 1 ▁ byte ▁ and ▁ do ▁ byte ▁ stuffing STRNEWLINE */ void AP_Frsky_Telem :: send_byte ( uint8_t byte ) { if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { // ▁ FrSky ▁ D ▁ protocol ▁ ( D - receivers ) ENDCOM if ( byte == START_STOP_D ) { _port -> write ( 0x5D ) ; _port -> write ( 0x3E ) ; } else if ( byte == BYTESTUFF_D ) { _port -> write ( 0x5D ) ; _port -> write ( 0x3D ) ; } else { _port -> write ( byte ) ; } } else { // ▁ FrSky ▁ SPort ▁ protocol ▁ ( X - receivers ) ENDCOM if ( byte == START_STOP_SPORT ) { _port -> write ( 0x7D ) ; _port -> write ( 0x5E ) ; } else if ( byte == BYTESTUFF_SPORT ) { _port -> write ( 0x7D ) ; _port -> write ( 0x5D ) ; } else { _port -> write ( byte ) ; } calc_crc ( byte ) ; } } /* STRNEWLINE ▁ * ▁ send ▁ one ▁ uint32 ▁ frame ▁ of ▁ FrSky ▁ data ▁ - ▁ for ▁ FrSky ▁ SPort ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ void AP_Frsky_Telem :: send_uint32 ( uint16_t id , uint32_t data ) { send_byte ( 0x10 ) ; // ▁ DATA _ FRAME ENDCOM uint8_t * bytes = ( uint8_t * ) & id ; send_byte ( bytes [ 0 ] ) ; // ▁ LSB ENDCOM send_byte ( bytes [ 1 ] ) ; // ▁ MSB ENDCOM bytes = ( uint8_t * ) & data ; send_byte ( bytes [ 0 ] ) ; // ▁ LSB ENDCOM send_byte ( bytes [ 1 ] ) ; send_byte ( bytes [ 2 ] ) ; send_byte ( bytes [ 3 ] ) ; // ▁ MSB ENDCOM send_crc ( ) ; } /* STRNEWLINE ▁ * ▁ send ▁ one ▁ uint16 ▁ frame ▁ of ▁ FrSky ▁ data ▁ - ▁ for ▁ FrSky ▁ D ▁ protocol ▁ ( D - receivers ) STRNEWLINE ▁ */ void AP_Frsky_Telem :: send_uint16 ( uint16_t id , uint16_t data ) { _port -> write ( START_STOP_D ) ; // ▁ send ▁ a ▁ 0x5E ▁ start ▁ byte ENDCOM uint8_t * bytes = ( uint8_t * ) & id ; send_byte ( bytes [ 0 ] ) ; bytes = ( uint8_t * ) & data ; send_byte ( bytes [ 0 ] ) ; // ▁ LSB ENDCOM send_byte ( bytes [ 1 ] ) ; // ▁ MSB ENDCOM } /* STRNEWLINE ▁ * ▁ grabs ▁ one ▁ " chunk " ▁ ( 4 ▁ bytes ) ▁ of ▁ the ▁ queued ▁ message ▁ to ▁ be ▁ transmitted STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ bool AP_Frsky_Telem :: get_next_msg_chunk ( void ) { if ( _statustext_queue . empty ( ) ) { return false ; } if ( _msg_chunk . repeats == 0 ) { // ▁ if ▁ it ' s ▁ the ▁ first ▁ time ▁ get _ next _ msg _ chunk ▁ is ▁ called ▁ for ▁ a ▁ given ▁ chunk ENDCOM uint8_t character = 0 ; _msg_chunk . chunk = 0 ; // ▁ clear ▁ the ▁ 4 ▁ bytes ▁ of ▁ the ▁ chunk ▁ buffer ENDCOM for ( int i = 3 ; i > - 1 && _msg_chunk . char_index < sizeof ( _statustext_queue [ 0 ] -> text ) ; i -- ) { character = _statustext_queue [ 0 ] -> text [ _msg_chunk . char_index ++ ] ; if ( ! character ) { break ; } _msg_chunk . chunk |= character << i * 8 ; } if ( ! character || ( _msg_chunk . char_index == sizeof ( _statustext_queue [ 0 ] -> text ) ) ) { // ▁ we ' ve ▁ reached ▁ the ▁ end ▁ of ▁ the ▁ message ▁ ( string ▁ terminated ▁ by ▁ ' \0 ' ▁ or ▁ last ▁ character ▁ of ▁ the ▁ string ▁ has ▁ been ▁ processed ) ENDCOM _msg_chunk . char_index = 0 ; // ▁ reset ▁ index ▁ to ▁ get ▁ ready ▁ to ▁ process ▁ the ▁ next ▁ message ENDCOM // ▁ add ▁ severity ▁ which ▁ is ▁ sent ▁ as ▁ the ▁ MSB ▁ of ▁ the ▁ last ▁ three ▁ bytes ▁ of ▁ the ▁ last ▁ chunk ▁ ( bits ▁ 24 , ▁ 16 , ▁ and ▁ 8 ) ▁ since ▁ a ▁ character ▁ is ▁ on ▁ 7 ▁ bits ENDCOM _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x4 ) << 21 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x2 ) << 14 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x1 ) << 7 ; } } if ( _msg_chunk . repeats ++ > 2 ) { // ▁ repeat ▁ each ▁ message ▁ chunk ▁ 3 ▁ times ▁ to ▁ ensure ▁ transmission ENDCOM _msg_chunk . repeats = 0 ; if ( _msg_chunk . char_index == 0 ) { // ▁ if ▁ we ' re ▁ ready ▁ for ▁ the ▁ next ▁ message ENDCOM _statustext_queue . remove ( 0 ) ; } } return true ; } /* STRNEWLINE ▁ * ▁ add ▁ message ▁ to ▁ message ▁ cue ▁ for ▁ transmission ▁ through ▁ FrSky ▁ link STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ void AP_Frsky_Telem :: queue_message ( MAV_SEVERITY severity , const char * text ) { mavlink_statustext_t statustext { } ; statustext . severity = severity ; strncpy ( statustext . text , text , sizeof ( statustext . text ) ) ; // ▁ The ▁ force ▁ push ▁ will ▁ ensure ▁ comm ▁ links ▁ do ▁ not ▁ block ▁ other ▁ comm ▁ links ▁ forever ▁ if ▁ they ▁ fail . ENDCOM // ▁ If ▁ we ▁ push ▁ to ▁ a ▁ full ▁ buffer ▁ then ▁ we ▁ overwrite ▁ the ▁ oldest ▁ entry , ▁ effectively ▁ removing ▁ the ENDCOM // ▁ block ▁ but ▁ not ▁ until ▁ the ▁ buffer ▁ fills ▁ up . ENDCOM _statustext_queue . push_force ( statustext ) ; } /* STRNEWLINE ▁ * ▁ add ▁ sensor _ status _ flags ▁ information ▁ to ▁ message ▁ cue , ▁ normally ▁ passed ▁ as ▁ sys _ status ▁ mavlink ▁ messages ▁ to ▁ the ▁ GCS , ▁ for ▁ transmission ▁ through ▁ FrSky ▁ link STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ void AP_Frsky_Telem :: check_sensor_status_flags ( void ) { uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - check_sensor_status_timer ) >= 5000 ) { // ▁ prevent ▁ repeating ▁ any ▁ system _ status ▁ messages ▁ unless ▁ 5 ▁ seconds ▁ have ▁ passed ENDCOM // ▁ only ▁ one ▁ error ▁ is ▁ reported ▁ at ▁ a ▁ time ▁ ( in ▁ order ▁ of ▁ preference ) . ▁ Same ▁ setup ▁ and ▁ displayed ▁ messages ▁ as ▁ Mission ▁ Planner . ENDCOM if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_GPS ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ GPS ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_GYRO ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Gyro ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_ACCEL ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Accel ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_MAG ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Compass ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Baro ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_LASER_POSITION ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ LiDAR ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ OptFlow ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_TERRAIN ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ or ▁ No ▁ Terrain ▁ Data " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_GEOFENCE ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Geofence ▁ Breach " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_AHRS ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ AHRS " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_RC_RECEIVER ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " No ▁ RC ▁ Receiver " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_LOGGING ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Logging " ) ; check_sensor_status_timer = now ; } } } /* STRNEWLINE ▁ * ▁ add ▁ innovation ▁ variance ▁ information ▁ to ▁ message ▁ cue , ▁ normally ▁ passed ▁ as ▁ ekf _ status _ report ▁ mavlink ▁ messages ▁ to ▁ the ▁ GCS , ▁ for ▁ transmission ▁ through ▁ FrSky ▁ link STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ void AP_Frsky_Telem :: check_ekf_status ( void ) { // ▁ get ▁ variances ENDCOM float velVar , posVar , hgtVar , tasVar ; Vector3f magVar ; Vector2f offset ; if ( _ahrs . get_variances ( velVar , posVar , hgtVar , magVar , tasVar , offset ) ) { uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - check_ekf_status_timer ) >= 10000 ) { // ▁ prevent ▁ repeating ▁ any ▁ ekf _ status ▁ message ▁ unless ▁ 10 ▁ seconds ▁ have ▁ passed ENDCOM // ▁ multiple ▁ errors ▁ can ▁ be ▁ reported ▁ at ▁ a ▁ time . ▁ Same ▁ setup ▁ as ▁ Mission ▁ Planner . ENDCOM if ( velVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ velocity ▁ variance " ) ; check_ekf_status_timer = now ; } if ( posVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ pos ▁ horiz ▁ variance " ) ; check_ekf_status_timer = now ; } if ( hgtVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ pos ▁ vert ▁ variance " ) ; check_ekf_status_timer = now ; } if ( magVar . length ( ) >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ compass ▁ variance " ) ; check_ekf_status_timer = now ; } if ( tasVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ terrain ▁ alt ▁ variance " ) ; check_ekf_status_timer = now ; } } } } /* STRNEWLINE ▁ * ▁ prepare ▁ parameter ▁ data STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ uint32_t AP_Frsky_Telem :: calc_param ( void ) { uint32_t param = 0 ; // ▁ cycle ▁ through ▁ paramIDs ENDCOM if ( _paramID >= 5 ) { _paramID = 0 ; } _paramID ++ ; switch ( _paramID ) { case 1 : param = _params . mav_type ; // ▁ frame ▁ type ▁ ( see ▁ MAV _ TYPE ▁ in ▁ Mavlink ▁ definition ▁ file ▁ common . h ) ENDCOM break ; case 2 : // ▁ was ▁ used ▁ to ▁ send ▁ the ▁ battery ▁ failsafe ▁ voltage ENDCOM case 3 : // ▁ was ▁ used ▁ to ▁ send ▁ the ▁ battery ▁ failsafe ▁ capacity ▁ in ▁ mAh ENDCOM break ; case 4 : param = ( uint32_t ) roundf ( _battery . pack_capacity_mah ( 0 ) ) ; // ▁ battery ▁ pack ▁ capacity ▁ in ▁ mAh ENDCOM break ; case 5 : param = ( uint32_t ) roundf ( _battery . pack_capacity_mah ( 1 ) ) ; // ▁ battery ▁ pack ▁ capacity ▁ in ▁ mAh ENDCOM break ; } // Reserve ▁ first ▁ 8 ▁ bits ▁ for ▁ param ▁ ID , ▁ use ▁ other ▁ 24 ▁ bits ▁ to ▁ store ▁ parameter ▁ value ENDCOM param = ( _paramID << PARAM_ID_OFFSET ) | ( param & PARAM_VALUE_LIMIT ) ; return param ; } /* STRNEWLINE ▁ * ▁ prepare ▁ gps ▁ latitude / longitude ▁ data STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ uint32_t AP_Frsky_Telem :: calc_gps_latlng ( bool * send_latitude ) { uint32_t latlng ; const Location & loc = AP :: gps ( ) . location ( 0 ) ; // ▁ use ▁ the ▁ first ▁ gps ▁ instance ▁ ( same ▁ as ▁ in ▁ send _ mavlink _ gps _ raw ) ENDCOM // ▁ alternate ▁ between ▁ latitude ▁ and ▁ longitude ENDCOM if ( ( * send_latitude ) == true ) { if ( loc . lat < 0 ) { latlng = ( ( labs ( loc . lat ) / 100 ) * 6 ) | 0x40000000 ; } else { latlng = ( ( labs ( loc . lat ) / 100 ) * 6 ) ; } ( * send_latitude ) = false ; } else { if ( loc . lng < 0 ) { latlng = ( ( labs ( loc . lng ) / 100 ) * 6 ) | 0xC0000000 ; } else { latlng = ( ( labs ( loc . lng ) / 100 ) * 6 ) | 0x80000000 ; } ( * send_latitude ) = true ; } return latlng ; } /* STRNEWLINE ▁ * ▁ prepare ▁ gps ▁ status ▁ data STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ uint32_t AP_Frsky_Telem :: calc_gps_status ( void ) { const AP_GPS & gps = AP :: gps ( ) ; uint32_t gps_status ; // ▁ number ▁ of ▁ GPS ▁ satellites ▁ visible ▁ ( limit ▁ to ▁ 15 ▁ ( 0xF ) ▁ since ▁ the ▁ value ▁ is ▁ stored ▁ on ▁ 4 ▁ bits ) ENDCOM gps_status = ( gps . num_sats ( ) < GPS_SATS_LIMIT ) ? gps . num_sats ( ) : GPS_SATS_LIMIT ; // ▁ GPS ▁ receiver ▁ status ▁ ( limit ▁ to ▁ 0-3 ▁ ( 0x3 ) ▁ since ▁ the ▁ value ▁ is ▁ stored ▁ on ▁ 2 ▁ bits : ▁ NO _ GPS ▁ = ▁ 0 , ▁ NO _ FIX ▁ = ▁ 1 , ▁ GPS _ OK _ FIX _ 2D ▁ = ▁ 2 , ▁ GPS _ OK _ FIX _ 3D ▁ or ▁ GPS _ OK _ FIX _ 3D _ DGPS ▁ or ▁ GPS _ OK _ FIX _ 3D _ RTK _ FLOAT ▁ or ▁ GPS _ OK _ FIX _ 3D _ RTK _ FIXED ▁ = ▁ 3 ) ENDCOM gps_status |= ( ( gps . status ( ) < GPS_STATUS_LIMIT ) ? gps . status ( ) : GPS_STATUS_LIMIT ) << GPS_STATUS_OFFSET ; // ▁ GPS ▁ horizontal ▁ dilution ▁ of ▁ precision ▁ in ▁ dm ENDCOM gps_status |= prep_number ( roundf ( gps . get_hdop ( ) * 0.1f ) , 2 , 1 ) << GPS_HDOP_OFFSET ; // ▁ GPS ▁ receiver ▁ advanced ▁ status ▁ ( 0 : ▁ no ▁ advanced ▁ fix , ▁ 1 : ▁ GPS _ OK _ FIX _ 3D _ DGPS , ▁ 2 : ▁ GPS _ OK _ FIX _ 3D _ RTK _ FLOAT , ▁ 3 : ▁ GPS _ OK _ FIX _ 3D _ RTK _ FIXED ) ENDCOM gps_status |= ( ( gps . status ( ) > GPS_STATUS_LIMIT ) ? gps . status ( ) - GPS_STATUS_LIMIT : 0 ) << GPS_ADVSTATUS_OFFSET ; // ▁ Altitude ▁ MSL ▁ in ▁ dm ENDCOM const Location & loc = gps . location ( ) ; gps_status |= prep_number ( roundf ( loc . alt * 0.1f ) , 2 , 2 ) << GPS_ALTMSL_OFFSET ; return gps_status ; } /* STRNEWLINE ▁ * ▁ prepare ▁ battery ▁ data STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ uint32_t AP_Frsky_Telem :: calc_batt ( uint8_t instance ) { uint32_t batt ; // ▁ battery ▁ voltage ▁ in ▁ decivolts , ▁ can ▁ have ▁ up ▁ to ▁ a ▁ 12S ▁ battery ▁ ( 4.25Vx12S ▁ = ▁ 51.0V ) ENDCOM batt = ( ( ( uint16_t ) roundf ( _battery . voltage ( instance ) * 10.0f ) ) & BATT_VOLTAGE_LIMIT ) ; // ▁ battery ▁ current ▁ draw ▁ in ▁ deciamps ENDCOM batt |= prep_number ( roundf ( _battery . current_amps ( instance ) * 10.0f ) , 2 , 1 ) << BATT_CURRENT_OFFSET ; // ▁ battery ▁ current ▁ drawn ▁ since ▁ power ▁ on ▁ in ▁ mAh ▁ ( limit ▁ to ▁ 32767 ▁ ( 0x7FFF ) ▁ since ▁ value ▁ is ▁ stored ▁ on ▁ 15 ▁ bits ) ENDCOM batt |= ( ( _battery . consumed_mah ( instance ) < BATT_TOTALMAH_LIMIT ) ? ( ( uint16_t ) roundf ( _battery . consumed_mah ( instance ) ) & BATT_TOTALMAH_LIMIT ) : BATT_TOTALMAH_LIMIT ) << BATT_TOTALMAH_OFFSET ; return batt ; } /* STRNEWLINE ▁ * ▁ prepare ▁ various ▁ autopilot ▁ status ▁ data STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ uint32_t AP_Frsky_Telem :: calc_ap_status ( void ) { uint32_t ap_status ; // ▁ IMU ▁ temperature : ▁ offset ▁ - 19 , ▁ 0 ▁ means ▁ temp ▁ = < ▁ 19 ° , ▁ 63 ▁ means ▁ temp ▁ = > ▁ 82 ° ENDCOM uint8_t imu_temp = ( uint8_t ) roundf ( constrain_float ( AP :: ins ( ) . get_temperature ( 0 ) , AP_IMU_TEMP_MIN , AP_IMU_TEMP_MAX ) - AP_IMU_TEMP_MIN ) ; // ▁ control / flight ▁ mode ▁ number ▁ ( limit ▁ to ▁ 31 ▁ ( 0x1F ) ▁ since ▁ the ▁ value ▁ is ▁ stored ▁ on ▁ 5 ▁ bits ) ENDCOM ap_status = ( uint8_t ) ( ( _ap . control_mode + 1 ) & AP_CONTROL_MODE_LIMIT ) ; // ▁ simple / super ▁ simple ▁ modes ▁ flags ENDCOM ap_status |= ( uint8_t ) ( ( * _ap . valuep ) & AP_SSIMPLE_FLAGS ) << AP_SSIMPLE_OFFSET ; // ▁ is _ flying ▁ flag ENDCOM ap_status |= ( uint8_t ) ( ( ( * _ap . valuep ) & AP_LANDCOMPLETE_FLAG ) ^ AP_LANDCOMPLETE_FLAG ) ; // ▁ armed ▁ flag ENDCOM ap_status |= ( uint8_t ) ( AP_Notify :: flags . armed ) << AP_ARMED_OFFSET ; // ▁ battery ▁ failsafe ▁ flag ENDCOM ap_status |= ( uint8_t ) ( AP_Notify :: flags . failsafe_battery ) << AP_BATT_FS_OFFSET ; // ▁ bad ▁ ekf ▁ flag ENDCOM ap_status |= ( uint8_t ) ( AP_Notify :: flags . ekf_bad ) << AP_EKF_FS_OFFSET ; // ▁ IMU ▁ temperature ENDCOM ap_status |= imu_temp << AP_IMU_TEMP_OFFSET ; return ap_status ; } /* STRNEWLINE ▁ * ▁ prepare ▁ home ▁ position ▁ related ▁ data STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ uint32_t AP_Frsky_Telem :: calc_home ( void ) { uint32_t home = 0 ; Location loc ; float _relative_home_altitude = 0 ; if ( _ahrs . get_position ( loc ) ) { // ▁ check ▁ home _ loc ▁ is ▁ valid ENDCOM const Location & home_loc = _ahrs . get_home ( ) ; if ( home_loc . lat != 0 || home_loc . lng != 0 ) { // ▁ distance ▁ between ▁ vehicle ▁ and ▁ home _ loc ▁ in ▁ meters ENDCOM home = prep_number ( roundf ( get_distance ( home_loc , loc ) ) , 3 , 2 ) ; // ▁ angle ▁ from ▁ front ▁ of ▁ vehicle ▁ to ▁ the ▁ direction ▁ of ▁ home _ loc ▁ in ▁ 3 ▁ degree ▁ increments ▁ ( just ▁ in ▁ case , ▁ limit ▁ to ▁ 127 ▁ ( 0x7F ) ▁ since ▁ the ▁ value ▁ is ▁ stored ▁ on ▁ 7 ▁ bits ) ENDCOM home |= ( ( ( uint8_t ) roundf ( get_bearing_cd ( loc , home_loc ) * 0.00333f ) ) & HOME_BEARING_LIMIT ) << HOME_BEARING_OFFSET ; } // ▁ altitude ▁ between ▁ vehicle ▁ and ▁ home _ loc ENDCOM _relative_home_altitude = loc . alt ; if ( ! loc . flags . relative_alt ) { // ▁ loc . alt ▁ has ▁ home ▁ altitude ▁ added , ▁ remove ▁ it ENDCOM _relative_home_altitude -= _ahrs . get_home ( ) . alt ; } } // ▁ altitude ▁ above ▁ home ▁ in ▁ decimeters ENDCOM home |= prep_number ( roundf ( _relative_home_altitude * 0.1f ) , 3 , 2 ) << HOME_ALT_OFFSET ; return home ; } /* STRNEWLINE ▁ * ▁ prepare ▁ velocity ▁ and ▁ yaw ▁ data STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ uint32_t AP_Frsky_Telem :: calc_velandyaw ( void ) { uint32_t velandyaw ; Vector3f velNED { } ; // ▁ if ▁ we ▁ can ' t ▁ get ▁ velocity ▁ then ▁ we ▁ use ▁ zero ▁ for ▁ vertical ▁ velocity ENDCOM _ahrs . get_velocity_NED ( velNED ) ; // ▁ vertical ▁ velocity ▁ in ▁ dm / s ENDCOM velandyaw = prep_number ( roundf ( - velNED . z * 10 ) , 2 , 1 ) ; // ▁ horizontal ▁ velocity ▁ in ▁ dm / s ▁ ( use ▁ airspeed ▁ if ▁ available ▁ and ▁ enabled ▁ - ▁ even ▁ if ▁ not ▁ used ▁ - ▁ otherwise ▁ use ▁ groundspeed ) ENDCOM const AP_Airspeed * aspeed = _ahrs . get_airspeed ( ) ; if ( aspeed && aspeed -> enabled ( ) ) { velandyaw |= prep_number ( roundf ( aspeed -> get_airspeed ( ) * 10 ) , 2 , 1 ) << VELANDYAW_XYVEL_OFFSET ; } else { // ▁ otherwise ▁ send ▁ groundspeed ▁ estimate ▁ from ▁ ahrs ENDCOM velandyaw |= prep_number ( roundf ( _ahrs . groundspeed ( ) * 10 ) , 2 , 1 ) << VELANDYAW_XYVEL_OFFSET ; } // ▁ yaw ▁ from ▁ [ 0;36000 ] ▁ centidegrees ▁ to ▁ . 2 ▁ degree ▁ increments ▁ [ 0;1800 ] ▁ ( just ▁ in ▁ case , ▁ limit ▁ to ▁ 2047 ▁ ( 0x7FF ) ▁ since ▁ the ▁ value ▁ is ▁ stored ▁ on ▁ 11 ▁ bits ) ENDCOM velandyaw |= ( ( uint16_t ) roundf ( _ahrs . yaw_sensor * 0.05f ) & VELANDYAW_YAW_LIMIT ) << VELANDYAW_YAW_OFFSET ; return velandyaw ; } /* STRNEWLINE ▁ * ▁ prepare ▁ attitude ▁ ( roll , ▁ pitch ) ▁ and ▁ range ▁ data STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ uint32_t AP_Frsky_Telem :: calc_attiandrng ( void ) { uint32_t attiandrng ; // ▁ roll ▁ from ▁ [ -18000;18000 ] ▁ centidegrees ▁ to ▁ unsigned ▁ . 2 ▁ degree ▁ increments ▁ [ 0;1800 ] ▁ ( just ▁ in ▁ case , ▁ limit ▁ to ▁ 2047 ▁ ( 0x7FF ) ▁ since ▁ the ▁ value ▁ is ▁ stored ▁ on ▁ 11 ▁ bits ) ENDCOM attiandrng = ( ( uint16_t ) roundf ( ( _ahrs . roll_sensor + 18000 ) * 0.05f ) & ATTIANDRNG_ROLL_LIMIT ) ; // ▁ pitch ▁ from ▁ [ -9000;9000 ] ▁ centidegrees ▁ to ▁ unsigned ▁ . 2 ▁ degree ▁ increments ▁ [ 0;900 ] ▁ ( just ▁ in ▁ case , ▁ limit ▁ to ▁ 1023 ▁ ( 0x3FF ) ▁ since ▁ the ▁ value ▁ is ▁ stored ▁ on ▁ 10 ▁ bits ) ENDCOM attiandrng |= ( ( uint16_t ) roundf ( ( _ahrs . pitch_sensor + 9000 ) * 0.05f ) & ATTIANDRNG_PITCH_LIMIT ) << ATTIANDRNG_PITCH_OFFSET ; // ▁ rangefinder ▁ measurement ▁ in ▁ cm ENDCOM attiandrng |= prep_number ( _rng . distance_cm_orient ( ROTATION_PITCH_270 ) , 3 , 1 ) << ATTIANDRNG_RNGFND_OFFSET ; return attiandrng ; } /* STRNEWLINE ▁ * ▁ prepare ▁ value ▁ for ▁ transmission ▁ through ▁ FrSky ▁ link STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ SPort ▁ Passthrough ▁ ( OpenTX ) ▁ protocol ▁ ( X - receivers ) STRNEWLINE ▁ */ uint16_t AP_Frsky_Telem :: prep_number ( int32_t number , uint8_t digits , uint8_t power ) { uint16_t res = 0 ; uint32_t abs_number = abs ( number ) ; if ( ( digits == 2 ) && ( power == 1 ) ) { // ▁ number ▁ encoded ▁ on ▁ 8 ▁ bits : ▁ 7 ▁ bits ▁ for ▁ digits ▁ + ▁ 1 ▁ for ▁ 10 ^ power ENDCOM if ( abs_number < 100 ) { res = abs_number << 1 ; } else if ( abs_number < 1270 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.1f ) << 1 ) | 0x1 ; } else { // ▁ transmit ▁ max ▁ possible ▁ value ▁ ( 0x7F ▁ x ▁ 10 ^ 1 ▁ = ▁ 1270 ) ENDCOM res = 0xFF ; } if ( number < 0 ) { // ▁ if ▁ number ▁ is ▁ negative , ▁ add ▁ sign ▁ bit ▁ in ▁ front ENDCOM res |= 0x1 << 8 ; } } else if ( ( digits == 2 ) && ( power == 2 ) ) { // ▁ number ▁ encoded ▁ on ▁ 9 ▁ bits : ▁ 7 ▁ bits ▁ for ▁ digits ▁ + ▁ 2 ▁ for ▁ 10 ^ power ENDCOM if ( abs_number < 100 ) { res = abs_number << 2 ; } else if ( abs_number < 1000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.1f ) << 2 ) | 0x1 ; } else if ( abs_number < 10000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.01f ) << 2 ) | 0x2 ; } else if ( abs_number < 127000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.001f ) << 2 ) | 0x3 ; } else { // ▁ transmit ▁ max ▁ possible ▁ value ▁ ( 0x7F ▁ x ▁ 10 ^ 3 ▁ = ▁ 127000 ) ENDCOM res = 0x1FF ; } if ( number < 0 ) { // ▁ if ▁ number ▁ is ▁ negative , ▁ add ▁ sign ▁ bit ▁ in ▁ front ENDCOM res |= 0x1 << 9 ; } } else if ( ( digits == 3 ) && ( power == 1 ) ) { // ▁ number ▁ encoded ▁ on ▁ 11 ▁ bits : ▁ 10 ▁ bits ▁ for ▁ digits ▁ + ▁ 1 ▁ for ▁ 10 ^ power ENDCOM if ( abs_number < 1000 ) { res = abs_number << 1 ; } else if ( abs_number < 10240 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.1f ) << 1 ) | 0x1 ; } else { // ▁ transmit ▁ max ▁ possible ▁ value ▁ ( 0x3FF ▁ x ▁ 10 ^ 1 ▁ = ▁ 10240 ) ENDCOM res = 0x7FF ; } if ( number < 0 ) { // ▁ if ▁ number ▁ is ▁ negative , ▁ add ▁ sign ▁ bit ▁ in ▁ front ENDCOM res |= 0x1 << 11 ; } } else if ( ( digits == 3 ) && ( power == 2 ) ) { // ▁ number ▁ encoded ▁ on ▁ 12 ▁ bits : ▁ 10 ▁ bits ▁ for ▁ digits ▁ + ▁ 2 ▁ for ▁ 10 ^ power ENDCOM if ( abs_number < 1000 ) { res = abs_number << 2 ; } else if ( abs_number < 10000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.1f ) << 2 ) | 0x1 ; } else if ( abs_number < 100000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.01f ) << 2 ) | 0x2 ; } else if ( abs_number < 1024000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.001f ) << 2 ) | 0x3 ; } else { // ▁ transmit ▁ max ▁ possible ▁ value ▁ ( 0x3FF ▁ x ▁ 10 ^ 3 ▁ = ▁ 127000 ) ENDCOM res = 0xFFF ; } if ( number < 0 ) { // ▁ if ▁ number ▁ is ▁ negative , ▁ add ▁ sign ▁ bit ▁ in ▁ front ENDCOM res |= 0x1 << 12 ; } } return res ; } /* STRNEWLINE ▁ * ▁ prepare ▁ altitude ▁ between ▁ vehicle ▁ and ▁ home ▁ location ▁ data STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ D ▁ and ▁ SPort ▁ protocols STRNEWLINE ▁ */ void AP_Frsky_Telem :: calc_nav_alt ( void ) { Location loc ; float current_height = 0 ; // ▁ in ▁ centimeters ▁ above ▁ home ENDCOM if ( _ahrs . get_position ( loc ) ) { current_height = loc . alt * 0.01f ; if ( ! loc . flags . relative_alt ) { // ▁ loc . alt ▁ has ▁ home ▁ altitude ▁ added , ▁ remove ▁ it ENDCOM current_height -= _ahrs . get_home ( ) . alt * 0.01f ; } } _gps . alt_nav_meters = ( int16_t ) current_height ; _gps . alt_nav_cm = ( current_height - _gps . alt_nav_meters ) * 100 ; } /* STRNEWLINE ▁ * ▁ format ▁ the ▁ decimal ▁ latitude / longitude ▁ to ▁ the ▁ required ▁ degrees / minutes STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ D ▁ and ▁ SPort ▁ protocols STRNEWLINE ▁ */ float AP_Frsky_Telem :: format_gps ( float dec ) { uint8_t dm_deg = ( uint8_t ) dec ; return ( dm_deg * 100.0f ) + ( dec - dm_deg ) * 60 ; } /* STRNEWLINE ▁ * ▁ prepare ▁ gps ▁ data STRNEWLINE ▁ * ▁ for ▁ FrSky ▁ D ▁ and ▁ SPort ▁ protocols STRNEWLINE ▁ */ void AP_Frsky_Telem :: calc_gps_position ( void ) { float lat ; float lon ; float alt ; float speed ; if ( AP :: gps ( ) . status ( ) >= 3 ) { const Location & loc = AP :: gps ( ) . location ( ) ; // get ▁ gps ▁ instance ▁ 0 ENDCOM lat = format_gps ( fabsf ( loc . lat / 10000000.0f ) ) ; _gps . latdddmm = lat ; _gps . latmmmm = ( lat - _gps . latdddmm ) * 10000 ; _gps . lat_ns = ( loc . lat < 0 ) ? ' S ' : ' N ' ; lon = format_gps ( fabsf ( loc . lng / 10000000.0f ) ) ; _gps . londddmm = lon ; _gps . lonmmmm = ( lon - _gps . londddmm ) * 10000 ; _gps . lon_ew = ( loc . lng < 0 ) ? ' W ' : ' E ' ; alt = loc . alt * 0.01f ; _gps . alt_gps_meters = ( int16_t ) alt ; _gps . alt_gps_cm = ( alt - _gps . alt_gps_meters ) * 100 ; speed = AP :: gps ( ) . ground_speed ( ) ; _gps . speed_in_meter = speed ; _gps . speed_in_centimeter = ( speed - _gps . speed_in_meter ) * 100 ; } else { _gps . latdddmm = 0 ; _gps . latmmmm = 0 ; _gps . lat_ns = 0 ; _gps . londddmm = 0 ; _gps . lonmmmm = 0 ; _gps . alt_gps_meters = 0 ; _gps . alt_gps_cm = 0 ; _gps . speed_in_meter = 0 ; _gps . speed_in_centimeter = 0 ; } } </DOCUMENT>
<DOCUMENT_ID="plexinc/plex-home-theater-public/tree/master/plex/Update-Installer/external/win32cpp/tutorials/Tutorial8/View.cpp"> // ▁ View . cpp ENDCOM // ▁ Definitions ▁ for ▁ the ▁ CView ▁ class ENDCOM # include " view . h " # include " GDI . h " # include " file . h " # include " resource . h " using namespace std ; CView :: CView ( ) : m_PenColor ( RGB ( 0 , 0 , 0 ) ) { m_Brush . CreateSolidBrush ( RGB ( 255 , 255 , 230 ) ) ; } CView :: ~ CView ( ) { } void CView :: ClearPoints ( ) { m_points . clear ( ) ; Invalidate ( ) ; } void CView :: DrawLine ( int x , int y ) { CClientDC dcClient ( this ) ; dcClient . CreatePen ( PS_SOLID , 1 , m_points . back ( ) . color ) ; dcClient . MoveTo ( m_points . back ( ) . x , m_points . back ( ) . y ) ; dcClient . LineTo ( x , y ) ; } void CView :: OnDraw ( CDC * pDC ) { if ( m_points . size ( ) > 0 ) { bool bDraw = false ; // Start ▁ with ▁ the ▁ pen ▁ up ENDCOM for ( unsigned int i = 0 ; i < m_points . size ( ) ; i ++ ) { pDC -> CreatePen ( PS_SOLID , 1 , m_points [ i ] . color ) ; if ( bDraw ) pDC -> LineTo ( m_points [ i ] . x , m_points [ i ] . y ) ; else pDC -> MoveTo ( m_points [ i ] . x , m_points [ i ] . y ) ; bDraw = m_points [ i ] . PenDown ; } } } void CView :: PreCreate ( CREATESTRUCT & cs ) { // ▁ Set ▁ the ▁ extra ▁ style ▁ to ▁ provide ▁ a ▁ sunken ▁ effect ENDCOM cs . dwExStyle = WS_EX_CLIENTEDGE ; } void CView :: PreRegisterClass ( WNDCLASS & wc ) { // ▁ Set ▁ the ▁ background ▁ brush , ▁ class ▁ name ▁ and ▁ cursor ENDCOM wc . hbrBackground = m_Brush ; wc . lpszClassName = _T ( " Scribble ▁ Window " ) ; wc . hCursor = :: LoadCursor ( GetApp ( ) -> GetInstanceHandle ( ) , MAKEINTRESOURCE ( IDC_CURSOR1 ) ) ; } BOOL CView :: FileOpen ( LPCTSTR szFilename ) { // ▁ empty ▁ the ▁ PlotPoint ▁ vector ENDCOM m_points . clear ( ) ; DWORD nBytesRead ; BOOL bResult = FALSE ; // ▁ Create ▁ a ▁ handle ▁ to ▁ the ▁ file ENDCOM CFile File ; if ( File . Open ( szFilename , OPEN_EXISTING ) ) { do { PlotPoint pp ; nBytesRead = File . Read ( & pp , sizeof ( PlotPoint ) ) ; if ( nBytesRead == sizeof ( PlotPoint ) ) m_points . push_back ( pp ) ; } while ( nBytesRead == sizeof ( PlotPoint ) ) ; if ( ( 0 != nBytesRead ) || ( m_points . empty ( ) ) ) { // ▁ Failed ▁ to ▁ read ▁ all ▁ of ▁ the ▁ file ENDCOM m_points . clear ( ) ; :: MessageBox ( 0 , _T ( " Invalid ▁ data ▁ in ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; } else bResult = TRUE ; } else { tString tsErrMsg = _T ( " Failed ▁ to ▁ open ▁ file ▁ " ) ; tsErrMsg += szFilename ; :: MessageBox ( 0 , tsErrMsg . c_str ( ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; } Invalidate ( ) ; return bResult ; } BOOL CView :: FileSave ( LPCTSTR szFilename ) { BOOL bResult = TRUE ; CFile hFile ; if ( ! hFile . Open ( szFilename , CREATE_ALWAYS ) ) { :: MessageBox ( 0 , _T ( " Failed ▁ to ▁ open ▁ file ▁ for ▁ writing " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; } if ( bResult ) { // ▁ Write ▁ the ▁ file ENDCOM for ( size_t i = 0 ; i < m_points . size ( ) ; ++ i ) { if ( ! hFile . Write ( & m_points [ i ] , sizeof ( PlotPoint ) ) ) { :: MessageBox ( 0 , _T ( " Error ▁ while ▁ writing ▁ to ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; break ; } } // ▁ Verify ▁ file ▁ length ENDCOM if ( hFile . GetLength ( ) != m_points . size ( ) * sizeof ( PlotPoint ) ) { :: MessageBox ( 0 , _T ( " Error ▁ while ▁ writing ▁ to ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; } } return bResult ; } void CView :: SetPen ( COLORREF color ) { m_PenColor = color ; } void CView :: StorePoint ( int x , int y , bool PenDown ) { PlotPoint P1 ; P1 . x = x ; P1 . y = y ; P1 . PenDown = PenDown ; P1 . color = m_PenColor ; m_points . push_back ( P1 ) ; // Add ▁ the ▁ point ▁ to ▁ the ▁ vector ENDCOM } void CView :: OnLButtonDown ( LPARAM lParam ) { // ▁ Capture ▁ mouse ▁ input . ENDCOM SetCapture ( ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , true ) ; } void CView :: OnLButtonUp ( LPARAM lParam ) { { // Release ▁ the ▁ capture ▁ on ▁ the ▁ mouse ENDCOM ReleaseCapture ( ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , false ) ; } } void CView :: OnMouseMove ( WPARAM wParam , LPARAM lParam ) { // ▁ hold ▁ down ▁ the ▁ left ▁ mouse ▁ button ▁ and ▁ move ▁ mouse ▁ to ▁ draw ▁ lines . ENDCOM if ( ( wParam & MK_LBUTTON ) && ( GetCapture ( ) == this ) ) { DrawLine ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , true ) ; } } LRESULT CView :: WndProc ( UINT uMsg , WPARAM wParam , LPARAM lParam ) { switch ( uMsg ) { case WM_LBUTTONDOWN : OnLButtonDown ( lParam ) ; break ; case WM_MOUSEMOVE : OnMouseMove ( wParam , lParam ) ; break ; case WM_LBUTTONUP : OnLButtonUp ( lParam ) ; break ; } // Use ▁ the ▁ default ▁ message ▁ handling ▁ for ▁ remaining ▁ messages ENDCOM return WndProcDefault ( uMsg , wParam , lParam ) ; } </DOCUMENT>
<DOCUMENT_ID="relipse/onethfour-chess-client/tree/master/src/quazip/JlCompress.cpp"> # include " JlCompress . h " # include < QDebug > static bool copyData ( QIODevice & inFile , QIODevice & outFile ) { while ( ! inFile . atEnd ( ) ) { char buf [ 4096 ] ; qint64 readLen = inFile . read ( buf , 4096 ) ; if ( readLen <= 0 ) return false ; if ( outFile . write ( buf , readLen ) != readLen ) return false ; } return true ; } /* * OK STRNEWLINE ▁ * ▁ Comprime ▁ il ▁ file ▁ fileName , ▁ nell ' oggetto ▁ zip , ▁ con ▁ il ▁ nome ▁ fileDest . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ La ▁ funzione ▁ fallisce ▁ se : STRNEWLINE ▁ * ▁ * ▁ zip = = NULL ; STRNEWLINE ▁ * ▁ * ▁ l ' oggetto ▁ zip ▁ e ▁ stato ▁ aperto ▁ in ▁ una ▁ modalita ▁ non ▁ compatibile ▁ con ▁ l ' aggiunta ▁ di ▁ file ; STRNEWLINE ▁ * ▁ * ▁ non ▁ e ▁ possibile ▁ aprire ▁ il ▁ file ▁ d ' origine ; STRNEWLINE ▁ * ▁ * ▁ non ▁ e ▁ possibile ▁ creare ▁ il ▁ file ▁ all ' interno ▁ dell ' oggetto ▁ zip ; STRNEWLINE ▁ * ▁ * ▁ si ▁ e ▁ rilevato ▁ un ▁ errore ▁ nella ▁ copia ▁ dei ▁ dati ; STRNEWLINE ▁ * ▁ * ▁ non ▁ e ▁ stato ▁ possibile ▁ chiudere ▁ il ▁ file ▁ all ' interno ▁ dell ' oggetto ▁ zip ; STRNEWLINE ▁ */ bool JlCompress :: compressFile ( QuaZip * zip , QString fileName , QString fileDest ) { // ▁ zip : ▁ oggetto ▁ dove ▁ aggiungere ▁ il ▁ file ENDCOM // ▁ fileName : ▁ nome ▁ del ▁ file ▁ reale ENDCOM // ▁ fileDest : ▁ nome ▁ del ▁ file ▁ all ' interno ▁ del ▁ file ▁ compresso ENDCOM // ▁ Controllo ▁ l ' apertura ▁ dello ▁ zip ENDCOM if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdCreate && zip -> getMode ( ) != QuaZip :: mdAppend && zip -> getMode ( ) != QuaZip :: mdAdd ) return false ; // ▁ Apro ▁ il ▁ file ▁ originale ENDCOM QFile inFile ; inFile . setFileName ( fileName ) ; if ( ! inFile . open ( QIODevice :: ReadOnly ) ) return false ; // ▁ Apro ▁ il ▁ file ▁ risulato ENDCOM QuaZipFile outFile ( zip ) ; if ( ! outFile . open ( QIODevice :: WriteOnly , QuaZipNewInfo ( fileDest , inFile . fileName ( ) ) ) ) return false ; // ▁ Copio ▁ i ▁ dati ENDCOM if ( ! copyData ( inFile , outFile ) || outFile . getZipError ( ) != UNZ_OK ) { return false ; } // ▁ Chiudo ▁ i ▁ file ENDCOM outFile . close ( ) ; if ( outFile . getZipError ( ) != UNZ_OK ) return false ; inFile . close ( ) ; return true ; } /* * OK STRNEWLINE ▁ * ▁ Comprime ▁ la ▁ cartella ▁ dir ▁ nel ▁ file ▁ fileCompressed , ▁ se ▁ recursive ▁ e ▁ true ▁ allora STRNEWLINE ▁ * ▁ comprime ▁ anche ▁ le ▁ sotto ▁ cartelle . ▁ I ▁ nomi ▁ dei ▁ file ▁ preceduti ▁ dal ▁ path ▁ creato STRNEWLINE ▁ * ▁ togliendo ▁ il ▁ pat ▁ della ▁ cartella ▁ origDir ▁ al ▁ path ▁ della ▁ cartella ▁ dir . STRNEWLINE ▁ * ▁ Se ▁ la ▁ funzione ▁ fallisce ▁ restituisce ▁ false ▁ e ▁ cancella ▁ il ▁ file ▁ che ▁ si ▁ e ▁ tentato STRNEWLINE ▁ * ▁ di ▁ creare . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ La ▁ funzione ▁ fallisce ▁ se : STRNEWLINE ▁ * ▁ * ▁ zip = = NULL ; STRNEWLINE ▁ * ▁ * ▁ l ' oggetto ▁ zip ▁ e ▁ stato ▁ aperto ▁ in ▁ una ▁ modalita ▁ non ▁ compatibile ▁ con ▁ l ' aggiunta ▁ di ▁ file ; STRNEWLINE ▁ * ▁ * ▁ la ▁ cartella ▁ dir ▁ non ▁ esiste ; STRNEWLINE ▁ * ▁ * ▁ la ▁ compressione ▁ di ▁ una ▁ sotto ▁ cartella ▁ fallisce ▁ ( 1 ) ; STRNEWLINE ▁ * ▁ * ▁ la ▁ compressione ▁ di ▁ un ▁ file ▁ fallisce ; STRNEWLINE ▁ * ▁ ( 1 ) ▁ La ▁ funzione ▁ si ▁ richiama ▁ in ▁ maniera ▁ ricorsiva ▁ per ▁ comprimere ▁ le ▁ sotto ▁ cartelle STRNEWLINE ▁ * ▁ dunque ▁ gli ▁ errori ▁ di ▁ compressione ▁ di ▁ una ▁ sotto ▁ cartella ▁ sono ▁ gli ▁ stessi ▁ di ▁ questa STRNEWLINE ▁ * ▁ funzione . STRNEWLINE ▁ */ bool JlCompress :: compressSubDir ( QuaZip * zip , QString dir , QString origDir , bool recursive ) { // ▁ zip : ▁ oggetto ▁ dove ▁ aggiungere ▁ il ▁ file ENDCOM // ▁ dir : ▁ cartella ▁ reale ▁ corrente ENDCOM // ▁ origDir : ▁ cartella ▁ reale ▁ originale ENDCOM // ▁ ( path ( dir ) - path ( origDir ) ) ▁ = ▁ path ▁ interno ▁ all ' oggetto ▁ zip ENDCOM // ▁ Controllo ▁ l ' apertura ▁ dello ▁ zip ENDCOM if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdCreate && zip -> getMode ( ) != QuaZip :: mdAppend && zip -> getMode ( ) != QuaZip :: mdAdd ) return false ; // ▁ Controllo ▁ la ▁ cartella ENDCOM QDir directory ( dir ) ; if ( ! directory . exists ( ) ) return false ; // ▁ Se ▁ comprimo ▁ anche ▁ le ▁ sotto ▁ cartelle ENDCOM if ( recursive ) { // ▁ Per ▁ ogni ▁ sotto ▁ cartella ENDCOM QFileInfoList files = directory . entryInfoList ( QDir :: AllDirs | QDir :: NoDotAndDotDot ) ; Q_FOREACH ( QFileInfo file , files ) { // ▁ Comprimo ▁ la ▁ sotto ▁ cartella ENDCOM if ( ! compressSubDir ( zip , file . absoluteFilePath ( ) , origDir , recursive ) ) return false ; } } // ▁ Per ▁ ogni ▁ file ▁ nella ▁ cartella ENDCOM QFileInfoList files = directory . entryInfoList ( QDir :: Files ) ; QDir origDirectory ( origDir ) ; Q_FOREACH ( QFileInfo file , files ) { // ▁ Se ▁ non ▁ e ▁ un ▁ file ▁ o ▁ e ▁ il ▁ file ▁ compresso ▁ che ▁ sto ▁ creando ENDCOM if ( ! file . isFile ( ) || file . absoluteFilePath ( ) == zip -> getZipName ( ) ) continue ; // ▁ Creo ▁ il ▁ nome ▁ relativo ▁ da ▁ usare ▁ all ' interno ▁ del ▁ file ▁ compresso ENDCOM QString filename = origDirectory . relativeFilePath ( file . absoluteFilePath ( ) ) ; // ▁ Comprimo ▁ il ▁ file ENDCOM if ( ! compressFile ( zip , file . absoluteFilePath ( ) , filename ) ) return false ; } return true ; } /* * OK STRNEWLINE ▁ * ▁ Estrae ▁ il ▁ file ▁ fileName , ▁ contenuto ▁ nell ' oggetto ▁ zip , ▁ con ▁ il ▁ nome ▁ fileDest . STRNEWLINE ▁ * ▁ Se ▁ la ▁ funzione ▁ fallisce ▁ restituisce ▁ false ▁ e ▁ cancella ▁ il ▁ file ▁ che ▁ si ▁ e ▁ tentato ▁ di ▁ estrarre . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ La ▁ funzione ▁ fallisce ▁ se : STRNEWLINE ▁ * ▁ * ▁ zip = = NULL ; STRNEWLINE ▁ * ▁ * ▁ l ' oggetto ▁ zip ▁ e ▁ stato ▁ aperto ▁ in ▁ una ▁ modalita ▁ non ▁ compatibile ▁ con ▁ l ' estrazione ▁ di ▁ file ; STRNEWLINE ▁ * ▁ * ▁ non ▁ e ▁ possibile ▁ aprire ▁ il ▁ file ▁ all ' interno ▁ dell ' oggetto ▁ zip ; STRNEWLINE ▁ * ▁ * ▁ non ▁ e ▁ possibile ▁ creare ▁ il ▁ file ▁ estratto ; STRNEWLINE ▁ * ▁ * ▁ si ▁ e ▁ rilevato ▁ un ▁ errore ▁ nella ▁ copia ▁ dei ▁ dati ▁ ( 1 ) ; STRNEWLINE ▁ * ▁ * ▁ non ▁ e ▁ stato ▁ possibile ▁ chiudere ▁ il ▁ file ▁ all ' interno ▁ dell ' oggetto ▁ zip ▁ ( 1 ) ; STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ ( 1 ) : ▁ prima ▁ di ▁ uscire ▁ dalla ▁ funzione ▁ cancella ▁ il ▁ file ▁ estratto . STRNEWLINE ▁ */ bool JlCompress :: extractFile ( QuaZip * zip , QString fileName , QString fileDest ) { // ▁ zip : ▁ oggetto ▁ dove ▁ aggiungere ▁ il ▁ file ENDCOM // ▁ filename : ▁ nome ▁ del ▁ file ▁ reale ENDCOM // ▁ fileincompress : ▁ nome ▁ del ▁ file ▁ all ' interno ▁ del ▁ file ▁ compresso ENDCOM // ▁ Controllo ▁ l ' apertura ▁ dello ▁ zip ENDCOM if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdUnzip ) return false ; // ▁ Apro ▁ il ▁ file ▁ compresso ENDCOM if ( ! fileName . isEmpty ( ) ) zip -> setCurrentFile ( fileName ) ; QuaZipFile inFile ( zip ) ; if ( ! inFile . open ( QIODevice :: ReadOnly ) || inFile . getZipError ( ) != UNZ_OK ) return false ; // ▁ Controllo ▁ esistenza ▁ cartella ▁ file ▁ risultato ENDCOM QDir curDir ; if ( ! curDir . mkpath ( QFileInfo ( fileDest ) . absolutePath ( ) ) ) { return false ; } if ( QFileInfo ( fileDest ) . isDir ( ) ) return true ; // ▁ Apro ▁ il ▁ file ▁ risultato ENDCOM QFile outFile ; outFile . setFileName ( fileDest ) ; if ( ! outFile . open ( QIODevice :: WriteOnly ) ) return false ; // ▁ Copio ▁ i ▁ dati ENDCOM if ( ! copyData ( inFile , outFile ) || inFile . getZipError ( ) != UNZ_OK ) { outFile . close ( ) ; removeFile ( QStringList ( fileDest ) ) ; return false ; } outFile . close ( ) ; // ▁ Chiudo ▁ i ▁ file ENDCOM inFile . close ( ) ; if ( inFile . getZipError ( ) != UNZ_OK ) { removeFile ( QStringList ( fileDest ) ) ; return false ; } return true ; } /* * STRNEWLINE ▁ * ▁ Rimuove ▁ i ▁ file ▁ il ▁ cui ▁ nome ▁ e ▁ specificato ▁ all ' interno ▁ di ▁ listFile . STRNEWLINE ▁ * ▁ Restituisce ▁ true ▁ se ▁ tutti ▁ i ▁ file ▁ sono ▁ stati ▁ cancellati ▁ correttamente , ▁ attenzione STRNEWLINE ▁ * ▁ perche ▁ puo ▁ restituire ▁ false ▁ anche ▁ se ▁ alcuni ▁ file ▁ non ▁ esistevano ▁ e ▁ si ▁ e ▁ tentato STRNEWLINE ▁ * ▁ di ▁ cancellarli . STRNEWLINE ▁ */ bool JlCompress :: removeFile ( QStringList listFile ) { bool ret = true ; // ▁ Per ▁ ogni ▁ file ENDCOM for ( int i = 0 ; i < listFile . count ( ) ; i ++ ) { // ▁ Lo ▁ elimino ENDCOM ret = ret && QFile :: remove ( listFile . at ( i ) ) ; } return ret ; } /* * OK STRNEWLINE ▁ * ▁ Comprime ▁ il ▁ file ▁ fileName ▁ nel ▁ file ▁ fileCompressed . STRNEWLINE ▁ * ▁ Se ▁ la ▁ funzione ▁ fallisce ▁ restituisce ▁ false ▁ e ▁ cancella ▁ il ▁ file ▁ che ▁ si ▁ e ▁ tentato STRNEWLINE ▁ * ▁ di ▁ creare . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ La ▁ funzione ▁ fallisce ▁ se : STRNEWLINE ▁ * ▁ * ▁ non ▁ si ▁ riesce ▁ ad ▁ aprire ▁ l ' oggetto ▁ zip ; STRNEWLINE ▁ * ▁ * ▁ la ▁ compressione ▁ del ▁ file ▁ fallisce ; STRNEWLINE ▁ * ▁ * ▁ non ▁ si ▁ riesce ▁ a ▁ chiudere ▁ l ' oggetto ▁ zip ; STRNEWLINE ▁ */ bool JlCompress :: compressFile ( QString fileCompressed , QString file ) { // ▁ Creo ▁ lo ▁ zip ENDCOM QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } // ▁ Aggiungo ▁ il ▁ file ENDCOM if ( ! compressFile ( & zip , file , QFileInfo ( file ) . fileName ( ) ) ) { QFile :: remove ( fileCompressed ) ; return false ; } // ▁ Chiudo ▁ il ▁ file ▁ zip ENDCOM zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; } /* * OK STRNEWLINE ▁ * ▁ Comprime ▁ i ▁ file ▁ specificati ▁ in ▁ files ▁ nel ▁ file ▁ fileCompressed . STRNEWLINE ▁ * ▁ Se ▁ la ▁ funzione ▁ fallisce ▁ restituisce ▁ false ▁ e ▁ cancella ▁ il ▁ file ▁ che ▁ si ▁ e ▁ tentato STRNEWLINE ▁ * ▁ di ▁ creare . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ La ▁ funzione ▁ fallisce ▁ se : STRNEWLINE ▁ * ▁ * ▁ non ▁ si ▁ riesce ▁ ad ▁ aprire ▁ l ' oggetto ▁ zip ; STRNEWLINE ▁ * ▁ * ▁ la ▁ compressione ▁ di ▁ un ▁ file ▁ fallisce ; STRNEWLINE ▁ * ▁ * ▁ non ▁ si ▁ riesce ▁ a ▁ chiudere ▁ l ' oggetto ▁ zip ; STRNEWLINE ▁ */ bool JlCompress :: compressFiles ( QString fileCompressed , QStringList files ) { // ▁ Creo ▁ lo ▁ zip ENDCOM QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } // ▁ Comprimo ▁ i ▁ file ENDCOM QFileInfo info ; Q_FOREACH ( QString file , files ) { info . setFile ( file ) ; if ( ! info . exists ( ) || ! compressFile ( & zip , file , info . fileName ( ) ) ) { QFile :: remove ( fileCompressed ) ; return false ; } } // ▁ Chiudo ▁ il ▁ file ▁ zip ENDCOM zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; } /* * OK STRNEWLINE ▁ * ▁ Comprime ▁ la ▁ cartella ▁ dir ▁ nel ▁ file ▁ fileCompressed , ▁ se ▁ recursive ▁ e ▁ true ▁ allora STRNEWLINE ▁ * ▁ comprime ▁ anche ▁ le ▁ sotto ▁ cartelle . STRNEWLINE ▁ * ▁ Se ▁ la ▁ funzione ▁ fallisce ▁ restituisce ▁ false ▁ e ▁ cancella ▁ il ▁ file ▁ che ▁ si ▁ e ▁ tentato STRNEWLINE ▁ * ▁ di ▁ creare . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ La ▁ funzione ▁ fallisce ▁ se : STRNEWLINE ▁ * ▁ * ▁ non ▁ si ▁ riesce ▁ ad ▁ aprire ▁ l ' oggetto ▁ zip ; STRNEWLINE ▁ * ▁ * ▁ la ▁ compressione ▁ di ▁ un ▁ file ▁ fallisce ; STRNEWLINE ▁ * ▁ * ▁ non ▁ si ▁ riesce ▁ a ▁ chiudere ▁ l ' oggetto ▁ zip ; STRNEWLINE ▁ */ bool JlCompress :: compressDir ( QString fileCompressed , QString dir , bool recursive ) { // ▁ Creo ▁ lo ▁ zip ENDCOM QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } // ▁ Aggiungo ▁ i ▁ file ▁ e ▁ le ▁ sotto ▁ cartelle ENDCOM if ( ! compressSubDir ( & zip , dir , dir , recursive ) ) { QFile :: remove ( fileCompressed ) ; return false ; } // ▁ Chiudo ▁ il ▁ file ▁ zip ENDCOM zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; } /* * OK STRNEWLINE ▁ * ▁ Estrae ▁ il ▁ file ▁ fileName , ▁ contenuto ▁ nel ▁ file ▁ fileCompressed , ▁ con ▁ il ▁ nome ▁ fileDest . STRNEWLINE ▁ * ▁ Se ▁ fileDest ▁ = ▁ " " ▁ allora ▁ il ▁ file ▁ viene ▁ estratto ▁ con ▁ lo ▁ stesso ▁ nome ▁ con ▁ cui ▁ e STRNEWLINE ▁ * ▁ stato ▁ compresso . STRNEWLINE ▁ * ▁ Se ▁ la ▁ funzione ▁ fallisce ▁ cancella ▁ il ▁ file ▁ che ▁ si ▁ e ▁ tentato ▁ di ▁ estrarre . STRNEWLINE ▁ * ▁ Restituisce ▁ il ▁ nome ▁ assoluto ▁ del ▁ file ▁ estratto . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ La ▁ funzione ▁ fallisce ▁ se : STRNEWLINE ▁ * ▁ * ▁ non ▁ si ▁ riesce ▁ ad ▁ aprire ▁ l ' oggetto ▁ zip ; STRNEWLINE ▁ * ▁ * ▁ l ' estrazione ▁ del ▁ file ▁ fallisce ; STRNEWLINE ▁ * ▁ * ▁ non ▁ si ▁ riesce ▁ a ▁ chiudere ▁ l ' oggetto ▁ zip ; STRNEWLINE ▁ */ QString JlCompress :: extractFile ( QString fileCompressed , QString fileName , QString fileDest ) { // ▁ Apro ▁ lo ▁ zip ENDCOM QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QString ( ) ; } // ▁ Estraggo ▁ il ▁ file ENDCOM if ( fileDest . isEmpty ( ) ) fileDest = fileName ; if ( ! extractFile ( & zip , fileName , fileDest ) ) { return QString ( ) ; } // ▁ Chiudo ▁ il ▁ file ▁ zip ENDCOM zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( QStringList ( fileDest ) ) ; return QString ( ) ; } return QFileInfo ( fileDest ) . absoluteFilePath ( ) ; } /* * OK STRNEWLINE ▁ * ▁ Estrae ▁ i ▁ file ▁ specificati ▁ in ▁ files , ▁ contenuti ▁ nel ▁ file ▁ fileCompressed , ▁ nella STRNEWLINE ▁ * ▁ cartella ▁ dir . ▁ La ▁ struttura ▁ a ▁ cartelle ▁ del ▁ file ▁ compresso ▁ viene ▁ rispettata . STRNEWLINE ▁ * ▁ Se ▁ dir ▁ = ▁ " " ▁ allora ▁ il ▁ file ▁ viene ▁ estratto ▁ nella ▁ cartella ▁ corrente . STRNEWLINE ▁ * ▁ Se ▁ la ▁ funzione ▁ fallisce ▁ cancella ▁ i ▁ file ▁ che ▁ si ▁ e ▁ tentato ▁ di ▁ estrarre . STRNEWLINE ▁ * ▁ Restituisce ▁ i ▁ nomi ▁ assoluti ▁ dei ▁ file ▁ estratti . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ La ▁ funzione ▁ fallisce ▁ se : STRNEWLINE ▁ * ▁ * ▁ non ▁ si ▁ riesce ▁ ad ▁ aprire ▁ l ' oggetto ▁ zip ; STRNEWLINE ▁ * ▁ * ▁ l ' estrazione ▁ di ▁ un ▁ file ▁ fallisce ; STRNEWLINE ▁ * ▁ * ▁ non ▁ si ▁ riesce ▁ a ▁ chiudere ▁ l ' oggetto ▁ zip ; STRNEWLINE ▁ */ QStringList JlCompress :: extractFiles ( QString fileCompressed , QStringList files , QString dir ) { // ▁ Creo ▁ lo ▁ zip ENDCOM QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QStringList ( ) ; } // ▁ Estraggo ▁ i ▁ file ENDCOM QStringList extracted ; for ( int i = 0 ; i < files . count ( ) ; i ++ ) { QString absPath = QDir ( dir ) . absoluteFilePath ( files . at ( i ) ) ; if ( ! extractFile ( & zip , files . at ( i ) , absPath ) ) { removeFile ( extracted ) ; return QStringList ( ) ; } extracted . append ( absPath ) ; } // ▁ Chiudo ▁ il ▁ file ▁ zip ENDCOM zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( extracted ) ; return QStringList ( ) ; } return extracted ; } /* * OK STRNEWLINE ▁ * ▁ Estrae ▁ il ▁ file ▁ fileCompressed ▁ nella ▁ cartella ▁ dir . STRNEWLINE ▁ * ▁ Se ▁ dir ▁ = ▁ " " ▁ allora ▁ il ▁ file ▁ viene ▁ estratto ▁ nella ▁ cartella ▁ corrente . STRNEWLINE ▁ * ▁ Se ▁ la ▁ funzione ▁ fallisce ▁ cancella ▁ i ▁ file ▁ che ▁ si ▁ e ▁ tentato ▁ di ▁ estrarre . STRNEWLINE ▁ * ▁ Restituisce ▁ i ▁ nomi ▁ assoluti ▁ dei ▁ file ▁ estratti . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ La ▁ funzione ▁ fallisce ▁ se : STRNEWLINE ▁ * ▁ * ▁ non ▁ si ▁ riesce ▁ ad ▁ aprire ▁ l ' oggetto ▁ zip ; STRNEWLINE ▁ * ▁ * ▁ la ▁ compressione ▁ di ▁ un ▁ file ▁ fallisce ; STRNEWLINE ▁ * ▁ * ▁ non ▁ si ▁ riesce ▁ a ▁ chiudere ▁ l ' oggetto ▁ zip ; STRNEWLINE ▁ */ QStringList JlCompress :: extractDir ( QString fileCompressed , QString dir ) { // ▁ Apro ▁ lo ▁ zip ENDCOM QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QStringList ( ) ; } QDir directory ( dir ) ; QStringList extracted ; if ( ! zip . goToFirstFile ( ) ) { return QStringList ( ) ; } do { QString name = zip . getCurrentFileName ( ) ; QString absFilePath = directory . absoluteFilePath ( name ) ; if ( ! extractFile ( & zip , " " , absFilePath ) ) { removeFile ( extracted ) ; return QStringList ( ) ; } extracted . append ( absFilePath ) ; } while ( zip . goToNextFile ( ) ) ; // ▁ Chiudo ▁ il ▁ file ▁ zip ENDCOM zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( extracted ) ; return QStringList ( ) ; } return extracted ; } /* * OK STRNEWLINE ▁ * ▁ Restituisce ▁ la ▁ lista ▁ dei ▁ file ▁ resenti ▁ nel ▁ file ▁ compresso ▁ fileCompressed . STRNEWLINE ▁ * ▁ Se ▁ la ▁ funzione ▁ fallisce , ▁ restituisce ▁ un ▁ elenco ▁ vuoto . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ La ▁ funzione ▁ fallisce ▁ se : STRNEWLINE ▁ * ▁ * ▁ non ▁ si ▁ riesce ▁ ad ▁ aprire ▁ l ' oggetto ▁ zip ; STRNEWLINE ▁ * ▁ * ▁ la ▁ richiesta ▁ di ▁ informazioni ▁ di ▁ un ▁ file ▁ fallisce ; STRNEWLINE ▁ * ▁ * ▁ non ▁ si ▁ riesce ▁ a ▁ chiudere ▁ l ' oggetto ▁ zip ; STRNEWLINE ▁ */ QStringList JlCompress :: getFileList ( QString fileCompressed ) { // ▁ Apro ▁ lo ▁ zip ENDCOM QuaZip * zip = new QuaZip ( QFileInfo ( fileCompressed ) . absoluteFilePath ( ) ) ; if ( ! zip -> open ( QuaZip :: mdUnzip ) ) { delete zip ; return QStringList ( ) ; } // ▁ Estraggo ▁ i ▁ nomi ▁ dei ▁ file ENDCOM QStringList lst ; QuaZipFileInfo info ; for ( bool more = zip -> goToFirstFile ( ) ; more ; more = zip -> goToNextFile ( ) ) { if ( ! zip -> getCurrentFileInfo ( & info ) ) { delete zip ; return QStringList ( ) ; } lst << info . name ; // info . name . toLocal8Bit ( ) . constData ( ) ENDCOM } // ▁ Chiudo ▁ il ▁ file ▁ zip ENDCOM zip -> close ( ) ; if ( zip -> getZipError ( ) != 0 ) { delete zip ; return QStringList ( ) ; } delete zip ; return lst ; } </DOCUMENT>
<DOCUMENT_ID="punker76/Windows-universal-samples/tree/master/Samples/XamlCloudFontIntegration/cpp/Scenario_Document1.xaml.cpp"> // ▁ Copyright ▁ ( c ) ▁ Microsoft . ▁ All ▁ rights ▁ reserved . ENDCOM // ▁ This ▁ code ▁ is ▁ licensed ▁ under ▁ the ▁ MIT ▁ License ▁ ( MIT ) . ENDCOM // ▁ THIS ▁ CODE ▁ IS ▁ PROVIDED ▁ * AS ▁ IS * ▁ WITHOUT ▁ WARRANTY ▁ OF ENDCOM // ▁ ANY ▁ KIND , ▁ EITHER ▁ EXPRESS ▁ OR ▁ IMPLIED , ▁ INCLUDING ▁ ANY ENDCOM // ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ENDCOM // ▁ PURPOSE , ▁ MERCHANTABILITY , ▁ OR ▁ NON - INFRINGEMENT . ENDCOM # include " pch . h " # include " Scenario _ Document1 . xaml . h " using namespace SDKTemplate ; using namespace Platform ; using namespace Windows :: Foundation ; using namespace Windows :: Foundation :: Collections ; using namespace Windows :: UI :: Xaml ; using namespace Windows :: UI :: Xaml :: Controls ; using namespace Windows :: UI :: Xaml :: Controls :: Primitives ; using namespace Windows :: UI :: Xaml :: Data ; using namespace Windows :: UI :: Xaml :: Input ; using namespace Windows :: UI :: Xaml :: Media ; using namespace Windows :: UI :: Xaml :: Navigation ; Scenario_Document1 :: Scenario_Document1 ( ) { InitializeComponent ( ) ; } void Scenario_Document1 :: Page_Loaded ( Platform :: Object ^ sender , Windows :: UI :: Xaml :: RoutedEventArgs ^ e ) { // ▁ Font ▁ formatting ▁ is ▁ being ▁ applied ▁ on ▁ page ▁ load ▁ rather ▁ than ▁ in ▁ XAML ▁ markup ENDCOM // ▁ so ▁ that ▁ the ▁ on - demand ▁ cloud ▁ font ▁ behavior ▁ can ▁ be ▁ experienced ▁ when ▁ the ENDCOM // ▁ app ▁ runs ▁ rather ▁ than ▁ when ▁ the ▁ XAML ▁ file ▁ is ▁ viewed ▁ in ▁ Visual ▁ Studio . ENDCOM // ▁ Formatting ▁ will ▁ be ▁ applied ▁ to ▁ all ▁ content ▁ elements ▁ in ▁ the ▁ page ▁ that ▁ don ' t ▁ ENDCOM // ▁ already ▁ have ▁ FontFamily ▁ set . ENDCOM this -> FontFamily = ref new Windows :: UI :: Xaml :: Media :: FontFamily ( " Neue ▁ Haas ▁ Grotesk ▁ Text ▁ Pro " ) ; } </DOCUMENT>
<DOCUMENT_ID="uwafsl/ardupilot/tree/master/libraries/AP_HAL_Linux/Util.cpp"> # include < AP_HAL / AP_HAL . h > # if CONFIG_HAL_BOARD == HAL_BOARD_LINUX # include < stdio . h > # include < stdarg . h > # include < sys / stat . h > # include < unistd . h > # include < stdlib . h > # include < errno . h > # include < time . h > # include < fcntl . h > extern const AP_HAL :: HAL & hal ; # include " ToneAlarm _ Raspilot . h " # include " Util . h " # include " Heat _ Pwm . h " using namespace Linux ; static int state ; # if CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_RASPILOT ToneAlarm_Raspilot Util :: _toneAlarm ; # else ToneAlarm Util :: _toneAlarm ; # endif void Util :: init ( int argc , char * const * argv ) { saved_argc = argc ; saved_argv = argv ; # ifdef HAL_UTILS_HEAT # if HAL_UTILS_HEAT == HAL_LINUX_HEAT_PWM _heat = new Linux :: HeatPwm ( HAL_LINUX_HEAT_PWM_NUM , HAL_LINUX_HEAT_KP , HAL_LINUX_HEAT_KI , HAL_LINUX_HEAT_PERIOD_NS , HAL_LINUX_HEAT_TARGET_TEMP ) ; # else # error Unrecognized Heat # endif // ▁ # if ENDCOM # else _heat = new Linux :: Heat ( ) ; # endif // ▁ # ifdef ENDCOM } void Util :: set_imu_temp ( float current ) { _heat -> set_imu_temp ( current ) ; } /* * STRNEWLINE ▁ return ▁ commandline ▁ arguments , ▁ if ▁ available STRNEWLINE */ void Util :: commandline_arguments ( uint8_t & argc , char * const * & argv ) { argc = saved_argc ; argv = saved_argv ; } bool Util :: toneAlarm_init ( ) { return _toneAlarm . init ( ) ; } void Util :: toneAlarm_set_tune ( uint8_t tone ) { _toneAlarm . set_tune ( tone ) ; } void Util :: _toneAlarm_timer_tick ( ) { if ( state == 0 ) { state = state + _toneAlarm . init_tune ( ) ; } else if ( state == 1 ) { state = state + _toneAlarm . set_note ( ) ; } if ( state == 2 ) { state = state + _toneAlarm . play ( ) ; } else if ( state == 3 ) { state = 1 ; } if ( _toneAlarm . is_tune_comp ( ) ) { state = 0 ; } } void Util :: set_system_clock ( uint64_t time_utc_usec ) { # if CONFIG_HAL_BOARD_SUBTYPE != HAL_BOARD_SUBTYPE_LINUX_NONE timespec ts ; ts . tv_sec = time_utc_usec / 1.0e6 ; ts . tv_nsec = ( time_utc_usec % 1000000 ) * 1000 ; clock_settime ( CLOCK_REALTIME , & ts ) ; # endif } bool Util :: is_chardev_node ( const char * path ) { struct stat st ; if ( ! path || lstat ( path , & st ) < 0 ) return false ; return S_ISCHR ( st . st_mode ) ; } /* STRNEWLINE ▁ always ▁ report ▁ 256k ▁ of ▁ free ▁ memory . ▁ Using ▁ mallinfo ( ) ▁ isn ' t ▁ useful ▁ as STRNEWLINE ▁ it ▁ only ▁ reported ▁ the ▁ current ▁ heap , ▁ which ▁ auto - expands . ▁ What ▁ we ' re STRNEWLINE ▁ trying ▁ to ▁ do ▁ here ▁ is ▁ ensure ▁ that ▁ code ▁ which ▁ checks ▁ for ▁ free ▁ memory STRNEWLINE ▁ before ▁ allocating ▁ objects ▁ does ▁ allow ▁ the ▁ allocation STRNEWLINE ▁ */ uint32_t Util :: available_memory ( void ) { return 256 * 1024 ; } int Util :: write_file ( const char * path , const char * fmt , ... ) { errno = 0 ; int fd = :: open ( path , O_WRONLY | O_CLOEXEC ) ; if ( fd == - 1 ) { return - errno ; } va_list args ; va_start ( args , fmt ) ; int ret = :: vdprintf ( fd , fmt , args ) ; int errno_bkp = errno ; :: close ( fd ) ; va_end ( args ) ; if ( ret < 1 ) { return - errno_bkp ; } return ret ; } int Util :: read_file ( const char * path , const char * fmt , ... ) { errno = 0 ; FILE * file = :: fopen ( path , " re " ) ; if ( ! file ) return - errno ; va_list args ; va_start ( args , fmt ) ; int ret = :: vfscanf ( file , fmt , args ) ; int errno_bkp = errno ; :: fclose ( file ) ; va_end ( args ) ; if ( ret < 1 ) return - errno_bkp ; return ret ; } const char * Linux :: Util :: _hw_names [ UTIL_NUM_HARDWARES ] = { [ UTIL_HARDWARE_RPI1 ] = " BCM2708" , [ UTIL_HARDWARE_RPI2 ] = " BCM2709" , [ UTIL_HARDWARE_BEBOP ] = " Mykonos3 ▁ board " , [ UTIL_HARDWARE_BEBOP2 ] = " Milos ▁ board " , } ; # define MAX_SIZE_LINE 50 int Util :: get_hw_arm32 ( ) { int ret = - ENOENT ; char buffer [ MAX_SIZE_LINE ] ; const char * hardware_description_entry = " Hardware " ; char * flag ; FILE * f ; f = fopen ( " / proc / cpuinfo " , " r " ) ; if ( f == NULL ) { ret = - errno ; goto end ; } while ( fgets ( buffer , MAX_SIZE_LINE , f ) != NULL ) { flag = strstr ( buffer , hardware_description_entry ) ; if ( flag != NULL ) { for ( uint8_t i = 0 ; i < UTIL_NUM_HARDWARES ; i ++ ) { if ( strstr ( buffer , _hw_names [ i ] ) != 0 ) { ret = i ; goto close_end ; } } } } close_end : fclose ( f ) ; end : return ret ; } # endif // ▁ CONFIG _ HAL _ BOARD ▁ = = ▁ HAL _ BOARD _ LINUX ENDCOM </DOCUMENT>
<DOCUMENT_ID="biojppm/c4stl/tree/master/bm/list/push_back/flat_fwd_list__paged__NumBytes_64___int32_t.cpp"> # include " benchmark / benchmark . h " # include " c4 / log . hpp " # include " c4 / allocator . hpp " # include " . . / list _ types . hpp " namespace bm = benchmark ; namespace c4 { template < class List > void BM_ListPushBack ( bm :: State & st ) { List li ; using T = typename List :: value_type ; T v { } ; size_t count = 0 ; while ( st . KeepRunning ( ) ) { for ( int i = 0 , e = st . range ( 0 ) ; i < e ; ++ i ) { if ( li . size ( ) == li . max_size ( ) ) li . clear ( ) ; li . push_back ( v ) ; ++ count ; } li . clear ( ) ; } st . SetComplexityN ( st . range ( 0 ) ) ; st . SetItemsProcessed ( count ) ; st . SetBytesProcessed ( count * sizeof ( T ) ) ; } BENCHMARK_TEMPLATE ( BM_ListPushBack , flat_fwd_list__paged < NumBytes < 64 > C4_COMMA int32_t > ) -> RangeMultiplier ( 2 ) -> Range ( 4 , 1 << 19 ) -> Complexity ( ) ; } // ▁ end ▁ namespace ▁ c4 ENDCOM BENCHMARK_MAIN ( ) </DOCUMENT>
<DOCUMENT_ID="jamesfowkes/DataLogger/tree/master/libraries/DLDataField/DLDataField.Manager.cpp"> /* STRNEWLINE ▁ * ▁ DLDataField . Manager . cpp STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Provides ▁ management ▁ of ▁ datafields ▁ for ▁ applications STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Author : ▁ James ▁ Fowkes STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ www . re - innovation . co . uk STRNEWLINE ▁ */ /* STRNEWLINE ▁ * ▁ Arduino / C + + ▁ Library ▁ Includes STRNEWLINE ▁ */ # ifdef ARDUINO # include < Arduino . h > # else # include < stdint . h > # include < stdio . h > # include < string . h > # endif # ifdef TEST # include < iostream > # endif /* STRNEWLINE ▁ * ▁ Datalogger ▁ Library ▁ Includes STRNEWLINE ▁ */ # include " DLUtility . Averager . h " # include " DLDataField . Types . h " # include " DLDataField . h " # include " DLDataField . Manager . h " # include " DLSettings . Reader . Errors . h " # include " DLSettings . DataChannels . h " # include " DLUtility . h " # include " DLUtility . ArrayFunctions . h " # include " DLPlatform . h " DataFieldManager :: DataFieldManager ( uint32_t dataSize , uint32_t averagerSize ) { m_dataSize = dataSize ; m_averagerSize = averagerSize ; m_fieldCount = 0 ; m_dataCount = 0 ; uint8_t i = 0 ; for ( i = 0 ; i < MAX_FIELDS ; i ++ ) { m_fields [ i ] = NULL ; } } uint8_t DataFieldManager :: fieldCount ( ) { return m_fieldCount ; } /* STRNEWLINE ▁ * ▁ addField STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Add ▁ a ▁ field ▁ to ▁ the ▁ manager . STRNEWLINE ▁ * ▁ Stores ▁ field ▁ pointer ▁ in ▁ next ▁ free ▁ location ▁ in ▁ m _ fields . STRNEWLINE ▁ * ▁ Channel ▁ number ▁ is ▁ stored ▁ in ▁ m _ channelNumbers . STRNEWLINE ▁ */ bool DataFieldManager :: addField ( NumericDataField * field ) { if ( ! field ) { return false ; } if ( m_fieldCount == MAX_FIELDS ) { return false ; } // ▁ The ▁ field ▁ might ▁ need ▁ extra ▁ setup ▁ based ▁ on ▁ the ▁ datatype / sensor ▁ and ▁ platform . ENDCOM // ▁ The ▁ platform ▁ interface ▁ takes ▁ care ▁ of ▁ that . ENDCOM PLATFORM_specialFieldSetup ( field ) ; field -> setDataSizes ( m_dataSize , m_averagerSize ) ; m_fields [ m_fieldCount ] = field ; m_channelNumbers [ m_fieldCount ] = field -> getChannelNumber ( ) ; m_fieldCount ++ ; return true ; } bool DataFieldManager :: addField ( StringDataField * field ) { if ( ! field ) { return false ; } if ( m_fieldCount == MAX_FIELDS ) { return false ; } m_fields [ m_fieldCount ] = field ; m_channelNumbers [ m_fieldCount ] = field -> getChannelNumber ( ) ; m_fieldCount ++ ; return true ; } void DataFieldManager :: storeDataArray ( int32_t * data ) { uint16_t field = 0 ; // ▁ The ▁ data ▁ manager ▁ stores ▁ only ▁ the ▁ fields ▁ of ▁ interest , ▁ but ▁ ENDCOM // ▁ the ▁ incoming ▁ data ▁ array ▁ is ▁ for ▁ ALL ▁ channels ▁ for ▁ the ▁ platform ENDCOM // ▁ dataIndex ▁ is ▁ the ▁ correct ▁ index ▁ for ▁ the ▁ raw ▁ data ▁ array ENDCOM uint16_t dataIndex ; bool newAverageStored = false ; for ( field = 0 ; field < m_fieldCount ; field ++ ) { NumericDataField * pField = ( NumericDataField * ) m_fields [ field ] ; if ( pField ) { dataIndex = m_channelNumbers [ field ] - 1 ; newAverageStored |= pField -> storeData ( data [ dataIndex ] ) ; } } if ( newAverageStored ) { m_dataCount ++ ; } } void DataFieldManager :: getDataArray ( float * buffer , bool converted , bool alsoRemove ) { uint16_t field ; for ( field = 0 ; field < m_fieldCount ; ++ field ) { if ( converted ) { buffer [ field ] = ( ( NumericDataField * ) m_fields [ field ] ) -> getConvData ( alsoRemove ) ; } else { buffer [ field ] = ( ( NumericDataField * ) m_fields [ field ] ) -> getRawData ( alsoRemove ) ; } } if ( alsoRemove ) { m_dataCount -- ; } } DataField * DataFieldManager :: getChannel ( uint8_t channel ) { int32_t actualIndex = indexOf ( m_channelNumbers , ( uint32_t ) channel , m_fieldCount ) ; return actualIndex >= 0 ? m_fields [ actualIndex ] : NULL ; } DataField * DataFieldManager :: getField ( uint8_t index ) { return m_fields [ index ] ; } DataField * * DataFieldManager :: getFields ( void ) { return m_fields ; } uint32_t DataFieldManager :: writeHeadersToBuffer ( char * buffer , uint8_t bufferLength ) { if ( ! buffer ) { return 0 ; } uint8_t i ; FixedLengthAccumulator headerAccumulator ( buffer , bufferLength ) ; for ( i = 0 ; i < m_fieldCount ; ++ i ) { headerAccumulator . writeString ( m_fields [ i ] -> getTypeString ( ) ) ; if ( ! lastinloop ( i , m_fieldCount ) ) { headerAccumulator . writeString ( " , ▁ " ) ; } } headerAccumulator . writeString ( " \n " ) ; return headerAccumulator . length ( ) ; } void DataFieldManager :: setupAllValidChannels ( void ) { uint8_t ch ; NumericDataField * field ; FIELD_TYPE type ; void * data ; uint32_t maxChannels = Settings_GetMaxChannels ( ) ; for ( ch = 1 ; ch < maxChannels ; ch ++ ) { if ( Settings_ChannelSettingIsValid ( ch ) ) { type = Settings_GetChannelType ( ch ) ; data = Settings_GetData ( ch ) ; switch ( type ) { case VOLTAGE : case CURRENT : case TEMPERATURE_C : case TEMPERATURE_K : case TEMPERATURE_F : field = new NumericDataField ( type , data , ch ) ; # ifdef TEST std :: cout << " Adding ▁ channel ▁ " << ( int ) ch << " , ▁ type ▁ " << field -> getTypeString ( ) << std :: endl ; # endif addField ( field ) ; break ; default : break ; } } } } bool DataFieldManager :: hasData ( void ) { uint8_t i = 0 ; bool atLeastOneFieldHasData = false ; for ( i = 0 ; i < m_fieldCount ; i ++ ) { atLeastOneFieldHasData |= m_fields [ i ] -> hasData ( ) ; } return atLeastOneFieldHasData ; } uint32_t DataFieldManager :: count ( void ) { return m_dataCount ; } uint32_t * DataFieldManager :: getChannelNumbers ( void ) { return m_channelNumbers ; } </DOCUMENT>
<DOCUMENT_ID="Poxleit/s-core/tree/master/src/scriptdev2/scripts/eastern_kingdoms/shadowfang_keep/instance_shadowfang_keep.cpp"> /* ▁ This ▁ file ▁ is ▁ part ▁ of ▁ the ▁ ScriptDev2 ▁ Project . ▁ See ▁ AUTHORS ▁ file ▁ for ▁ Copyright ▁ information STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or STRNEWLINE ▁ * ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software STRNEWLINE ▁ * ▁ Foundation , ▁ Inc . , ▁ 59 ▁ Temple ▁ Place , ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 ▁ USA STRNEWLINE ▁ */ /* ▁ ScriptData STRNEWLINE SDName : ▁ Instance _ Shadowfang _ Keep STRNEWLINE SD % Complete : ▁ 90 STRNEWLINE SDComment : STRNEWLINE SDCategory : ▁ Shadowfang ▁ Keep STRNEWLINE EndScriptData ▁ */ # include " precompiled . h " # include " shadowfang _ keep . h " instance_shadowfang_keep :: instance_shadowfang_keep ( Map * pMap ) : ScriptedInstance ( pMap ) { Initialize ( ) ; } void instance_shadowfang_keep :: Initialize ( ) { memset ( & m_auiEncounter , 0 , sizeof ( m_auiEncounter ) ) ; } void instance_shadowfang_keep :: OnCreatureCreate ( Creature * pCreature ) { switch ( pCreature -> GetEntry ( ) ) { case NPC_ASH : case NPC_ADA : case NPC_FENRUS : break ; case NPC_VINCENT : // ▁ If ▁ Arugal ▁ has ▁ done ▁ the ▁ intro , ▁ make ▁ Vincent ▁ dead ! ENDCOM if ( m_auiEncounter [ 4 ] == DONE ) pCreature -> SetStandState ( UNIT_STAND_STATE_DEAD ) ; break ; default : return ; } m_mNpcEntryGuidStore [ pCreature -> GetEntry ( ) ] = pCreature -> GetObjectGuid ( ) ; } void instance_shadowfang_keep :: OnObjectCreate ( GameObject * pGo ) { switch ( pGo -> GetEntry ( ) ) { case GO_COURTYARD_DOOR : if ( m_auiEncounter [ 0 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; // ▁ For ▁ this ▁ we ▁ ignore ▁ voidwalkers , ▁ because ▁ if ▁ the ▁ server ▁ restarts ENDCOM // ▁ They ▁ won ' t ▁ be ▁ there , ▁ but ▁ Fenrus ▁ is ▁ dead ▁ so ▁ the ▁ door ▁ can ' t ▁ be ▁ opened ! ENDCOM case GO_SORCERER_DOOR : if ( m_auiEncounter [ 2 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_ARUGAL_DOOR : if ( m_auiEncounter [ 3 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_ARUGAL_FOCUS : break ; default : return ; } m_mGoEntryGuidStore [ pGo -> GetEntry ( ) ] = pGo -> GetObjectGuid ( ) ; } void instance_shadowfang_keep :: DoSpeech ( ) { Creature * pAda = GetSingleCreatureFromStorage ( NPC_ADA ) ; Creature * pAsh = GetSingleCreatureFromStorage ( NPC_ASH ) ; if ( pAda && pAda -> isAlive ( ) && pAsh && pAsh -> isAlive ( ) ) { DoScriptText ( SAY_BOSS_DIE_AD , pAda ) ; DoScriptText ( SAY_BOSS_DIE_AS , pAsh ) ; } } void instance_shadowfang_keep :: SetData ( uint32 uiType , uint32 uiData ) { switch ( uiType ) { case TYPE_FREE_NPC : if ( uiData == DONE ) DoUseDoorOrButton ( GO_COURTYARD_DOOR ) ; m_auiEncounter [ 0 ] = uiData ; break ; case TYPE_RETHILGORE : if ( uiData == DONE ) DoSpeech ( ) ; m_auiEncounter [ 1 ] = uiData ; break ; case TYPE_FENRUS : if ( uiData == DONE ) { if ( Creature * pFenrus = GetSingleCreatureFromStorage ( NPC_FENRUS ) ) pFenrus -> SummonCreature ( NPC_ARCHMAGE_ARUGAL , - 136.89f , 2169.17f , 136.58f , 2.794f , TEMPSUMMON_TIMED_DESPAWN , 30000 ) ; } m_auiEncounter [ 2 ] = uiData ; break ; case TYPE_NANDOS : if ( uiData == DONE ) DoUseDoorOrButton ( GO_ARUGAL_DOOR ) ; m_auiEncounter [ 3 ] = uiData ; break ; case TYPE_INTRO : m_auiEncounter [ 4 ] = uiData ; break ; case TYPE_VOIDWALKER : if ( uiData == DONE ) { m_auiEncounter [ 5 ] ++ ; if ( m_auiEncounter [ 5 ] > 3 ) DoUseDoorOrButton ( GO_SORCERER_DOOR ) ; } break ; } if ( uiData == DONE ) { OUT_SAVE_INST_DATA ; std :: ostringstream saveStream ; saveStream << m_auiEncounter [ 0 ] << " ▁ " << m_auiEncounter [ 1 ] << " ▁ " << m_auiEncounter [ 2 ] << " ▁ " << m_auiEncounter [ 3 ] << " ▁ " << m_auiEncounter [ 4 ] << " ▁ " << m_auiEncounter [ 5 ] ; m_strInstData = saveStream . str ( ) ; SaveToDB ( ) ; OUT_SAVE_INST_DATA_COMPLETE ; } } uint32 instance_shadowfang_keep :: GetData ( uint32 uiType ) const { switch ( uiType ) { case TYPE_FREE_NPC : return m_auiEncounter [ 0 ] ; case TYPE_RETHILGORE : return m_auiEncounter [ 1 ] ; case TYPE_FENRUS : return m_auiEncounter [ 2 ] ; case TYPE_NANDOS : return m_auiEncounter [ 3 ] ; case TYPE_INTRO : return m_auiEncounter [ 4 ] ; default : return 0 ; } } void instance_shadowfang_keep :: Load ( const char * chrIn ) { if ( ! chrIn ) { OUT_LOAD_INST_DATA_FAIL ; return ; } OUT_LOAD_INST_DATA ( chrIn ) ; std :: istringstream loadStream ( chrIn ) ; loadStream >> m_auiEncounter [ 0 ] >> m_auiEncounter [ 1 ] >> m_auiEncounter [ 2 ] >> m_auiEncounter [ 3 ] >> m_auiEncounter [ 4 ] >> m_auiEncounter [ 5 ] ; for ( uint8 i = 0 ; i < MAX_ENCOUNTER ; ++ i ) { if ( m_auiEncounter [ i ] == IN_PROGRESS ) m_auiEncounter [ i ] = NOT_STARTED ; } OUT_LOAD_INST_DATA_COMPLETE ; } InstanceData * GetInstanceData_instance_shadowfang_keep ( Map * pMap ) { return new instance_shadowfang_keep ( pMap ) ; } void AddSC_instance_shadowfang_keep ( ) { Script * pNewScript ; pNewScript = new Script ; pNewScript -> Name = " instance _ shadowfang _ keep " ; pNewScript -> GetInstanceData = & GetInstanceData_instance_shadowfang_keep ; pNewScript -> RegisterSelf ( ) ; } </DOCUMENT>
<DOCUMENT_ID="nextgis/NextGIS_QGIS_open/tree/master/src/gui/qgsfieldvalidator.cpp"> /* * * * * STRNEWLINE ▁ qgsfieldvalidator . cpp ▁ - ▁ description STRNEWLINE ▁ - - - - - STRNEWLINE ▁ begin ▁ : ▁ March ▁ 2011 STRNEWLINE ▁ copyright ▁ : ▁ ( C ) ▁ 2011 ▁ by ▁ SunilRajKiran - kCube STRNEWLINE ▁ email ▁ : ▁ sunilraj . kiran @ kcubeconsulting . com STRNEWLINE STRNEWLINE ▁ adapted ▁ version ▁ of ▁ QValidator ▁ for ▁ QgsField STRNEWLINE ▁ * * * * */ /* * * * * STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ * STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ * STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ * STRNEWLINE ▁ * ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ▁ * STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * * * * */ # include " qgsfieldvalidator . h " # include < QValidator > # include < QRegExpValidator > # include < QDate > # include < QVariant > # include < QSettings > # include " qgslogger . h " # include " qgslonglongvalidator . h " # include " qgsfield . h " QgsFieldValidator :: QgsFieldValidator ( QObject * parent , const QgsField & field , QString dateFormat ) : QValidator ( parent ) , mField ( field ) , mDateFormat ( dateFormat ) { switch ( mField . type ( ) ) { case QVariant :: Int : { if ( mField . length ( ) > 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } " ) . arg ( mField . length ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else { mValidator = new QIntValidator ( parent ) ; } } break ; case QVariant :: Double : { if ( mField . length ( ) > 0 && mField . precision ( ) > 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } ( \\ . \\d { 0 , % 2 } ) ? " ) . arg ( mField . length ( ) - mField . precision ( ) ) . arg ( mField . precision ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else if ( mField . length ( ) > 0 && mField . precision ( ) == 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } " ) . arg ( mField . length ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else if ( mField . precision ( ) > 0 ) { QString re = QString ( " - ? \\d * ( \\ . \\d { 0 , % 1 } ) ? " ) . arg ( mField . precision ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else { mValidator = new QDoubleValidator ( parent ) ; } } break ; case QVariant :: LongLong : mValidator = new QgsLongLongValidator ( parent ) ; break ; default : mValidator = 0 ; } QSettings settings ; mNullValue = settings . value ( " qgis / nullValue " , " NULL " ) . toString ( ) ; } QgsFieldValidator :: ~ QgsFieldValidator ( ) { delete mValidator ; } QValidator :: State QgsFieldValidator :: validate ( QString & s , int & i ) const { // ▁ empty ▁ values ▁ are ▁ considered ▁ NULL ▁ for ▁ numbers ▁ and ▁ dates ▁ and ▁ are ▁ acceptable ENDCOM if ( s . isEmpty ( ) && ( mField . type ( ) == QVariant :: Double || mField . type ( ) == QVariant :: Int || mField . type ( ) == QVariant :: LongLong || mField . type ( ) == QVariant :: Date ) ) { return Acceptable ; } // ▁ delegate ▁ to ▁ the ▁ child ▁ validator ▁ if ▁ any ENDCOM if ( mValidator ) { QValidator :: State result = mValidator -> validate ( s , i ) ; return result ; } else if ( mField . type ( ) == QVariant :: String ) { // ▁ allow ▁ to ▁ enter ▁ the ▁ NULL ▁ representation , ▁ which ▁ might ▁ be ENDCOM // ▁ longer ▁ than ▁ the ▁ actual ▁ field ENDCOM if ( mNullValue . size ( ) > 0 && s . size ( ) > 0 && s . size ( ) < mNullValue . size ( ) && s == mNullValue . left ( s . size ( ) ) ) return Intermediate ; if ( s == mNullValue ) return Acceptable ; if ( mField . length ( ) > 0 && s . size ( ) > mField . length ( ) ) return Invalid ; } else if ( mField . type ( ) == QVariant :: Date ) { return QDate :: fromString ( s , mDateFormat ) . isValid ( ) ? Acceptable : Intermediate ; } else { QgsDebugMsg ( QString ( " unsupported ▁ type ▁ % 1 ▁ for ▁ validation " ) . arg ( mField . type ( ) ) ) ; return Invalid ; } return Acceptable ; } void QgsFieldValidator :: fixup ( QString & s ) const { if ( mValidator ) { mValidator -> fixup ( s ) ; } else if ( mField . type ( ) == QVariant :: String && mField . length ( ) > 0 && s . size ( ) > mField . length ( ) ) { // ▁ if ▁ the ▁ value ▁ is ▁ longer , ▁ this ▁ must ▁ be ▁ a ▁ partial ▁ NULL ▁ representation ENDCOM s = mNullValue ; } else if ( mField . type ( ) == QVariant :: Date ) { // ▁ invalid ▁ dates ▁ will ▁ also ▁ translate ▁ to ▁ NULL ENDCOM s = " " ; } } </DOCUMENT>
<DOCUMENT_ID="domin1101/malmo-challenge/tree/master/cpp/src/main.cpp"> # include " LightBulbApp / App . hpp " # include < wx / wxprec . h > # include " PigChase / PigChaseEvolution . hpp " # include " PigChase / TensorflowExporter . hpp " int main ( int argc , char * * argv ) { // ▁ Setup ▁ the ▁ main ▁ app ENDCOM LightBulb :: App * app = new LightBulb :: App ( ) ; app -> addTrainingPlan ( new PigChaseEvolution ( ) ) ; app -> addExporter ( new TensorflowExporter ( ) ) ; wxApp :: SetInstance ( app ) ; wxEntry ( argc , argv ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="einon/affymetrix-power-tools/tree/master/sdk/calvin_files/parameter/test/ParameterFileDataTest.cpp"> // ▁ Copyright ▁ ( C ) ▁ 2005 ▁ Affymetrix , ▁ Inc . ENDCOM // ▁ This ▁ library ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM // ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ ENDCOM // ▁ ( version ▁ 2.1 ) ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation . ENDCOM // ▁ This ▁ library ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ENDCOM // ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ENDCOM // ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ENDCOM // ▁ for ▁ more ▁ details . ENDCOM // ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ENDCOM // ▁ along ▁ with ▁ this ▁ library ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ENDCOM // ▁ 59 ▁ Temple ▁ Place , ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 ▁ USA ▁ ENDCOM # include " calvin _ files / parameter / src / ParameterFileData . h " # include < cppunit / extensions / HelperMacros . h > using namespace affymetrix_calvin_parameter ; class ParameterFileDataTest : public CPPUNIT_NS :: TestFixture { CPPUNIT_TEST_SUITE ( ParameterFileDataTest ) ; CPPUNIT_TEST ( testAccess ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void setUp ( ) ; void tearDown ( ) ; void testAccess ( ) ; } ; CPPUNIT_TEST_SUITE_REGISTRATION ( ParameterFileDataTest ) ; void ParameterFileDataTest :: setUp ( ) { } void ParameterFileDataTest :: tearDown ( ) { } void ParameterFileDataTest :: testAccess ( ) { ParameterFileData d ; d . ImplementationAttributes ( ) . description = L " d " ; d . ImplementationAttributes ( ) . executableFileName = L " e " ; d . ImplementationAttributes ( ) . name = L " n " ; d . ImplementationAttributes ( ) . version = L " v " ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . description == L " d " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . executableFileName == L " e " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . name == L " n " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . version == L " v " ) ; d . ParameterFileAttributes ( ) . company = L " c " ; d . ParameterFileAttributes ( ) . userName = L " u " ; d . ParameterFileAttributes ( ) . contentVersion = L " cv " ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . company == L " c " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . userName == L " u " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . contentVersion == L " cv " ) ; ParameterType p ; p . name = L " n " ; p . index = L " i " ; p . displayName = L " d " ; p . category = L " c " ; p . isEditable = L " is " ; p . type = L " t " ; p . currentValue = L " cv " ; p . minValue = L " mv " ; p . maxValue = L " xv " ; p . defaultValue = L " dv " ; p . precision = L " p " ; p . maxLength = L " l " ; p . description = L " de " ; CPPUNIT_ASSERT ( p . name == L " n " ) ; CPPUNIT_ASSERT ( p . index == L " i " ) ; CPPUNIT_ASSERT ( p . displayName == L " d " ) ; CPPUNIT_ASSERT ( p . category == L " c " ) ; CPPUNIT_ASSERT ( p . isEditable == L " is " ) ; CPPUNIT_ASSERT ( p . type == L " t " ) ; CPPUNIT_ASSERT ( p . currentValue == L " cv " ) ; CPPUNIT_ASSERT ( p . minValue == L " mv " ) ; CPPUNIT_ASSERT ( p . maxValue == L " xv " ) ; CPPUNIT_ASSERT ( p . defaultValue == L " dv " ) ; CPPUNIT_ASSERT ( p . precision == L " p " ) ; CPPUNIT_ASSERT ( p . maxLength == L " l " ) ; CPPUNIT_ASSERT ( p . description == L " de " ) ; d . Parameters ( ) . push_back ( p ) ; p . name . clear ( ) ; p . index . clear ( ) ; CPPUNIT_ASSERT ( d . Parameters ( ) . size ( ) == 1 ) ; d . Clear ( ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . description == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . executableFileName == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . name == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . version == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . company == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . userName == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . contentVersion == L " " ) ; CPPUNIT_ASSERT ( d . Parameters ( ) . size ( ) == 0 ) ; } </DOCUMENT>
<DOCUMENT_ID="JIghtuse/functional-cpp/tree/master/src/functional_objects/company.cpp"> # include < company . h > # include < algorithm > // ▁ possible ▁ implementation ▁ for ▁ lambda ▁ in ▁ countTeamMembers ENDCOM class lambda_implementation { public : lambda_implementation ( const Company * _this , const std :: string & teamName ) : m_this { _this } , m_teamName { teamName } { } bool operator ( ) ( const Person & employee ) const { return m_this -> teamNameFor ( employee ) == m_teamName ; } private : const Company * m_this ; const std :: string & m_teamName ; } ; int Company :: countTeamMembers ( const std :: string & teamName ) const { return std :: count_if ( m_employees . cbegin ( ) , m_employees . cend ( ) , [ this , & teamName ] ( const Person & p ) { return teamNameFor ( p ) == teamName ; } ) ; } std :: string Company :: teamNameFor ( const Person & ) const { return " some " ; } </DOCUMENT>
<DOCUMENT_ID="dev-ily/ILoveYouCoins/tree/master/src/rpcwallet.cpp"> // ▁ Copyright ▁ ( c ) ▁ 2010 ▁ Satoshi ▁ Nakamoto ENDCOM // ▁ Copyright ▁ ( c ) ▁ 2009-2014 ▁ The ▁ Bitcoin ▁ developers ENDCOM // ▁ Distributed ▁ under ▁ the ▁ MIT / X11 ▁ software ▁ license , ▁ see ▁ the ▁ accompanying ENDCOM // ▁ file ▁ COPYING ▁ or ▁ http : // www . opensource . org / licenses / mit - license . php . ENDCOM # include < boost / assign / list_of . hpp > # include " wallet . h " # include " walletdb . h " # include " bitcoinrpc . h " # include " init . h " # include " base58 . h " using namespace std ; using namespace boost ; using namespace boost :: assign ; using namespace json_spirit ; int64 nWalletUnlockTime ; static CCriticalSection cs_nWalletUnlockTime ; std :: string HelpRequiringPassphrase ( ) { return pwalletMain && pwalletMain -> IsCrypted ( ) ? " \n requires ▁ wallet ▁ passphrase ▁ to ▁ be ▁ set ▁ with ▁ walletpassphrase ▁ first " : " " ; } void EnsureWalletIsUnlocked ( ) { if ( pwalletMain -> IsLocked ( ) ) throw JSONRPCError ( RPC_WALLET_UNLOCK_NEEDED , " Error : ▁ Please ▁ enter ▁ the ▁ wallet ▁ passphrase ▁ with ▁ walletpassphrase ▁ first . " ) ; if ( fWalletUnlockStakingOnly ) throw JSONRPCError ( RPC_WALLET_ALREADY_UNLOCKED_STAKING_ONLY , " Error : ▁ Wallet ▁ is ▁ unlocked ▁ for ▁ staking ▁ only . " ) ; } void WalletTxToJSON ( const CWalletTx & wtx , Object & entry ) { int confirms = wtx . GetDepthInMainChain ( ) ; entry . push_back ( Pair ( " confirmations " , confirms ) ) ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " generated " , true ) ) ; if ( confirms > 0 ) { entry . push_back ( Pair ( " blockhash " , wtx . hashBlock . GetHex ( ) ) ) ; entry . push_back ( Pair ( " blockindex " , wtx . nIndex ) ) ; entry . push_back ( Pair ( " blocktime " , ( boost :: int64_t ) ( mapBlockIndex [ wtx . hashBlock ] -> nTime ) ) ) ; } entry . push_back ( Pair ( " txid " , wtx . GetHash ( ) . GetHex ( ) ) ) ; entry . push_back ( Pair ( " normtxid " , wtx . GetNormalizedHash ( ) . GetHex ( ) ) ) ; entry . push_back ( Pair ( " time " , ( boost :: int64_t ) wtx . GetTxTime ( ) ) ) ; entry . push_back ( Pair ( " timereceived " , ( boost :: int64_t ) wtx . nTimeReceived ) ) ; BOOST_FOREACH ( const PAIRTYPE ( string , string ) & item , wtx . mapValue ) entry . push_back ( Pair ( item . first , item . second ) ) ; } string AccountFromValue ( const Value & value ) { string strAccount = value . get_str ( ) ; if ( strAccount == " * " ) throw JSONRPCError ( RPC_WALLET_INVALID_ACCOUNT_NAME , " Invalid ▁ account ▁ name " ) ; return strAccount ; } Value getinfo ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 0 ) throw runtime_error ( " getinfo \n " " Returns ▁ an ▁ object ▁ containing ▁ various ▁ state ▁ info . " ) ; proxyType proxy ; GetProxy ( NET_IPV4 , proxy ) ; Object obj ; obj . push_back ( Pair ( " version " , ( int ) CLIENT_VERSION ) ) ; obj . push_back ( Pair ( " protocolversion " , ( int ) PROTOCOL_VERSION ) ) ; if ( pwalletMain ) { obj . push_back ( Pair ( " walletversion " , pwalletMain -> GetVersion ( ) ) ) ; obj . push_back ( Pair ( " balance " , ValueFromAmount ( pwalletMain -> GetBalance ( ) ) ) ) ; obj . push_back ( Pair ( " unconfirmedbalance " , ValueFromAmount ( pwalletMain -> GetUnconfirmedBalance ( ) ) ) ) ; obj . push_back ( Pair ( " stake " , ValueFromAmount ( pwalletMain -> GetStake ( ) ) ) ) ; obj . push_back ( Pair ( " locked " , pwalletMain -> IsLocked ( ) ) ) ; obj . push_back ( Pair ( " encrypted " , pwalletMain -> IsCrypted ( ) ) ) ; } obj . push_back ( Pair ( " blocks " , ( int ) nBestHeight ) ) ; obj . push_back ( Pair ( " timeoffset " , ( boost :: int64_t ) GetTimeOffset ( ) ) ) ; obj . push_back ( Pair ( " moneysupply " , ValueFromAmount ( pindexBest -> nMoneySupply ) ) ) ; obj . push_back ( Pair ( " connections " , ( int ) vNodes . size ( ) ) ) ; obj . push_back ( Pair ( " proxy " , ( proxy . first . IsValid ( ) ? proxy . first . ToStringIPPort ( ) : string ( ) ) ) ) ; obj . push_back ( Pair ( " difficulty " , ( double ) GetDifficulty ( ) ) ) ; obj . push_back ( Pair ( " testnet " , fTestNet ) ) ; if ( pwalletMain ) { obj . push_back ( Pair ( " keypoololdest " , ( boost :: int64_t ) pwalletMain -> GetOldestKeyPoolTime ( ) ) ) ; obj . push_back ( Pair ( " keypoolsize " , ( int ) pwalletMain -> GetKeyPoolSize ( ) ) ) ; } obj . push_back ( Pair ( " paytxfee " , ValueFromAmount ( nTransactionFee ) ) ) ; obj . push_back ( Pair ( " mininput " , ValueFromAmount ( nMinimumInputValue ) ) ) ; if ( pwalletMain && pwalletMain -> IsCrypted ( ) ) obj . push_back ( Pair ( " unlocked _ until " , ( boost :: int64_t ) nWalletUnlockTime ) ) ; obj . push_back ( Pair ( " errors " , GetWarnings ( " statusbar " ) ) ) ; return obj ; } Value getnewaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 1 ) throw runtime_error ( " getnewaddress ▁ [ account ] \n " " Returns ▁ a ▁ new ▁ ILoveYouCoins ▁ address ▁ for ▁ receiving ▁ payments . ▁ ▁ " " If ▁ [ account ] ▁ is ▁ specified ▁ ( recommended ) , ▁ it ▁ is ▁ added ▁ to ▁ the ▁ address ▁ book ▁ " " so ▁ payments ▁ received ▁ with ▁ the ▁ address ▁ will ▁ be ▁ credited ▁ to ▁ [ account ] . " ) ; // ▁ Parse ▁ the ▁ account ▁ first ▁ so ▁ we ▁ don ' t ▁ generate ▁ a ▁ key ▁ if ▁ there ' s ▁ an ▁ error ENDCOM string strAccount ; if ( params . size ( ) > 0 ) strAccount = AccountFromValue ( params [ 0 ] ) ; if ( ! pwalletMain -> IsLocked ( ) ) pwalletMain -> TopUpKeyPool ( ) ; // ▁ Generate ▁ a ▁ new ▁ key ▁ that ▁ is ▁ added ▁ to ▁ wallet ENDCOM CPubKey newKey ; if ( ! pwalletMain -> GetKeyFromPool ( newKey , false ) ) throw JSONRPCError ( RPC_WALLET_KEYPOOL_RAN_OUT , " Error : ▁ Keypool ▁ ran ▁ out , ▁ please ▁ call ▁ keypoolrefill ▁ first " ) ; CKeyID keyID = newKey . GetID ( ) ; pwalletMain -> SetAddressBookName ( keyID , strAccount ) ; return CBitcoinAddress ( keyID ) . ToString ( ) ; } CBitcoinAddress GetAccountAddress ( string strAccount , bool bForceNew = false ) { CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; CAccount account ; walletdb . ReadAccount ( strAccount , account ) ; bool bKeyUsed = false ; // ▁ Check ▁ if ▁ the ▁ current ▁ key ▁ has ▁ been ▁ used ENDCOM if ( account . vchPubKey . IsValid ( ) ) { CScript scriptPubKey ; scriptPubKey . SetDestination ( account . vchPubKey . GetID ( ) ) ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) && account . vchPubKey . IsValid ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) if ( txout . scriptPubKey == scriptPubKey ) bKeyUsed = true ; } } // ▁ Generate ▁ a ▁ new ▁ key ENDCOM if ( ! account . vchPubKey . IsValid ( ) || bForceNew || bKeyUsed ) { if ( ! pwalletMain -> GetKeyFromPool ( account . vchPubKey , false ) ) throw JSONRPCError ( RPC_WALLET_KEYPOOL_RAN_OUT , " Error : ▁ Keypool ▁ ran ▁ out , ▁ please ▁ call ▁ keypoolrefill ▁ first " ) ; pwalletMain -> SetAddressBookName ( account . vchPubKey . GetID ( ) , strAccount ) ; walletdb . WriteAccount ( strAccount , account ) ; } return CBitcoinAddress ( account . vchPubKey . GetID ( ) ) ; } Value getaccountaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaccountaddress ▁ < account > \n " " Returns ▁ the ▁ current ▁ ILoveYouCoins ▁ address ▁ for ▁ receiving ▁ payments ▁ to ▁ this ▁ account . " ) ; // ▁ Parse ▁ the ▁ account ▁ first ▁ so ▁ we ▁ don ' t ▁ generate ▁ a ▁ key ▁ if ▁ there ' s ▁ an ▁ error ENDCOM string strAccount = AccountFromValue ( params [ 0 ] ) ; Value ret ; ret = GetAccountAddress ( strAccount ) . ToString ( ) ; return ret ; } Value setaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " setaccount ▁ < iloveyoucoinsaddress > ▁ < account > \n " " Sets ▁ the ▁ account ▁ associated ▁ with ▁ the ▁ given ▁ address . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; string strAccount ; if ( params . size ( ) > 1 ) strAccount = AccountFromValue ( params [ 1 ] ) ; // ▁ Detect ▁ when ▁ changing ▁ the ▁ account ▁ of ▁ an ▁ address ▁ that ▁ is ▁ the ▁ ' unused ▁ current ▁ key ' ▁ of ▁ another ▁ account : ENDCOM if ( pwalletMain -> mapAddressBook . count ( address . Get ( ) ) ) { string strOldAccount = pwalletMain -> mapAddressBook [ address . Get ( ) ] ; if ( address == GetAccountAddress ( strOldAccount ) ) GetAccountAddress ( strOldAccount , true ) ; } pwalletMain -> SetAddressBookName ( address . Get ( ) , strAccount ) ; return Value :: null ; } Value getaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaccount ▁ < iloveyoucoinsaddress > \n " " Returns ▁ the ▁ account ▁ associated ▁ with ▁ the ▁ given ▁ address . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; string strAccount ; map < CTxDestination , string > :: iterator mi = pwalletMain -> mapAddressBook . find ( address . Get ( ) ) ; if ( mi != pwalletMain -> mapAddressBook . end ( ) && ! ( * mi ) . second . empty ( ) ) strAccount = ( * mi ) . second ; return strAccount ; } Value getaddressesbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaddressesbyaccount ▁ < account > \n " " Returns ▁ the ▁ list ▁ of ▁ addresses ▁ for ▁ the ▁ given ▁ account . " ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; // ▁ Find ▁ all ▁ addresses ▁ that ▁ have ▁ the ▁ given ▁ account ENDCOM Array ret ; BOOST_FOREACH ( const PAIRTYPE ( CBitcoinAddress , string ) & item , pwalletMain -> mapAddressBook ) { const CBitcoinAddress & address = item . first ; const string & strName = item . second ; if ( strName == strAccount ) ret . push_back ( address . ToString ( ) ) ; } return ret ; } Value setmininput ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 1 ) throw runtime_error ( " setmininput ▁ < amount > \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" ) ; // ▁ Amount ENDCOM int64 nAmount = 0 ; if ( params [ 0 ] . get_real ( ) != 0.0 ) nAmount = AmountFromValue ( params [ 0 ] ) ; // ▁ rejects ▁ 0.0 ▁ amounts ENDCOM nMinimumInputValue = nAmount ; return true ; } Value sendtoaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 4 ) throw runtime_error ( " sendtoaddress ▁ < iloveyoucoinsaddress > ▁ < amount > ▁ [ comment ] ▁ [ comment - to ] \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" + HelpRequiringPassphrase ( ) ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; // ▁ Amount ENDCOM int64 nAmount = AmountFromValue ( params [ 1 ] ) ; // ▁ Wallet ▁ comments ENDCOM CWalletTx wtx ; if ( params . size ( ) > 2 && params [ 2 ] . type ( ) != null_type && ! params [ 2 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 2 ] . get_str ( ) ; if ( params . size ( ) > 3 && params [ 3 ] . type ( ) != null_type && ! params [ 3 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " to " ] = params [ 3 ] . get_str ( ) ; EnsureWalletIsUnlocked ( ) ; string strError = pwalletMain -> SendMoneyToDestination ( address . Get ( ) , nAmount , wtx ) ; if ( strError != " " ) throw JSONRPCError ( RPC_WALLET_ERROR , strError ) ; return wtx . GetHash ( ) . GetHex ( ) ; } Value listaddressgroupings ( const Array & params , bool fHelp ) { if ( fHelp ) throw runtime_error ( " listaddressgroupings \n " " Lists ▁ groups ▁ of ▁ addresses ▁ which ▁ have ▁ had ▁ their ▁ common ▁ ownership \n " " made ▁ public ▁ by ▁ common ▁ use ▁ as ▁ inputs ▁ or ▁ as ▁ the ▁ resulting ▁ change \n " " in ▁ past ▁ transactions " ) ; Array jsonGroupings ; map < CTxDestination , int64 > balances = pwalletMain -> GetAddressBalances ( ) ; BOOST_FOREACH ( set < CTxDestination > grouping , pwalletMain -> GetAddressGroupings ( ) ) { Array jsonGrouping ; BOOST_FOREACH ( CTxDestination address , grouping ) { Array addressInfo ; addressInfo . push_back ( CBitcoinAddress ( address ) . ToString ( ) ) ; addressInfo . push_back ( ValueFromAmount ( balances [ address ] ) ) ; { LOCK ( pwalletMain -> cs_wallet ) ; if ( pwalletMain -> mapAddressBook . find ( CBitcoinAddress ( address ) . Get ( ) ) != pwalletMain -> mapAddressBook . end ( ) ) addressInfo . push_back ( pwalletMain -> mapAddressBook . find ( CBitcoinAddress ( address ) . Get ( ) ) -> second ) ; } jsonGrouping . push_back ( addressInfo ) ; } jsonGroupings . push_back ( jsonGrouping ) ; } return jsonGroupings ; } Value signmessage ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 2 ) throw runtime_error ( " signmessage ▁ < iloveyoucoinsaddress > ▁ < message > \n " " Sign ▁ a ▁ message ▁ with ▁ the ▁ private ▁ key ▁ of ▁ an ▁ address " ) ; EnsureWalletIsUnlocked ( ) ; string strAddress = params [ 0 ] . get_str ( ) ; string strMessage = params [ 1 ] . get_str ( ) ; CBitcoinAddress addr ( strAddress ) ; if ( ! addr . IsValid ( ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Invalid ▁ address " ) ; CKeyID keyID ; if ( ! addr . GetKeyID ( keyID ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Address ▁ does ▁ not ▁ refer ▁ to ▁ key " ) ; CKey key ; if ( ! pwalletMain -> GetKey ( keyID , key ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Private ▁ key ▁ not ▁ available " ) ; CHashWriter ss ( SER_GETHASH , 0 ) ; ss << strMessageMagic ; ss << strMessage ; vector < unsigned char > vchSig ; if ( ! key . SignCompact ( ss . GetHash ( ) , vchSig ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Sign ▁ failed " ) ; return EncodeBase64 ( & vchSig [ 0 ] , vchSig . size ( ) ) ; } Value verifymessage ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 3 ) throw runtime_error ( " verifymessage ▁ < iloveyoucoinsaddress > ▁ < signature > ▁ < message > \n " " Verify ▁ a ▁ signed ▁ message " ) ; string strAddress = params [ 0 ] . get_str ( ) ; string strSign = params [ 1 ] . get_str ( ) ; string strMessage = params [ 2 ] . get_str ( ) ; CBitcoinAddress addr ( strAddress ) ; if ( ! addr . IsValid ( ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Invalid ▁ address " ) ; CKeyID keyID ; if ( ! addr . GetKeyID ( keyID ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Address ▁ does ▁ not ▁ refer ▁ to ▁ key " ) ; bool fInvalid = false ; vector < unsigned char > vchSig = DecodeBase64 ( strSign . c_str ( ) , & fInvalid ) ; if ( fInvalid ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Malformed ▁ base64 ▁ encoding " ) ; CHashWriter ss ( SER_GETHASH , 0 ) ; ss << strMessageMagic ; ss << strMessage ; CPubKey pubkey ; if ( ! pubkey . RecoverCompact ( ss . GetHash ( ) , vchSig ) ) return false ; return ( pubkey . GetID ( ) == keyID ) ; } Value getreceivedbyaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " getreceivedbyaddress ▁ < iloveyoucoinsaddress > ▁ [ minconf = 1 ] \n " " Returns ▁ the ▁ total ▁ amount ▁ received ▁ by ▁ < iloveyoucoinsaddress > ▁ in ▁ transactions ▁ with ▁ at ▁ least ▁ [ minconf ] ▁ confirmations . " ) ; // ▁ Bitcoin ▁ address ENDCOM CBitcoinAddress address = CBitcoinAddress ( params [ 0 ] . get_str ( ) ) ; CScript scriptPubKey ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; scriptPubKey . SetDestination ( address . Get ( ) ) ; if ( ! IsMine ( * pwalletMain , scriptPubKey ) ) return ( double ) 0.0 ; // ▁ Minimum ▁ confirmations ENDCOM int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; // ▁ Tally ENDCOM int64 nAmount = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) if ( txout . scriptPubKey == scriptPubKey ) if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) nAmount += txout . nValue ; } return ValueFromAmount ( nAmount ) ; } void GetAccountAddresses ( string strAccount , set < CTxDestination > & setAddress ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , string ) & item , pwalletMain -> mapAddressBook ) { const CTxDestination & address = item . first ; const string & strName = item . second ; if ( strName == strAccount ) setAddress . insert ( address ) ; } } Value getreceivedbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " getreceivedbyaccount ▁ < account > ▁ [ minconf = 1 ] \n " " Returns ▁ the ▁ total ▁ amount ▁ received ▁ by ▁ addresses ▁ with ▁ < account > ▁ in ▁ transactions ▁ with ▁ at ▁ least ▁ [ minconf ] ▁ confirmations . " ) ; // ▁ Minimum ▁ confirmations ENDCOM int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; // ▁ Get ▁ the ▁ set ▁ of ▁ pub ▁ keys ▁ assigned ▁ to ▁ account ENDCOM string strAccount = AccountFromValue ( params [ 0 ] ) ; set < CTxDestination > setAddress ; GetAccountAddresses ( strAccount , setAddress ) ; // ▁ Tally ENDCOM int64 nAmount = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) { CTxDestination address ; if ( ExtractDestination ( txout . scriptPubKey , address ) && IsMine ( * pwalletMain , address ) && setAddress . count ( address ) ) if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) nAmount += txout . nValue ; } } return ( double ) nAmount / ( double ) COIN ; } int64 GetAccountBalance ( CWalletDB & walletdb , const string & strAccount , int nMinDepth ) { int64 nBalance = 0 ; // ▁ Tally ▁ wallet ▁ transactions ENDCOM for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsFinal ( ) ) continue ; int64 nReceived , nSent , nFee ; wtx . GetAccountAmounts ( strAccount , nReceived , nSent , nFee ) ; if ( nReceived != 0 && wtx . GetDepthInMainChain ( ) >= nMinDepth ) nBalance += nReceived ; nBalance -= nSent + nFee ; } // ▁ Tally ▁ internal ▁ accounting ▁ entries ENDCOM nBalance += walletdb . GetAccountCreditDebit ( strAccount ) ; return nBalance ; } int64 GetAccountBalance ( const string & strAccount , int nMinDepth ) { CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; return GetAccountBalance ( walletdb , strAccount , nMinDepth ) ; } Value getbalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " getbalance ▁ [ account ] ▁ [ minconf = 1 ] \n " " If ▁ [ account ] ▁ is ▁ not ▁ specified , ▁ returns ▁ the ▁ server ' s ▁ total ▁ available ▁ balance . \n " " If ▁ [ account ] ▁ is ▁ specified , ▁ returns ▁ the ▁ balance ▁ in ▁ the ▁ account . " ) ; if ( params . size ( ) == 0 ) return ValueFromAmount ( pwalletMain -> GetBalance ( ) ) ; int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; if ( params [ 0 ] . get_str ( ) == " * " ) { // ▁ Calculate ▁ total ▁ balance ▁ a ▁ different ▁ way ▁ from ▁ GetBalance ( ) ENDCOM // ▁ ( GetBalance ( ) ▁ sums ▁ up ▁ all ▁ unspent ▁ TxOuts ) ENDCOM // ▁ getbalance ▁ and ▁ getbalance ▁ ' * ' ▁ 0 ▁ should ▁ return ▁ the ▁ same ▁ number ENDCOM int64 nBalance = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsConfirmed ( ) ) continue ; int64 allFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , allFee , strSentAccount ) ; if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) nBalance += r . second ; } BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listSent ) nBalance -= r . second ; nBalance -= allFee ; } return ValueFromAmount ( nBalance ) ; } string strAccount = AccountFromValue ( params [ 0 ] ) ; int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; return ValueFromAmount ( nBalance ) ; } Value getunconfirmedbalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " getunconfirmedbalance \n " " Returns ▁ the ▁ server ' s ▁ total ▁ unconfirmed ▁ balance \n " ) ; return ValueFromAmount ( pwalletMain -> GetUnconfirmedBalance ( ) ) ; } Value movecmd ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 3 || params . size ( ) > 5 ) throw runtime_error ( " move ▁ < fromaccount > ▁ < toaccount > ▁ < amount > ▁ [ minconf = 1 ] ▁ [ comment ] \n " " Move ▁ from ▁ one ▁ account ▁ in ▁ your ▁ wallet ▁ to ▁ another . " ) ; string strFrom = AccountFromValue ( params [ 0 ] ) ; string strTo = AccountFromValue ( params [ 1 ] ) ; int64 nAmount = AmountFromValue ( params [ 2 ] ) ; if ( params . size ( ) > 3 ) // ▁ unused ▁ parameter , ▁ used ▁ to ▁ be ▁ nMinDepth , ▁ keep ▁ type - checking ▁ it ▁ though ENDCOM ( void ) params [ 3 ] . get_int ( ) ; string strComment ; if ( params . size ( ) > 4 ) strComment = params [ 4 ] . get_str ( ) ; CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; if ( ! walletdb . TxnBegin ( ) ) throw JSONRPCError ( RPC_DATABASE_ERROR , " database ▁ error " ) ; int64 nNow = GetAdjustedTime ( ) ; // ▁ Debit ENDCOM CAccountingEntry debit ; debit . nOrderPos = pwalletMain -> IncOrderPosNext ( & walletdb ) ; debit . strAccount = strFrom ; debit . nCreditDebit = - nAmount ; debit . nTime = nNow ; debit . strOtherAccount = strTo ; debit . strComment = strComment ; walletdb . WriteAccountingEntry ( debit ) ; // ▁ Credit ENDCOM CAccountingEntry credit ; credit . nOrderPos = pwalletMain -> IncOrderPosNext ( & walletdb ) ; credit . strAccount = strTo ; credit . nCreditDebit = nAmount ; credit . nTime = nNow ; credit . strOtherAccount = strFrom ; credit . strComment = strComment ; walletdb . WriteAccountingEntry ( credit ) ; if ( ! walletdb . TxnCommit ( ) ) throw JSONRPCError ( RPC_DATABASE_ERROR , " database ▁ error " ) ; return true ; } Value sendfrom ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 3 || params . size ( ) > 6 ) throw runtime_error ( " sendfrom ▁ < fromaccount > ▁ < toiloveyoucoinsaddress > ▁ < amount > ▁ [ minconf = 1 ] ▁ [ comment ] ▁ [ comment - to ] \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" + HelpRequiringPassphrase ( ) ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; CBitcoinAddress address ( params [ 1 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; int64 nAmount = AmountFromValue ( params [ 2 ] ) ; int nMinDepth = 1 ; if ( params . size ( ) > 3 ) nMinDepth = params [ 3 ] . get_int ( ) ; CWalletTx wtx ; wtx . strFromAccount = strAccount ; if ( params . size ( ) > 4 && params [ 4 ] . type ( ) != null_type && ! params [ 4 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 4 ] . get_str ( ) ; if ( params . size ( ) > 5 && params [ 5 ] . type ( ) != null_type && ! params [ 5 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " to " ] = params [ 5 ] . get_str ( ) ; EnsureWalletIsUnlocked ( ) ; // ▁ Check ▁ funds ENDCOM int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; if ( nAmount > nBalance ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , " Account ▁ has ▁ insufficient ▁ funds " ) ; // ▁ Send ENDCOM string strError = pwalletMain -> SendMoneyToDestination ( address . Get ( ) , nAmount , wtx ) ; if ( strError != " " ) throw JSONRPCError ( RPC_WALLET_ERROR , strError ) ; return wtx . GetHash ( ) . GetHex ( ) ; } Value sendmany ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 4 ) throw runtime_error ( " sendmany ▁ < fromaccount > ▁ { address : amount , . . . } ▁ [ minconf = 1 ] ▁ [ comment ] \n " " amounts ▁ are ▁ double - precision ▁ floating ▁ point ▁ numbers " + HelpRequiringPassphrase ( ) ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; Object sendTo = params [ 1 ] . get_obj ( ) ; int nMinDepth = 1 ; if ( params . size ( ) > 2 ) nMinDepth = params [ 2 ] . get_int ( ) ; CWalletTx wtx ; wtx . strFromAccount = strAccount ; if ( params . size ( ) > 3 && params [ 3 ] . type ( ) != null_type && ! params [ 3 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 3 ] . get_str ( ) ; set < CBitcoinAddress > setAddress ; vector < pair < CScript , int64 > > vecSend ; int64 totalAmount = 0 ; BOOST_FOREACH ( const Pair & s , sendTo ) { CBitcoinAddress address ( s . name_ ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , string ( " Invalid ▁ ILoveYouCoins ▁ address : ▁ " ) + s . name_ ) ; if ( setAddress . count ( address ) ) throw JSONRPCError ( RPC_INVALID_PARAMETER , string ( " Invalid ▁ parameter , ▁ duplicated ▁ address : ▁ " ) + s . name_ ) ; setAddress . insert ( address ) ; CScript scriptPubKey ; scriptPubKey . SetDestination ( address . Get ( ) ) ; int64 nAmount = AmountFromValue ( s . value_ ) ; totalAmount += nAmount ; vecSend . push_back ( make_pair ( scriptPubKey , nAmount ) ) ; } EnsureWalletIsUnlocked ( ) ; // ▁ Check ▁ funds ENDCOM int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; if ( totalAmount > nBalance ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , " Account ▁ has ▁ insufficient ▁ funds " ) ; // ▁ Send ENDCOM CReserveKey keyChange ( pwalletMain ) ; int64 nFeeRequired = 0 ; string strFailReason ; bool fCreated = pwalletMain -> CreateTransaction ( vecSend , wtx , keyChange , nFeeRequired , strFailReason ) ; if ( ! fCreated ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , strFailReason ) ; if ( ! pwalletMain -> CommitTransaction ( wtx , keyChange ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Transaction ▁ commit ▁ failed " ) ; return wtx . GetHash ( ) . GetHex ( ) ; } // ▁ Used ▁ by ▁ addmultisigaddress ▁ / ▁ createmultisig : ENDCOM static CScript _createmultisig ( const Array & params ) { int nRequired = params [ 0 ] . get_int ( ) ; const Array & keys = params [ 1 ] . get_array ( ) ; // ▁ Gather ▁ public ▁ keys ENDCOM if ( nRequired < 1 ) throw runtime_error ( " a ▁ multisignature ▁ address ▁ must ▁ require ▁ at ▁ least ▁ one ▁ key ▁ to ▁ redeem " ) ; if ( ( int ) keys . size ( ) < nRequired ) throw runtime_error ( strprintf ( " not ▁ enough ▁ keys ▁ supplied ▁ " " ( got ▁ % " PRIszu " ▁ keys , ▁ but ▁ need ▁ at ▁ least ▁ % d ▁ to ▁ redeem ) " , keys . size ( ) , nRequired ) ) ; std :: vector < CPubKey > pubkeys ; pubkeys . resize ( keys . size ( ) ) ; for ( unsigned int i = 0 ; i < keys . size ( ) ; i ++ ) { const std :: string & ks = keys [ i ] . get_str ( ) ; // ▁ Case ▁ 1 : ▁ ILoveYouCoins ▁ address ▁ and ▁ we ▁ have ▁ full ▁ public ▁ key : ENDCOM CBitcoinAddress address ( ks ) ; if ( pwalletMain && address . IsValid ( ) ) { CKeyID keyID ; if ( ! address . GetKeyID ( keyID ) ) throw runtime_error ( strprintf ( " % s ▁ does ▁ not ▁ refer ▁ to ▁ a ▁ key " , ks . c_str ( ) ) ) ; CPubKey vchPubKey ; if ( ! pwalletMain -> GetPubKey ( keyID , vchPubKey ) ) throw runtime_error ( strprintf ( " no ▁ full ▁ public ▁ key ▁ for ▁ address ▁ % s " , ks . c_str ( ) ) ) ; if ( ! vchPubKey . IsFullyValid ( ) ) throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; pubkeys [ i ] = vchPubKey ; } // ▁ Case ▁ 2 : ▁ hex ▁ public ▁ key ENDCOM else if ( IsHex ( ks ) ) { CPubKey vchPubKey ( ParseHex ( ks ) ) ; if ( ! vchPubKey . IsFullyValid ( ) ) throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; pubkeys [ i ] = vchPubKey ; } else { throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; } } CScript result ; result . SetMultisig ( nRequired , pubkeys ) ; return result ; } Value addmultisigaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 3 ) { string msg = " addmultisigaddress ▁ < nrequired > ▁ < ' [ \ " key\ " , \ " key\ " ] ' > ▁ [ account ] \n " " Add ▁ a ▁ nrequired - to - sign ▁ multisignature ▁ address ▁ to ▁ the ▁ wallet\ " \n " " each ▁ key ▁ is ▁ a ▁ ILoveYouCoins ▁ address ▁ or ▁ hex - encoded ▁ public ▁ key \n " " If ▁ [ account ] ▁ is ▁ specified , ▁ assign ▁ address ▁ to ▁ [ account ] . " ; throw runtime_error ( msg ) ; } string strAccount ; if ( params . size ( ) > 2 ) strAccount = AccountFromValue ( params [ 2 ] ) ; // ▁ Construct ▁ using ▁ pay - to - script - hash : ENDCOM CScript inner = _createmultisig ( params ) ; CScriptID innerID = inner . GetID ( ) ; pwalletMain -> AddCScript ( inner ) ; pwalletMain -> SetAddressBookName ( innerID , strAccount ) ; return CBitcoinAddress ( innerID ) . ToString ( ) ; } Value createmultisig ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 2 ) { string msg = " createmultisig ▁ < nrequired > ▁ < ' [ \ " key\ " , \ " key\ " ] ' > \n " " Creates ▁ a ▁ multi - signature ▁ address ▁ and ▁ returns ▁ a ▁ json ▁ object \n " " with ▁ keys : \n " " address ▁ : ▁ iloveyoucoins ▁ address \n " " redeemScript ▁ : ▁ hex - encoded ▁ redemption ▁ script " ; throw runtime_error ( msg ) ; } // ▁ Construct ▁ using ▁ pay - to - script - hash : ENDCOM CScript inner = _createmultisig ( params ) ; CScriptID innerID = inner . GetID ( ) ; CBitcoinAddress address ( innerID ) ; Object result ; result . push_back ( Pair ( " address " , address . ToString ( ) ) ) ; result . push_back ( Pair ( " redeemScript " , HexStr ( inner . begin ( ) , inner . end ( ) ) ) ) ; return result ; } struct tallyitem { int64 nAmount ; int nConf ; vector < uint256 > txids ; tallyitem ( ) { nAmount = 0 ; nConf = std :: numeric_limits < int > :: max ( ) ; } } ; Value ListReceived ( const Array & params , bool fByAccounts ) { // ▁ Minimum ▁ confirmations ENDCOM int nMinDepth = 1 ; if ( params . size ( ) > 0 ) nMinDepth = params [ 0 ] . get_int ( ) ; // ▁ Whether ▁ to ▁ include ▁ empty ▁ accounts ENDCOM bool fIncludeEmpty = false ; if ( params . size ( ) > 1 ) fIncludeEmpty = params [ 1 ] . get_bool ( ) ; // ▁ Tally ENDCOM map < CBitcoinAddress , tallyitem > mapTally ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; int nDepth = wtx . GetDepthInMainChain ( ) ; if ( nDepth < nMinDepth ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) { CTxDestination address ; if ( ! ExtractDestination ( txout . scriptPubKey , address ) || ! IsMine ( * pwalletMain , address ) ) continue ; tallyitem & item = mapTally [ address ] ; item . nAmount += txout . nValue ; item . nConf = min ( item . nConf , nDepth ) ; item . txids . push_back ( wtx . GetHash ( ) ) ; } } // ▁ Reply ENDCOM Array ret ; map < string , tallyitem > mapAccountTally ; BOOST_FOREACH ( const PAIRTYPE ( CBitcoinAddress , string ) & item , pwalletMain -> mapAddressBook ) { const CBitcoinAddress & address = item . first ; const string & strAccount = item . second ; map < CBitcoinAddress , tallyitem > :: iterator it = mapTally . find ( address ) ; if ( it == mapTally . end ( ) && ! fIncludeEmpty ) continue ; int64 nAmount = 0 ; int nConf = std :: numeric_limits < int > :: max ( ) ; if ( it != mapTally . end ( ) ) { nAmount = ( * it ) . second . nAmount ; nConf = ( * it ) . second . nConf ; } if ( fByAccounts ) { tallyitem & item = mapAccountTally [ strAccount ] ; item . nAmount += nAmount ; item . nConf = min ( item . nConf , nConf ) ; } else { Object obj ; obj . push_back ( Pair ( " address " , address . ToString ( ) ) ) ; obj . push_back ( Pair ( " account " , strAccount ) ) ; obj . push_back ( Pair ( " amount " , ValueFromAmount ( nAmount ) ) ) ; obj . push_back ( Pair ( " confirmations " , ( nConf == std :: numeric_limits < int > :: max ( ) ? 0 : nConf ) ) ) ; Array transactions ; if ( it != mapTally . end ( ) ) { BOOST_FOREACH ( const uint256 & item , ( * it ) . second . txids ) { transactions . push_back ( item . GetHex ( ) ) ; } } obj . push_back ( Pair ( " txids " , transactions ) ) ; ret . push_back ( obj ) ; } } if ( fByAccounts ) { for ( map < string , tallyitem > :: iterator it = mapAccountTally . begin ( ) ; it != mapAccountTally . end ( ) ; ++ it ) { int64 nAmount = ( * it ) . second . nAmount ; int nConf = ( * it ) . second . nConf ; Object obj ; obj . push_back ( Pair ( " account " , ( * it ) . first ) ) ; obj . push_back ( Pair ( " amount " , ValueFromAmount ( nAmount ) ) ) ; obj . push_back ( Pair ( " confirmations " , ( nConf == std :: numeric_limits < int > :: max ( ) ? 0 : nConf ) ) ) ; ret . push_back ( obj ) ; } } return ret ; } Value listreceivedbyaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " listreceivedbyaddress ▁ [ minconf = 1 ] ▁ [ includeempty = false ] \n " " [ minconf ] ▁ is ▁ the ▁ minimum ▁ number ▁ of ▁ confirmations ▁ before ▁ payments ▁ are ▁ included . \n " " [ includeempty ] ▁ whether ▁ to ▁ include ▁ addresses ▁ that ▁ haven ' t ▁ received ▁ any ▁ payments . \n " " Returns ▁ an ▁ array ▁ of ▁ objects ▁ containing : \n " " ▁ ▁ \ " address\ " ▁ : ▁ receiving ▁ address \n " " ▁ ▁ \ " account\ " ▁ : ▁ the ▁ account ▁ of ▁ the ▁ receiving ▁ address \n " " ▁ ▁ \ " amount\ " ▁ : ▁ total ▁ amount ▁ received ▁ by ▁ the ▁ address \n " " ▁ ▁ \ " confirmations\ " ▁ : ▁ number ▁ of ▁ confirmations ▁ of ▁ the ▁ most ▁ recent ▁ transaction ▁ included \n " " ▁ ▁ \ " txids\ " ▁ : ▁ list ▁ of ▁ transactions ▁ with ▁ outputs ▁ to ▁ the ▁ address \n " ) ; return ListReceived ( params , false ) ; } Value listreceivedbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " listreceivedbyaccount ▁ [ minconf = 1 ] ▁ [ includeempty = false ] \n " " [ minconf ] ▁ is ▁ the ▁ minimum ▁ number ▁ of ▁ confirmations ▁ before ▁ payments ▁ are ▁ included . \n " " [ includeempty ] ▁ whether ▁ to ▁ include ▁ accounts ▁ that ▁ haven ' t ▁ received ▁ any ▁ payments . \n " " Returns ▁ an ▁ array ▁ of ▁ objects ▁ containing : \n " " ▁ ▁ \ " account\ " ▁ : ▁ the ▁ account ▁ of ▁ the ▁ receiving ▁ addresses \n " " ▁ ▁ \ " amount\ " ▁ : ▁ total ▁ amount ▁ received ▁ by ▁ addresses ▁ with ▁ this ▁ account \n " " ▁ ▁ \ " confirmations\ " ▁ : ▁ number ▁ of ▁ confirmations ▁ of ▁ the ▁ most ▁ recent ▁ transaction ▁ included " ) ; return ListReceived ( params , true ) ; } static void MaybePushAddress ( Object & entry , const CTxDestination & dest ) { CBitcoinAddress addr ; if ( addr . Set ( dest ) ) entry . push_back ( Pair ( " address " , addr . ToString ( ) ) ) ; } void ListTransactions ( const CWalletTx & wtx , const string & strAccount , int nMinDepth , bool fLong , Array & ret ) { int64 nFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , nFee , strSentAccount ) ; bool fAllAccounts = ( strAccount == string ( " * " ) ) ; // ▁ Sent ENDCOM if ( ! wtx . IsCoinStake ( ) && ( ! listSent . empty ( ) || nFee != 0 ) && ( fAllAccounts || strAccount == strSentAccount ) ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & s , listSent ) { Object entry ; entry . push_back ( Pair ( " account " , strSentAccount ) ) ; MaybePushAddress ( entry , s . first ) ; entry . push_back ( Pair ( " category " , " send " ) ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( - s . second ) ) ) ; entry . push_back ( Pair ( " fee " , ValueFromAmount ( - nFee ) ) ) ; if ( fLong ) WalletTxToJSON ( wtx , entry ) ; ret . push_back ( entry ) ; } } // ▁ Received ENDCOM if ( listReceived . size ( ) > 0 && wtx . GetDepthInMainChain ( ) >= nMinDepth ) { bool stop = false ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) { string account ; if ( pwalletMain -> mapAddressBook . count ( r . first ) ) account = pwalletMain -> mapAddressBook [ r . first ] ; if ( fAllAccounts || ( account == strAccount ) ) { Object entry ; entry . push_back ( Pair ( " account " , account ) ) ; MaybePushAddress ( entry , r . first ) ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) ) { if ( wtx . GetDepthInMainChain ( ) < 1 ) entry . push_back ( Pair ( " category " , " orphan " ) ) ; else if ( wtx . GetBlocksToMaturity ( ) > 0 ) entry . push_back ( Pair ( " category " , " immature " ) ) ; else if ( wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " category " , " stake " ) ) ; else entry . push_back ( Pair ( " category " , " generate " ) ) ; } else { entry . push_back ( Pair ( " category " , " receive " ) ) ; } if ( ! wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " amount " , ValueFromAmount ( r . second ) ) ) ; else { entry . push_back ( Pair ( " amount " , ValueFromAmount ( - nFee ) ) ) ; stop = true ; // ▁ only ▁ one ▁ coinstake ▁ output ENDCOM } if ( fLong ) WalletTxToJSON ( wtx , entry ) ; ret . push_back ( entry ) ; } if ( stop ) break ; } } } void AcentryToJSON ( const CAccountingEntry & acentry , const string & strAccount , Array & ret ) { bool fAllAccounts = ( strAccount == string ( " * " ) ) ; if ( fAllAccounts || acentry . strAccount == strAccount ) { Object entry ; entry . push_back ( Pair ( " account " , acentry . strAccount ) ) ; entry . push_back ( Pair ( " category " , " move " ) ) ; entry . push_back ( Pair ( " time " , ( boost :: int64_t ) acentry . nTime ) ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( acentry . nCreditDebit ) ) ) ; entry . push_back ( Pair ( " otheraccount " , acentry . strOtherAccount ) ) ; entry . push_back ( Pair ( " comment " , acentry . strComment ) ) ; ret . push_back ( entry ) ; } } Value listtransactions ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 3 ) throw runtime_error ( " listtransactions ▁ [ account ] ▁ [ count = 10 ] ▁ [ from = 0 ] \n " " Returns ▁ up ▁ to ▁ [ count ] ▁ most ▁ recent ▁ transactions ▁ skipping ▁ the ▁ first ▁ [ from ] ▁ transactions ▁ for ▁ account ▁ [ account ] . " ) ; string strAccount = " * " ; if ( params . size ( ) > 0 ) strAccount = params [ 0 ] . get_str ( ) ; int nCount = 10 ; if ( params . size ( ) > 1 ) nCount = params [ 1 ] . get_int ( ) ; int nFrom = 0 ; if ( params . size ( ) > 2 ) nFrom = params [ 2 ] . get_int ( ) ; if ( nCount < 0 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Negative ▁ count " ) ; if ( nFrom < 0 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Negative ▁ from " ) ; Array ret ; std :: list < CAccountingEntry > acentries ; CWallet :: TxItems txOrdered = pwalletMain -> OrderedTxItems ( acentries , strAccount ) ; // ▁ iterate ▁ backwards ▁ until ▁ we ▁ have ▁ nCount ▁ items ▁ to ▁ return : ENDCOM for ( CWallet :: TxItems :: reverse_iterator it = txOrdered . rbegin ( ) ; it != txOrdered . rend ( ) ; ++ it ) { CWalletTx * const pwtx = ( * it ) . second . first ; if ( pwtx != 0 ) ListTransactions ( * pwtx , strAccount , 0 , true , ret ) ; CAccountingEntry * const pacentry = ( * it ) . second . second ; if ( pacentry != 0 ) AcentryToJSON ( * pacentry , strAccount , ret ) ; if ( ( int ) ret . size ( ) >= ( nCount + nFrom ) ) break ; } // ▁ ret ▁ is ▁ newest ▁ to ▁ oldest ENDCOM if ( nFrom > ( int ) ret . size ( ) ) nFrom = ret . size ( ) ; if ( ( nFrom + nCount ) > ( int ) ret . size ( ) ) nCount = ret . size ( ) - nFrom ; Array :: iterator first = ret . begin ( ) ; std :: advance ( first , nFrom ) ; Array :: iterator last = ret . begin ( ) ; std :: advance ( last , nFrom + nCount ) ; if ( last != ret . end ( ) ) ret . erase ( last , ret . end ( ) ) ; if ( first != ret . begin ( ) ) ret . erase ( ret . begin ( ) , first ) ; std :: reverse ( ret . begin ( ) , ret . end ( ) ) ; // ▁ Return ▁ oldest ▁ to ▁ newest ENDCOM return ret ; } Value listaccounts ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 1 ) throw runtime_error ( " listaccounts ▁ [ minconf = 1 ] \n " " Returns ▁ Object ▁ that ▁ has ▁ account ▁ names ▁ as ▁ keys , ▁ account ▁ balances ▁ as ▁ values . " ) ; int nMinDepth = 1 ; if ( params . size ( ) > 0 ) nMinDepth = params [ 0 ] . get_int ( ) ; map < string , int64 > mapAccountBalances ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , string ) & entry , pwalletMain -> mapAddressBook ) { if ( IsMine ( * pwalletMain , entry . first ) ) // ▁ This ▁ address ▁ belongs ▁ to ▁ me ENDCOM mapAccountBalances [ entry . second ] = 0 ; } for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; int64 nFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , nFee , strSentAccount ) ; mapAccountBalances [ strSentAccount ] -= nFee ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & s , listSent ) mapAccountBalances [ strSentAccount ] -= s . second ; if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) if ( pwalletMain -> mapAddressBook . count ( r . first ) ) mapAccountBalances [ pwalletMain -> mapAddressBook [ r . first ] ] += r . second ; else mapAccountBalances [ " " ] += r . second ; } } list < CAccountingEntry > acentries ; CWalletDB ( pwalletMain -> strWalletFile ) . ListAccountCreditDebit ( " * " , acentries ) ; BOOST_FOREACH ( const CAccountingEntry & entry , acentries ) mapAccountBalances [ entry . strAccount ] += entry . nCreditDebit ; Object ret ; BOOST_FOREACH ( const PAIRTYPE ( string , int64 ) & accountBalance , mapAccountBalances ) { ret . push_back ( Pair ( accountBalance . first , ValueFromAmount ( accountBalance . second ) ) ) ; } return ret ; } Value listsinceblock ( const Array & params , bool fHelp ) { if ( fHelp ) throw runtime_error ( " listsinceblock ▁ [ blockhash ] ▁ [ target - confirmations ] \n " " Get ▁ all ▁ transactions ▁ in ▁ blocks ▁ since ▁ block ▁ [ blockhash ] , ▁ or ▁ all ▁ transactions ▁ if ▁ omitted " ) ; CBlockIndex * pindex = NULL ; int target_confirms = 1 ; if ( params . size ( ) > 0 ) { uint256 blockId = 0 ; blockId . SetHex ( params [ 0 ] . get_str ( ) ) ; pindex = CBlockLocator ( blockId ) . GetBlockIndex ( ) ; } if ( params . size ( ) > 1 ) { target_confirms = params [ 1 ] . get_int ( ) ; if ( target_confirms < 1 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Invalid ▁ parameter " ) ; } int depth = pindex ? ( 1 + nBestHeight - pindex -> nHeight ) : - 1 ; Array transactions ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; it ++ ) { CWalletTx tx = ( * it ) . second ; if ( depth == - 1 || tx . GetDepthInMainChain ( ) < depth ) ListTransactions ( tx , " * " , 0 , true , transactions ) ; } uint256 lastblock ; if ( target_confirms == 1 ) { lastblock = hashBestChain ; } else { int target_height = pindexBest -> nHeight + 1 - target_confirms ; CBlockIndex * block ; for ( block = pindexBest ; block && block -> nHeight > target_height ; block = block -> pprev ) { } lastblock = block ? block -> GetBlockHash ( ) : 0 ; } Object ret ; ret . push_back ( Pair ( " transactions " , transactions ) ) ; ret . push_back ( Pair ( " lastblock " , lastblock . GetHex ( ) ) ) ; return ret ; } Value gettransaction ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " gettransaction ▁ < txid > \n " " Get ▁ detailed ▁ information ▁ about ▁ in - wallet ▁ transaction ▁ < txid > " ) ; uint256 hash ; hash . SetHex ( params [ 0 ] . get_str ( ) ) ; Object entry ; if ( ! pwalletMain -> mapWallet . count ( hash ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ or ▁ non - wallet ▁ transaction ▁ id " ) ; const CWalletTx & wtx = pwalletMain -> mapWallet [ hash ] ; int64 nCredit = wtx . GetCredit ( ) ; int64 nDebit = wtx . GetDebit ( ) ; int64 nNet = nCredit - nDebit ; int64 nFee = ( wtx . IsFromMe ( ) ? wtx . GetValueOut ( ) - nDebit : 0 ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( nNet - nFee ) ) ) ; if ( wtx . IsFromMe ( ) ) entry . push_back ( Pair ( " fee " , ValueFromAmount ( nFee ) ) ) ; WalletTxToJSON ( wtx , entry ) ; Array details ; ListTransactions ( wtx , " * " , 0 , false , details ) ; entry . push_back ( Pair ( " details " , details ) ) ; return entry ; } Value backupwallet ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " backupwallet ▁ < destination > \n " " Safely ▁ copies ▁ wallet . dat ▁ to ▁ destination , ▁ which ▁ can ▁ be ▁ a ▁ directory ▁ or ▁ a ▁ path ▁ with ▁ filename . " ) ; string strDest = params [ 0 ] . get_str ( ) ; if ( ! BackupWallet ( * pwalletMain , strDest ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Error : ▁ Wallet ▁ backup ▁ failed ! " ) ; return Value :: null ; } Value keypoolrefill ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " keypoolrefill \n " " Fills ▁ the ▁ keypool . " + HelpRequiringPassphrase ( ) ) ; EnsureWalletIsUnlocked ( ) ; pwalletMain -> TopUpKeyPool ( ) ; if ( pwalletMain -> GetKeyPoolSize ( ) < GetArg ( " - keypool " , 100 ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Error ▁ refreshing ▁ keypool . " ) ; return Value :: null ; } void ThreadTopUpKeyPool ( void * parg ) { // ▁ Make ▁ this ▁ thread ▁ recognisable ▁ as ▁ the ▁ key - topping - up ▁ thread ENDCOM RenameThread ( " iloveyoucoins - key - top " ) ; pwalletMain -> TopUpKeyPool ( ) ; } void ThreadCleanWalletPassphrase ( void * parg ) { // ▁ Make ▁ this ▁ thread ▁ recognisable ▁ as ▁ the ▁ wallet ▁ relocking ▁ thread ENDCOM RenameThread ( " iloveyoucoins - lock - wa " ) ; int64 nMyWakeTime = GetTimeMillis ( ) + * ( ( int64 * ) parg ) * 1000 ; ENTER_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; if ( nWalletUnlockTime == 0 ) { nWalletUnlockTime = nMyWakeTime ; do { if ( nWalletUnlockTime == 0 ) break ; int64 nToSleep = nWalletUnlockTime - GetTimeMillis ( ) ; if ( nToSleep <= 0 ) break ; LEAVE_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; MilliSleep ( nToSleep ) ; ENTER_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; } while ( 1 ) ; if ( nWalletUnlockTime ) { nWalletUnlockTime = 0 ; pwalletMain -> Lock ( ) ; } } else { if ( nWalletUnlockTime < nMyWakeTime ) nWalletUnlockTime = nMyWakeTime ; } LEAVE_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; delete ( int64 * ) parg ; } Value walletpassphrase ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) < 2 || params . size ( ) > 3 ) ) throw runtime_error ( " walletpassphrase ▁ < passphrase > ▁ < timeout > ▁ [ stakingonly ] \n " " Stores ▁ the ▁ wallet ▁ decryption ▁ key ▁ in ▁ memory ▁ for ▁ < timeout > ▁ seconds . \n " " if ▁ [ stakingonly ] ▁ is ▁ true ▁ sending ▁ functions ▁ are ▁ disabled . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletpassphrase ▁ was ▁ called . " ) ; if ( ! pwalletMain -> IsLocked ( ) ) throw JSONRPCError ( RPC_WALLET_ALREADY_UNLOCKED , " Error : ▁ Wallet ▁ is ▁ already ▁ unlocked . " ) ; // ▁ Note ▁ that ▁ the ▁ walletpassphrase ▁ is ▁ stored ▁ in ▁ params [ 0 ] ▁ which ▁ is ▁ not ▁ mlock ( ) ed ENDCOM SecureString strWalletPass ; strWalletPass . reserve ( 100 ) ; // ▁ TODO : ▁ get ▁ rid ▁ of ▁ this ▁ . c _ str ( ) ▁ by ▁ implementing ▁ SecureString : : operator = ( std : : string ) ENDCOM // ▁ Alternately , ▁ find ▁ a ▁ way ▁ to ▁ make ▁ params [ 0 ] ▁ mlock ( ) ' d ▁ to ▁ begin ▁ with . ENDCOM strWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; if ( strWalletPass . length ( ) > 0 ) { if ( ! pwalletMain -> Unlock ( strWalletPass ) ) throw JSONRPCError ( RPC_WALLET_PASSPHRASE_INCORRECT , " Error : ▁ The ▁ wallet ▁ passphrase ▁ entered ▁ was ▁ incorrect . " ) ; } else throw runtime_error ( " walletpassphrase ▁ < passphrase > ▁ < timeout > \n " " Stores ▁ the ▁ wallet ▁ decryption ▁ key ▁ in ▁ memory ▁ for ▁ < timeout > ▁ seconds . " ) ; NewThread ( ThreadTopUpKeyPool , NULL ) ; int64 * pnSleepTime = new int64 ( params [ 1 ] . get_int64 ( ) ) ; NewThread ( ThreadCleanWalletPassphrase , pnSleepTime ) ; // ▁ ppcoin : ▁ if ▁ user ▁ OS ▁ account ▁ compromised ▁ prevent ▁ trivial ▁ sendmoney ▁ commands ENDCOM if ( params . size ( ) > 2 ) fWalletUnlockStakingOnly = params [ 2 ] . get_bool ( ) ; else fWalletUnlockStakingOnly = false ; return Value :: null ; } Value walletpassphrasechange ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 2 ) ) throw runtime_error ( " walletpassphrasechange ▁ < oldpassphrase > ▁ < newpassphrase > \n " " Changes ▁ the ▁ wallet ▁ passphrase ▁ from ▁ < oldpassphrase > ▁ to ▁ < newpassphrase > . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletpassphrasechange ▁ was ▁ called . " ) ; // ▁ TODO : ▁ get ▁ rid ▁ of ▁ these ▁ . c _ str ( ) ▁ calls ▁ by ▁ implementing ▁ SecureString : : operator = ( std : : string ) ENDCOM // ▁ Alternately , ▁ find ▁ a ▁ way ▁ to ▁ make ▁ params [ 0 ] ▁ mlock ( ) ' d ▁ to ▁ begin ▁ with . ENDCOM SecureString strOldWalletPass ; strOldWalletPass . reserve ( 100 ) ; strOldWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; SecureString strNewWalletPass ; strNewWalletPass . reserve ( 100 ) ; strNewWalletPass = params [ 1 ] . get_str ( ) . c_str ( ) ; if ( strOldWalletPass . length ( ) < 1 || strNewWalletPass . length ( ) < 1 ) throw runtime_error ( " walletpassphrasechange ▁ < oldpassphrase > ▁ < newpassphrase > \n " " Changes ▁ the ▁ wallet ▁ passphrase ▁ from ▁ < oldpassphrase > ▁ to ▁ < newpassphrase > . " ) ; if ( ! pwalletMain -> ChangeWalletPassphrase ( strOldWalletPass , strNewWalletPass ) ) throw JSONRPCError ( RPC_WALLET_PASSPHRASE_INCORRECT , " Error : ▁ The ▁ wallet ▁ passphrase ▁ entered ▁ was ▁ incorrect . " ) ; return Value :: null ; } Value walletlock ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 0 ) ) throw runtime_error ( " walletlock \n " " Removes ▁ the ▁ wallet ▁ encryption ▁ key ▁ from ▁ memory , ▁ locking ▁ the ▁ wallet . \n " " After ▁ calling ▁ this ▁ method , ▁ you ▁ will ▁ need ▁ to ▁ call ▁ walletpassphrase ▁ again \n " " before ▁ being ▁ able ▁ to ▁ call ▁ any ▁ methods ▁ which ▁ require ▁ the ▁ wallet ▁ to ▁ be ▁ unlocked . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletlock ▁ was ▁ called . " ) ; { LOCK ( cs_nWalletUnlockTime ) ; pwalletMain -> Lock ( ) ; nWalletUnlockTime = 0 ; } return Value :: null ; } Value encryptwallet ( const Array & params , bool fHelp ) { if ( ! pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 1 ) ) throw runtime_error ( " encryptwallet ▁ < passphrase > \n " " Encrypts ▁ the ▁ wallet ▁ with ▁ < passphrase > . " ) ; if ( fHelp ) return true ; if ( pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ encrypted ▁ wallet , ▁ but ▁ encryptwallet ▁ was ▁ called . " ) ; // ▁ TODO : ▁ get ▁ rid ▁ of ▁ this ▁ . c _ str ( ) ▁ by ▁ implementing ▁ SecureString : : operator = ( std : : string ) ENDCOM // ▁ Alternately , ▁ find ▁ a ▁ way ▁ to ▁ make ▁ params [ 0 ] ▁ mlock ( ) ' d ▁ to ▁ begin ▁ with . ENDCOM SecureString strWalletPass ; strWalletPass . reserve ( 100 ) ; strWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; if ( strWalletPass . length ( ) < 1 ) throw runtime_error ( " encryptwallet ▁ < passphrase > \n " " Encrypts ▁ the ▁ wallet ▁ with ▁ < passphrase > . " ) ; if ( ! pwalletMain -> EncryptWallet ( strWalletPass ) ) throw JSONRPCError ( RPC_WALLET_ENCRYPTION_FAILED , " Error : ▁ Failed ▁ to ▁ encrypt ▁ the ▁ wallet . " ) ; // ▁ BDB ▁ seems ▁ to ▁ have ▁ a ▁ bad ▁ habit ▁ of ▁ writing ▁ old ▁ data ▁ into ENDCOM // ▁ slack ▁ space ▁ in ▁ . dat ▁ files ; ▁ that ▁ is ▁ bad ▁ if ▁ the ▁ old ▁ data ▁ is ENDCOM // ▁ unencrypted ▁ private ▁ keys . ▁ So : ENDCOM StartShutdown ( ) ; return " wallet ▁ encrypted ; ▁ ILoveYouCoins ▁ server ▁ stopping , ▁ restart ▁ to ▁ run ▁ with ▁ encrypted ▁ wallet . ▁ The ▁ keypool ▁ has ▁ been ▁ flushed , ▁ you ▁ need ▁ to ▁ make ▁ a ▁ new ▁ backup . " ; } class DescribeAddressVisitor : public boost :: static_visitor < Object > { public : Object operator ( ) ( const CNoDestination & dest ) const { return Object ( ) ; } Object operator ( ) ( const CKeyID & keyID ) const { Object obj ; CPubKey vchPubKey ; pwalletMain -> GetPubKey ( keyID , vchPubKey ) ; obj . push_back ( Pair ( " isscript " , false ) ) ; obj . push_back ( Pair ( " pubkey " , HexStr ( vchPubKey ) ) ) ; obj . push_back ( Pair ( " iscompressed " , vchPubKey . IsCompressed ( ) ) ) ; return obj ; } Object operator ( ) ( const CScriptID & scriptID ) const { Object obj ; obj . push_back ( Pair ( " isscript " , true ) ) ; CScript subscript ; pwalletMain -> GetCScript ( scriptID , subscript ) ; std :: vector < CTxDestination > addresses ; txnouttype whichType ; int nRequired ; ExtractDestinations ( subscript , whichType , addresses , nRequired ) ; obj . push_back ( Pair ( " script " , GetTxnOutputType ( whichType ) ) ) ; Array a ; BOOST_FOREACH ( const CTxDestination & addr , addresses ) a . push_back ( CBitcoinAddress ( addr ) . ToString ( ) ) ; obj . push_back ( Pair ( " addresses " , a ) ) ; if ( whichType == TX_MULTISIG ) obj . push_back ( Pair ( " sigsrequired " , nRequired ) ) ; return obj ; } } ; Value validateaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " validateaddress ▁ < iloveyoucoinsaddress > \n " " Return ▁ information ▁ about ▁ < iloveyoucoinsaddress > . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; bool isValid = address . IsValid ( ) ; Object ret ; ret . push_back ( Pair ( " isvalid " , isValid ) ) ; if ( isValid ) { CTxDestination dest = address . Get ( ) ; string currentAddress = address . ToString ( ) ; ret . push_back ( Pair ( " address " , currentAddress ) ) ; bool fMine = pwalletMain ? IsMine ( * pwalletMain , dest ) : false ; ret . push_back ( Pair ( " ismine " , fMine ) ) ; if ( fMine ) { Object detail = boost :: apply_visitor ( DescribeAddressVisitor ( ) , dest ) ; ret . insert ( ret . end ( ) , detail . begin ( ) , detail . end ( ) ) ; } if ( pwalletMain && pwalletMain -> mapAddressBook . count ( dest ) ) ret . push_back ( Pair ( " account " , pwalletMain -> mapAddressBook [ dest ] ) ) ; } return ret ; } // ▁ ppcoin : ▁ reserve ▁ balance ▁ from ▁ being ▁ staked ▁ for ▁ network ▁ protection ENDCOM Value reservebalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " reservebalance ▁ [ < reserve > ▁ [ amount ] ] \n " " < reserve > ▁ is ▁ true ▁ or ▁ false ▁ to ▁ turn ▁ balance ▁ reserve ▁ on ▁ or ▁ off . \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ rounded ▁ to ▁ cent . \n " " Set ▁ reserve ▁ amount ▁ not ▁ participating ▁ in ▁ network ▁ protection . \n " " If ▁ no ▁ parameters ▁ provided ▁ current ▁ setting ▁ is ▁ printed . \n " ) ; if ( params . size ( ) > 0 ) { bool fReserve = params [ 0 ] . get_bool ( ) ; if ( fReserve ) { if ( params . size ( ) == 1 ) throw runtime_error ( " must ▁ provide ▁ amount ▁ to ▁ reserve ▁ balance . \n " ) ; int64 nAmount = AmountFromValue ( params [ 1 ] ) ; nAmount = ( nAmount / CENT ) * CENT ; // ▁ round ▁ to ▁ cent ENDCOM if ( nAmount < 0 ) throw runtime_error ( " amount ▁ cannot ▁ be ▁ negative . \n " ) ; nReserveBalance = nAmount ; } else { if ( params . size ( ) > 1 ) throw runtime_error ( " cannot ▁ specify ▁ amount ▁ to ▁ turn ▁ off ▁ reserve . \n " ) ; nReserveBalance = 0 ; } } Object result ; result . push_back ( Pair ( " reserve " , ( nReserveBalance > 0 ) ) ) ; result . push_back ( Pair ( " amount " , ValueFromAmount ( nReserveBalance ) ) ) ; return result ; } // ▁ posv : ▁ interest ▁ received ENDCOM Value getinterest ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " getinterest ▁ [ start ] ▁ [ end ] \n " " Both ▁ [ start ] ▁ and ▁ [ end ] ▁ are ▁ inclusive ▁ and ▁ in ▁ the ▁ form ▁ of ▁ UNIX ▁ timestamps . " ) ; unsigned int nTimeStart = 0 ; unsigned int nTimeEnd = - 1 ; if ( params . size ( ) >= 1 ) nTimeStart = ( unsigned int ) ( params [ 0 ] . get_int ( ) ) ; if ( params . size ( ) == 2 ) nTimeEnd = ( unsigned int ) ( params [ 1 ] . get_int ( ) ) ; int64 nInterest = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsCoinStake ( ) || wtx . nTime < nTimeStart || wtx . nTime > nTimeEnd ) continue ; int64 nDebit = wtx . GetDebit ( ) ; int64 nCredit = wtx . GetCredit ( ) ; if ( nDebit <= 0 || nCredit <= 0 || nDebit >= nCredit ) continue ; else nInterest += nCredit - nDebit ; } return ValueFromAmount ( nInterest ) ; } Value lockunspent ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " lockunspent ▁ unlock ? ▁ [ array - of - Objects ] \n " " Updates ▁ list ▁ of ▁ temporarily ▁ unspendable ▁ outputs . " ) ; if ( params . size ( ) == 1 ) RPCTypeCheck ( params , list_of ( bool_type ) ) ; else RPCTypeCheck ( params , list_of ( bool_type ) ( array_type ) ) ; bool fUnlock = params [ 0 ] . get_bool ( ) ; if ( params . size ( ) == 1 ) { if ( fUnlock ) pwalletMain -> UnlockAllCoins ( ) ; return true ; } Array outputs = params [ 1 ] . get_array ( ) ; BOOST_FOREACH ( Value & output , outputs ) { if ( output . type ( ) != obj_type ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ expected ▁ object " ) ; const Object & o = output . get_obj ( ) ; RPCTypeCheck ( o , map_list_of ( " txid " , str_type ) ( " vout " , int_type ) ) ; string txid = find_value ( o , " txid " ) . get_str ( ) ; if ( ! IsHex ( txid ) ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ expected ▁ hex ▁ txid " ) ; int nOutput = find_value ( o , " vout " ) . get_int ( ) ; if ( nOutput < 0 ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ vout ▁ must ▁ be ▁ positive " ) ; COutPoint outpt ( uint256 ( txid ) , nOutput ) ; if ( fUnlock ) pwalletMain -> UnlockCoin ( outpt ) ; else pwalletMain -> LockCoin ( outpt ) ; } return true ; } Value listlockunspent ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " listlockunspent \n " " Returns ▁ list ▁ of ▁ temporarily ▁ unspendable ▁ outputs . " ) ; vector < COutPoint > vOutpts ; pwalletMain -> ListLockedCoins ( vOutpts ) ; Array ret ; BOOST_FOREACH ( COutPoint & outpt , vOutpts ) { Object o ; o . push_back ( Pair ( " txid " , outpt . hash . GetHex ( ) ) ) ; o . push_back ( Pair ( " vout " , ( int ) outpt . n ) ) ; ret . push_back ( o ) ; } return ret ; } </DOCUMENT>
<DOCUMENT_ID="Sija/swift/tree/master/Tests/Source/TestValueBool.cpp"> # include " stdafx . h " # include < cppunit / extensions / HelperMacros . h > # include " . . / . . / Source / stdafx . h " # include " . . / . . / Source / values / Bool . h " using namespace Swift ; class TestValueBool : public CPPUNIT_NS :: TestFixture { public : CPPUNIT_TEST_SUITE ( TestValueBool ) ; CPPUNIT_TEST ( testInit ) ; CPPUNIT_TEST ( testAssign ) ; CPPUNIT_TEST ( testGet ) ; CPPUNIT_TEST ( testSetClear ) ; CPPUNIT_TEST ( testOperators ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void setUp ( ) { } void tearDown ( ) { } protected : void testInit ( ) { CPPUNIT_ASSERT ( iValue :: hasTypeString ( Values :: Bool :: id ) ) ; } void testAssign ( ) { oValue b ( true ) ; CPPUNIT_ASSERT ( b -> getID ( ) == Values :: Bool :: id ) ; } void testGet ( ) { CPPUNIT_ASSERT ( oValue ( true ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ! ( ( Values :: Bool * ) oValue ( false ) . get ( ) ) -> output ( ) ) ; } void testSetClear ( ) { oValue v ( true ) ; v -> clear ( ) ; CPPUNIT_ASSERT ( ! ( v >> bool ( ) ) ) ; Values :: Bool * b = ( Values :: Bool * ) v . get ( ) ; b -> set ( true ) ; CPPUNIT_ASSERT ( v >> bool ( ) ) ; } void testOperators ( ) { CPPUNIT_ASSERT ( ( oValue ( true ) == oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( true ) != oValue ( false ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( true ) && oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( false ) || oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( ! oValue ( true ) == oValue ( false ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( ) << true ) -> getID ( ) == Values :: Bool :: id ) ; CPPUNIT_ASSERT ( ( oValue ( false ) >> bool ( ) ) == false ) ; } } ; CPPUNIT_TEST_SUITE_REGISTRATION ( TestValueBool ) ; </DOCUMENT>
<DOCUMENT_ID="CodeDJ/qt5-hidpi/tree/master/qt/qtdeclarative/src/quick/util/qquickanimatorcontroller.cpp"> /* * * * * STRNEWLINE * * STRNEWLINE * * ▁ Copyright ▁ ( C ) ▁ 2013 ▁ Digia ▁ Plc ▁ and / or ▁ its ▁ subsidiary ( - ies ) . STRNEWLINE * * ▁ Contact : ▁ http : // www . qt - project . org / legal STRNEWLINE * * STRNEWLINE * * ▁ This ▁ file ▁ is ▁ part ▁ of ▁ the ▁ QtQuick ▁ module ▁ of ▁ the ▁ Qt ▁ Toolkit . STRNEWLINE * * STRNEWLINE * * ▁ $ QT _ BEGIN _ LICENSE : LGPL $ STRNEWLINE * * ▁ Commercial ▁ License ▁ Usage STRNEWLINE * * ▁ Licensees ▁ holding ▁ valid ▁ commercial ▁ Qt ▁ licenses ▁ may ▁ use ▁ this ▁ file ▁ in STRNEWLINE * * ▁ accordance ▁ with ▁ the ▁ commercial ▁ license ▁ agreement ▁ provided ▁ with ▁ the STRNEWLINE * * ▁ Software ▁ or , ▁ alternatively , ▁ in ▁ accordance ▁ with ▁ the ▁ terms ▁ contained ▁ in STRNEWLINE * * ▁ a ▁ written ▁ agreement ▁ between ▁ you ▁ and ▁ Digia . ▁ For ▁ licensing ▁ terms ▁ and STRNEWLINE * * ▁ conditions ▁ see ▁ http : // qt . digia . com / licensing . ▁ For ▁ further ▁ information STRNEWLINE * * ▁ use ▁ the ▁ contact ▁ form ▁ at ▁ http : // qt . digia . com / contact - us . STRNEWLINE * * STRNEWLINE * * ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ Usage STRNEWLINE * * ▁ Alternatively , ▁ this ▁ file ▁ may ▁ be ▁ used ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser STRNEWLINE * * ▁ General ▁ Public ▁ License ▁ version ▁ 2.1 ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software STRNEWLINE * * ▁ Foundation ▁ and ▁ appearing ▁ in ▁ the ▁ file ▁ LICENSE . LGPL ▁ included ▁ in ▁ the STRNEWLINE * * ▁ packaging ▁ of ▁ this ▁ file . ▁ Please ▁ review ▁ the ▁ following ▁ information ▁ to STRNEWLINE * * ▁ ensure ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ version ▁ 2.1 ▁ requirements STRNEWLINE * * ▁ will ▁ be ▁ met : ▁ http : // www . gnu . org / licenses / old - licenses / lgpl - 2.1 . html . STRNEWLINE * * STRNEWLINE * * ▁ In ▁ addition , ▁ as ▁ a ▁ special ▁ exception , ▁ Digia ▁ gives ▁ you ▁ certain ▁ additional STRNEWLINE * * ▁ rights . ▁ These ▁ rights ▁ are ▁ described ▁ in ▁ the ▁ Digia ▁ Qt ▁ LGPL ▁ Exception STRNEWLINE * * ▁ version ▁ 1.1 , ▁ included ▁ in ▁ the ▁ file ▁ LGPL _ EXCEPTION . txt ▁ in ▁ this ▁ package . STRNEWLINE * * STRNEWLINE * * ▁ GNU ▁ General ▁ Public ▁ License ▁ Usage STRNEWLINE * * ▁ Alternatively , ▁ this ▁ file ▁ may ▁ be ▁ used ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU STRNEWLINE * * ▁ General ▁ Public ▁ License ▁ version ▁ 3.0 ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software STRNEWLINE * * ▁ Foundation ▁ and ▁ appearing ▁ in ▁ the ▁ file ▁ LICENSE . GPL ▁ included ▁ in ▁ the STRNEWLINE * * ▁ packaging ▁ of ▁ this ▁ file . ▁ Please ▁ review ▁ the ▁ following ▁ information ▁ to STRNEWLINE * * ▁ ensure ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ version ▁ 3.0 ▁ requirements ▁ will ▁ be STRNEWLINE * * ▁ met : ▁ http : // www . gnu . org / copyleft / gpl . html . STRNEWLINE * * STRNEWLINE * * STRNEWLINE * * ▁ $ QT _ END _ LICENSE $ STRNEWLINE * * STRNEWLINE * * * * */ # include " qquickanimatorcontroller _ p . h " # include < private / qquickwindow_p . h > # include < private / qsgrenderloop_p . h > # include < private / qanimationgroupjob_p . h > # include < QtGui / qscreen . h > # include < QtCore / qcoreapplication . h > QT_BEGIN_NAMESPACE QQuickAnimatorController :: QQuickAnimatorController ( ) : m_window ( 0 ) { } QQuickAnimatorController :: ~ QQuickAnimatorController ( ) { // ▁ The ▁ proxy ▁ job ▁ might ▁ already ▁ have ▁ been ▁ deleted , ▁ in ▁ which ▁ case ▁ we ENDCOM // ▁ need ▁ to ▁ avoid ▁ calling ▁ functions ▁ on ▁ them . ▁ Then ▁ delete ▁ the ▁ job . ENDCOM foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; delete job ; } foreach ( QQuickAnimatorProxyJob * proxy , m_animatorRoots ) proxy -> controllerWasDeleted ( ) ; qDeleteAll ( m_animatorRoots . keys ( ) ) ; // ▁ Delete ▁ those ▁ who ▁ have ▁ been ▁ started , ▁ stopped ▁ and ▁ are ▁ now ▁ still ENDCOM // ▁ pending ▁ for ▁ restart . ENDCOM foreach ( QAbstractAnimationJob * job , m_starting . keys ( ) ) { if ( ! m_animatorRoots . contains ( job ) ) delete job ; } } void QQuickAnimatorController :: itemDestroyed ( QObject * o ) { m_deletedSinceLastFrame << ( QQuickItem * ) o ; } void QQuickAnimatorController :: advance ( ) { bool running = false ; for ( QHash < QAbstractAnimationJob * , QQuickAnimatorProxyJob * > :: const_iterator it = m_animatorRoots . constBegin ( ) ; ! running && it != m_animatorRoots . constEnd ( ) ; ++ it ) { if ( it . key ( ) -> isRunning ( ) ) running = true ; } // ▁ It ▁ was ▁ tempting ▁ to ▁ only ▁ run ▁ over ▁ the ▁ active ▁ animations , ▁ but ▁ we ▁ need ▁ to ▁ push ENDCOM // ▁ the ▁ values ▁ for ▁ the ▁ transforms ▁ that ▁ finished ▁ in ▁ the ▁ last ▁ frame ▁ and ▁ those ▁ will ENDCOM // ▁ have ▁ been ▁ removed ▁ already . . . ENDCOM lock ( ) ; for ( QHash < QQuickItem * , QQuickTransformAnimatorJob :: Helper * > :: const_iterator it = m_transforms . constBegin ( ) ; it != m_transforms . constEnd ( ) ; ++ it ) { QQuickTransformAnimatorJob :: Helper * xform = * it ; // ▁ Set ▁ to ▁ zero ▁ when ▁ the ▁ item ▁ was ▁ deleted ▁ in ▁ beforeNodeSync ( ) . ENDCOM if ( ! xform -> item ) continue ; ( * it ) -> apply ( ) ; } unlock ( ) ; if ( running ) m_window -> update ( ) ; } static void qquick_initialize_helper ( QAbstractAnimationJob * job , QQuickAnimatorController * c ) { if ( job -> isRenderThreadJob ( ) ) { QQuickAnimatorJob * j = static_cast < QQuickAnimatorJob * > ( job ) ; if ( ! j -> target ( ) ) { return ; } else if ( c -> m_deletedSinceLastFrame . contains ( j -> target ( ) ) ) { j -> targetWasDeleted ( ) ; } else { j -> addAnimationChangeListener ( c , QAbstractAnimationJob :: StateChange ) ; j -> initialize ( c ) ; } } else if ( job -> isGroup ( ) ) { QAnimationGroupJob * g = static_cast < QAnimationGroupJob * > ( job ) ; for ( QAbstractAnimationJob * a = g -> firstChild ( ) ; a ; a = a -> nextSibling ( ) ) qquick_initialize_helper ( a , c ) ; } } void QQuickAnimatorController :: beforeNodeSync ( ) { foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; job -> stop ( ) ; delete job ; } m_deleting . clear ( ) ; if ( m_starting . size ( ) ) m_window -> update ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_starting ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> addAnimationChangeListener ( this , QAbstractAnimationJob :: Completion ) ; qquick_initialize_helper ( job , this ) ; m_animatorRoots [ job ] = proxy ; job -> start ( ) ; proxy -> startedByController ( ) ; } m_starting . clear ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_stopping ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> stop ( ) ; } m_stopping . clear ( ) ; foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( ! job -> target ( ) ) continue ; else if ( m_deletedSinceLastFrame . contains ( job -> target ( ) ) ) job -> targetWasDeleted ( ) ; else if ( job -> isTransform ( ) ) { QQuickTransformAnimatorJob * xform = static_cast < QQuickTransformAnimatorJob * > ( job ) ; xform -> transformHelper ( ) -> sync ( ) ; } } foreach ( QQuickItem * wiped , m_deletedSinceLastFrame ) { QQuickTransformAnimatorJob :: Helper * helper = m_transforms . value ( wiped ) ; if ( helper ) helper -> item = 0 ; } m_deletedSinceLastFrame . clear ( ) ; } void QQuickAnimatorController :: afterNodeSync ( ) { foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( job -> isUniform ( ) && job -> target ( ) ) static_cast < QQuickUniformAnimatorJob * > ( job ) -> afterNodeSync ( ) ; } } void QQuickAnimatorController :: animationFinished ( QAbstractAnimationJob * job ) { /* ▁ We ▁ are ▁ currently ▁ on ▁ the ▁ render ▁ thread ▁ and ▁ m _ deleting ▁ is ▁ primarily STRNEWLINE ▁ * ▁ being ▁ written ▁ on ▁ the ▁ GUI ▁ Thread ▁ and ▁ read ▁ during ▁ sync . ▁ However , ▁ we ▁ don ' t STRNEWLINE ▁ * ▁ need ▁ to ▁ lock ▁ here ▁ as ▁ this ▁ is ▁ a ▁ direct ▁ result ▁ of ▁ animationDriver - > advance ( ) STRNEWLINE ▁ * ▁ which ▁ is ▁ already ▁ locked . ▁ For ▁ non - threaded ▁ render ▁ loops ▁ no ▁ locking ▁ is STRNEWLINE ▁ * ▁ needed ▁ in ▁ any ▁ case . STRNEWLINE ▁ */ if ( ! m_deleting . contains ( job ) ) { QQuickAnimatorProxyJob * proxy = m_animatorRoots [ job ] ; if ( proxy ) QCoreApplication :: postEvent ( proxy , new QEvent ( QEvent :: User ) ) ; // ▁ else ▁ already ▁ gone . . . ENDCOM } } void QQuickAnimatorController :: animationStateChanged ( QAbstractAnimationJob * job , QAbstractAnimationJob :: State newState , QAbstractAnimationJob :: State oldState ) { Q_ASSERT ( job -> isRenderThreadJob ( ) ) ; QQuickAnimatorJob * animator = static_cast < QQuickAnimatorJob * > ( job ) ; if ( newState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations << animator ; animator -> setHasBeenRunning ( true ) ; } else if ( oldState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations . remove ( animator ) ; } } void QQuickAnimatorController :: requestSync ( ) { // ▁ Force ▁ a ▁ " sync " ▁ pass ▁ as ▁ the ▁ newly ▁ started ▁ animation ▁ needs ▁ to ▁ sync ▁ properties ▁ from ▁ GUI . ENDCOM m_window -> maybeUpdate ( ) ; } // ▁ These ▁ functions ▁ are ▁ called ▁ on ▁ the ▁ GUI ▁ thread . ENDCOM void QQuickAnimatorController :: startJob ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_starting [ job ] = proxy ; requestSync ( ) ; } void QQuickAnimatorController :: stopJob ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_stopping [ job ] = proxy ; requestSync ( ) ; } void QQuickAnimatorController :: deleteJob ( QAbstractAnimationJob * job ) { lock ( ) ; m_deleting << job ; requestSync ( ) ; unlock ( ) ; } QT_END_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="miniwebkit/src/tree/master/WebCore/xml/XMLSerializer.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2003 , ▁ 2006 ▁ Apple ▁ Inc . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2006 ▁ Samuel ▁ Weinig ▁ ( sam @ webkit . org ) STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ library ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or STRNEWLINE ▁ * ▁ modify ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public STRNEWLINE ▁ * ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either STRNEWLINE ▁ * ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ library ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU STRNEWLINE ▁ * ▁ Lesser ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public STRNEWLINE ▁ * ▁ License ▁ along ▁ with ▁ this ▁ library ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software STRNEWLINE ▁ * ▁ Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , ▁ Boston , ▁ MA ▁ 02110-1301 ▁ USA STRNEWLINE ▁ */ # include " config . h " # include " XMLSerializer . h " # include " Document . h " # include " ExceptionCode . h " # include " markup . h " namespace WebCore { String XMLSerializer :: serializeToString ( Node * node , ExceptionCode & ec ) { if ( ! node ) return String ( ) ; if ( ! node -> document ( ) ) { // ▁ Due ▁ to ▁ the ▁ fact ▁ that ▁ DocumentType ▁ nodes ▁ are ▁ created ▁ by ▁ the ▁ DOMImplementation ENDCOM // ▁ and ▁ not ▁ the ▁ Document , ▁ it ▁ is ▁ possible ▁ for ▁ it ▁ to ▁ not ▁ have ▁ a ▁ Document ▁ associated ENDCOM // ▁ with ▁ it . ▁ It ▁ should ▁ be ▁ the ▁ only ▁ type ▁ of ▁ node ▁ where ▁ this ▁ is ▁ possible . ENDCOM ASSERT ( node -> nodeType ( ) == Node :: DOCUMENT_TYPE_NODE ) ; ec = INVALID_ACCESS_ERR ; return String ( ) ; } return createMarkup ( node ) ; } } // ▁ namespace ▁ WebCore ENDCOM </DOCUMENT>
<DOCUMENT_ID="hkernbach/arangodb/tree/master/3rdParty/boost/1.62.0/libs/phoenix/test/include/core/visit_each.cpp"> /* = = = = = STRNEWLINE ▁ Copyright ▁ ( c ) ▁ 2011 ▁ Thomas ▁ Heller STRNEWLINE ▁ Distributed ▁ under ▁ the ▁ Boost ▁ Software ▁ License , ▁ Version ▁ 1.0 . ▁ ( See ▁ accompanying STRNEWLINE ▁ file ▁ LICENSE _ 1_0 . txt ▁ or ▁ copy ▁ at ▁ http : // www . boost . org / LICENSE _ 1_0 . txt ) STRNEWLINE = = = = = */ # include < boost / phoenix / core / visit_each . hpp > int main ( ) { } </DOCUMENT>
<DOCUMENT_ID="rfloca/MITK/tree/master/Plugins/org.mitk.gui.qt.diffusionimagingapp/src/internal/Perspectives/QmitkDIAppConnectomicsPerspective.cpp"> /* = = = = = STRNEWLINE STRNEWLINE The ▁ Medical ▁ Imaging ▁ Interaction ▁ Toolkit ▁ ( MITK ) STRNEWLINE STRNEWLINE Copyright ▁ ( c ) ▁ German ▁ Cancer ▁ Research ▁ Center , STRNEWLINE Division ▁ of ▁ Medical ▁ and ▁ Biological ▁ Informatics . STRNEWLINE All ▁ rights ▁ reserved . STRNEWLINE STRNEWLINE This ▁ software ▁ is ▁ distributed ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without STRNEWLINE even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR STRNEWLINE A ▁ PARTICULAR ▁ PURPOSE . STRNEWLINE STRNEWLINE See ▁ LICENSE . txt ▁ or ▁ http : // www . mitk . org ▁ for ▁ details . STRNEWLINE STRNEWLINE = = = = = */ # include " QmitkDIAppConnectomicsPerspective . h " # include " berryIViewLayout . h " void QmitkDIAppConnectomicsPerspective :: CreateInitialLayout ( berry :: IPageLayout :: Pointer layout ) { // ▁ all ▁ di - app ▁ perspectives ▁ should ▁ have ▁ the ▁ following : ENDCOM std :: string editorArea = layout -> GetEditorArea ( ) ; layout -> AddStandaloneView ( " org . mitk . views . datamanager " , false , berry :: IPageLayout :: LEFT , 0.3f , editorArea ) ; layout -> AddStandaloneView ( " org . mitk . views . controlvisualizationpropertiesview " , false , berry :: IPageLayout :: BOTTOM , .15f , " org . mitk . views . datamanager " ) ; berry :: IFolderLayout :: Pointer left = layout -> CreateFolder ( " org . mbi . diffusionimaginginternal . leftcontrols " , berry :: IPageLayout :: BOTTOM , 0.1f , " org . mitk . views . controlvisualizationpropertiesview " ) ; layout -> AddStandaloneViewPlaceholder ( " org . mitk . views . imagenavigator " , berry :: IPageLayout :: BOTTOM , .4f , " org . mbi . diffusionimaginginternal . leftcontrols " , false ) ; // ▁ here ▁ goes ▁ the ▁ perspective ▁ specific ▁ stuff ENDCOM left -> AddView ( " org . mitk . views . connectomicsstatistics " ) ; berry :: IViewLayout :: Pointer lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsstatistics " ) ; lo -> SetCloseable ( false ) ; left -> AddView ( " org . mitk . views . connectomicsnetworkoperations " ) ; lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsnetworkoperations " ) ; lo -> SetCloseable ( false ) ; left -> AddView ( " org . mitk . views . connectomicsdata " ) ; lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsdata " ) ; lo -> SetCloseable ( false ) ; } </DOCUMENT>
<DOCUMENT_ID="kyroskoh/phantomjs/tree/master/src/qt/qtwebkit/Source/WebCore/platform/network/soup/SoupURIUtils.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 20010 ▁ Igalia ▁ S . L . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ library ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or STRNEWLINE ▁ * ▁ modify ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public STRNEWLINE ▁ * ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either STRNEWLINE ▁ * ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ library ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU STRNEWLINE ▁ * ▁ Lesser ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public STRNEWLINE ▁ * ▁ License ▁ along ▁ with ▁ this ▁ library ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software STRNEWLINE ▁ * ▁ Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , ▁ Boston , ▁ MA ▁ 02110-1301 ▁ USA STRNEWLINE ▁ */ # include " config . h " # include " SoupURIUtils . h " # include < wtf / gobject / GOwnPtr . h > # include < libsoup / soup . h > namespace WebCore { // ▁ Motivated ▁ by ▁ https : // bugs . webkit . org / show _ bug . cgi ? id = 38956 . ▁ libsoup ENDCOM // ▁ does ▁ not ▁ add ▁ the ▁ password ▁ to ▁ the ▁ URL ▁ when ▁ calling ENDCOM // ▁ soup _ uri _ to _ string , ▁ and ▁ thus ▁ the ▁ requests ▁ are ▁ not ▁ properly ENDCOM // ▁ built . ▁ Fixing ▁ soup _ uri _ to _ string ▁ is ▁ a ▁ no - no ▁ as ▁ the ▁ maintainer ▁ does ENDCOM // ▁ not ▁ want ▁ to ▁ break ▁ compatibility ▁ with ▁ previous ▁ implementations ENDCOM KURL soupURIToKURL ( SoupURI * soupURI ) { GOwnPtr < gchar > urlString ( soup_uri_to_string ( soupURI , FALSE ) ) ; KURL url ( KURL ( ) , String :: fromUTF8 ( urlString . get ( ) ) ) ; if ( ! soupURI -> password ) return url ; url . setPass ( String :: fromUTF8 ( soupURI -> password ) ) ; return url ; } } </DOCUMENT>
<DOCUMENT_ID="samdnic/Tarantula/tree/master/boost/libs/coroutine/src/detail/standard_stack_allocator_posix.cpp"> // ▁ Copyright ▁ Oliver ▁ Kowalke ▁ 2009 . ENDCOM // ▁ Distributed ▁ under ▁ the ▁ Boost ▁ Software ▁ License , ▁ Version ▁ 1.0 . ENDCOM // ▁ ( See ▁ accompanying ▁ file ▁ LICENSE _ 1_0 . txt ▁ or ▁ copy ▁ at ENDCOM // ▁ http : // www . boost . org / LICENSE _ 1_0 . txt ) ENDCOM # define BOOST_COROUTINES_SOURCE # include " boost / coroutine / detail / standard _ stack _ allocator . hpp " extern " C " { # include < fcntl . h > # include < signal . h > # include < sys / mman . h > # include < sys / resource . h > # include < sys / stat . h > # include < sys / time . h > # include < sys / types . h > # include < unistd . h > } // # if ▁ _ POSIX _ C _ SOURCE ▁ > = ▁ 200112L ENDCOM # include < algorithm > # include < cmath > # include < cstring > # include < stdexcept > # include < boost / assert . hpp > # include < boost / context / fcontext . hpp > # include < boost / coroutine / stack_context . hpp > # if ! defined ( SIGSTKSZ ) # define SIGSTKSZ ( 8 * 1024 ) # define UDEF_SIGSTKSZ # endif # ifdef BOOST_HAS_ABI_HEADERS # include BOOST_ABI_PREFIX # endif namespace boost { namespace coroutines { namespace detail { std :: size_t pagesize ( ) { // ▁ conform ▁ to ▁ POSIX . 1-2001 ENDCOM static std :: size_t size = :: sysconf ( _SC_PAGESIZE ) ; return size ; } rlimit stacksize_limit_ ( ) { rlimit limit ; // ▁ conforming ▁ to ▁ POSIX . 1-2001 ENDCOM # if defined ( BOOST_DISABLE_ASSERTS ) :: getrlimit ( RLIMIT_STACK , & limit ) ; # else const int result = :: getrlimit ( RLIMIT_STACK , & limit ) ; BOOST_ASSERT ( 0 == result ) ; # endif return limit ; } rlimit stacksize_limit ( ) { static rlimit limit = stacksize_limit_ ( ) ; return limit ; } std :: size_t page_count ( std :: size_t stacksize ) { return static_cast < std :: size_t > ( std :: ceil ( static_cast < float > ( stacksize ) / pagesize ( ) ) ) ; } bool standard_stack_allocator :: is_stack_unbound ( ) { return RLIM_INFINITY == detail :: stacksize_limit ( ) . rlim_max ; } std :: size_t standard_stack_allocator :: default_stacksize ( ) { std :: size_t size = 8 * minimum_stacksize ( ) ; if ( is_stack_unbound ( ) ) return size ; BOOST_ASSERT ( maximum_stacksize ( ) >= minimum_stacksize ( ) ) ; return maximum_stacksize ( ) == size ? size : ( std :: min ) ( size , maximum_stacksize ( ) ) ; } std :: size_t standard_stack_allocator :: minimum_stacksize ( ) { return SIGSTKSZ + sizeof ( context :: fcontext_t ) + 15 ; } std :: size_t standard_stack_allocator :: maximum_stacksize ( ) { BOOST_ASSERT ( ! is_stack_unbound ( ) ) ; return static_cast < std :: size_t > ( detail :: stacksize_limit ( ) . rlim_max ) ; } void standard_stack_allocator :: allocate ( stack_context & ctx , std :: size_t size ) { BOOST_ASSERT ( minimum_stacksize ( ) <= size ) ; BOOST_ASSERT ( is_stack_unbound ( ) || ( maximum_stacksize ( ) >= size ) ) ; const std :: size_t pages ( detail :: page_count ( size ) + 1 ) ; // ▁ add ▁ one ▁ guard ▁ page ENDCOM const std :: size_t size_ ( pages * detail :: pagesize ( ) ) ; BOOST_ASSERT ( 0 < size && 0 < size_ ) ; const int fd ( :: open ( " / dev / zero " , O_RDONLY ) ) ; BOOST_ASSERT ( - 1 != fd ) ; // ▁ conform ▁ to ▁ POSIX . 4 ▁ ( POSIX . 1b - 1993 , ▁ _ POSIX _ C _ SOURCE = 199309L ) ENDCOM void * limit = # if defined ( macintosh ) || defined ( __APPLE__ ) || defined ( __APPLE_CC__ ) :: mmap ( 0 , size_ , PROT_READ | PROT_WRITE , MAP_PRIVATE | MAP_ANON , - 1 , 0 ) ; # else :: mmap ( 0 , size_ , PROT_READ | PROT_WRITE , MAP_PRIVATE , fd , 0 ) ; # endif :: close ( fd ) ; if ( ! limit ) throw std :: bad_alloc ( ) ; std :: memset ( limit , ' \0' , size_ ) ; // ▁ conforming ▁ to ▁ POSIX . 1-2001 ENDCOM # if defined ( BOOST_DISABLE_ASSERTS ) :: mprotect ( limit , detail :: pagesize ( ) , PROT_NONE ) ; # else const int result ( :: mprotect ( limit , detail :: pagesize ( ) , PROT_NONE ) ) ; BOOST_ASSERT ( 0 == result ) ; # endif ctx . size = size_ ; ctx . sp = static_cast < char * > ( limit ) + ctx . size ; } void standard_stack_allocator :: deallocate ( stack_context & ctx ) { BOOST_ASSERT ( ctx . sp ) ; BOOST_ASSERT ( minimum_stacksize ( ) <= ctx . size ) ; BOOST_ASSERT ( is_stack_unbound ( ) || ( maximum_stacksize ( ) >= ctx . size ) ) ; void * limit = static_cast < char * > ( ctx . sp ) - ctx . size ; // ▁ conform ▁ to ▁ POSIX . 4 ▁ ( POSIX . 1b - 1993 , ▁ _ POSIX _ C _ SOURCE = 199309L ) ENDCOM :: munmap ( limit , ctx . size ) ; } } } } # ifdef BOOST_HAS_ABI_HEADERS # include BOOST_ABI_SUFFIX # endif # ifdef UDEF_SIGSTKSZ # undef SIGSTKSZ # endif </DOCUMENT>
<DOCUMENT_ID="renatofilho/QtCreator/tree/master/src/plugins/texteditor/codeassist/functionhintproposalwidget.cpp"> /* * * * * STRNEWLINE * * STRNEWLINE * * ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Qt ▁ Creator STRNEWLINE * * STRNEWLINE * * ▁ Copyright ▁ ( c ) ▁ 2011 ▁ Nokia ▁ Corporation ▁ and / or ▁ its ▁ subsidiary ( - ies ) . STRNEWLINE * * STRNEWLINE * * ▁ Contact : ▁ Nokia ▁ Corporation ▁ ( info @ qt . nokia . com ) STRNEWLINE * * STRNEWLINE * * STRNEWLINE * * ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ Usage STRNEWLINE * * STRNEWLINE * * ▁ This ▁ file ▁ may ▁ be ▁ used ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public STRNEWLINE * * ▁ License ▁ version ▁ 2.1 ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation ▁ and STRNEWLINE * * ▁ appearing ▁ in ▁ the ▁ file ▁ LICENSE . LGPL ▁ included ▁ in ▁ the ▁ packaging ▁ of ▁ this ▁ file . STRNEWLINE * * ▁ Please ▁ review ▁ the ▁ following ▁ information ▁ to ▁ ensure ▁ the ▁ GNU ▁ Lesser ▁ General STRNEWLINE * * ▁ Public ▁ License ▁ version ▁ 2.1 ▁ requirements ▁ will ▁ be ▁ met : STRNEWLINE * * ▁ http : // www . gnu . org / licenses / old - licenses / lgpl - 2.1 . html . STRNEWLINE * * STRNEWLINE * * ▁ In ▁ addition , ▁ as ▁ a ▁ special ▁ exception , ▁ Nokia ▁ gives ▁ you ▁ certain ▁ additional STRNEWLINE * * ▁ rights . ▁ These ▁ rights ▁ are ▁ described ▁ in ▁ the ▁ Nokia ▁ Qt ▁ LGPL ▁ Exception STRNEWLINE * * ▁ version ▁ 1.1 , ▁ included ▁ in ▁ the ▁ file ▁ LGPL _ EXCEPTION . txt ▁ in ▁ this ▁ package . STRNEWLINE * * STRNEWLINE * * ▁ Other ▁ Usage STRNEWLINE * * STRNEWLINE * * ▁ Alternatively , ▁ this ▁ file ▁ may ▁ be ▁ used ▁ in ▁ accordance ▁ with ▁ the ▁ terms ▁ and STRNEWLINE * * ▁ conditions ▁ contained ▁ in ▁ a ▁ signed ▁ written ▁ agreement ▁ between ▁ you ▁ and ▁ Nokia . STRNEWLINE * * STRNEWLINE * * ▁ If ▁ you ▁ have ▁ questions ▁ regarding ▁ the ▁ use ▁ of ▁ this ▁ file , ▁ please ▁ contact STRNEWLINE * * ▁ Nokia ▁ at ▁ info @ qt . nokia . com . STRNEWLINE * * STRNEWLINE * * * * */ # include " functionhintproposalwidget . h " # include " ifunctionhintproposalmodel . h " # include " codeassistant . h " # include < utils / faketooltip . h > # include < QtCore / QDebug > # include < QtGui / QApplication > # include < QtGui / QLabel > # include < QtGui / QToolButton > # include < QtGui / QHBoxLayout > # include < QtGui / QVBoxLayout > # include < QtGui / QDesktopWidget > # include < QtGui / QKeyEvent > # include < QtGui / QShortcutEvent > namespace TextEditor { // ▁ HintProposalWidgetPrivate ENDCOM struct FunctionHintProposalWidgetPrivate { FunctionHintProposalWidgetPrivate ( ) ; const QWidget * m_underlyingWidget ; CodeAssistant * m_assistant ; IFunctionHintProposalModel * m_model ; Utils :: FakeToolTip * m_popupFrame ; QLabel * m_numberLabel ; QLabel * m_hintLabel ; QWidget * m_pager ; QRect m_displayRect ; int m_currentHint ; int m_totalHints ; int m_currentArgument ; bool m_escapePressed ; } ; FunctionHintProposalWidgetPrivate :: FunctionHintProposalWidgetPrivate ( ) : m_underlyingWidget ( 0 ) , m_assistant ( 0 ) , m_model ( 0 ) , m_popupFrame ( new Utils :: FakeToolTip ) , m_numberLabel ( new QLabel ) , m_hintLabel ( new QLabel ) , m_pager ( new QWidget ) , m_currentHint ( - 1 ) , m_totalHints ( 0 ) , m_currentArgument ( - 1 ) , m_escapePressed ( false ) { m_hintLabel -> setTextFormat ( Qt :: RichText ) ; } // ▁ HintProposalWidget ENDCOM FunctionHintProposalWidget :: FunctionHintProposalWidget ( ) : m_d ( new FunctionHintProposalWidgetPrivate ) { QToolButton * downArrow = new QToolButton ; downArrow -> setArrowType ( Qt :: DownArrow ) ; downArrow -> setFixedSize ( 16 , 16 ) ; downArrow -> setAutoRaise ( true ) ; QToolButton * upArrow = new QToolButton ; upArrow -> setArrowType ( Qt :: UpArrow ) ; upArrow -> setFixedSize ( 16 , 16 ) ; upArrow -> setAutoRaise ( true ) ; QHBoxLayout * pagerLayout = new QHBoxLayout ( m_d -> m_pager ) ; pagerLayout -> setMargin ( 0 ) ; pagerLayout -> setSpacing ( 0 ) ; pagerLayout -> addWidget ( upArrow ) ; pagerLayout -> addWidget ( m_d -> m_numberLabel ) ; pagerLayout -> addWidget ( downArrow ) ; QHBoxLayout * popupLayout = new QHBoxLayout ( m_d -> m_popupFrame ) ; popupLayout -> setMargin ( 0 ) ; popupLayout -> setSpacing ( 0 ) ; popupLayout -> addWidget ( m_d -> m_pager ) ; popupLayout -> addWidget ( m_d -> m_hintLabel ) ; connect ( upArrow , SIGNAL ( clicked ( ) ) , SLOT ( previousPage ( ) ) ) ; connect ( downArrow , SIGNAL ( clicked ( ) ) , SLOT ( nextPage ( ) ) ) ; qApp -> installEventFilter ( this ) ; setFocusPolicy ( Qt :: NoFocus ) ; } FunctionHintProposalWidget :: ~ FunctionHintProposalWidget ( ) { delete m_d -> m_model ; } void FunctionHintProposalWidget :: setAssistant ( CodeAssistant * assistant ) { m_d -> m_assistant = assistant ; } void FunctionHintProposalWidget :: setReason ( AssistReason reason ) { Q_UNUSED ( reason ) ; } void FunctionHintProposalWidget :: setUnderlyingWidget ( const QWidget * underlyingWidget ) { m_d -> m_underlyingWidget = underlyingWidget ; } void FunctionHintProposalWidget :: setModel ( IAssistProposalModel * model ) { m_d -> m_model = static_cast < IFunctionHintProposalModel * > ( model ) ; } void FunctionHintProposalWidget :: setDisplayRect ( const QRect & rect ) { m_d -> m_displayRect = rect ; } void FunctionHintProposalWidget :: setIsSynchronized ( bool ) { } void FunctionHintProposalWidget :: showProposal ( const QString & prefix ) { m_d -> m_totalHints = m_d -> m_model -> size ( ) ; if ( m_d -> m_totalHints == 0 ) { abort ( ) ; return ; } m_d -> m_pager -> setVisible ( m_d -> m_totalHints > 1 ) ; m_d -> m_currentHint = 0 ; if ( ! updateAndCheck ( prefix ) ) { abort ( ) ; return ; } m_d -> m_popupFrame -> show ( ) ; } void FunctionHintProposalWidget :: updateProposal ( const QString & prefix ) { updateAndCheck ( prefix ) ; } void FunctionHintProposalWidget :: closeProposal ( ) { abort ( ) ; } void FunctionHintProposalWidget :: abort ( ) { if ( m_d -> m_popupFrame -> isVisible ( ) ) m_d -> m_popupFrame -> close ( ) ; deleteLater ( ) ; } bool FunctionHintProposalWidget :: eventFilter ( QObject * obj , QEvent * e ) { switch ( e -> type ( ) ) { case QEvent :: ShortcutOverride : if ( static_cast < QKeyEvent * > ( e ) -> key ( ) == Qt :: Key_Escape ) { m_d -> m_escapePressed = true ; } break ; case QEvent :: KeyPress : if ( static_cast < QKeyEvent * > ( e ) -> key ( ) == Qt :: Key_Escape ) { m_d -> m_escapePressed = true ; } if ( m_d -> m_model -> size ( ) > 1 ) { QKeyEvent * ke = static_cast < QKeyEvent * > ( e ) ; if ( ke -> key ( ) == Qt :: Key_Up ) { previousPage ( ) ; return true ; } else if ( ke -> key ( ) == Qt :: Key_Down ) { nextPage ( ) ; return true ; } return false ; } break ; case QEvent :: KeyRelease : if ( static_cast < QKeyEvent * > ( e ) -> key ( ) == Qt :: Key_Escape && m_d -> m_escapePressed ) { abort ( ) ; return false ; } m_d -> m_assistant -> notifyChange ( ) ; break ; case QEvent :: WindowDeactivate : case QEvent :: FocusOut : if ( obj != m_d -> m_underlyingWidget ) { break ; } abort ( ) ; break ; case QEvent :: MouseButtonPress : case QEvent :: MouseButtonRelease : case QEvent :: MouseButtonDblClick : case QEvent :: Wheel : { QWidget * widget = qobject_cast < QWidget * > ( obj ) ; if ( ! ( widget == this || isAncestorOf ( widget ) ) ) { abort ( ) ; } } break ; default : break ; } return false ; } void FunctionHintProposalWidget :: nextPage ( ) { m_d -> m_currentHint = ( m_d -> m_currentHint + 1 ) % m_d -> m_totalHints ; updateContent ( ) ; } void FunctionHintProposalWidget :: previousPage ( ) { if ( m_d -> m_currentHint == 0 ) m_d -> m_currentHint = m_d -> m_totalHints - 1 ; else -- m_d -> m_currentHint ; updateContent ( ) ; } bool FunctionHintProposalWidget :: updateAndCheck ( const QString & prefix ) { const int activeArgument = m_d -> m_model -> activeArgument ( prefix ) ; if ( activeArgument == - 1 ) { abort ( ) ; return false ; } else if ( activeArgument != m_d -> m_currentArgument ) { m_d -> m_currentArgument = activeArgument ; updateContent ( ) ; } return true ; } void FunctionHintProposalWidget :: updateContent ( ) { m_d -> m_hintLabel -> setText ( m_d -> m_model -> text ( m_d -> m_currentHint ) ) ; m_d -> m_numberLabel -> setText ( tr ( " % 1 ▁ of ▁ % 2" ) . arg ( m_d -> m_currentHint + 1 ) . arg ( m_d -> m_totalHints ) ) ; updatePosition ( ) ; } void FunctionHintProposalWidget :: updatePosition ( ) { const QDesktopWidget * desktop = QApplication :: desktop ( ) ; # ifdef Q_WS_MAC const QRect & screen = desktop -> availableGeometry ( desktop -> screenNumber ( m_d -> m_underlyingWidget ) ) ; # else const QRect & screen = desktop -> screenGeometry ( desktop -> screenNumber ( m_d -> m_underlyingWidget ) ) ; # endif m_d -> m_pager -> setFixedWidth ( m_d -> m_pager -> minimumSizeHint ( ) . width ( ) ) ; m_d -> m_hintLabel -> setWordWrap ( false ) ; const int maxDesiredWidth = screen . width ( ) - 10 ; const QSize & minHint = m_d -> m_popupFrame -> minimumSizeHint ( ) ; if ( minHint . width ( ) > maxDesiredWidth ) { m_d -> m_hintLabel -> setWordWrap ( true ) ; m_d -> m_popupFrame -> setFixedWidth ( maxDesiredWidth ) ; const int extra = m_d -> m_popupFrame -> contentsMargins ( ) . bottom ( ) + m_d -> m_popupFrame -> contentsMargins ( ) . top ( ) ; m_d -> m_popupFrame -> setFixedHeight ( m_d -> m_hintLabel -> heightForWidth ( maxDesiredWidth - m_d -> m_pager -> width ( ) ) + extra ) ; } else { m_d -> m_popupFrame -> setFixedSize ( minHint ) ; } const QSize & sz = m_d -> m_popupFrame -> size ( ) ; QPoint pos = m_d -> m_displayRect . topLeft ( ) ; pos . setY ( pos . y ( ) - sz . height ( ) - 1 ) ; if ( pos . x ( ) + sz . width ( ) > screen . right ( ) ) pos . setX ( screen . right ( ) - sz . width ( ) ) ; m_d -> m_popupFrame -> move ( pos ) ; } } // ▁ TextEditor ENDCOM </DOCUMENT>
<DOCUMENT_ID="lassoan/CTK/tree/master/Plugins/org.commontk.plugingenerator.ui/ctkPluginGeneratorUiPlugin.cpp"> /* = = = = = STRNEWLINE STRNEWLINE ▁ Library : ▁ CTK STRNEWLINE STRNEWLINE ▁ Copyright ▁ ( c ) ▁ German ▁ Cancer ▁ Research ▁ Center , STRNEWLINE ▁ Division ▁ of ▁ Medical ▁ and ▁ Biological ▁ Informatics STRNEWLINE STRNEWLINE ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE STRNEWLINE ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE STRNEWLINE ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE STRNEWLINE = = = = = */ # include " ctkPluginGeneratorUiPlugin _ p . h " # include " ctkPluginGeneratorMainExtension . h " # include < ctkPluginConstants . h > # include < QtPlugin > # include < QDebug > void ctkPluginGeneratorUiPlugin :: start ( ctkPluginContext * context ) { mainExtension = new ctkPluginGeneratorMainExtension ( ) ; ctkDictionary props ; props . insert ( ctkPluginConstants :: SERVICE_RANKING , 0 ) ; context -> registerService ( QStringList ( " ctkPluginGeneratorAbstractUiExtension " ) , mainExtension , props ) ; qDebug ( ) << " Registered ▁ Main ▁ Extension " ; } void ctkPluginGeneratorUiPlugin :: stop ( ctkPluginContext * context ) { Q_UNUSED ( context ) delete mainExtension ; } Q_EXPORT_PLUGIN2 ( org_commontk_plugingenerator_ui , ctkPluginGeneratorUiPlugin ) </DOCUMENT>
<DOCUMENT_ID="Sumahitha/samples/tree/master/AllJoyn/Samples/BACnetAdapter/HeadlessAdapterApp/pch.cpp"> // ▁ Copyright ▁ ( c ) ▁ 2015 , ▁ Microsoft ▁ Corporation ENDCOM // ▁ Permission ▁ to ▁ use , ▁ copy , ▁ modify , ▁ and / or ▁ distribute ▁ this ▁ software ▁ for ▁ any ENDCOM // ▁ purpose ▁ with ▁ or ▁ without ▁ fee ▁ is ▁ hereby ▁ granted , ▁ provided ▁ that ▁ the ▁ above ENDCOM // ▁ copyright ▁ notice ▁ and ▁ this ▁ permission ▁ notice ▁ appear ▁ in ▁ all ▁ copies . ENDCOM // ▁ THE ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ " AS ▁ IS " ▁ AND ▁ THE ▁ AUTHOR ▁ DISCLAIMS ▁ ALL ▁ WARRANTIES ENDCOM // ▁ WITH ▁ REGARD ▁ TO ▁ THIS ▁ SOFTWARE ▁ INCLUDING ▁ ALL ▁ IMPLIED ▁ WARRANTIES ▁ OF ENDCOM // ▁ MERCHANTABILITY ▁ AND ▁ FITNESS . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ▁ AUTHOR ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ENDCOM // ▁ SPECIAL , ▁ DIRECT , ▁ INDIRECT , ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ OR ▁ ANY ▁ DAMAGES ENDCOM // ▁ WHATSOEVER ▁ RESULTING ▁ FROM ▁ LOSS ▁ OF ▁ USE , ▁ DATA ▁ OR ▁ PROFITS , ▁ WHETHER ▁ IN ▁ AN ENDCOM // ▁ ACTION ▁ OF ▁ CONTRACT , ▁ NEGLIGENCE ▁ OR ▁ OTHER ▁ TORTIOUS ▁ ACTION , ▁ ARISING ▁ OUT ▁ OF ▁ OR ENDCOM // ▁ IN ▁ CONNECTION ▁ WITH ▁ THE ▁ USE ▁ OR ▁ PERFORMANCE ▁ OF ▁ THIS ▁ SOFTWARE . ENDCOM # include " pch . h " </DOCUMENT>
<DOCUMENT_ID="OpenDSA/OpenDSA-stable/tree/master/SourceCode/C++/Sorting/Heapsort.cpp"> # include " Maxheap . cpp " /* ▁ * * * ▁ ODSATag : ▁ Heapsort ▁ * * * ▁ */ void heapsort ( Comparable * A [ ] , int n ) { std :: cout << " Getting ▁ started ▁ with ▁ array : " << std :: endl ; for ( int j = 0 ; j < n ; j ++ ) std :: cout << * A [ j ] << " ▁ " ; std :: cout << std :: endl ; MaxHeap H ( A , n , n ) ; std :: cout << " Now , ▁ ready ▁ to ▁ unpack ▁ the ▁ heap " << std :: endl ; for ( int i = 0 ; i < n ; i ++ ) H . removemax ( ) ; } /* ▁ * * * ▁ ODSAendTag : ▁ Heapsort ▁ * * * ▁ */ // ▁ With ▁ KVPair ENDCOM bool sorttest ( int array [ ] , int n , int threshold ) { Comparable * A [ n ] ; int i ; cout << " We ▁ came ▁ in ▁ with ▁ array : " << endl ; for ( i = 0 ; i < n ; i ++ ) std :: cout << array [ i ] << " ▁ " ; std :: cout << std :: endl ; /* ▁ Sort ▁ an ▁ array ▁ of ▁ Ints ▁ */ for ( i = 0 ; i < n ; ++ i ) { A [ i ] = new Int ( array [ i ] ) ; } cout << " We ▁ are ▁ going ▁ to ▁ call ▁ Heapsort ▁ with ▁ this ▁ array : " << endl ; for ( i = 0 ; i < n ; i ++ ) std :: cout << A [ i ] << " ▁ " ; std :: cout << std :: endl ; // ▁ for ▁ ( i ▁ = ▁ 0 ; ▁ i ▁ < ▁ n ; ▁ + + i ) ▁ { ENDCOM // ▁ cout ▁ < < ▁ * A [ i ] ▁ < < ▁ " ▁ " ; ENDCOM // ▁ cout ▁ < < ▁ std : : endl ; ENDCOM heapsort ( A , n ) ; if ( ! checkorder ( A , n ) ) return false ; for ( i = 0 ; i < n ; ++ i ) { delete A [ i ] ; } /* ▁ Sort ▁ an ▁ array ▁ of ▁ KVPairs ▁ */ for ( i = 0 ; i < n ; ++ i ) { A [ i ] = new KVPair ( array [ i ] , & array [ i ] ) ; } // heapsort ( A , ▁ n ) ; ENDCOM if ( ! checkorder ( A , n ) ) return false ; for ( i = 0 ; i < n ; ++ i ) { delete A [ i ] ; } delete [ ] array ; return true ; } # include " SortTest . cpp " </DOCUMENT>
<DOCUMENT_ID="slitvinov/lammps-sph-multiphase/tree/master/src/ASPHERE/compute_temp_asphere.cpp"> /* ▁ - - - - - STRNEWLINE ▁ LAMMPS ▁ - ▁ Large - scale ▁ Atomic / Molecular ▁ Massively ▁ Parallel ▁ Simulator STRNEWLINE ▁ http : // lammps . sandia . gov , ▁ Sandia ▁ National ▁ Laboratories STRNEWLINE ▁ Steve ▁ Plimpton , ▁ sjplimp @ sandia . gov STRNEWLINE STRNEWLINE ▁ Copyright ▁ ( 2003 ) ▁ Sandia ▁ Corporation . ▁ Under ▁ the ▁ terms ▁ of ▁ Contract STRNEWLINE ▁ DE - AC04-94AL85000 ▁ with ▁ Sandia ▁ Corporation , ▁ the ▁ U . S . ▁ Government ▁ retains STRNEWLINE ▁ certain ▁ rights ▁ in ▁ this ▁ software . ▁ This ▁ software ▁ is ▁ distributed ▁ under STRNEWLINE ▁ the ▁ GNU ▁ General ▁ Public ▁ License . STRNEWLINE STRNEWLINE ▁ See ▁ the ▁ README ▁ file ▁ in ▁ the ▁ top - level ▁ LAMMPS ▁ directory . STRNEWLINE - - - - - ▁ */ /* ▁ - - - - - STRNEWLINE ▁ Contributing ▁ author : ▁ Mike ▁ Brown ▁ ( SNL ) STRNEWLINE - - - - - ▁ */ # include " mpi . h " # include " string . h " # include " compute _ temp _ asphere . h " # include " math _ extra . h " # include " atom . h " # include " atom _ vec _ ellipsoid . h " # include " update . h " # include " force . h " # include " domain . h " # include " modify . h " # include " group . h " # include " memory . h " # include " error . h " using namespace LAMMPS_NS ; enum { ROTATE , ALL } ; # define INERTIA 0.2 // ▁ moment ▁ of ▁ inertia ▁ prefactor ▁ for ▁ ellipsoid ENDCOM ComputeTempAsphere :: ComputeTempAsphere ( LAMMPS * lmp , int narg , char * * arg ) : Compute ( lmp , narg , arg ) { if ( narg < 3 ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; scalar_flag = vector_flag = 1 ; size_vector = 6 ; extscalar = 0 ; extvector = 1 ; tempflag = 1 ; tempbias = 0 ; id_bias = NULL ; mode = ALL ; int iarg = 3 ; while ( iarg < narg ) { if ( strcmp ( arg [ iarg ] , " bias " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; tempbias = 1 ; int n = strlen ( arg [ iarg + 1 ] ) + 1 ; id_bias = new char [ n ] ; strcpy ( id_bias , arg [ iarg + 1 ] ) ; iarg += 2 ; } else if ( strcmp ( arg [ iarg ] , " dof " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; if ( strcmp ( arg [ iarg + 1 ] , " rotate " ) == 0 ) mode = ROTATE ; else if ( strcmp ( arg [ iarg + 1 ] , " all " ) == 0 ) mode = ALL ; else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; iarg += 2 ; } else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; } vector = new double [ 6 ] ; } ComputeTempAsphere :: ~ ComputeTempAsphere ( ) { delete [ ] id_bias ; delete [ ] vector ; } void ComputeTempAsphere :: init ( ) { // ▁ error ▁ check ENDCOM avec = ( AtomVecEllipsoid * ) atom -> style_match ( " ellipsoid " ) ; if ( ! avec ) error -> all ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ atom ▁ style ▁ ellipsoid " ) ; // ▁ check ▁ that ▁ all ▁ particles ▁ are ▁ finite - size , ▁ no ▁ point ▁ particles ▁ allowed ENDCOM int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( ellipsoid [ i ] < 0 ) error -> one ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ extended ▁ particles " ) ; if ( tempbias ) { int i = modify -> find_compute ( id_bias ) ; if ( i < 0 ) error -> all ( FLERR , " Could ▁ not ▁ find ▁ compute ▁ ID ▁ for ▁ temperature ▁ bias " ) ; tbias = modify -> compute [ i ] ; if ( tbias -> tempflag == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ temperature " ) ; if ( tbias -> tempbias == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ a ▁ velocity ▁ bias " ) ; if ( tbias -> igroup != igroup ) error -> all ( FLERR , " Bias ▁ compute ▁ group ▁ does ▁ not ▁ match ▁ compute ▁ group " ) ; tbias -> init ( ) ; tbias -> setup ( ) ; if ( strcmp ( tbias -> style , " temp / region " ) == 0 ) tempbias = 2 ; else tempbias = 1 ; } } void ComputeTempAsphere :: setup ( ) { fix_dof = - 1 ; dof_compute ( ) ; } void ComputeTempAsphere :: dof_compute ( ) { if ( fix_dof ) adjust_dof_fix ( ) ; // ▁ 6 ▁ dof ▁ for ▁ 3d , ▁ 3 ▁ dof ▁ for ▁ 2d ENDCOM // ▁ which ▁ dof ▁ are ▁ included ▁ also ▁ depends ▁ on ▁ mode ENDCOM // ▁ assume ▁ full ▁ rotation ▁ of ▁ extended ▁ particles ENDCOM // ▁ user ▁ should ▁ correct ▁ this ▁ via ▁ compute _ modify ▁ if ▁ needed ENDCOM double natoms = group -> count ( igroup ) ; int nper ; if ( domain -> dimension == 3 ) { if ( mode == ALL ) nper = 6 ; else nper = 3 ; } else { if ( mode == ALL ) nper = 3 ; else nper = 1 ; } dof = nper * natoms ; // ▁ additional ▁ adjustments ▁ to ▁ dof ENDCOM if ( tempbias == 1 ) { if ( mode == ALL ) dof -= tbias -> dof_remove ( - 1 ) * natoms ; } else if ( tempbias == 2 ) { int * mask = atom -> mask ; int nlocal = atom -> nlocal ; tbias -> dof_remove_pre ( ) ; int count = 0 ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( tbias -> dof_remove ( i ) ) count ++ ; int count_all ; MPI_Allreduce ( & count , & count_all , 1 , MPI_INT , MPI_SUM , world ) ; dof -= nper * count_all ; } dof -= extra_dof + fix_dof ; if ( dof > 0 ) tfactor = force -> mvv2e / ( dof * force -> boltz ) ; else tfactor = 0.0 ; } double ComputeTempAsphere :: compute_scalar ( ) { invoked_scalar = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_scalar != update -> ntimestep ) tbias -> compute_scalar ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] ; double rot [ 3 ] [ 3 ] ; // ▁ sum ▁ translational ▁ and ▁ rotational ▁ energy ▁ for ▁ each ▁ particle ENDCOM // ▁ no ▁ point ▁ particles ▁ since ▁ divide ▁ by ▁ inertia ENDCOM double t = 0.0 ; if ( mode == ALL ) { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { t += ( v [ i ] [ 0 ] * v [ i ] [ 0 ] + v [ i ] [ 1 ] * v [ i ] [ 1 ] + v [ i ] [ 2 ] * v [ i ] [ 2 ] ) * rmass [ i ] ; // ▁ principal ▁ moments ▁ of ▁ inertia ENDCOM shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; // ▁ wbody ▁ = ▁ angular ▁ velocity ▁ in ▁ body ▁ frame ENDCOM MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } else { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { // ▁ principal ▁ moments ▁ of ▁ inertia ENDCOM shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; // ▁ wbody ▁ = ▁ angular ▁ velocity ▁ in ▁ body ▁ frame ENDCOM MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( & t , & scalar , 1 , MPI_DOUBLE , MPI_SUM , world ) ; if ( dynamic || tempbias == 2 ) dof_compute ( ) ; scalar *= tfactor ; return scalar ; } void ComputeTempAsphere :: compute_vector ( ) { int i ; invoked_vector = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_vector != update -> ntimestep ) tbias -> compute_vector ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] , t [ 6 ] ; double rot [ 3 ] [ 3 ] ; double massone ; // ▁ sum ▁ translational ▁ and ▁ rotational ▁ energy ▁ for ▁ each ▁ particle ENDCOM // ▁ no ▁ point ▁ particles ▁ since ▁ divide ▁ by ▁ inertia ENDCOM for ( i = 0 ; i < 6 ; i ++ ) t [ i ] = 0.0 ; if ( mode == ALL ) { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { massone = rmass [ i ] ; t [ 0 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 0 ] ; t [ 1 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 1 ] ; t [ 2 ] += massone * v [ i ] [ 2 ] * v [ i ] [ 2 ] ; t [ 3 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 1 ] ; t [ 4 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 2 ] ; t [ 5 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 2 ] ; // ▁ principal ▁ moments ▁ of ▁ inertia ENDCOM shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; // ▁ wbody ▁ = ▁ angular ▁ velocity ▁ in ▁ body ▁ frame ENDCOM MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; // ▁ rotational ▁ kinetic ▁ energy ENDCOM t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } else { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { // ▁ principal ▁ moments ▁ of ▁ inertia ENDCOM shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; massone = rmass [ i ] ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; // ▁ wbody ▁ = ▁ angular ▁ velocity ▁ in ▁ body ▁ frame ENDCOM MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; // ▁ rotational ▁ kinetic ▁ energy ENDCOM t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( t , vector , 6 , MPI_DOUBLE , MPI_SUM , world ) ; for ( i = 0 ; i < 6 ; i ++ ) vector [ i ] *= force -> mvv2e ; } /* ▁ - - - - - STRNEWLINE ▁ remove ▁ velocity ▁ bias ▁ from ▁ atom ▁ I ▁ to ▁ leave ▁ thermal ▁ velocity STRNEWLINE - - - - - ▁ */ void ComputeTempAsphere :: remove_bias ( int i , double * v ) { if ( tbias ) tbias -> remove_bias ( i , v ) ; } /* ▁ - - - - - STRNEWLINE ▁ add ▁ back ▁ in ▁ velocity ▁ bias ▁ to ▁ atom ▁ I ▁ removed ▁ by ▁ remove _ bias ( ) STRNEWLINE ▁ assume ▁ remove _ bias ( ) ▁ was ▁ previously ▁ called STRNEWLINE - - - - - ▁ */ void ComputeTempAsphere :: restore_bias ( int i , double * v ) { if ( tbias ) tbias -> restore_bias ( i , v ) ; } </DOCUMENT>
<DOCUMENT_ID="syslover33/ctank/tree/master/java/android-sdk-linux_r24.4.1_src/ndk-bundle_r11c/sources/cxx-stl/llvm-libc++/libcxx/test/localization/locales/locale.convenience/conversions/conversions.buffer/pbackfail.pass.cpp"> // ▁ The ▁ LLVM ▁ Compiler ▁ Infrastructure ENDCOM // ▁ This ▁ file ▁ is ▁ dual ▁ licensed ▁ under ▁ the ▁ MIT ▁ and ▁ the ▁ University ▁ of ▁ Illinois ▁ Open ENDCOM // ▁ Source ▁ Licenses . ▁ See ▁ LICENSE . TXT ▁ for ▁ details . ENDCOM // ▁ < locale > ENDCOM // ▁ wbuffer _ convert < Codecvt , ▁ Elem , ▁ Tr > ENDCOM // ▁ int _ type ▁ pbackfail ( int _ type ▁ c ▁ = ▁ traits : : eof ( ) ) ; ENDCOM // ▁ This ▁ test ▁ is ▁ not ▁ entirely ▁ portable ENDCOM # include < locale > # include < codecvt > # include < fstream > # include < cassert > struct test_buf : public std :: wbuffer_convert < std :: codecvt_utf8 < wchar_t > > { typedef std :: wbuffer_convert < std :: codecvt_utf8 < wchar_t > > base ; typedef base :: char_type char_type ; typedef base :: int_type int_type ; typedef base :: traits_type traits_type ; explicit test_buf ( std :: streambuf * sb ) : base ( sb ) { } char_type * eback ( ) const { return base :: eback ( ) ; } char_type * gptr ( ) const { return base :: gptr ( ) ; } char_type * egptr ( ) const { return base :: egptr ( ) ; } void gbump ( int n ) { base :: gbump ( n ) ; } virtual int_type pbackfail ( int_type c = traits_type :: eof ( ) ) { return base :: pbackfail ( c ) ; } } ; int main ( ) { { std :: ifstream bs ( " underflow . dat " ) ; test_buf f ( bs . rdbuf ( ) ) ; assert ( f . sbumpc ( ) == L ' 1' ) ; assert ( f . sgetc ( ) == L ' 2' ) ; assert ( f . pbackfail ( L ' a ' ) == test_buf :: traits_type :: eof ( ) ) ; } { std :: fstream bs ( " underflow . dat " ) ; test_buf f ( bs . rdbuf ( ) ) ; assert ( f . sbumpc ( ) == L ' 1' ) ; assert ( f . sgetc ( ) == L ' 2' ) ; assert ( f . pbackfail ( L ' a ' ) == test_buf :: traits_type :: eof ( ) ) ; assert ( f . sbumpc ( ) == L ' 2' ) ; assert ( f . sgetc ( ) == L ' 3' ) ; } } </DOCUMENT>
<DOCUMENT_ID="KDE/koffice/tree/master/kcells/dialogs/StyleManagerDialog.cpp"> /* ▁ This ▁ file ▁ is ▁ part ▁ of ▁ the ▁ KDE ▁ project STRNEWLINE ▁ Copyright ▁ 2007 ▁ Stefan ▁ Nikolaus ▁ < stefan . nikolaus @ kdemail . net > STRNEWLINE ▁ Copyright ▁ 2003 ▁ Laurent ▁ Montel ▁ < montel @ kde . org > STRNEWLINE ▁ Copyright ▁ 2003 ▁ Norbert ▁ Andres ▁ < nandres @ web . de > STRNEWLINE STRNEWLINE ▁ This ▁ library ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or STRNEWLINE ▁ modify ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Library ▁ General ▁ Public STRNEWLINE ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either STRNEWLINE ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE STRNEWLINE ▁ This ▁ library ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU STRNEWLINE ▁ Library ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE STRNEWLINE ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Library ▁ General ▁ Public ▁ License STRNEWLINE ▁ along ▁ with ▁ this ▁ library ; ▁ see ▁ the ▁ file ▁ COPYING . LIB . ▁ If ▁ not , ▁ write ▁ to STRNEWLINE ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , STRNEWLINE ▁ Boston , ▁ MA ▁ 02110-1301 , ▁ USA . STRNEWLINE */ # include " StyleManagerDialog . h " # include < QMap > # include < QTreeWidget > # include < QVBoxLayout > # include < kcombobox . h > # include < kdebug . h > # include < klocale . h > # include " KCCell . h " # include " LayoutDialog . h " # include " ui / Selection . h " # include " KCSheet . h " # include " KCStyle . h " # include " KCStyleManager . h " # include " commands / KCStyleCommand . h " StyleManagerDialog :: StyleManagerDialog ( QWidget * parent , Selection * selection , KCStyleManager * manager ) : KDialog ( parent ) , m_selection ( selection ) , m_styleManager ( manager ) { setButtons ( Apply | User1 | User2 | User3 | Close ) ; setButtonText ( User3 , i18n ( " & New . . . " ) ) ; setButtonText ( User2 , i18n ( " & Modify . . . " ) ) ; setButtonText ( User1 , i18n ( " & Delete . . . " ) ) ; setButtonsOrientation ( Qt :: Vertical ) ; setCaption ( i18n ( " Style ▁ Manager " ) ) ; QWidget * widget = new QWidget ( this ) ; setMainWidget ( widget ) ; QVBoxLayout * layout = new QVBoxLayout ( widget ) ; m_styleList = new QTreeWidget ( this ) ; m_styleList -> setHeaderLabel ( i18n ( " Style " ) ) ; layout -> addWidget ( m_styleList ) ; m_displayBox = new KComboBox ( false , this ) ; m_displayBox -> insertItem ( 0 , i18n ( " All ▁ Styles " ) ) ; m_displayBox -> insertItem ( 1 , i18n ( " Custom ▁ Styles " ) ) ; m_displayBox -> insertItem ( 2 , i18n ( " Hierarchical " ) ) ; layout -> addWidget ( m_displayBox ) ; slotDisplayMode ( 0 ) ; enableButton ( KDialog :: User3 , true ) ; enableButton ( KDialog :: User2 , true ) ; enableButton ( KDialog :: User1 , false ) ; connect ( m_displayBox , SIGNAL ( activated ( int ) ) , this , SLOT ( slotDisplayMode ( int ) ) ) ; connect ( this , SIGNAL ( applyClicked ( ) ) , this , SLOT ( slotOk ( ) ) ) ; connect ( this , SIGNAL ( user3Clicked ( ) ) , this , SLOT ( slotNew ( ) ) ) ; connect ( this , SIGNAL ( user2Clicked ( ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( this , SIGNAL ( user1Clicked ( ) ) , this , SLOT ( slotRemove ( ) ) ) ; connect ( m_styleList , SIGNAL ( itemDoubleClicked ( QTreeWidgetItem * , int ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( m_styleList , SIGNAL ( currentItemChanged ( QTreeWidgetItem * , QTreeWidgetItem * ) ) , this , SLOT ( selectionChanged ( QTreeWidgetItem * ) ) ) ; } StyleManagerDialog :: ~ StyleManagerDialog ( ) { } void StyleManagerDialog :: fillComboBox ( ) { typedef QMap < KCCustomStyle * , QTreeWidgetItem * > KCMap ; KCMap entries ; entries . clear ( ) ; entries [ m_styleManager -> defaultStyle ( ) ] = new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: const_iterator iter = m_styleManager -> m_styles . constBegin ( ) ; CustomStyles :: const_iterator end = m_styleManager -> m_styles . constEnd ( ) ; while ( entries . count ( ) != m_styleManager -> m_styles . count ( ) + 1 ) { if ( entries . find ( iter . value ( ) ) == entries . end ( ) ) { if ( iter . value ( ) -> parentName ( ) . isNull ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( entries [ m_styleManager -> defaultStyle ( ) ] , QStringList ( iter . value ( ) -> name ( ) ) ) ; else { KCCustomStyle * parentStyle = m_styleManager -> style ( iter . value ( ) -> parentName ( ) ) ; if ( parentStyle ) { KCMap :: const_iterator i = entries . constFind ( parentStyle ) ; if ( i != entries . constEnd ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( i . value ( ) , QStringList ( iter . value ( ) -> name ( ) ) ) ; } } } ++ iter ; if ( iter == end ) iter = m_styleManager -> m_styles . constBegin ( ) ; } entries . clear ( ) ; } void StyleManagerDialog :: slotDisplayMode ( int mode ) { m_styleList -> clear ( ) ; if ( mode != 2 ) // ▁ NOT ▁ " Hierarchical " ENDCOM m_styleList -> setRootIsDecorated ( false ) ; else { // ▁ " Hierarchical " ENDCOM m_styleList -> setRootIsDecorated ( true ) ; fillComboBox ( ) ; return ; } if ( mode != 1 ) // ▁ NOT ▁ " Custom ▁ Styles " ENDCOM new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: iterator iter = m_styleManager -> m_styles . begin ( ) ; CustomStyles :: iterator end = m_styleManager -> m_styles . end ( ) ; while ( iter != end ) { KCCustomStyle * styleData = iter . value ( ) ; if ( ! styleData || styleData -> name ( ) . isEmpty ( ) ) { ++ iter ; continue ; } if ( mode == 1 ) { // ▁ " Custom ▁ Styles " ENDCOM if ( styleData -> type ( ) == KCStyle :: CUSTOM ) new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; } else new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; ++ iter ; } } void StyleManagerDialog :: slotOk ( ) { kDebug ( ) ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) { accept ( ) ; return ; } QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setDefault ( ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } else { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setParentName ( name ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } accept ( ) ; } void StyleManagerDialog :: slotNew ( ) { KCCustomStyle * parentStyle = 0 ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( item ) { const QString name = item -> text ( 0 ) ; if ( name == i18n ( " Default " ) ) parentStyle = m_styleManager -> defaultStyle ( ) ; else parentStyle = m_styleManager -> style ( name ) ; } else parentStyle = m_styleManager -> defaultStyle ( ) ; int i = 1 ; QString newName ( i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ) ; while ( m_styleManager -> style ( newName ) != 0 ) { ++ i ; newName = i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ; } KCCustomStyle * style = new KCCustomStyle ( newName , parentStyle ) ; style -> setType ( KCStyle :: TENTATIVE ) ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; delete dialog ; if ( style -> type ( ) == KCStyle :: TENTATIVE ) { delete style ; return ; } m_styleManager -> m_styles [ style -> name ( ) ] = style ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; } void StyleManagerDialog :: slotEdit ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; KCCustomStyle * style = 0 ; QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; if ( dialog -> result ( ) == Accepted ) m_selection -> emitRefreshSheetViews ( ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; delete dialog ; } void StyleManagerDialog :: slotRemove ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; if ( style -> type ( ) != KCStyle :: CUSTOM ) return ; m_styleManager -> takeStyle ( style ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; } void StyleManagerDialog :: selectionChanged ( QTreeWidgetItem * item ) { if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) { enableButton ( KDialog :: User1 , false ) ; return ; } if ( style -> type ( ) == KCStyle :: BUILTIN ) enableButton ( KDialog :: User1 , false ) ; else enableButton ( KDialog :: User1 , true ) ; } # include " StyleManagerDialog . moc " </DOCUMENT>
<DOCUMENT_ID="sjsinju/coreclr/tree/master/src/pal/tests/palsuite/c_runtime/fmod/test1/test1.cpp"> // ▁ Licensed ▁ to ▁ the ▁ . NET ▁ Foundation ▁ under ▁ one ▁ or ▁ more ▁ agreements . ENDCOM // ▁ The ▁ . NET ▁ Foundation ▁ licenses ▁ this ▁ file ▁ to ▁ you ▁ under ▁ the ▁ MIT ▁ license . ENDCOM // ▁ See ▁ the ▁ LICENSE ▁ file ▁ in ▁ the ▁ project ▁ root ▁ for ▁ more ▁ information . ENDCOM /* = = = = = STRNEWLINE * * STRNEWLINE * * ▁ Source : ▁ test1 . c STRNEWLINE * * STRNEWLINE * * ▁ Purpose : ▁ Test ▁ to ▁ ensure ▁ that ▁ fmod ▁ return ▁ the ▁ correct ▁ values STRNEWLINE * * ▁ STRNEWLINE * * ▁ Dependencies : ▁ PAL _ Initialize STRNEWLINE * * ▁ PAL _ Terminate STRNEWLINE * * ▁ Fail STRNEWLINE * * ▁ fabs STRNEWLINE * * STRNEWLINE * * = = = = = */ # include < palsuite . h > // ▁ binary64 ▁ ( double ) ▁ has ▁ a ▁ machine ▁ epsilon ▁ of ▁ 2 ^ - 52 ▁ ( approx . ▁ 2.22e - 16 ) . ▁ However , ▁ this ▁ ENDCOM // ▁ is ▁ slightly ▁ too ▁ accurate ▁ when ▁ writing ▁ tests ▁ meant ▁ to ▁ run ▁ against ▁ libm ▁ implementations ENDCOM // ▁ for ▁ various ▁ platforms . ▁ 2 ^ - 50 ▁ ( approx . ▁ 8.88e - 16 ) ▁ seems ▁ to ▁ be ▁ as ▁ accurate ▁ as ▁ we ▁ can ▁ get . ENDCOM // ▁ The ▁ tests ▁ themselves ▁ will ▁ take ▁ PAL _ EPSILON ▁ and ▁ adjust ▁ it ▁ according ▁ to ▁ the ▁ expected ▁ result ENDCOM // ▁ so ▁ that ▁ the ▁ delta ▁ used ▁ for ▁ comparison ▁ will ▁ compare ▁ the ▁ most ▁ significant ▁ digits ▁ and ▁ ignore ENDCOM // ▁ any ▁ digits ▁ that ▁ are ▁ outside ▁ the ▁ double ▁ precision ▁ range ▁ ( 15-17 ▁ digits ) . ENDCOM // ▁ For ▁ example , ▁ a ▁ test ▁ with ▁ an ▁ expect ▁ result ▁ in ▁ the ▁ format ▁ of ▁ 0 . xxxxx ▁ will ▁ use ENDCOM // ▁ PAL _ EPSILON ▁ for ▁ the ▁ variance , ▁ while ▁ an ▁ expected ▁ result ▁ in ▁ the ▁ format ▁ of ▁ 0.0xxxxx ENDCOM // ▁ will ▁ use ▁ PAL _ EPSILON ▁ / ▁ 10 ▁ and ▁ and ▁ expected ▁ result ▁ in ▁ the ▁ format ▁ of ▁ x . xxxxx ▁ will ENDCOM // ▁ use ▁ PAL _ EPSILON ▁ * ▁ 10 . ENDCOM # define PAL_EPSILON 8.8817841970012523e - 16 # define PAL_NAN sqrt ( - 1.0 ) # define PAL_POSINF - log ( 0.0 ) # define PAL_NEGINF log ( 0.0 ) /* * STRNEWLINE ▁ * ▁ Helper ▁ test ▁ structure STRNEWLINE ▁ */ struct test { double numerator ; /* ▁ second ▁ component ▁ of ▁ the ▁ value ▁ to ▁ test ▁ the ▁ function ▁ with ▁ */ double denominator ; /* ▁ first ▁ component ▁ of ▁ the ▁ value ▁ to ▁ test ▁ the ▁ function ▁ with ▁ */ double expected ; /* ▁ expected ▁ result ▁ */ double variance ; /* ▁ maximum ▁ delta ▁ between ▁ the ▁ expected ▁ and ▁ actual ▁ result ▁ */ } ; /* * STRNEWLINE ▁ * ▁ validate STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ test ▁ validation ▁ function STRNEWLINE ▁ */ void __cdecl validate ( double numerator , double denominator , double expected , double variance ) { double result = fmod ( numerator , denominator ) ; /* STRNEWLINE ▁ * ▁ The ▁ test ▁ is ▁ valid ▁ when ▁ the ▁ difference ▁ between ▁ result STRNEWLINE ▁ * ▁ and ▁ expected ▁ is ▁ less ▁ than ▁ or ▁ equal ▁ to ▁ variance STRNEWLINE ▁ */ double delta = fabs ( result - expected ) ; if ( delta > variance ) { Fail ( " fmod ( % g , ▁ % g ) ▁ returned ▁ % 20.17g ▁ when ▁ it ▁ should ▁ have ▁ returned ▁ % 20.17g " , numerator , denominator , result , expected ) ; } } /* * STRNEWLINE ▁ * ▁ validate STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ test ▁ validation ▁ function ▁ for ▁ values ▁ returning ▁ NaN STRNEWLINE ▁ */ void __cdecl validate_isnan ( double numerator , double denominator ) { double result = fmod ( numerator , denominator ) ; if ( ! _isnan ( result ) ) { Fail ( " fmod ( % g , ▁ % g ) ▁ returned ▁ % 20.17g ▁ when ▁ it ▁ should ▁ have ▁ returned ▁ % 20.17g " , numerator , denominator , result , PAL_NAN ) ; } } /* * STRNEWLINE ▁ * ▁ main STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ executable ▁ entry ▁ point STRNEWLINE ▁ */ INT __cdecl main ( INT argc , CHAR * * argv ) { struct test tests [ ] = { /* ▁ numerator ▁ denominator ▁ expected ▁ variance ▁ */ { 0 , PAL_POSINF , 0 , PAL_EPSILON } , { 0.31296179620778659 , 0.94976571538163866 , 0.31296179620778658 , PAL_EPSILON } , { 0.42077048331375735 , 0.90716712923909839 , 0.42077048331375733 , PAL_EPSILON } , { 0.59448076852482208 , 0.80410982822879171 , 0.59448076852482212 , PAL_EPSILON } , { 0.63896127631363480 , 0.76923890136397213 , 0.63896127631363475 , PAL_EPSILON } , { 0.64963693908006244 , 0.76024459707563015 , 0.64963693908006248 , PAL_EPSILON } , { 0.70710678118654752 , 0.70710678118654752 , 0 , PAL_EPSILON } , { 1 , 1 , 0 , PAL_EPSILON } , { 0.84147098480789651 , 0.54030230586813972 , 0.30116867893975674 , PAL_EPSILON } , { 0.90371945743584630 , 0.42812514788535792 , 0.047469161665130377 , PAL_EPSILON / 10 } , { 0.98776594599273553 , 0.15594369476537447 , 0.052103777400488605 , PAL_EPSILON / 10 } , { 0.99180624439366372 , 0.12775121753523991 , 0.097547721646984359 , PAL_EPSILON / 10 } , { 0.74398033695749319 , - 0.66820151019031295 , 0.075778826767180285 , PAL_EPSILON / 10 } , { 0.41078129050290870 , - 0.91173391478696510 , 0.41078129050290868 , PAL_EPSILON } , { 0 , - 1 , 0 , PAL_EPSILON } , { 1 , PAL_POSINF , 1 , PAL_EPSILON * 10 } , } ; // ▁ PAL ▁ initialization ENDCOM if ( PAL_Initialize ( argc , argv ) != 0 ) { return FAIL ; } for ( int i = 0 ; i < ( sizeof ( tests ) / sizeof ( struct test ) ) ; i ++ ) { validate ( tests [ i ] . numerator , tests [ i ] . denominator , tests [ i ] . expected , tests [ i ] . variance ) ; validate ( - tests [ i ] . numerator , tests [ i ] . denominator , - tests [ i ] . expected , tests [ i ] . variance ) ; validate ( tests [ i ] . numerator , - tests [ i ] . denominator , tests [ i ] . expected , tests [ i ] . variance ) ; validate ( - tests [ i ] . numerator , - tests [ i ] . denominator , - tests [ i ] . expected , tests [ i ] . variance ) ; } validate_isnan ( 0 , 0 ) ; validate_isnan ( - 0.0 , 0 ) ; validate_isnan ( 0 , - 0.0 ) ; validate_isnan ( - 0.0 , - 0.0 ) ; validate_isnan ( 1 , 0 ) ; validate_isnan ( - 1.0 , 0 ) ; validate_isnan ( 1 , - 0.0 ) ; validate_isnan ( - 1.0 , - 0.0 ) ; validate_isnan ( PAL_POSINF , PAL_POSINF ) ; validate_isnan ( PAL_NEGINF , PAL_POSINF ) ; validate_isnan ( PAL_POSINF , PAL_NEGINF ) ; validate_isnan ( PAL_NEGINF , PAL_NEGINF ) ; validate_isnan ( PAL_POSINF , 0 ) ; validate_isnan ( PAL_NEGINF , 0 ) ; validate_isnan ( PAL_POSINF , - 0.0 ) ; validate_isnan ( PAL_NEGINF , - 0.0 ) ; validate_isnan ( PAL_POSINF , 1 ) ; validate_isnan ( PAL_NEGINF , 1 ) ; validate_isnan ( PAL_POSINF , - 1.0 ) ; validate_isnan ( PAL_NEGINF , - 1.0 ) ; PAL_Terminate ( ) ; return PASS ; } </DOCUMENT>
<DOCUMENT_ID="pete318/TrinityCore/tree/master/src/server/scripts/Northrend/FrozenHalls/HallsOfReflection/halls_of_reflection.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2008-2019 ▁ TrinityCore ▁ < https : // www . trinitycore . org / > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it STRNEWLINE ▁ * ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the STRNEWLINE ▁ * ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your STRNEWLINE ▁ * ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT STRNEWLINE ▁ * ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or STRNEWLINE ▁ * ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for STRNEWLINE ▁ * ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along STRNEWLINE ▁ * ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ */ # include " halls _ of _ reflection . h " # include " Creature . h " # include " EventProcessor . h " # include " InstanceScript . h " # include " MotionMaster . h " # include " MoveSplineInit . h " # include " ObjectAccessor . h " # include " ObjectGuid . h " # include " Player . h " # include " ScriptedCreature . h " # include " ScriptedGossip . h " # include " ScriptMgr . h " # include " Spell . h " # include " SpellInfo . h " # include " SpellScript . h " # include " TemporarySummon . h " # include " Transport . h " # include " Unit . h " enum Text { SAY_JAINA_INTRO_1 = 0 , SAY_JAINA_INTRO_2 = 1 , SAY_JAINA_INTRO_3 = 2 , SAY_JAINA_INTRO_4 = 3 , SAY_JAINA_INTRO_5 = 4 , SAY_JAINA_INTRO_6 = 5 , SAY_JAINA_INTRO_7 = 6 , SAY_JAINA_INTRO_8 = 7 , SAY_JAINA_INTRO_9 = 8 , SAY_JAINA_INTRO_10 = 9 , SAY_JAINA_INTRO_11 = 10 , SAY_JAINA_INTRO_END = 11 , SAY_SYLVANAS_INTRO_1 = 0 , SAY_SYLVANAS_INTRO_2 = 1 , SAY_SYLVANAS_INTRO_3 = 2 , SAY_SYLVANAS_INTRO_4 = 3 , SAY_SYLVANAS_INTRO_5 = 4 , SAY_SYLVANAS_INTRO_6 = 5 , SAY_SYLVANAS_INTRO_7 = 6 , SAY_SYLVANAS_INTRO_8 = 7 , SAY_SYLVANAS_INTRO_END = 8 , SAY_UTHER_INTRO_A2_1 = 0 , SAY_UTHER_INTRO_A2_2 = 1 , SAY_UTHER_INTRO_A2_3 = 2 , SAY_UTHER_INTRO_A2_4 = 3 , SAY_UTHER_INTRO_A2_5 = 4 , SAY_UTHER_INTRO_A2_6 = 5 , SAY_UTHER_INTRO_A2_7 = 6 , SAY_UTHER_INTRO_A2_8 = 7 , SAY_UTHER_INTRO_A2_9 = 8 , SAY_UTHER_INTRO_H2_1 = 9 , SAY_UTHER_INTRO_H2_2 = 10 , SAY_UTHER_INTRO_H2_3 = 11 , SAY_UTHER_INTRO_H2_4 = 12 , SAY_UTHER_INTRO_H2_5 = 13 , SAY_UTHER_INTRO_H2_6 = 14 , SAY_UTHER_INTRO_H2_7 = 15 , SAY_LK_INTRO_1 = 0 , SAY_LK_INTRO_2 = 1 , SAY_LK_INTRO_3 = 2 , SAY_LK_JAINA_INTRO_END = 3 , SAY_LK_SYLVANAS_INTRO_END = 4 , SAY_JAINA_SYLVANAS_ESCAPE_1 = 0 , SAY_JAINA_SYLVANAS_ESCAPE_2 = 1 , SAY_JAINA_SYLVANAS_ESCAPE_3 = 2 , SAY_JAINA_SYLVANAS_ESCAPE_4 = 3 , SAY_JAINA_SYLVANAS_ESCAPE_5 = 4 , SAY_JAINA_SYLVANAS_ESCAPE_6 = 5 , SAY_JAINA_SYLVANAS_ESCAPE_7 = 6 , // ▁ unused ENDCOM SAY_JAINA_SYLVANAS_ESCAPE_8 = 7 , SAY_JAINA_ESCAPE_9 = 8 , SAY_JAINA_ESCAPE_10 = 9 , SAY_SYLVANAS_ESCAPE_9 = 8 , SAY_LK_ESCAPE_1 = 0 , SAY_LK_ESCAPE_2 = 1 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_1 = 2 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_2 = 3 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_3 = 4 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_4 = 5 , SAY_LK_ESCAPE_GHOULS = 6 , SAY_LK_ESCAPE_ABOMINATION = 7 , SAY_LK_ESCAPE_WINTER = 8 , SAY_LK_ESCAPE_HARVEST_SOUL = 9 , SAY_FALRIC_INTRO_1 = 5 , SAY_FALRIC_INTRO_2 = 6 , SAY_MARWYN_INTRO_1 = 4 } ; enum Events { EVENT_WALK_INTRO1 = 1 , EVENT_WALK_INTRO2 , EVENT_START_INTRO , EVENT_SKIP_INTRO , EVENT_INTRO_A2_1 , EVENT_INTRO_A2_2 , EVENT_INTRO_A2_3 , EVENT_INTRO_A2_4 , EVENT_INTRO_A2_5 , EVENT_INTRO_A2_6 , EVENT_INTRO_A2_7 , EVENT_INTRO_A2_8 , EVENT_INTRO_A2_9 , EVENT_INTRO_A2_10 , EVENT_INTRO_A2_11 , EVENT_INTRO_A2_12 , EVENT_INTRO_A2_13 , EVENT_INTRO_A2_14 , EVENT_INTRO_A2_15 , EVENT_INTRO_A2_16 , EVENT_INTRO_A2_17 , EVENT_INTRO_A2_18 , EVENT_INTRO_A2_19 , EVENT_INTRO_H2_1 , EVENT_INTRO_H2_2 , EVENT_INTRO_H2_3 , EVENT_INTRO_H2_4 , EVENT_INTRO_H2_5 , EVENT_INTRO_H2_6 , EVENT_INTRO_H2_7 , EVENT_INTRO_H2_8 , EVENT_INTRO_H2_9 , EVENT_INTRO_H2_10 , EVENT_INTRO_H2_11 , EVENT_INTRO_H2_12 , EVENT_INTRO_H2_13 , EVENT_INTRO_H2_14 , EVENT_INTRO_H2_15 , EVENT_INTRO_LK_1 , EVENT_INTRO_LK_2 , EVENT_INTRO_LK_3 , EVENT_INTRO_LK_4 , EVENT_INTRO_LK_5 , EVENT_INTRO_LK_6 , EVENT_INTRO_LK_7 , EVENT_INTRO_LK_8 , EVENT_INTRO_LK_9 , EVENT_INTRO_LK_10 , EVENT_INTRO_LK_11 , EVENT_INTRO_END , EVENT_ESCAPE , EVENT_ESCAPE_1 , EVENT_ESCAPE_2 , EVENT_ESCAPE_3 , EVENT_ESCAPE_4 , EVENT_ESCAPE_5 , EVENT_ESCAPE_6 , EVENT_ESCAPE_7 , EVENT_ESCAPE_8 , EVENT_ESCAPE_9 , EVENT_ESCAPE_10 , EVENT_ESCAPE_11 , EVENT_ESCAPE_12 , EVENT_ESCAPE_13 , EVENT_ESCAPE_14 , EVENT_ESCAPE_15 , EVENT_ESCAPE_16 , EVENT_ESCAPE_17 , EVENT_REMORSELESS_WINTER , EVENT_ESCAPE_SUMMON_GHOULS , EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , EVENT_OPEN_IMPENETRABLE_DOOR , EVENT_CLOSE_IMPENETRABLE_DOOR , EVENT_KORELN_LORALEN_DEATH } ; enum Misc { ACTION_START_INTRO , ACTION_SKIP_INTRO , JAINA_SYLVANAS_MAX_HEALTH = 252000 , POINT_SHADOW_THRONE_DOOR = 1 , POINT_ATTACK_ICEWALL = 2 , POINT_TRAP = 3 , SOUND_LK_SLAY_1 = 17214 , SOUND_LK_SLAY_2 = 17215 , SOUND_LK_FURY_OF_FROSTMOURNE = 17224 } ; enum Spells { // ▁ Misc ENDCOM SPELL_TAKE_FROSTMOURNE = 72729 , SPELL_FROSTMOURNE_DESPAWN = 72726 , SPELL_FROSTMOURNE_VISUAL = 73220 , SPELL_FROSTMOURNE_SOUNDS = 70667 , SPELL_BOSS_SPAWN_AURA = 72712 , // ▁ Falric ▁ and ▁ Marwyn ENDCOM SPELL_UTHER_DESPAWN = 70693 , // ▁ Jaina , ▁ Sylvanas ENDCOM SPELL_CAST_VISUAL = 65633 , // ▁ wrong ENDCOM SPELL_SUMMON_SOULS = 72711 , SPELL_TAUNT_ARTHAS = 69857 , SPELL_JAINA_ICE_BARRIER = 69787 , // ▁ Jaina ▁ Ice ▁ Barrier ENDCOM SPELL_JAINA_ICE_PRISON = 69708 , // ▁ Jaina ▁ Ice ▁ Prison ENDCOM SPELL_JAINA_DESTROY_ICE_WALL = 69784 , // ▁ Jaina ENDCOM SPELL_SYLVANAS_CLOAK_OF_DARKNESS = 70188 , // ▁ Sylvanas ▁ Cloak ▁ of ▁ Darkness ENDCOM SPELL_SYLVANAS_DARK_BINDING = 70194 , // ▁ Sylvanas ▁ Dark ▁ Binding ENDCOM SPELL_SYLVANAS_DESTROY_ICE_WALL = 70224 , // ▁ Sylvanas ENDCOM SPELL_SYLVANAS_BLINDING_RETREAT = 70199 , // ▁ Sylvanas ▁ Blinding ▁ Retreat ENDCOM // ▁ Lich ▁ King ENDCOM SPELL_REMORSELESS_WINTER = 69780 , // ▁ Lich ▁ King ▁ Remorseless ▁ Winter ENDCOM SPELL_SOUL_REAPER = 69409 , // ▁ Lich ▁ King ▁ Soul ▁ Reaper ENDCOM SPELL_FURY_OF_FROSTMOURNE = 70063 , // ▁ Lich ▁ King ▁ Fury ▁ of ▁ Frostmourne ENDCOM SPELL_RAISE_DEAD = 69818 , SPELL_SUMMON_RISEN_WITCH_DOCTOR = 69836 , SPELL_SUMMON_LUMBERING_ABOMINATION = 69835 , SPELL_SUMMON_ICE_WALL = 69768 , // ▁ Visual ▁ effect ▁ and ▁ icewall ▁ summoning ENDCOM SPELL_PAIN_AND_SUFFERING = 74115 , // ▁ Lich ▁ King ▁ Pain ▁ and ▁ Suffering ENDCOM SPELL_STUN_BREAK_JAINA = 69764 , // ▁ Lich ▁ King ▁ visual ▁ spell , ▁ another ▁ Stun ▁ Break ▁ is ▁ 69763 , ▁ should ▁ remove ▁ the ▁ stun ▁ effect ENDCOM SPELL_STUN_BREAK_SYLVANAS = 70200 , SPELL_HARVEST_SOUL = 69866 , // ▁ Lich ▁ King ▁ Harvest ▁ Soul ENDCOM // ▁ Koreln , ▁ Loralen ENDCOM SPELL_FEIGN_DEATH = 29266 , // ▁ Raging ▁ Ghoul ENDCOM SPELL_GHOUL_JUMP = 70150 , SPELL_RAGING_GHOUL_SPAWN = 69636 , // ▁ Risen ▁ Witch ▁ Doctor ENDCOM SPELL_CURSE_OF_DOOM = 70144 , SPELL_SHADOW_BOLT_VOLLEY = 70145 , SPELL_SHADOW_BOLT = 70080 , SPELL_RISEN_WITCH_DOCTOR_SPAWN = 69639 , // ▁ Lumbering ▁ Abomination ENDCOM SPELL_CLEAVE = 40505 , SPELL_VOMIT_SPRAY = 70176 } ; enum HorGossipMenu { GOSSIP_MENU_JAINA_FINAL = 10930 , GOSSIP_MENU_SYLVANAS_FINAL = 10931 } ; Position const NpcJainaOrSylvanasEscapeRoute [ ] = { { 5601.217285f , 2207.652832f , 731.541931f , 5.223304f } , // ▁ leave ▁ the ▁ throne ▁ room ENDCOM { 5607.224375f , 2173.913330f , 731.126038f , 2.608723f } , // ▁ adjust ▁ route ENDCOM { 5583.427246f , 2138.784180f , 731.150391f , 4.260901f } , // ▁ stop ▁ for ▁ talking ENDCOM { 5560.281738f , 2104.025635f , 731.410889f , 4.058383f } , // ▁ attack ▁ the ▁ first ▁ icewall ENDCOM { 5510.990723f , 2000.772217f , 734.716064f , 3.973213f } , // ▁ attack ▁ the ▁ second ▁ icewall ENDCOM { 5452.641113f , 1905.762329f , 746.530579f , 4.118834f } , // ▁ attack ▁ the ▁ third ▁ icewall ENDCOM { 5338.126953f , 1768.429810f , 767.237244f , 3.855189f } , // ▁ attack ▁ the ▁ fourth ▁ icewall ENDCOM { 5259.06f , 1669.27f , 784.3008f , 0.0f } , // ▁ trap ▁ ( sniffed ) ENDCOM { 5265.53f , 1681.6f , 784.2947f , 4.13643f } // ▁ final ▁ position ▁ ( sniffed ) ENDCOM } ; Position const LichKingMoveAwayPos = { 5400.069824f , 2102.7131689f , 707.69525f , 0.843803f } ; // ▁ Lich ▁ King ▁ walks ▁ away ENDCOM Position const LichKingFirstSummon = { 5600.076172f , 2192.270996f , 731.750488f , 4.330935f } ; // ▁ Lich ▁ King ▁ First ▁ summons ENDCOM Position const JainaSylvanasShadowThroneDoor = { 5577.243f , 2235.852f , 733.0128f , 2.209562f } ; // ▁ Jaina / Sylvanas ▁ move ▁ to ▁ door ENDCOM Position const LichKingFinalPos = { 5283.742188f , 1706.335693f , 783.293518f , 4.138510f } ; // ▁ Lich ▁ King ▁ Final ▁ Pos ENDCOM // ▁ sniffed ENDCOM Position const KorelnOrLoralenPos [ ] = { { 5253.061f , 1953.616f , 707.6948f , 0.8377581f } , { 5283.226f , 1992.300f , 707.7445f , 0.8377581f } , { 5360.711f , 2064.797f , 707.6948f , 0.0f } } ; Position const SylvanasIntroPosition [ ] = { { 0.0f , 0.0f , 0.0f , 0.0f } , // ▁ 0 ▁ - ▁ Spawn ENDCOM { 5263.2f , 1950.96f , 707.6948f , 0.8028514f } , // ▁ 1 ▁ - ▁ Move ▁ to ▁ Door ENDCOM { 5306.82f , 1998.17f , 709.341f , 1.239184f } , // ▁ 2 ▁ - ▁ Move ▁ to ▁ Frostmourne ENDCOM } ; Position const JainaIntroPosition [ ] = { { 0.0f , 0.0f , 0.0f , 0.0f } , // ▁ 0 ▁ - ▁ Spawn ENDCOM { 5265.89f , 1952.98f , 707.6978f , 0.0f } , // ▁ 1 ▁ - ▁ Move ▁ to ▁ Door ENDCOM { 5306.95f , 1998.49f , 709.3414f , 1.277278f } // ▁ 2 ▁ - ▁ Move ▁ to ▁ Frostmourne ENDCOM } ; Position const UtherSpawnPos = { 5307.814f , 2003.168f , 709.4244f , 4.537856f } ; Position const LichKingIntroPosition [ ] = { { 5362.463f , 2062.693f , 707.7781f , 3.944444f } , // ▁ 0 ▁ - ▁ Spawn ENDCOM { 5332.83f , 2031.24f , 707.6948f , 0.0f } , // ▁ 1 ▁ - ▁ Door ENDCOM { 5312.93f , 2010.24f , 709.34f , 0.0f } , // ▁ 2 ▁ - ▁ Move ▁ to ▁ Frostmourne ENDCOM { 5319.028f , 2016.662f , 707.6948f , 0.0f } , // ▁ 3 ▁ - ▁ Move ▁ back ENDCOM { 5332.285f , 2030.832f , 707.6948f , 0.0f } , // ▁ 4 ▁ - ▁ Move ▁ back ▁ 2 ENDCOM { 5355.488f , 2055.149f , 707.6907f , 0.0f } // ▁ 5 ▁ - ▁ Move ▁ back ▁ 3 ENDCOM } ; Position const FalricPosition [ ] = { { 5276.583f , 2037.45f , 709.4025f , 5.532694f } , // ▁ 0 ▁ - ▁ Spawn ENDCOM { 5283.95f , 2030.53f , 709.3191f , 0.0f } // ▁ 1 ▁ - ▁ Intro ENDCOM } ; Position const MarwynPosition [ ] = { { 5342.232f , 1975.696f , 709.4025f , 2.391101f } , // ▁ 0 ▁ - ▁ Spawn ENDCOM { 5335.01f , 1982.37f , 709.3191f , 0.0f } // ▁ 1 ▁ - ▁ Intro ENDCOM } ; Position const SylvanasShadowThroneDoorPosition = { 5576.79f , 2235.73f , 733.0029f , 2.687807f } ; Position const IceWallTargetPosition [ ] = { { 5547.833f , 2083.701f , 731.4332f , 1.029744f } , // ▁ 1st ▁ Icewall ENDCOM { 5503.213f , 1969.547f , 737.0245f , 1.27409f } , // ▁ 2nd ▁ Icewall ENDCOM { 5439.976f , 1879.005f , 752.7048f , 1.064651f } , // ▁ 3rd ▁ Icewall ENDCOM { 5318.289f , 1749.184f , 771.9423f , 0.8726646f } // ▁ 4th ▁ Icewall ENDCOM } ; class npc_jaina_or_sylvanas_intro_hor : public CreatureScript { public : npc_jaina_or_sylvanas_intro_hor ( ) : CreatureScript ( " npc _ jaina _ or _ sylvanas _ intro _ hor " ) { } struct npc_jaina_or_sylvanas_intro_horAI : public ScriptedAI { npc_jaina_or_sylvanas_intro_horAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; } bool GossipHello ( Player * player ) override { // ▁ override ▁ default ▁ gossip ENDCOM if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == IN_PROGRESS || _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == SPECIAL ) { ClearGossipMenuFor ( player ) ; return true ; } // ▁ load ▁ default ▁ gossip ENDCOM return false ; } bool GossipSelect ( Player * player , uint32 /* menuId */ , uint32 gossipListId ) override { ClearGossipMenuFor ( player ) ; switch ( gossipListId ) { case 0 : player -> PlayerTalkClass -> SendCloseGossip ( ) ; _events . ScheduleEvent ( EVENT_START_INTRO , 1s ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; case 1 : player -> PlayerTalkClass -> SendCloseGossip ( ) ; _events . ScheduleEvent ( EVENT_SKIP_INTRO , 1s ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; default : break ; } return false ; } void Reset ( ) override { _events . Reset ( ) ; _utherGUID . Clear ( ) ; _lichkingGUID . Clear ( ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; me -> SetStandState ( UNIT_STAND_STATE_STAND ) ; _events . ScheduleEvent ( EVENT_WALK_INTRO1 , 3000 ) ; } void UpdateAI ( uint32 diff ) override { _events . Update ( diff ) ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_WALK_INTRO1 : if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 0 , KorelnOrLoralenPos [ 0 ] ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) { me -> GetMotionMaster ( ) -> MovePoint ( 0 , JainaIntroPosition [ 1 ] ) ; Talk ( SAY_JAINA_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_WALK_INTRO2 , 7000 ) ; } else { me -> GetMotionMaster ( ) -> MovePoint ( 0 , SylvanasIntroPosition [ 1 ] ) ; Talk ( SAY_SYLVANAS_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_WALK_INTRO2 , 9000 ) ; } break ; case EVENT_WALK_INTRO2 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_INTRO_2 ) ; else Talk ( SAY_SYLVANAS_INTRO_2 ) ; me -> SetFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; case EVENT_START_INTRO : if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 0 , KorelnOrLoralenPos [ 1 ] ) ; // ▁ Begining ▁ of ▁ intro ▁ is ▁ differents ▁ between ▁ factions ▁ as ▁ the ▁ speech ▁ sequence ▁ and ▁ timers ▁ are ▁ differents . ENDCOM if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) { me -> GetMotionMaster ( ) -> MovePoint ( 0 , JainaIntroPosition [ 2 ] ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_1 , 0 ) ; } else { me -> GetMotionMaster ( ) -> MovePoint ( 0 , SylvanasIntroPosition [ 2 ] ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_1 , 0 ) ; } break ; // ▁ A2 ▁ Intro ▁ Events ENDCOM case EVENT_INTRO_A2_1 : Talk ( SAY_JAINA_INTRO_3 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_2 , 7000 ) ; break ; case EVENT_INTRO_A2_2 : Talk ( SAY_JAINA_INTRO_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_3 , 10000 ) ; break ; case EVENT_INTRO_A2_3 : me -> CastSpell ( me , SPELL_CAST_VISUAL , false ) ; me -> CastSpell ( me , SPELL_FROSTMOURNE_SOUNDS , true ) ; _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_FROSTMOURNE ) , true ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_4 , 10000 ) ; break ; case EVENT_INTRO_A2_4 : if ( Creature * uther = me -> SummonCreature ( NPC_UTHER , UtherSpawnPos , TEMPSUMMON_MANUAL_DESPAWN ) ) _utherGUID = uther -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_5 , 2000 ) ; break ; case EVENT_INTRO_A2_5 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_6 , 3000 ) ; break ; case EVENT_INTRO_A2_6 : Talk ( SAY_JAINA_INTRO_5 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_7 , 7000 ) ; break ; case EVENT_INTRO_A2_7 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_8 , 7000 ) ; break ; case EVENT_INTRO_A2_8 : Talk ( SAY_JAINA_INTRO_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_9 , 1200 ) ; break ; case EVENT_INTRO_A2_9 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_3 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_10 , 11000 ) ; break ; case EVENT_INTRO_A2_10 : Talk ( SAY_JAINA_INTRO_7 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_11 , 6000 ) ; break ; case EVENT_INTRO_A2_11 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_12 , 12000 ) ; break ; case EVENT_INTRO_A2_12 : Talk ( SAY_JAINA_INTRO_8 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_13 , 6000 ) ; break ; case EVENT_INTRO_A2_13 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_5 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_14 , 13000 ) ; break ; case EVENT_INTRO_A2_14 : Talk ( SAY_JAINA_INTRO_9 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_15 , 12000 ) ; break ; case EVENT_INTRO_A2_15 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_16 , 25000 ) ; break ; case EVENT_INTRO_A2_16 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_7 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_17 , 6000 ) ; break ; case EVENT_INTRO_A2_17 : Talk ( SAY_JAINA_INTRO_10 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_18 , 5000 ) ; break ; case EVENT_INTRO_A2_18 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> HandleEmoteCommand ( EMOTE_ONESHOT_NO ) ; uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_8 ) ; } _events . ScheduleEvent ( EVENT_INTRO_A2_19 , 12000 ) ; break ; case EVENT_INTRO_A2_19 : Talk ( SAY_JAINA_INTRO_11 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_1 , 3000 ) ; break ; // ▁ H2 ▁ Intro ▁ Events ENDCOM case EVENT_INTRO_H2_1 : Talk ( SAY_SYLVANAS_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_2 , 8000 ) ; break ; case EVENT_INTRO_H2_2 : Talk ( SAY_SYLVANAS_INTRO_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_3 , 6000 ) ; break ; case EVENT_INTRO_H2_3 : Talk ( SAY_SYLVANAS_INTRO_3 ) ; me -> CastSpell ( me , SPELL_CAST_VISUAL , false ) ; me -> CastSpell ( me , SPELL_FROSTMOURNE_SOUNDS , true ) ; _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_FROSTMOURNE ) , true ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_4 , 6000 ) ; break ; case EVENT_INTRO_H2_4 : // ▁ spawn ▁ UTHER ▁ during ▁ speach ▁ 2 ENDCOM if ( Creature * uther = me -> SummonCreature ( NPC_UTHER , UtherSpawnPos , TEMPSUMMON_MANUAL_DESPAWN ) ) _utherGUID = uther -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_5 , 2000 ) ; break ; case EVENT_INTRO_H2_5 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_6 , 11000 ) ; break ; case EVENT_INTRO_H2_6 : Talk ( SAY_SYLVANAS_INTRO_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_7 , 3000 ) ; break ; case EVENT_INTRO_H2_7 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_8 , 6000 ) ; break ; case EVENT_INTRO_H2_8 : Talk ( SAY_SYLVANAS_INTRO_5 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_9 , 5000 ) ; break ; case EVENT_INTRO_H2_9 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_3 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_10 , 19000 ) ; break ; case EVENT_INTRO_H2_10 : Talk ( SAY_SYLVANAS_INTRO_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_11 , 1500 ) ; break ; case EVENT_INTRO_H2_11 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_12 , 19500 ) ; break ; case EVENT_INTRO_H2_12 : Talk ( SAY_SYLVANAS_INTRO_7 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_13 , 2000 ) ; break ; case EVENT_INTRO_H2_13 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> HandleEmoteCommand ( EMOTE_ONESHOT_NO ) ; uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_5 ) ; } _events . ScheduleEvent ( EVENT_INTRO_H2_14 , 12000 ) ; break ; case EVENT_INTRO_H2_14 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_15 , 8000 ) ; break ; case EVENT_INTRO_H2_15 : Talk ( SAY_SYLVANAS_INTRO_8 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_1 , 2000 ) ; break ; // ▁ Remaining ▁ Intro ▁ Events ▁ common ▁ for ▁ both ▁ faction ENDCOM case EVENT_INTRO_LK_1 : // ▁ Spawn ▁ LK ▁ in ▁ front ▁ of ▁ door , ▁ and ▁ make ▁ him ▁ move ▁ to ▁ the ▁ sword . ENDCOM if ( Creature * lichking = me -> SummonCreature ( NPC_THE_LICH_KING_INTRO , LichKingIntroPosition [ 0 ] , TEMPSUMMON_MANUAL_DESPAWN ) ) { lichking -> SetWalk ( true ) ; lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingIntroPosition [ 2 ] ) ; _lichkingGUID = lichking -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_OPEN_IMPENETRABLE_DOOR , 0 ) ; _events . ScheduleEvent ( EVENT_CLOSE_IMPENETRABLE_DOOR , 4s ) ; } if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> SetUInt32Value ( UNIT_NPC_EMOTESTATE , EMOTE_STATE_COWER ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_9 ) ; else uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_7 ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_2 , 10000 ) ; break ; case EVENT_INTRO_LK_2 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) lichking -> AI ( ) -> Talk ( SAY_LK_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_3 , 1000 ) ; break ; case EVENT_INTRO_LK_3 : // ▁ The ▁ Lich ▁ King ▁ banishes ▁ Uther ▁ to ▁ the ▁ abyss . ENDCOM if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> CastSpell ( uther , SPELL_UTHER_DESPAWN , true ) ; uther -> DespawnOrUnsummon ( 5000 ) ; _utherGUID . Clear ( ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_4 , 9000 ) ; break ; case EVENT_INTRO_LK_4 : // ▁ He ▁ steps ▁ forward ▁ and ▁ removes ▁ the ▁ runeblade ▁ from ▁ the ▁ heap ▁ of ▁ skulls . ENDCOM if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { if ( GameObject * frostmourne = ObjectAccessor :: GetGameObject ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE ) ) ) frostmourne -> SetPhaseMask ( 2 , true ) ; lichking -> CastSpell ( lichking , SPELL_TAKE_FROSTMOURNE , true ) ; lichking -> CastSpell ( lichking , SPELL_FROSTMOURNE_VISUAL , true ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_5 , 8000 ) ; break ; case EVENT_INTRO_LK_5 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) lichking -> AI ( ) -> Talk ( SAY_LK_INTRO_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_6 , 10000 ) ; break ; case EVENT_INTRO_LK_6 : // ▁ summon ▁ Falric ▁ and ▁ Marwyn . ▁ then ▁ go ▁ back ▁ to ▁ the ▁ door ENDCOM if ( Creature * falric = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FALRIC ) ) ) { falric -> CastSpell ( falric , SPELL_BOSS_SPAWN_AURA , true ) ; falric -> SetVisible ( true ) ; } if ( Creature * marwyn = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_MARWYN ) ) ) { marwyn -> CastSpell ( marwyn , SPELL_BOSS_SPAWN_AURA , true ) ; marwyn -> SetVisible ( true ) ; } if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { lichking -> AI ( ) -> Talk ( SAY_LK_INTRO_3 ) ; lichking -> SetWalk ( true ) ; lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingMoveAwayPos ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_7 , 10000 ) ; _events . ScheduleEvent ( EVENT_OPEN_IMPENETRABLE_DOOR , 5s ) ; break ; case EVENT_INTRO_LK_7 : if ( Creature * marwyn = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_MARWYN ) ) ) { marwyn -> AI ( ) -> Talk ( SAY_MARWYN_INTRO_1 ) ; marwyn -> SetWalk ( true ) ; marwyn -> GetMotionMaster ( ) -> MovePoint ( 0 , MarwynPosition [ 1 ] ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_8 , 1000 ) ; break ; case EVENT_INTRO_LK_8 : if ( Creature * falric = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FALRIC ) ) ) { falric -> AI ( ) -> Talk ( SAY_FALRIC_INTRO_1 ) ; falric -> SetWalk ( true ) ; falric -> GetMotionMaster ( ) -> MovePoint ( 0 , FalricPosition [ 1 ] ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_9 , 5000 ) ; break ; case EVENT_INTRO_LK_9 : if ( Creature * falric = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FALRIC ) ) ) falric -> AI ( ) -> Talk ( SAY_FALRIC_INTRO_2 ) ; _instance -> ProcessEvent ( 0 , EVENT_SPAWN_WAVES ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_10 , 4000 ) ; break ; case EVENT_INTRO_LK_10 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_INTRO_END ) ; else Talk ( SAY_SYLVANAS_INTRO_END ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingMoveAwayPos ) ; // / ▁ @ todo : ▁ needs ▁ some ▁ improvements ENDCOM if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 1 , KorelnOrLoralenPos [ 2 ] ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_11 , 5000 ) ; break ; case EVENT_INTRO_LK_11 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) lichking -> AI ( ) -> Talk ( SAY_LK_JAINA_INTRO_END ) ; else lichking -> AI ( ) -> Talk ( SAY_LK_SYLVANAS_INTRO_END ) ; } _events . ScheduleEvent ( EVENT_INTRO_END , 5s ) ; break ; case EVENT_INTRO_END : _instance -> SetData ( DATA_INTRO_EVENT , DONE ) ; _events . ScheduleEvent ( EVENT_KORELN_LORALEN_DEATH , 8s ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { lichking -> DespawnOrUnsummon ( 5000 ) ; _lichkingGUID . Clear ( ) ; } me -> DespawnOrUnsummon ( 10000 ) ; _events . ScheduleEvent ( EVENT_CLOSE_IMPENETRABLE_DOOR , 7s ) ; break ; case EVENT_SKIP_INTRO : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) me -> GetMotionMaster ( ) -> MovePoint ( 0 , JainaIntroPosition [ 2 ] ) ; else me -> GetMotionMaster ( ) -> MovePoint ( 0 , SylvanasIntroPosition [ 2 ] ) ; if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 0 , KorelnOrLoralenPos [ 1 ] ) ; if ( Creature * lichking = me -> SummonCreature ( NPC_THE_LICH_KING_INTRO , LichKingIntroPosition [ 0 ] , TEMPSUMMON_MANUAL_DESPAWN ) ) { lichking -> SetWalk ( true ) ; lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingIntroPosition [ 2 ] ) ; lichking -> SetReactState ( REACT_PASSIVE ) ; _lichkingGUID = lichking -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_OPEN_IMPENETRABLE_DOOR , 0 ) ; _events . ScheduleEvent ( EVENT_CLOSE_IMPENETRABLE_DOOR , 4s ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_4 , 15000 ) ; break ; case EVENT_OPEN_IMPENETRABLE_DOOR : _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_IMPENETRABLE_DOOR ) , true ) ; break ; case EVENT_CLOSE_IMPENETRABLE_DOOR : _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_IMPENETRABLE_DOOR ) , false ) ; break ; case EVENT_KORELN_LORALEN_DEATH : if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> CastSpell ( korelnOrLoralen , SPELL_FEIGN_DEATH ) ; break ; default : break ; } } private : InstanceScript * _instance ; EventMap _events ; ObjectGuid _utherGUID ; ObjectGuid _lichkingGUID ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_jaina_or_sylvanas_intro_horAI > ( creature ) ; } } ; class HoRGameObjectDeleteDelayEvent : public BasicEvent { public : explicit HoRGameObjectDeleteDelayEvent ( Unit * owner , ObjectGuid gameObjectGUID ) : _owner ( owner ) , _gameObjectGUID ( gameObjectGUID ) { } void DeleteGameObject ( ) { if ( GameObject * go = ObjectAccessor :: GetGameObject ( * _owner , _gameObjectGUID ) ) go -> Delete ( ) ; } bool Execute ( uint64 /* execTime */ , uint32 /* diff */ ) override { DeleteGameObject ( ) ; return true ; } void Abort ( uint64 /* execTime */ ) override { DeleteGameObject ( ) ; } private : Unit * _owner ; ObjectGuid _gameObjectGUID ; } ; class npc_jaina_or_sylvanas_escape_hor : public CreatureScript { public : npc_jaina_or_sylvanas_escape_hor ( ) : CreatureScript ( " npc _ jaina _ or _ sylvanas _ escape _ hor " ) { } struct npc_jaina_or_sylvanas_escape_horAI : public ScriptedAI { npc_jaina_or_sylvanas_escape_horAI ( Creature * creature ) : ScriptedAI ( creature ) , _instance ( creature -> GetInstanceScript ( ) ) , _icewall ( 0 ) , _prefight ( false ) , _invincibility ( true ) { } void Reset ( ) override { _events . Reset ( ) ; _icewall = 0 ; _events . ScheduleEvent ( EVENT_ESCAPE , 1s ) ; _instance -> DoStopTimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , ACHIEV_NOT_RETREATING_EVENT ) ; } void JustDied ( Unit * /* killer */ ) override { if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> AI ( ) -> EnterEvadeMode ( ) ; // ▁ event ▁ failed ENDCOM } void DamageTaken ( Unit * /* attacker */ , uint32 & damage ) override { if ( damage >= me -> GetHealth ( ) && _invincibility ) damage = me -> GetHealth ( ) - 1 ; } void DoAction ( int32 actionId ) override { switch ( actionId ) { case ACTION_START_PREFIGHT : if ( _prefight ) return ; _prefight = true ; _events . ScheduleEvent ( EVENT_ESCAPE_1 , 1000 ) ; break ; case ACTION_WALL_BROKEN : ++ _icewall ; if ( _icewall < 4 ) _events . ScheduleEvent ( EVENT_ESCAPE_13 , 3000 ) ; else _events . ScheduleEvent ( EVENT_ESCAPE_15 , 3000 ) ; break ; case ACTION_GUNSHIP_ARRIVAL : _events . ScheduleEvent ( EVENT_ESCAPE_16 , 5000 ) ; break ; case ACTION_GUNSHIP_ARRIVAL_2 : _events . ScheduleEvent ( EVENT_ESCAPE_17 , 5000 ) ; break ; default : break ; } } bool GossipHello ( Player * player ) override { // ▁ override ▁ default ▁ gossip ENDCOM if ( _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == DONE ) { player -> PrepareGossipMenu ( me , me -> GetEntry ( ) == NPC_JAINA_ESCAPE ? GOSSIP_MENU_JAINA_FINAL : GOSSIP_MENU_SYLVANAS_FINAL , true ) ; player -> SendPreparedGossip ( me ) ; return true ; } // ▁ load ▁ default ▁ gossip ENDCOM return false ; } bool GossipSelect ( Player * player , uint32 /* menuId */ , uint32 gossipListId ) override { ClearGossipMenuFor ( player ) ; switch ( gossipListId ) { case 0 : player -> PlayerTalkClass -> SendCloseGossip ( ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP ) ; _events . ScheduleEvent ( EVENT_ESCAPE_6 , 0 ) ; break ; default : break ; } return false ; } void DestroyIceWall ( ) { if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) me -> RemoveAurasDueToSpell ( SPELL_JAINA_DESTROY_ICE_WALL ) ; else me -> RemoveAurasDueToSpell ( SPELL_SYLVANAS_DESTROY_ICE_WALL ) ; _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_ICEWALL ) , true ) ; me -> m_Events . AddEvent ( new HoRGameObjectDeleteDelayEvent ( me , _instance -> GetGuidData ( DATA_ICEWALL ) ) , me -> m_Events . CalculateTime ( 5000 ) ) ; if ( Creature * wallTarget = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ICEWALL_TARGET ) ) ) wallTarget -> DespawnOrUnsummon ( ) ; } void SummonIceWall ( ) { if ( _icewall < 4 ) { if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> StopMoving ( ) ; if ( Creature * wallTarget = me -> SummonCreature ( NPC_ICE_WALL_TARGET , IceWallTargetPosition [ _icewall ] , TEMPSUMMON_MANUAL_DESPAWN , 720000 ) ) lichking -> CastSpell ( wallTarget , SPELL_SUMMON_ICE_WALL ) ; lichking -> AI ( ) -> SetData ( DATA_ICEWALL , _icewall ) ; } } } void AttackIceWall ( ) { if ( _icewall < 4 ) Talk ( SAY_JAINA_SYLVANAS_ESCAPE_2 + _icewall ) ; if ( Creature * wallTarget = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ICEWALL_TARGET ) ) ) me -> SetFacingToObject ( wallTarget ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_JAINA_DESTROY_ICE_WALL , true ) ; else DoCast ( me , SPELL_SYLVANAS_DESTROY_ICE_WALL , true ) ; } void MovementInform ( uint32 type , uint32 pointId ) override { if ( type != POINT_MOTION_TYPE ) return ; switch ( pointId ) { case POINT_SHADOW_THRONE_DOOR : if ( me -> GetEntry ( ) == NPC_JAINA_ESCAPE ) me -> RemoveAurasDueToSpell ( SPELL_JAINA_ICE_BARRIER ) ; else me -> RemoveAurasDueToSpell ( SPELL_SYLVANAS_CLOAK_OF_DARKNESS ) ; me -> SetFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP ) ; me -> SetHealth ( JAINA_SYLVANAS_MAX_HEALTH ) ; me -> SetFacingTo ( SylvanasShadowThroneDoorPosition . GetOrientation ( ) ) ; break ; case POINT_ATTACK_ICEWALL : AttackIceWall ( ) ; break ; case POINT_TRAP : Talk ( SAY_JAINA_SYLVANAS_ESCAPE_8 ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) me -> SetFacingToObject ( lichking ) ; break ; default : break ; } } void DeleteAllFromThreatList ( Unit * target , ObjectGuid except ) { for ( ThreatReference * ref : target -> GetThreatManager ( ) . GetModifiableThreatList ( ) ) if ( ref -> GetVictim ( ) -> GetGUID ( ) != except ) ref -> ClearThreat ( ) ; } void UpdateAI ( uint32 diff ) override { _events . Update ( diff ) ; while ( uint32 event = _events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_ESCAPE : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_JAINA_ICE_BARRIER ) ; else DoCast ( me , SPELL_SYLVANAS_CLOAK_OF_DARKNESS ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { me -> CastSpell ( lichking , SPELL_TAUNT_ARTHAS , true ) ; lichking -> ApplySpellImmune ( 0 , IMMUNITY_STATE , SPELL_AURA_MOD_TAUNT , true ) ; lichking -> ApplySpellImmune ( 0 , IMMUNITY_EFFECT , SPELL_EFFECT_ATTACK_ME , true ) ; AttackStart ( lichking ) ; lichking -> AI ( ) -> AttackStart ( me ) ; } me -> SetHealth ( JAINA_SYLVANAS_MAX_HEALTH ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; case EVENT_ESCAPE_1 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) lichking -> AI ( ) -> Talk ( SAY_LK_ESCAPE_1 ) ; else lichking -> AI ( ) -> Talk ( SAY_LK_ESCAPE_2 ) ; _events . ScheduleEvent ( EVENT_ESCAPE_2 , 8000 ) ; } break ; case EVENT_ESCAPE_2 : me -> AttackStop ( ) ; me -> StopMoving ( ) ; me -> SetReactState ( REACT_PASSIVE ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_JAINA_ICE_PRISON , false ) ; else DoCast ( me , SPELL_SYLVANAS_BLINDING_RETREAT , true ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> SetReactState ( REACT_PASSIVE ) ; lichking -> SetFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_PACIFIED ) ; } _events . ScheduleEvent ( EVENT_ESCAPE_3 , 1500 ) ; break ; case EVENT_ESCAPE_3 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == HORDE ) DoCastAOE ( SPELL_SYLVANAS_DARK_BINDING , true ) ; _events . ScheduleEvent ( EVENT_ESCAPE_4 , 1000 ) ; break ; case EVENT_ESCAPE_4 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_CREDIT_FINDING_JAINA ) ; else DoCast ( me , SPELL_CREDIT_FINDING_SYLVANAS ) ; Talk ( SAY_JAINA_SYLVANAS_ESCAPE_1 ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> SetImmuneToPC ( true ) ; lichking -> RemoveAllAttackers ( ) ; DeleteAllFromThreatList ( lichking , me -> GetGUID ( ) ) ; } _events . ScheduleEvent ( EVENT_ESCAPE_5 , 2000 ) ; break ; case EVENT_ESCAPE_5 : me -> GetMotionMaster ( ) -> MovePoint ( POINT_SHADOW_THRONE_DOOR , SylvanasShadowThroneDoorPosition ) ; break ; case EVENT_ESCAPE_6 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> RemoveFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_PACIFIED ) ; lichking -> SetImmuneToPC ( false ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) { lichking -> CastSpell ( lichking , SPELL_STUN_BREAK_JAINA ) ; lichking -> RemoveAurasDueToSpell ( SPELL_JAINA_ICE_PRISON ) ; } else { lichking -> CastSpell ( lichking , SPELL_STUN_BREAK_SYLVANAS ) ; lichking -> RemoveAurasDueToSpell ( SPELL_SYLVANAS_DARK_BINDING ) ; } } _invincibility = false ; _instance -> DoStartTimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , ACHIEV_NOT_RETREATING_EVENT ) ; _events . ScheduleEvent ( EVENT_ESCAPE_7 , 1000 ) ; break ; case EVENT_ESCAPE_7 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> HandleEmoteCommand ( TEXT_EMOTE_ROAR ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 0 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_8 , 3000 ) ; break ; case EVENT_ESCAPE_8 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 0 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_9 , 1000 ) ; break ; case EVENT_ESCAPE_9 : me -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 1 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_10 , 5000 ) ; break ; case EVENT_ESCAPE_10 : me -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 2 ] ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> GetMotionMaster ( ) -> MovePoint ( 1 , LichKingFirstSummon ) ; _events . ScheduleEvent ( EVENT_ESCAPE_11 , 6000 ) ; break ; case EVENT_ESCAPE_11 : SummonIceWall ( ) ; _events . ScheduleEvent ( EVENT_ESCAPE_12 , 4000 ) ; break ; case EVENT_ESCAPE_12 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> CastSpell ( lichking , SPELL_PAIN_AND_SUFFERING , true ) ; me -> GetMotionMaster ( ) -> MovePoint ( POINT_ATTACK_ICEWALL , NpcJainaOrSylvanasEscapeRoute [ 3 ] ) ; break ; case EVENT_ESCAPE_13 : // ▁ ICEWALL ▁ BROKEN ENDCOM DestroyIceWall ( ) ; if ( _icewall && _icewall < 4 ) me -> GetMotionMaster ( ) -> MovePoint ( POINT_ATTACK_ICEWALL , NpcJainaOrSylvanasEscapeRoute [ _icewall + 3 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_14 , 8000 ) ; break ; case EVENT_ESCAPE_14 : SummonIceWall ( ) ; break ; case EVENT_ESCAPE_15 : // ▁ FINAL ▁ PART ENDCOM DestroyIceWall ( ) ; Talk ( SAY_JAINA_SYLVANAS_ESCAPE_6 ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> GetMotionMaster ( ) -> MovePoint ( 2 , LichKingFinalPos ) ; lichking -> RemoveAurasDueToSpell ( SPELL_REMORSELESS_WINTER ) ; } me -> GetMotionMaster ( ) -> MovePoint ( POINT_TRAP , NpcJainaOrSylvanasEscapeRoute [ 7 ] ) ; break ; case EVENT_ESCAPE_16 : me -> RemoveAurasDueToSpell ( SPELL_HARVEST_SOUL ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_ESCAPE_9 ) ; if ( Transport * gunship = ObjectAccessor :: GetTransport ( * me , _instance -> GetGuidData ( DATA_GUNSHIP ) ) ) gunship -> EnableMovement ( true ) ; _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , DONE ) ; break ; case EVENT_ESCAPE_17 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_ESCAPE_10 ) ; else Talk ( SAY_SYLVANAS_ESCAPE_9 ) ; DoCast ( me , SPELL_CREDIT_ESCAPING_ARTHAS ) ; me -> SetFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } private : InstanceScript * _instance ; EventMap _events ; uint32 _icewall ; // ▁ icewall ▁ number ENDCOM bool _prefight ; bool _invincibility ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_jaina_or_sylvanas_escape_horAI > ( creature ) ; } } ; class npc_the_lich_king_escape_hor : public CreatureScript { public : npc_the_lich_king_escape_hor ( ) : CreatureScript ( " npc _ the _ lich _ king _ escape _ hor " ) { } struct npc_the_lich_king_escape_horAI : public ScriptedAI { npc_the_lich_king_escape_horAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , NOT_STARTED ) ; _summonsCount = 0 ; _icewall = 0 ; _despawn = false ; } void DamageTaken ( Unit * /* attacker */ , uint32 & damage ) override { if ( damage >= me -> GetHealth ( ) ) damage = me -> GetHealth ( ) - 1 ; } void MovementInform ( uint32 type , uint32 pointId ) override { if ( type == POINT_MOTION_TYPE ) { switch ( pointId ) { case 1 : if ( Creature * target = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) me -> GetMotionMaster ( ) -> MoveChase ( target ) ; break ; case 2 : Talk ( SAY_LK_ESCAPE_HARVEST_SOUL ) ; if ( Creature * target = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) DoCast ( target , SPELL_HARVEST_SOUL ) ; if ( Transport * gunship = ObjectAccessor :: GetTransport ( * me , _instance -> GetGuidData ( DATA_GUNSHIP ) ) ) gunship -> EnableMovement ( true ) ; break ; default : break ; } } } void JustSummoned ( Creature * /* summon */ ) override { ++ _summonsCount ; } void SummonedCreatureDies ( Creature * /* summon */ , Unit * /* killer */ ) override { // ▁ should ▁ never ▁ happen ENDCOM if ( ! _summonsCount ) return ; -- _summonsCount ; // ▁ All ▁ summons ▁ dead ▁ and ▁ no ▁ summon ▁ events ▁ scheduled ENDCOM if ( ! _summonsCount && _events . Empty ( ) ) { if ( Creature * jainaOrSylvanas = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) jainaOrSylvanas -> AI ( ) -> DoAction ( ACTION_WALL_BROKEN ) ; } } void KilledUnit ( Unit * who ) override { if ( who -> GetTypeId ( ) == TYPEID_PLAYER ) DoPlaySoundToSet ( me , RAND ( SOUND_LK_SLAY_1 , SOUND_LK_SLAY_2 ) ) ; } void SetData ( uint32 type , uint32 data ) override { if ( type != DATA_ICEWALL ) return ; _icewall = data ; switch ( _icewall ) { case 0 : // ▁ 6 ▁ Ghouls , ▁ 1 ▁ Witch ▁ Doctor ENDCOM DoZoneInCombat ( ) ; _events . ScheduleEvent ( EVENT_REMORSELESS_WINTER , 0 ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 8s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 14s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_1 ) ; break ; case 1 : // ▁ 6 ▁ Ghouls , ▁ 2 ▁ Witch ▁ Doctor , ▁ 1 ▁ Lumbering ▁ Abomination ENDCOM _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 8s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 13s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 15s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 18s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_2 ) ; break ; case 2 : // ▁ 6 ▁ Ghouls , ▁ 2 ▁ Witch ▁ Doctor , ▁ 2 ▁ Lumbering ▁ Abomination ENDCOM _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 9s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 14s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 15s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 19s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 39s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_3 ) ; break ; case 3 : // ▁ 12 ▁ Ghouls , ▁ 4 ▁ Witch ▁ Doctor , ▁ 3 ▁ Lumbering ▁ Abomination ENDCOM _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 9s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 15s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 19s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 40s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 45s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 55s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 62s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 65s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 14s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_4 ) ; break ; default : break ; } } void EnterEvadeMode ( EvadeReason /* why */ ) override { if ( _despawn ) return ; _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , FAIL ) ; me -> StopMoving ( ) ; DoPlaySoundToSet ( me , SOUND_LK_FURY_OF_FROSTMOURNE ) ; DoCastAOE ( SPELL_FURY_OF_FROSTMOURNE ) ; me -> DespawnOrUnsummon ( 12000 ) ; _despawn = true ; } void UpdateAI ( uint32 diff ) override { if ( ! SelectVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; while ( uint32 event = _events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_REMORSELESS_WINTER : me -> StopMoving ( ) ; Talk ( SAY_LK_ESCAPE_WINTER ) ; DoCast ( me , SPELL_REMORSELESS_WINTER ) ; break ; case EVENT_ESCAPE_SUMMON_GHOULS : me -> StopMoving ( ) ; Talk ( SAY_LK_ESCAPE_GHOULS ) ; DoCast ( me , SPELL_RAISE_DEAD ) ; break ; case EVENT_ESCAPE_SUMMON_WITCH_DOCTOR : DoCast ( me , SPELL_SUMMON_RISEN_WITCH_DOCTOR ) ; break ; case EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION : Talk ( SAY_LK_ESCAPE_ABOMINATION ) ; DoCast ( me , SPELL_SUMMON_LUMBERING_ABOMINATION ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } private : bool SelectVictim ( ) { if ( ! me -> IsInCombat ( ) ) return false ; if ( ! me -> HasReactState ( REACT_PASSIVE ) ) { if ( Unit * victim = me -> SelectVictim ( ) ) if ( ! me -> HasSpellFocus ( ) && victim != me -> GetVictim ( ) ) AttackStart ( victim ) ; return me -> GetVictim ( ) != nullptr ; } else if ( me -> GetCombatManager ( ) . GetPvECombatRefs ( ) . size ( ) < 2 && me -> HasAura ( SPELL_REMORSELESS_WINTER ) ) { EnterEvadeMode ( EVADE_REASON_OTHER ) ; return false ; } return true ; } InstanceScript * _instance ; EventMap _events ; uint8 _icewall ; uint32 _summonsCount ; bool _despawn ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_the_lich_king_escape_horAI > ( creature ) ; } } ; enum TrashSpells { // ▁ Ghostly ▁ Priest ENDCOM SPELL_SHADOW_WORD_PAIN = 72318 , SPELL_CIRCLE_OF_DESTRUCTION = 72320 , SPELL_COWER_IN_FEAR = 72321 , SPELL_DARK_MENDING = 72322 , // ▁ Phantom ▁ Mage ENDCOM SPELL_FIREBALL = 72163 , SPELL_FLAMESTRIKE = 72169 , SPELL_FROSTBOLT = 72166 , SPELL_CHAINS_OF_ICE = 72121 , SPELL_HALLUCINATION = 72342 , AURA_HALLUCINATION = 72343 , // ▁ Phantom ▁ Hallucination ▁ ( same ▁ as ▁ phantom ▁ mage ▁ + ▁ HALLUCINATION _ 2 ▁ when ▁ dies ) ENDCOM SPELL_HALLUCINATION_2 = 72344 , // ▁ Shadowy ▁ Mercenary ENDCOM SPELL_SHADOW_STEP = 72326 , SPELL_DEADLY_POISON = 72329 , SPELL_ENVENOMED_DAGGER_THROW = 72333 , SPELL_KIDNEY_SHOT = 72335 , // ▁ Spectral ▁ Footman ENDCOM SPELL_SPECTRAL_STRIKE = 72198 , SPELL_SHIELD_BASH = 72194 , SPELL_TORTURED_ENRAGE = 72203 , // ▁ Tortured ▁ Rifleman ENDCOM SPELL_SHOOT = 72208 , SPELL_CURSED_ARROW = 72222 , SPELL_FROST_TRAP = 72215 , SPELL_ICE_SHOT = 72268 } ; enum TrashEvents { EVENT_TRASH_NONE , // ▁ Ghostly ▁ Priest ENDCOM EVENT_SHADOW_WORD_PAIN , EVENT_CIRCLE_OF_DESTRUCTION , EVENT_COWER_IN_FEAR , EVENT_DARK_MENDING , // ▁ Phantom ▁ Mage ENDCOM EVENT_FIREBALL , EVENT_FLAMESTRIKE , EVENT_FROSTBOLT , EVENT_CHAINS_OF_ICE , EVENT_HALLUCINATION , // ▁ Shadowy ▁ Mercenary ENDCOM EVENT_SHADOW_STEP , EVENT_DEADLY_POISON , EVENT_ENVENOMED_DAGGER_THROW , EVENT_KIDNEY_SHOT , // ▁ Spectral ▁ Footman ENDCOM EVENT_SPECTRAL_STRIKE , EVENT_SHIELD_BASH , EVENT_TORTURED_ENRAGE , // ▁ Tortured ▁ Rifleman ENDCOM EVENT_SHOOT , EVENT_CURSED_ARROW , EVENT_FROST_TRAP , EVENT_ICE_SHOT } ; struct npc_gauntlet_trash : public ScriptedAI { npc_gauntlet_trash ( Creature * creature ) : ScriptedAI ( creature ) , _instance ( creature -> GetInstanceScript ( ) ) , InternalWaveId ( 0 ) { } void Reset ( ) override { me -> CastSpell ( me , SPELL_WELL_OF_SOULS , true ) ; _events . Reset ( ) ; } void EnterEvadeMode ( EvadeReason /* why */ ) override { if ( _instance -> GetData ( DATA_WAVE_COUNT ) != NOT_STARTED ) _instance -> SetData ( DATA_WAVE_COUNT , NOT_STARTED ) ; } void SetData ( uint32 type , uint32 value ) override { if ( type ) return ; InternalWaveId = value ; } uint32 GetData ( uint32 type ) const override { if ( type ) return 0 ; return InternalWaveId ; } protected : EventMap _events ; InstanceScript * _instance ; uint32 InternalWaveId ; } ; class npc_ghostly_priest : public CreatureScript { public : npc_ghostly_priest ( ) : CreatureScript ( " npc _ ghostly _ priest " ) { } struct npc_ghostly_priestAI : public npc_gauntlet_trash { npc_ghostly_priestAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * /* who */ ) override { _events . ScheduleEvent ( EVENT_SHADOW_WORD_PAIN , 6s , 15s ) ; _events . ScheduleEvent ( EVENT_CIRCLE_OF_DESTRUCTION , 12s ) ; _events . ScheduleEvent ( EVENT_COWER_IN_FEAR , 10s ) ; _events . ScheduleEvent ( EVENT_DARK_MENDING , 20s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SHADOW_WORD_PAIN : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_SHADOW_WORD_PAIN ) ; _events . ScheduleEvent ( EVENT_SHADOW_WORD_PAIN , 6s , 15s ) ; break ; case EVENT_CIRCLE_OF_DESTRUCTION : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 10.0f , true ) ) DoCast ( target , SPELL_CIRCLE_OF_DESTRUCTION ) ; _events . ScheduleEvent ( EVENT_CIRCLE_OF_DESTRUCTION , 12s ) ; break ; case EVENT_COWER_IN_FEAR : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 20.0f , true ) ) DoCast ( target , SPELL_COWER_IN_FEAR ) ; _events . ScheduleEvent ( EVENT_COWER_IN_FEAR , 10s ) ; break ; case EVENT_DARK_MENDING : // ▁ find ▁ an ▁ ally ▁ with ▁ missing ▁ HP ENDCOM if ( Unit * target = DoSelectLowestHpFriendly ( 40 , DUNGEON_MODE ( 30000 , 50000 ) ) ) { DoCast ( target , SPELL_DARK_MENDING ) ; _events . ScheduleEvent ( EVENT_DARK_MENDING , 20s ) ; } else { // ▁ no ▁ friendly ▁ unit ▁ with ▁ missing ▁ hp . ▁ re - check ▁ in ▁ just ▁ 5 ▁ sec . ENDCOM _events . ScheduleEvent ( EVENT_DARK_MENDING , 5s ) ; } break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_ghostly_priestAI > ( creature ) ; } } ; class npc_phantom_mage : public CreatureScript { public : npc_phantom_mage ( ) : CreatureScript ( " npc _ phantom _ mage " ) { } struct npc_phantom_mageAI : public npc_gauntlet_trash { npc_phantom_mageAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void EnterEvadeMode ( EvadeReason why ) override { if ( ! me -> HasAura ( AURA_HALLUCINATION ) ) npc_gauntlet_trash :: EnterEvadeMode ( why ) ; } void JustEngagedWith ( Unit * /* who */ ) override { _events . ScheduleEvent ( EVENT_FIREBALL , 3s ) ; _events . ScheduleEvent ( EVENT_FLAMESTRIKE , 6s ) ; _events . ScheduleEvent ( EVENT_FROSTBOLT , 9s ) ; _events . ScheduleEvent ( EVENT_CHAINS_OF_ICE , 12s ) ; _events . ScheduleEvent ( EVENT_HALLUCINATION , 40s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_FIREBALL : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_FIREBALL ) ; _events . ScheduleEvent ( EVENT_FIREBALL , 15s ) ; break ; case EVENT_FLAMESTRIKE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_FLAMESTRIKE ) ; _events . ScheduleEvent ( EVENT_FLAMESTRIKE , 15s ) ; break ; case EVENT_FROSTBOLT : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_FROSTBOLT ) ; _events . ScheduleEvent ( EVENT_FROSTBOLT , 15s ) ; break ; case EVENT_CHAINS_OF_ICE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM ) ) DoCast ( target , SPELL_CHAINS_OF_ICE ) ; _events . ScheduleEvent ( EVENT_CHAINS_OF_ICE , 15s ) ; break ; case EVENT_HALLUCINATION : // ▁ removing ▁ any ▁ dots ▁ on ▁ mage ▁ or ▁ else ▁ the ▁ invisibility ▁ spell ▁ will ▁ break ▁ duration ENDCOM me -> RemoveAllAuras ( ) ; DoCast ( me , SPELL_HALLUCINATION ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_phantom_mageAI > ( creature ) ; } } ; class npc_phantom_hallucination : public CreatureScript { public : npc_phantom_hallucination ( ) : CreatureScript ( " npc _ phantom _ hallucination " ) { } struct npc_phantom_hallucinationAI : public npc_phantom_mage :: npc_phantom_mageAI { npc_phantom_hallucinationAI ( Creature * creature ) : npc_phantom_mage :: npc_phantom_mageAI ( creature ) { } void Reset ( ) override { DoZoneInCombat ( me ) ; } void EnterEvadeMode ( EvadeReason why ) override { if ( me -> GetOwner ( ) && ! me -> GetOwner ( ) -> HasAura ( AURA_HALLUCINATION ) ) npc_phantom_mage :: npc_phantom_mageAI :: EnterEvadeMode ( why ) ; } void JustDied ( Unit * /* killer */ ) override { DoCastAOE ( SPELL_HALLUCINATION_2 ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_phantom_hallucinationAI > ( creature ) ; } } ; class npc_shadowy_mercenary : public CreatureScript { public : npc_shadowy_mercenary ( ) : CreatureScript ( " npc _ shadowy _ mercenary " ) { } struct npc_shadowy_mercenaryAI : public npc_gauntlet_trash { npc_shadowy_mercenaryAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * /* who */ ) override { _events . ScheduleEvent ( EVENT_SHADOW_STEP , 23s ) ; _events . ScheduleEvent ( EVENT_DEADLY_POISON , 5s ) ; _events . ScheduleEvent ( EVENT_ENVENOMED_DAGGER_THROW , 10s ) ; _events . ScheduleEvent ( EVENT_KIDNEY_SHOT , 12s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SHADOW_STEP : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 100.0f , true ) ) DoCast ( target , SPELL_SHADOW_STEP ) ; _events . ScheduleEvent ( EVENT_SHADOW_STEP , 8s ) ; break ; case EVENT_DEADLY_POISON : DoCastVictim ( SPELL_DEADLY_POISON ) ; _events . ScheduleEvent ( EVENT_DEADLY_POISON , 10s ) ; break ; case EVENT_ENVENOMED_DAGGER_THROW : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_ENVENOMED_DAGGER_THROW ) ; _events . ScheduleEvent ( EVENT_ENVENOMED_DAGGER_THROW , 10s ) ; break ; case EVENT_KIDNEY_SHOT : DoCastVictim ( SPELL_KIDNEY_SHOT ) ; _events . ScheduleEvent ( EVENT_KIDNEY_SHOT , 10s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_shadowy_mercenaryAI > ( creature ) ; } } ; class npc_spectral_footman : public CreatureScript { public : npc_spectral_footman ( ) : CreatureScript ( " npc _ spectral _ footman " ) { } struct npc_spectral_footmanAI : public npc_gauntlet_trash { npc_spectral_footmanAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * /* who */ ) override { _events . ScheduleEvent ( EVENT_SPECTRAL_STRIKE , 14s ) ; _events . ScheduleEvent ( EVENT_SHIELD_BASH , 10s ) ; _events . ScheduleEvent ( EVENT_TORTURED_ENRAGE , 15s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SPECTRAL_STRIKE : DoCastVictim ( SPELL_SPECTRAL_STRIKE ) ; _events . ScheduleEvent ( EVENT_SPECTRAL_STRIKE , 5s ) ; break ; case EVENT_SHIELD_BASH : DoCastVictim ( SPELL_SHIELD_BASH ) ; _events . ScheduleEvent ( EVENT_SHIELD_BASH , 5s ) ; break ; case EVENT_TORTURED_ENRAGE : DoCast ( me , SPELL_TORTURED_ENRAGE ) ; _events . ScheduleEvent ( EVENT_TORTURED_ENRAGE , 15s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_spectral_footmanAI > ( creature ) ; } } ; class npc_tortured_rifleman : public CreatureScript { public : npc_tortured_rifleman ( ) : CreatureScript ( " npc _ tortured _ rifleman " ) { } struct npc_tortured_riflemanAI : public npc_gauntlet_trash { npc_tortured_riflemanAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * /* who */ ) override { _events . ScheduleEvent ( EVENT_SHOOT , 1 ) ; _events . ScheduleEvent ( EVENT_CURSED_ARROW , 7s ) ; _events . ScheduleEvent ( EVENT_FROST_TRAP , 10s ) ; _events . ScheduleEvent ( EVENT_ICE_SHOT , 15s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SHOOT : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_SHOOT ) ; _events . ScheduleEvent ( EVENT_SHOOT , 2s ) ; break ; case EVENT_CURSED_ARROW : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_CURSED_ARROW ) ; _events . ScheduleEvent ( EVENT_CURSED_ARROW , 10s ) ; break ; case EVENT_FROST_TRAP : DoCast ( me , SPELL_FROST_TRAP ) ; _events . ScheduleEvent ( EVENT_FROST_TRAP , 30s ) ; break ; case EVENT_ICE_SHOT : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_ICE_SHOT ) ; _events . ScheduleEvent ( EVENT_ICE_SHOT , 15s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_tortured_riflemanAI > ( creature ) ; } } ; enum FrostswornGeneral { // ▁ General ENDCOM EVENT_SHIELD = 1 , EVENT_SPIKE = 2 , EVENT_CLONE = 3 , SAY_AGGRO = 0 , SAY_DEATH = 1 , SPELL_SHIELD_THROWN = 69222 , SPELL_SPIKE = 69184 , SPELL_CLONE = 69828 , SPELL_GHOST_VISUAL = 69861 , // ▁ Reflection ENDCOM EVENT_BALEFUL_STRIKE = 1 , SPELL_BALEFUL_STRIKE = 69933 , SPELL_SPIRIT_BURST = 69900 } ; class npc_frostsworn_general : public CreatureScript { public : npc_frostsworn_general ( ) : CreatureScript ( " npc _ frostsworn _ general " ) { } struct npc_frostsworn_generalAI : public ScriptedAI { npc_frostsworn_generalAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = creature -> GetInstanceScript ( ) ; } void Reset ( ) override { _events . Reset ( ) ; _instance -> SetData ( DATA_FROSTSWORN_GENERAL , NOT_STARTED ) ; } void JustDied ( Unit * /* killer */ ) override { Talk ( SAY_DEATH ) ; _events . Reset ( ) ; _instance -> SetData ( DATA_FROSTSWORN_GENERAL , DONE ) ; } void JustEngagedWith ( Unit * /* victim */ ) override { Talk ( SAY_AGGRO ) ; DoZoneInCombat ( ) ; _events . ScheduleEvent ( EVENT_SHIELD , 5s ) ; _events . ScheduleEvent ( EVENT_SPIKE , 14s ) ; _events . ScheduleEvent ( EVENT_CLONE , 22s ) ; _instance -> SetData ( DATA_FROSTSWORN_GENERAL , IN_PROGRESS ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; while ( uint32 event = _events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_SHIELD : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 45.0f , true ) ) DoCast ( target , SPELL_SHIELD_THROWN ) ; _events . ScheduleEvent ( EVENT_SHIELD , 8s , 12s ) ; break ; case EVENT_SPIKE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 45.0f , true ) ) DoCast ( target , SPELL_SPIKE ) ; _events . ScheduleEvent ( EVENT_SPIKE , 15s , 20s ) ; break ; case EVENT_CLONE : SummonClones ( ) ; _events . ScheduleEvent ( EVENT_CLONE , 1min ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } void SummonClones ( ) { std :: list < Unit * > playerList ; SelectTargetList ( playerList , 5 , SELECT_TARGET_MAXTHREAT , 0 , 0.0f , true ) ; for ( Unit * target : playerList ) { if ( Creature * reflection = me -> SummonCreature ( NPC_REFLECTION , * target , TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT , 3000 ) ) { reflection -> SetImmuneToPC ( false ) ; target -> CastSpell ( reflection , SPELL_CLONE , true ) ; target -> CastSpell ( reflection , SPELL_GHOST_VISUAL , true ) ; reflection -> AI ( ) -> AttackStart ( target ) ; } } } private : InstanceScript * _instance ; EventMap _events ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_frostsworn_generalAI > ( creature ) ; } } ; class npc_spiritual_reflection : public CreatureScript { public : npc_spiritual_reflection ( ) : CreatureScript ( " npc _ spiritual _ reflection " ) { } struct npc_spiritual_reflectionAI : public ScriptedAI { npc_spiritual_reflectionAI ( Creature * creature ) : ScriptedAI ( creature ) { } void Reset ( ) override { _events . Reset ( ) ; } void JustEngagedWith ( Unit * /* victim */ ) override { _events . ScheduleEvent ( EVENT_BALEFUL_STRIKE , 3s ) ; } void JustDied ( Unit * /* killer */ ) override { DoCastAOE ( SPELL_SPIRIT_BURST ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_BALEFUL_STRIKE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 8.0f , true ) ) DoCast ( target , SPELL_BALEFUL_STRIKE ) ; _events . ScheduleEvent ( EVENT_BALEFUL_STRIKE , 3s , 8s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } private : EventMap _events ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_spiritual_reflectionAI > ( creature ) ; } } ; // ▁ 5689 ENDCOM class at_hor_intro_start : public AreaTriggerScript { public : at_hor_intro_start ( ) : AreaTriggerScript ( " at _ hor _ intro _ start " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * /* trigger */ ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetData ( DATA_INTRO_EVENT ) == NOT_STARTED ) _instance -> SetData ( DATA_INTRO_EVENT , IN_PROGRESS ) ; if ( player -> HasAura ( SPELL_QUEL_DELAR_COMPULSION ) && ( player -> GetQuestStatus ( QUEST_HALLS_OF_REFLECTION_ALLIANCE ) == QUEST_STATUS_INCOMPLETE || player -> GetQuestStatus ( QUEST_HALLS_OF_REFLECTION_HORDE ) == QUEST_STATUS_INCOMPLETE ) && _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == NOT_STARTED ) { _instance -> SetData ( DATA_QUEL_DELAR_EVENT , IN_PROGRESS ) ; _instance -> SetGuidData ( DATA_QUEL_DELAR_INVOKER , player -> GetGUID ( ) ) ; } return true ; } } ; class at_hor_waves_restarter : public AreaTriggerScript { public : at_hor_waves_restarter ( ) : AreaTriggerScript ( " at _ hor _ waves _ restarter " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * /* trigger */ ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetData ( DATA_WAVE_COUNT ) ) return true ; if ( _instance -> GetData ( DATA_INTRO_EVENT ) == DONE && _instance -> GetBossState ( DATA_MARWYN ) != DONE ) { _instance -> ProcessEvent ( 0 , EVENT_SPAWN_WAVES ) ; if ( Creature * falric = ObjectAccessor :: GetCreature ( * player , _instance -> GetGuidData ( DATA_FALRIC ) ) ) { falric -> CastSpell ( falric , SPELL_BOSS_SPAWN_AURA , true ) ; falric -> SetVisible ( true ) ; } if ( Creature * marwyn = ObjectAccessor :: GetCreature ( * player , _instance -> GetGuidData ( DATA_MARWYN ) ) ) { marwyn -> CastSpell ( marwyn , SPELL_BOSS_SPAWN_AURA , true ) ; marwyn -> SetVisible ( true ) ; } } return true ; } } ; // ▁ 5740 ENDCOM class at_hor_impenetrable_door : public AreaTriggerScript { public : at_hor_impenetrable_door ( ) : AreaTriggerScript ( " at _ hor _ impenetrable _ door " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * /* at */ ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetBossState ( DATA_MARWYN ) == DONE ) return true ; // / ▁ return ▁ false ▁ to ▁ handle ▁ teleport ▁ by ▁ db ENDCOM return false ; } } ; // ▁ 5605 ENDCOM class at_hor_shadow_throne : public AreaTriggerScript { public : at_hor_shadow_throne ( ) : AreaTriggerScript ( " at _ hor _ shadow _ throne " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * /* at */ ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == NOT_STARTED ) _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , IN_PROGRESS ) ; return true ; } } ; enum EscapeEvents { // ▁ Raging ▁ Ghoul ENDCOM EVENT_RAGING_GHOUL_JUMP = 1 , // ▁ Risen ▁ Witch ▁ Doctor ENDCOM EVENT_RISEN_WITCH_DOCTOR_CURSE , EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT , EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY , // ▁ Lumbering ▁ Abomination ENDCOM EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY , EVENT_LUMBERING_ABOMINATION_CLEAVE } ; class HoRStartMovementEvent : public BasicEvent { public : explicit HoRStartMovementEvent ( Creature * owner ) : _owner ( owner ) { } bool Execute ( uint64 /* execTime */ , uint32 /* diff */ ) override { _owner -> SetReactState ( REACT_AGGRESSIVE ) ; if ( Unit * target = _owner -> AI ( ) -> SelectTarget ( SELECT_TARGET_RANDOM , 0 , 0.0f , true ) ) _owner -> AI ( ) -> AttackStart ( target ) ; return true ; } private : Creature * _owner ; } ; struct npc_escape_event_trash : public ScriptedAI { npc_escape_event_trash ( Creature * creature ) : ScriptedAI ( creature ) , _instance ( creature -> GetInstanceScript ( ) ) { } void Reset ( ) override { _events . Reset ( ) ; } void UpdateAI ( uint32 /* diff */ ) override { if ( _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == FAIL || _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == NOT_STARTED ) me -> DespawnOrUnsummon ( ) ; } void IsSummonedBy ( WorldObject * /* summoner */ ) override { DoZoneInCombat ( me ) ; if ( Creature * leader = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) { me -> SetImmuneToPC ( false ) ; me -> SetInCombatWith ( leader ) ; leader -> SetInCombatWith ( me ) ; AddThreat ( leader , 0.0f ) ; } } protected : EventMap _events ; InstanceScript * _instance ; } ; class npc_raging_ghoul : public CreatureScript { public : npc_raging_ghoul ( ) : CreatureScript ( " npc _ raging _ ghoul " ) { } struct npc_raging_ghoulAI : public npc_escape_event_trash { npc_raging_ghoulAI ( Creature * creature ) : npc_escape_event_trash ( creature ) { } void Reset ( ) override { npc_escape_event_trash :: Reset ( ) ; _events . ScheduleEvent ( EVENT_RAGING_GHOUL_JUMP , 5s ) ; } void IsSummonedBy ( WorldObject * summoner ) override { me -> CastSpell ( me , SPELL_RAGING_GHOUL_SPAWN , true ) ; me -> SetReactState ( REACT_PASSIVE ) ; me -> HandleEmoteCommand ( EMOTE_ONESHOT_EMERGE ) ; me -> m_Events . AddEvent ( new HoRStartMovementEvent ( me ) , me -> m_Events . CalculateTime ( 5000 ) ) ; npc_escape_event_trash :: IsSummonedBy ( summoner ) ; } void UpdateAI ( uint32 diff ) override { npc_escape_event_trash :: UpdateAI ( diff ) ; if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_RAGING_GHOUL_JUMP : if ( Unit * victim = me -> GetVictim ( ) ) { if ( me -> IsInRange ( victim , 5.0f , 30.0f ) ) { DoCast ( victim , SPELL_GHOUL_JUMP ) ; return ; } } _events . ScheduleEvent ( EVENT_RAGING_GHOUL_JUMP , 500ms ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_raging_ghoulAI > ( creature ) ; } } ; class npc_risen_witch_doctor : public CreatureScript { public : npc_risen_witch_doctor ( ) : CreatureScript ( " npc _ risen _ witch _ doctor " ) { } struct npc_risen_witch_doctorAI : public npc_escape_event_trash { npc_risen_witch_doctorAI ( Creature * creature ) : npc_escape_event_trash ( creature ) { } void Reset ( ) override { npc_escape_event_trash :: Reset ( ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT , 6s ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY , 15s ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_CURSE , 7s ) ; } void IsSummonedBy ( WorldObject * summoner ) override { me -> CastSpell ( me , SPELL_RISEN_WITCH_DOCTOR_SPAWN , true ) ; me -> SetReactState ( REACT_PASSIVE ) ; me -> HandleEmoteCommand ( EMOTE_ONESHOT_EMERGE ) ; me -> m_Events . AddEvent ( new HoRStartMovementEvent ( me ) , me -> m_Events . CalculateTime ( 5000 ) ) ; npc_escape_event_trash :: IsSummonedBy ( summoner ) ; } void UpdateAI ( uint32 diff ) override { npc_escape_event_trash :: UpdateAI ( diff ) ; if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_RISEN_WITCH_DOCTOR_CURSE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 30.0f , true ) ) DoCast ( target , SPELL_CURSE_OF_DOOM ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_CURSE , 10s , 15s ) ; break ; case EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT : if ( Unit * target = SelectTarget ( SELECT_TARGET_MAXTHREAT , 0 , 20.0f , true ) ) DoCast ( target , SPELL_SHADOW_BOLT ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT , 2s , 3s ) ; break ; case EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY : if ( SelectTarget ( SELECT_TARGET_RANDOM , 0 , 30.0f , true ) ) DoCastAOE ( SPELL_SHADOW_BOLT_VOLLEY ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY , 15s , 22s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_risen_witch_doctorAI > ( creature ) ; } } ; class npc_lumbering_abomination : public CreatureScript { public : npc_lumbering_abomination ( ) : CreatureScript ( " npc _ lumbering _ abomination " ) { } struct npc_lumbering_abominationAI : public npc_escape_event_trash { npc_lumbering_abominationAI ( Creature * creature ) : npc_escape_event_trash ( creature ) { } void Reset ( ) override { npc_escape_event_trash :: Reset ( ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY , 15s ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_CLEAVE , 6s ) ; } void UpdateAI ( uint32 diff ) override { npc_escape_event_trash :: UpdateAI ( diff ) ; if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY : DoCastVictim ( SPELL_VOMIT_SPRAY ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY , 15s , 20s ) ; break ; case EVENT_LUMBERING_ABOMINATION_CLEAVE : DoCastVictim ( SPELL_CLEAVE ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_CLEAVE , 7s , 9s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_lumbering_abominationAI > ( creature ) ; } } ; enum QuelDelarUther { ACTION_UTHER_START_SCREAM = 1 , ACTION_UTHER_OUTRO = 2 , EVENT_UTHER_1 = 1 , EVENT_UTHER_2 = 2 , EVENT_UTHER_3 = 3 , EVENT_UTHER_4 = 4 , EVENT_UTHER_5 = 5 , EVENT_UTHER_6 = 6 , EVENT_UTHER_7 = 7 , EVENT_UTHER_8 = 8 , EVENT_UTHER_9 = 9 , EVENT_UTHER_10 = 10 , EVENT_UTHER_11 = 11 , EVENT_UTHER_FACING = 12 , EVENT_UTHER_KNEEL = 13 , SAY_UTHER_QUEL_DELAR_1 = 16 , SAY_UTHER_QUEL_DELAR_2 = 17 , SAY_UTHER_QUEL_DELAR_3 = 18 , SAY_UTHER_QUEL_DELAR_4 = 19 , SAY_UTHER_QUEL_DELAR_5 = 20 , SAY_UTHER_QUEL_DELAR_6 = 21 , SPELL_ESSENCE_OF_CAPTURED_1 = 73036 } ; enum QuelDelarSword { SPELL_WHIRLWIND_VISUAL = 70300 , SPELL_HEROIC_STRIKE = 29426 , SPELL_WHIRLWIND = 67716 , SPELL_BLADESTORM = 67541 , NPC_QUEL_DELAR = 37158 , POINT_TAKE_OFF = 1 , EVENT_QUEL_DELAR_INIT = 1 , EVENT_QUEL_DELAR_FLIGHT_INIT = 2 , EVENT_QUEL_DELAR_FLIGHT = 3 , EVENT_QUEL_DELAR_LAND = 4 , EVENT_QUEL_DELAR_FIGHT = 5 , EVENT_QUEL_DELAR_BLADESTORM = 6 , EVENT_QUEL_DELAR_HEROIC_STRIKE = 7 , EVENT_QUEL_DELAR_WHIRLWIND = 8 , SAY_QUEL_DELAR_SWORD = 0 } ; enum QuelDelarMisc { SAY_FROSTMOURNE_BUNNY = 0 , SPELL_QUEL_DELAR_WILL = 70698 } ; Position const QuelDelarCenterPos = { 5309.259f , 2006.390f , 718.046f , 0.0f } ; Position const QuelDelarSummonPos = { 5298.473f , 1994.852f , 709.424f , 3.979351f } ; Position const QuelDelarMovement [ ] = { { 5292.870f , 1998.950f , 718.046f , 0.0f } , { 5295.819f , 1991.912f , 707.707f , 0.0f } , { 5295.301f , 1989.782f , 708.696f , 0.0f } } ; Position const UtherQuelDelarMovement [ ] = { { 5336.830f , 1981.700f , 709.319f , 0.0f } , { 5314.350f , 1993.440f , 707.726f , 0.0f } } ; class npc_uther_quel_delar : public CreatureScript { public : npc_uther_quel_delar ( ) : CreatureScript ( " npc _ uther _ quel _ delar " ) { } struct npc_uther_quel_delarAI : public ScriptedAI { npc_uther_quel_delarAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; } void Reset ( ) override { // ▁ Prevent ▁ to ▁ break ▁ Uther ▁ in ▁ intro ▁ event ▁ during ▁ instance ▁ encounter ENDCOM if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != IN_PROGRESS && _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != SPECIAL ) return ; _events . Reset ( ) ; _events . ScheduleEvent ( EVENT_UTHER_1 , 1 ) ; } void DamageTaken ( Unit * /* attacker */ , uint32 & damage ) override { if ( damage >= me -> GetHealth ( ) ) damage = me -> GetHealth ( ) - 1 ; } void DoAction ( int32 action ) override { switch ( action ) { case ACTION_UTHER_START_SCREAM : _instance -> SetData ( DATA_QUEL_DELAR_EVENT , SPECIAL ) ; _events . ScheduleEvent ( EVENT_UTHER_2 , 0 ) ; break ; case ACTION_UTHER_OUTRO : _events . ScheduleEvent ( EVENT_UTHER_6 , 0 ) ; break ; default : break ; } } void MovementInform ( uint32 /* type */ , uint32 pointId ) override { switch ( pointId ) { case 1 : _events . ScheduleEvent ( EVENT_UTHER_FACING , 1s ) ; break ; default : break ; } } void UpdateAI ( uint32 diff ) override { // ▁ Prevent ▁ to ▁ break ▁ Uther ▁ in ▁ intro ▁ event ▁ during ▁ instance ▁ encounter ENDCOM if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != IN_PROGRESS && _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != SPECIAL ) return ; _events . Update ( diff ) ; while ( uint32 eventId = _events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_UTHER_1 : Talk ( SAY_UTHER_QUEL_DELAR_1 ) ; break ; case EVENT_UTHER_2 : if ( Creature * bunny = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE_ALTAR_BUNNY ) ) ) if ( Unit * target = ObjectAccessor :: GetPlayer ( * me , _instance -> GetGuidData ( DATA_QUEL_DELAR_INVOKER ) ) ) bunny -> CastSpell ( target , SPELL_QUEL_DELAR_WILL , true ) ; _events . ScheduleEvent ( EVENT_UTHER_3 , 2000 ) ; break ; case EVENT_UTHER_3 : me -> SummonCreature ( NPC_QUEL_DELAR , QuelDelarSummonPos ) ; _events . ScheduleEvent ( EVENT_UTHER_4 , 2000 ) ; break ; case EVENT_UTHER_4 : Talk ( SAY_UTHER_QUEL_DELAR_2 ) ; _events . ScheduleEvent ( EVENT_UTHER_5 , 8000 ) ; break ; case EVENT_UTHER_5 : me -> GetMotionMaster ( ) -> MovePoint ( 1 , UtherQuelDelarMovement [ 0 ] ) ; break ; case EVENT_UTHER_6 : me -> SetWalk ( true ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , UtherQuelDelarMovement [ 1 ] ) ; _events . ScheduleEvent ( EVENT_UTHER_7 , 5000 ) ; break ; case EVENT_UTHER_7 : Talk ( SAY_UTHER_QUEL_DELAR_3 ) ; _events . ScheduleEvent ( EVENT_UTHER_8 , 12000 ) ; break ; case EVENT_UTHER_8 : Talk ( SAY_UTHER_QUEL_DELAR_4 ) ; _events . ScheduleEvent ( EVENT_UTHER_9 , 7000 ) ; break ; case EVENT_UTHER_9 : Talk ( SAY_UTHER_QUEL_DELAR_5 ) ; _events . ScheduleEvent ( EVENT_UTHER_10 , 10000 ) ; break ; case EVENT_UTHER_10 : Talk ( SAY_UTHER_QUEL_DELAR_6 ) ; _events . ScheduleEvent ( EVENT_UTHER_11 , 5000 ) ; break ; case EVENT_UTHER_11 : DoCast ( me , SPELL_ESSENCE_OF_CAPTURED_1 , true ) ; me -> DespawnOrUnsummon ( 3000 ) ; _instance -> SetData ( DATA_QUEL_DELAR_EVENT , DONE ) ; break ; case EVENT_UTHER_FACING : if ( Creature * bunny = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE_ALTAR_BUNNY ) ) ) me -> SetFacingToObject ( bunny ) ; _events . ScheduleEvent ( EVENT_UTHER_KNEEL , 1s ) ; break ; case EVENT_UTHER_KNEEL : me -> HandleEmoteCommand ( EMOTE_STATE_KNEEL ) ; break ; default : break ; } } } private : EventMap _events ; InstanceScript * _instance ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_uther_quel_delarAI > ( creature ) ; } } ; class npc_quel_delar_sword : public CreatureScript { public : npc_quel_delar_sword ( ) : CreatureScript ( " npc _ quel _ delar _ sword " ) { } struct npc_quel_delar_swordAI : public ScriptedAI { npc_quel_delar_swordAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; me -> SetDisplayId ( me -> GetCreatureTemplate ( ) -> Modelid2 ) ; _intro = true ; } void Reset ( ) override { _events . Reset ( ) ; me -> SetSpeedRate ( MOVE_FLIGHT , 4.5f ) ; DoCast ( SPELL_WHIRLWIND_VISUAL ) ; if ( _intro ) _events . ScheduleEvent ( EVENT_QUEL_DELAR_INIT , 0 ) ; else me -> SetImmuneToAll ( false ) ; } void JustEngagedWith ( Unit * /* victim */ ) override { _events . ScheduleEvent ( EVENT_QUEL_DELAR_HEROIC_STRIKE , 4s ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_BLADESTORM , 6s ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_WHIRLWIND , 6s ) ; } void JustDied ( Unit * /* killer */ ) override { if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_UTHER_QUEL_DELAR ) ) ) uther -> AI ( ) -> DoAction ( ACTION_UTHER_OUTRO ) ; } void MovementInform ( uint32 type , uint32 pointId ) override { if ( type != EFFECT_MOTION_TYPE ) return ; switch ( pointId ) { case POINT_TAKE_OFF : _events . ScheduleEvent ( EVENT_QUEL_DELAR_FLIGHT , 0 ) ; break ; default : break ; } } void UpdateAI ( uint32 diff ) override { _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; if ( ! UpdateVictim ( ) ) { while ( uint32 eventId = _events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_QUEL_DELAR_INIT : if ( Creature * bunny = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE_ALTAR_BUNNY ) ) ) bunny -> AI ( ) -> Talk ( SAY_FROSTMOURNE_BUNNY ) ; _intro = false ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_FLIGHT_INIT , 2500ms ) ; break ; case EVENT_QUEL_DELAR_FLIGHT_INIT : me -> GetMotionMaster ( ) -> MoveTakeoff ( POINT_TAKE_OFF , QuelDelarMovement [ 0 ] ) ; break ; case EVENT_QUEL_DELAR_FLIGHT : { me -> GetMotionMaster ( ) -> MoveCirclePath ( QuelDelarCenterPos . GetPositionX ( ) , QuelDelarCenterPos . GetPositionY ( ) , 718.046f , 18.0f , true , 16 ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_LAND , 15s ) ; break ; } case EVENT_QUEL_DELAR_LAND : me -> StopMoving ( ) ; me -> GetMotionMaster ( ) -> Clear ( ) ; me -> GetMotionMaster ( ) -> MoveLand ( 0 , QuelDelarMovement [ 1 ] ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_FIGHT , 6s ) ; break ; case EVENT_QUEL_DELAR_FIGHT : Talk ( SAY_QUEL_DELAR_SWORD ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , QuelDelarMovement [ 2 ] ) ; me -> SetImmuneToAll ( false ) ; break ; default : break ; } } } else { while ( uint32 eventId = _events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_QUEL_DELAR_BLADESTORM : DoCast ( me , SPELL_BLADESTORM ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_BLADESTORM , 10s ) ; break ; case EVENT_QUEL_DELAR_HEROIC_STRIKE : DoCastVictim ( SPELL_HEROIC_STRIKE ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_HEROIC_STRIKE , 6s ) ; break ; case EVENT_QUEL_DELAR_WHIRLWIND : DoCastAOE ( SPELL_WHIRLWIND ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_WHIRLWIND , 1s ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } } private : EventMap _events ; InstanceScript * _instance ; bool _intro ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_quel_delar_swordAI > ( creature ) ; } } ; // ▁ 5660 ENDCOM class at_hor_uther_quel_delar_start : public AreaTriggerScript { public : at_hor_uther_quel_delar_start ( ) : AreaTriggerScript ( " at _ hor _ uther _ quel _ delar _ start " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * /* trigger */ ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == IN_PROGRESS ) if ( Creature * uther = ObjectAccessor :: GetCreature ( * player , _instance -> GetGuidData ( DATA_UTHER_QUEL_DELAR ) ) ) uther -> AI ( ) -> DoAction ( ACTION_UTHER_START_SCREAM ) ; return true ; } } ; // ▁ 72900 ▁ - ▁ Start ▁ Halls ▁ of ▁ Reflection ▁ Quest ▁ AE ENDCOM class spell_hor_start_halls_of_reflection_quest_ae : public SpellScriptLoader { public : spell_hor_start_halls_of_reflection_quest_ae ( ) : SpellScriptLoader ( " spell _ hor _ start _ halls _ of _ reflection _ quest _ ae " ) { } class spell_hor_start_halls_of_reflection_quest_ae_SpellScript : public SpellScript { PrepareSpellScript ( spell_hor_start_halls_of_reflection_quest_ae_SpellScript ) ; void StartQuests ( SpellEffIndex /* effIndex */ ) { if ( Player * target = GetHitPlayer ( ) ) { // ▁ CanTakeQuest ▁ and ▁ CanAddQuest ▁ checks ▁ done ▁ in ▁ spell ▁ effect ▁ execution ENDCOM if ( target -> GetTeam ( ) == ALLIANCE ) target -> CastSpell ( target , SPELL_START_HALLS_OF_REFLECTION_QUEST_A , true ) ; else target -> CastSpell ( target , SPELL_START_HALLS_OF_REFLECTION_QUEST_H , true ) ; } } void Register ( ) override { OnEffectHitTarget += SpellEffectFn ( spell_hor_start_halls_of_reflection_quest_ae_SpellScript :: StartQuests , EFFECT_0 , SPELL_EFFECT_SCRIPT_EFFECT ) ; } } ; SpellScript * GetSpellScript ( ) const override { return new spell_hor_start_halls_of_reflection_quest_ae_SpellScript ( ) ; } } ; // ▁ 70190 ▁ - ▁ Evasion ENDCOM class spell_hor_evasion : public SpellScriptLoader { public : spell_hor_evasion ( ) : SpellScriptLoader ( " spell _ hor _ evasion " ) { } class spell_hor_evasion_SpellScript : public SpellScript { PrepareSpellScript ( spell_hor_evasion_SpellScript ) ; bool Load ( ) override { return GetCaster ( ) -> GetTypeId ( ) == TYPEID_UNIT ; } void SetDest ( SpellDestination & dest ) { WorldObject * target = GetExplTargetWorldObject ( ) ; Position pos ( * target ) ; Position home = GetCaster ( ) -> ToCreature ( ) -> GetHomePosition ( ) ; // ▁ prevent ▁ evasion ▁ outside ▁ the ▁ room ENDCOM if ( pos . IsInDist2d ( & home , 15.0f ) ) return ; float angle = pos . GetAbsoluteAngle ( & home ) ; float dist = GetSpellInfo ( ) -> Effects [ EFFECT_0 ] . CalcRadius ( GetCaster ( ) ) ; target -> MovePosition ( pos , dist , angle ) ; dest . Relocate ( pos ) ; } void Register ( ) override { OnDestinationTargetSelect += SpellDestinationTargetSelectFn ( spell_hor_evasion_SpellScript :: SetDest , EFFECT_0 , TARGET_DEST_TARGET_RADIUS ) ; } } ; SpellScript * GetSpellScript ( ) const override { return new spell_hor_evasion_SpellScript ( ) ; } } ; // ▁ 70017 ▁ - ▁ Gunship ▁ Cannon ▁ Fire ENDCOM class spell_hor_gunship_cannon_fire : public SpellScriptLoader { public : spell_hor_gunship_cannon_fire ( ) : SpellScriptLoader ( " spell _ hor _ gunship _ cannon _ fire " ) { } class spell_hor_gunship_cannon_fire_AuraScript : public AuraScript { PrepareAuraScript ( spell_hor_gunship_cannon_fire_AuraScript ) ; void HandlePeriodic ( AuraEffect const * /* aurEff */ ) { if ( ! urand ( 0 , 2 ) ) { if ( GetTarget ( ) -> GetEntry ( ) == NPC_GUNSHIP_CANNON_HORDE ) GetTarget ( ) -> CastSpell ( nullptr , SPELL_GUNSHIP_CANNON_FIRE_MISSILE_HORDE , true ) ; else GetTarget ( ) -> CastSpell ( nullptr , SPELL_GUNSHIP_CANNON_FIRE_MISSILE_ALLIANCE , true ) ; } } void Register ( ) override { OnEffectPeriodic += AuraEffectPeriodicFn ( spell_hor_gunship_cannon_fire_AuraScript :: HandlePeriodic , EFFECT_0 , SPELL_AURA_PERIODIC_TRIGGER_SPELL ) ; } } ; AuraScript * GetAuraScript ( ) const override { return new spell_hor_gunship_cannon_fire_AuraScript ( ) ; } } ; // ▁ 70698 ▁ - ▁ Quel ' Delar ' s ▁ Will ENDCOM class spell_hor_quel_delars_will : public SpellScript { PrepareSpellScript ( spell_hor_quel_delars_will ) ; bool Validate ( SpellInfo const * spellInfo ) override { return ValidateSpellInfo ( { spellInfo -> Effects [ EFFECT_0 ] . TriggerSpell } ) ; } void HandleReagent ( SpellEffIndex effIndex ) { PreventHitDefaultEffect ( effIndex ) ; // ▁ dummy ▁ spell ▁ consumes ▁ reagent , ▁ don ' t ▁ ignore ▁ it ENDCOM GetHitUnit ( ) -> CastSpell ( GetCaster ( ) , GetSpellInfo ( ) -> Effects [ effIndex ] . TriggerSpell , TriggerCastFlags ( TRIGGERED_FULL_MASK & ~ TRIGGERED_IGNORE_POWER_AND_REAGENT_COST ) ) ; } void Register ( ) override { OnEffectHitTarget += SpellEffectFn ( spell_hor_quel_delars_will :: HandleReagent , EFFECT_0 , SPELL_EFFECT_FORCE_CAST ) ; } } ; void AddSC_halls_of_reflection ( ) { new at_hor_intro_start ( ) ; new at_hor_waves_restarter ( ) ; new at_hor_impenetrable_door ( ) ; new at_hor_shadow_throne ( ) ; new at_hor_uther_quel_delar_start ( ) ; new npc_jaina_or_sylvanas_intro_hor ( ) ; new npc_jaina_or_sylvanas_escape_hor ( ) ; new npc_the_lich_king_escape_hor ( ) ; new npc_ghostly_priest ( ) ; new npc_phantom_mage ( ) ; new npc_phantom_hallucination ( ) ; new npc_shadowy_mercenary ( ) ; new npc_spectral_footman ( ) ; new npc_tortured_rifleman ( ) ; new npc_frostsworn_general ( ) ; new npc_spiritual_reflection ( ) ; new npc_raging_ghoul ( ) ; new npc_risen_witch_doctor ( ) ; new npc_lumbering_abomination ( ) ; new npc_uther_quel_delar ( ) ; new npc_quel_delar_sword ( ) ; new spell_hor_start_halls_of_reflection_quest_ae ( ) ; new spell_hor_evasion ( ) ; new spell_hor_gunship_cannon_fire ( ) ; RegisterSpellScript ( spell_hor_quel_delars_will ) ; } </DOCUMENT>
<DOCUMENT_ID="paulfitz/phantomjs/tree/master/src/qt/qtwebkit/Tools/DumpRenderTree/TestNetscapePlugIn/Tests/GetURLWithJavaScriptURLDestroyingPlugin.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2011 ▁ Apple ▁ Inc . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without STRNEWLINE ▁ * ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions STRNEWLINE ▁ * ▁ are ▁ met : STRNEWLINE ▁ * ▁ 1 . ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . STRNEWLINE ▁ * ▁ 2 . ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in ▁ the STRNEWLINE ▁ * ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the ▁ distribution . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ APPLE ▁ INC . ▁ AND ▁ ITS ▁ CONTRIBUTORS ▁ ` ` AS ▁ IS ' ' STRNEWLINE ▁ * ▁ AND ▁ ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , STRNEWLINE ▁ * ▁ THE ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR STRNEWLINE ▁ * ▁ PURPOSE ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ APPLE ▁ INC . ▁ OR ▁ ITS ▁ CONTRIBUTORS STRNEWLINE ▁ * ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR STRNEWLINE ▁ * ▁ CONSEQUENTIAL ▁ DAMAGES ▁ ( INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ PROCUREMENT ▁ OF STRNEWLINE ▁ * ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES ; ▁ LOSS ▁ OF ▁ USE , ▁ DATA , ▁ OR ▁ PROFITS ; ▁ OR ▁ BUSINESS STRNEWLINE ▁ * ▁ INTERRUPTION ) ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY ▁ THEORY ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN STRNEWLINE ▁ * ▁ CONTRACT , ▁ STRICT ▁ LIABILITY , ▁ OR ▁ TORT ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) STRNEWLINE ▁ * ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE ▁ OF ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF STRNEWLINE ▁ * ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . STRNEWLINE ▁ */ # include " PluginTest . h " using namespace std ; // ▁ From ▁ NPP _ New , ▁ call ▁ NPN _ GetURL ▁ to ▁ evaluate ▁ JavaScript ▁ that ▁ destroys ▁ the ▁ plug - in . ENDCOM class GetURLWithJavaScriptURLDestroyingPlugin : public PluginTest { public : GetURLWithJavaScriptURLDestroyingPlugin ( NPP npp , const string & identifier ) : PluginTest ( npp , identifier ) { } private : virtual NPError NPP_New ( NPMIMEType pluginType , uint16_t mode , int16_t argc , char * argn [ ] , char * argv [ ] , NPSavedData * saved ) { NPN_GetURL ( " javascript : removePlugin ( ) " , 0 ) ; return NPERR_NO_ERROR ; } } ; static PluginTest :: Register < GetURLWithJavaScriptURLDestroyingPlugin > getURLWithJavaScriptURLDestroyingPlugin ( " get - url - with - javascript - url - destroying - plugin " ) ; </DOCUMENT>
<DOCUMENT_ID="KonceptGeek/mosesdecoder/tree/master/mert/TER/infosHasher.cpp"> /* * * * * STRNEWLINE tercpp : ▁ an ▁ open - source ▁ Translation ▁ Edit ▁ Rate ▁ ( TER ) ▁ scorer ▁ tool ▁ for ▁ Machine ▁ Translation . STRNEWLINE STRNEWLINE Copyright ▁ 2010-2013 , ▁ Christophe ▁ Servan , ▁ LIUM , ▁ University ▁ of ▁ Le ▁ Mans , ▁ France STRNEWLINE Contact : ▁ christophe . servan @ lium . univ - lemans . fr STRNEWLINE STRNEWLINE The ▁ tercpp ▁ tool ▁ and ▁ library ▁ are ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it STRNEWLINE under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 2.1 ▁ of ▁ the ▁ licence , ▁ or STRNEWLINE ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE STRNEWLINE This ▁ program ▁ and ▁ library ▁ are ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT STRNEWLINE ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or STRNEWLINE FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE for ▁ more ▁ details . STRNEWLINE STRNEWLINE You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License STRNEWLINE along ▁ with ▁ this ▁ library ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ▁ Foundation , STRNEWLINE Inc . , ▁ 59 ▁ Temple ▁ Place , ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 ▁ USA STRNEWLINE * * * * */ # include " infosHasher . h " // ▁ The ▁ following ▁ class ▁ defines ▁ a ▁ hash ▁ function ▁ for ▁ strings ENDCOM using namespace std ; using namespace TERCPPNS_Tools ; namespace TERCPPNS_HashMapSpace { infosHasher :: infosHasher ( long cle , string cleTxt , vector < int > valueVecInt ) { m_hashKey = cle ; m_key = cleTxt ; m_value = valueVecInt ; } // ▁ infosHasher : : ~ infosHasher ( ) { } ; */ ENDCOM long infosHasher :: getHashKey ( ) { return m_hashKey ; } string infosHasher :: getKey ( ) { return m_key ; } vector < int > infosHasher :: getValue ( ) { return m_value ; } void infosHasher :: setValue ( vector < int > value ) { m_value = value ; } string infosHasher :: toString ( ) { stringstream to_return ; to_return << m_hashKey << " \t " << m_key << " \t " << vectorToString ( m_value , " \t " ) << endl ; return to_return . str ( ) ; } // ▁ typedef ▁ stdext : : hash _ map < std : : string , string , ▁ stringhasher > ▁ HASH _ S _ S ; ENDCOM } </DOCUMENT>
<DOCUMENT_ID="Rudi9719/curly-octo-barnacle/tree/master/TrinityCore/src/server/scripts/Northrend/Nexus/Nexus/boss_ormorok.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2008-2016 ▁ TrinityCore ▁ < http : // www . trinitycore . org / > STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2006-2009 ▁ ScriptDev2 ▁ < https : // scriptdev2 . svn . sourceforge . net / > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it STRNEWLINE ▁ * ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the STRNEWLINE ▁ * ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your STRNEWLINE ▁ * ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT STRNEWLINE ▁ * ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or STRNEWLINE ▁ * ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for STRNEWLINE ▁ * ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along STRNEWLINE ▁ * ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ */ # include " ScriptMgr . h " # include " ScriptedCreature . h " # include " nexus . h " # include " SpellScript . h " enum Spells { SPELL_SPELL_REFLECTION = 47981 , SPELL_TRAMPLE = 48016 , SPELL_FRENZY = 48017 , SPELL_SUMMON_CRYSTALLINE_TANGLER = 61564 , SPELL_CRYSTAL_SPIKES = 47958 , } ; enum Yells { SAY_AGGRO = 1 , SAY_DEATH = 2 , SAY_REFLECT = 3 , SAY_CRYSTAL_SPIKES = 4 , SAY_KILL = 5 , SAY_FRENZY = 6 } ; enum Events { EVENT_CRYSTAL_SPIKES = 1 , EVENT_TRAMPLE = 2 , EVENT_SPELL_REFLECTION = 3 , EVENT_CRYSTALLINE_TANGLER = 4 , } ; class OrmorokTanglerPredicate { public : OrmorokTanglerPredicate ( Unit * unit ) : me ( unit ) { } bool operator ( ) ( WorldObject * object ) const { return object -> GetDistance2d ( me ) >= 5.0f ; } private : Unit * me ; } ; class boss_ormorok : public CreatureScript { public : boss_ormorok ( ) : CreatureScript ( " boss _ ormorok " ) { } struct boss_ormorokAI : public BossAI { boss_ormorokAI ( Creature * creature ) : BossAI ( creature , DATA_ORMOROK ) { Initialize ( ) ; } void Initialize ( ) { frenzy = false ; } void Reset ( ) override { BossAI :: Reset ( ) ; Initialize ( ) ; } void EnterCombat ( Unit * /* who */ ) override { _EnterCombat ( ) ; events . ScheduleEvent ( EVENT_CRYSTAL_SPIKES , 12000 ) ; events . ScheduleEvent ( EVENT_TRAMPLE , 10000 ) ; events . ScheduleEvent ( EVENT_SPELL_REFLECTION , 30000 ) ; if ( IsHeroic ( ) ) events . ScheduleEvent ( EVENT_CRYSTALLINE_TANGLER , 17000 ) ; Talk ( SAY_AGGRO ) ; } void DamageTaken ( Unit * /* attacker */ , uint32 & /* damage */ ) override { if ( ! frenzy && HealthBelowPct ( 25 ) ) { Talk ( SAY_FRENZY ) ; DoCast ( me , SPELL_FRENZY ) ; frenzy = true ; } } void JustDied ( Unit * /* killer */ ) override { _JustDied ( ) ; Talk ( SAY_DEATH ) ; } void KilledUnit ( Unit * who ) override { if ( who -> GetTypeId ( ) == TYPEID_PLAYER ) Talk ( SAY_KILL ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; while ( uint32 eventId = events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_TRAMPLE : DoCast ( me , SPELL_TRAMPLE ) ; events . ScheduleEvent ( EVENT_TRAMPLE , 10000 ) ; break ; case EVENT_SPELL_REFLECTION : Talk ( SAY_REFLECT ) ; DoCast ( me , SPELL_SPELL_REFLECTION ) ; events . ScheduleEvent ( EVENT_SPELL_REFLECTION , 30000 ) ; break ; case EVENT_CRYSTAL_SPIKES : Talk ( SAY_CRYSTAL_SPIKES ) ; DoCast ( SPELL_CRYSTAL_SPIKES ) ; events . ScheduleEvent ( EVENT_CRYSTAL_SPIKES , 12000 ) ; break ; case EVENT_CRYSTALLINE_TANGLER : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , OrmorokTanglerPredicate ( me ) ) ) DoCast ( target , SPELL_SUMMON_CRYSTALLINE_TANGLER ) ; events . ScheduleEvent ( EVENT_CRYSTALLINE_TANGLER , 17000 ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } private : bool frenzy ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetInstanceAI < boss_ormorokAI > ( creature ) ; } } ; enum CrystalSpikes { NPC_CRYSTAL_SPIKE_INITIAL = 27101 , NPC_CRYSTAL_SPIKE_TRIGGER = 27079 , DATA_COUNT = 1 , MAX_COUNT = 5 , SPELL_CRYSTAL_SPIKE_DAMAGE = 47944 , GO_CRYSTAL_SPIKE_TRAP = 188537 , } ; uint32 const crystalSpikeSummon [ 3 ] = { 47936 , 47942 , 47943 } ; class npc_crystal_spike_trigger : public CreatureScript { public : npc_crystal_spike_trigger ( ) : CreatureScript ( " npc _ crystal _ spike _ trigger " ) { } struct npc_crystal_spike_triggerAI : public ScriptedAI { npc_crystal_spike_triggerAI ( Creature * creature ) : ScriptedAI ( creature ) { _count = 0 ; _despawntimer = 0 ; } void IsSummonedBy ( Unit * owner ) override { switch ( me -> GetEntry ( ) ) { case NPC_CRYSTAL_SPIKE_INITIAL : _count = 0 ; me -> SetFacingToObject ( owner ) ; break ; case NPC_CRYSTAL_SPIKE_TRIGGER : if ( Creature * trigger = owner -> ToCreature ( ) ) _count = trigger -> AI ( ) -> GetData ( DATA_COUNT ) + 1 ; break ; default : _count = MAX_COUNT ; break ; } if ( me -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( GameObject * trap = me -> FindNearestGameObject ( GO_CRYSTAL_SPIKE_TRAP , 1.0f ) ) trap -> Use ( me ) ; _despawntimer = 2000 ; } uint32 GetData ( uint32 type ) const override { return type == DATA_COUNT ? _count : 0 ; } void UpdateAI ( uint32 diff ) override { if ( _despawntimer <= diff ) { if ( me -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( GameObject * trap = me -> FindNearestGameObject ( GO_CRYSTAL_SPIKE_TRAP , 1.0f ) ) trap -> Delete ( ) ; me -> DespawnOrUnsummon ( ) ; } else _despawntimer -= diff ; } private : uint32 _count ; uint32 _despawntimer ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return new npc_crystal_spike_triggerAI ( creature ) ; } } ; class spell_crystal_spike : public SpellScriptLoader { public : spell_crystal_spike ( ) : SpellScriptLoader ( " spell _ crystal _ spike " ) { } class spell_crystal_spike_AuraScript : public AuraScript { PrepareAuraScript ( spell_crystal_spike_AuraScript ) ; void HandlePeriodic ( AuraEffect const * /* aurEff */ ) { Unit * target = GetTarget ( ) ; if ( target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_INITIAL || target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( Creature * trigger = target -> ToCreature ( ) ) { uint32 spell = target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_INITIAL ? crystalSpikeSummon [ 0 ] : crystalSpikeSummon [ urand ( 0 , 2 ) ] ; if ( trigger -> AI ( ) -> GetData ( DATA_COUNT ) < MAX_COUNT ) trigger -> CastSpell ( trigger , spell , true ) ; } } void Register ( ) override { OnEffectPeriodic += AuraEffectPeriodicFn ( spell_crystal_spike_AuraScript :: HandlePeriodic , EFFECT_0 , SPELL_AURA_PERIODIC_DUMMY ) ; } } ; AuraScript * GetAuraScript ( ) const override { return new spell_crystal_spike_AuraScript ( ) ; } } ; void AddSC_boss_ormorok ( ) { new boss_ormorok ( ) ; new npc_crystal_spike_trigger ( ) ; new spell_crystal_spike ( ) ; } </DOCUMENT>
<DOCUMENT_ID="ellipsis14/dolfin/tree/master/test/unit/la/cpp/Vector.cpp"> // ▁ Copyright ▁ ( C ) ▁ 2007 ▁ Johan ▁ Hake ENDCOM // ▁ This ▁ file ▁ is ▁ part ▁ of ▁ DOLFIN . ENDCOM // ▁ DOLFIN ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM // ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ENDCOM // ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or ENDCOM // ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM // ▁ DOLFIN ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM // ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM // ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM // ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM // ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ENDCOM // ▁ along ▁ with ▁ DOLFIN . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . ENDCOM // ▁ First ▁ added : ▁ 2008-09-30 ENDCOM // ▁ Last ▁ changed : ▁ 2012-08-21 ENDCOM // ▁ Unit ▁ tests ▁ Selected ▁ methods ▁ for ▁ GenericVector ENDCOM # include < dolfin . h > # include < dolfin / common / unittest . h > using namespace dolfin ; class TestVector : public CppUnit :: TestFixture { CPPUNIT_TEST_SUITE ( TestVector ) ; CPPUNIT_TEST ( test_backends ) ; CPPUNIT_TEST ( test_init ) ; CPPUNIT_TEST ( test_get_local_empty ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void test_backends ( ) { // ▁ Eigen ENDCOM parameters [ " linear _ algebra _ backend " ] = " Eigen " ; _test_operators ( MPI_COMM_SELF ) ; // ▁ FIXME : ▁ Outcommented ▁ STL ▁ backend ▁ to ▁ circumvent ▁ infinite ▁ loops ▁ as ENDCOM // ▁ FIXME : ▁ seen ▁ on ▁ one ▁ buildbot ENDCOM // ▁ STL ENDCOM // parameters [ " linear _ algebra _ backend " ] ▁ = ▁ " STL " ; ENDCOM // _ test _ operators ( ) ; ENDCOM // ▁ PETSc ENDCOM # ifdef HAS_PETSC parameters [ " linear _ algebra _ backend " ] = " PETSc " ; _test_operators ( MPI_COMM_WORLD ) ; # endif } void _test_operators ( MPI_Comm comm ) { Vector v ( comm , 10 ) , u ( comm , 10 ) ; v = 0.0 ; u = 0.0 ; CPPUNIT_ASSERT ( v . sum ( ) == 0.0 ) ; // ▁ operator = ( double ▁ a ) ENDCOM v = 1.0 ; CPPUNIT_ASSERT ( v . sum ( ) == v . size ( ) ) ; // ▁ operator = ( const ▁ GenericVector & ▁ x ) ENDCOM u = v ; CPPUNIT_ASSERT ( u . sum ( ) == u . size ( ) ) ; // ▁ operator + = ( const ▁ GenericVector & ▁ x ) ENDCOM u += v ; CPPUNIT_ASSERT ( u . sum ( ) == 2 * u . size ( ) ) ; // ▁ operator - = ( const ▁ GenericVector & ▁ x ) ENDCOM u -= v ; u -= v ; CPPUNIT_ASSERT ( u . sum ( ) == 0.0 ) ; // ▁ operator * = ( double ▁ a ) ENDCOM v *= 5.0 ; CPPUNIT_ASSERT ( v . sum ( ) == v . size ( ) * 5.0 ) ; // ▁ operator / = ( double ▁ a ) ENDCOM v /= 2.0 ; CPPUNIT_ASSERT ( v . sum ( ) == 2.5 * v . size ( ) ) ; // ▁ operator * = ( const ▁ GenericVector & ▁ x ) ENDCOM u = 2.0 ; v *= u ; CPPUNIT_ASSERT ( v . sum ( ) == v . size ( ) * 5.0 ) ; } void test_init ( ) { // ▁ Create ▁ local ▁ and ▁ distributed ▁ vector ▁ layouts ENDCOM const std :: vector < std :: size_t > dims ( 1 , 203 ) ; // ▁ Create ▁ local ▁ vector ▁ layout ENDCOM TensorLayout layout_local ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > local_range ( 1 , std :: make_pair ( 0 , 203 ) ) ; layout_local . init ( MPI_COMM_SELF , dims , 1 , local_range ) ; // ▁ Create ▁ distributed ▁ vector ▁ layout ENDCOM TensorLayout layout_distributed ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > ownership_range ( 1 , dolfin :: MPI :: local_range ( MPI_COMM_WORLD , 203 ) ) ; layout_distributed . init ( MPI_COMM_WORLD , dims , 1 , ownership_range ) ; // ▁ Vector ENDCOM # ifdef HAS_PETSC parameters [ " linear _ algebra _ backend " ] = " PETSc " ; { Vector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; Vector y ; y . init ( layout_distributed ) ; CPPUNIT_ASSERT ( y . size ( ) == 203 ) ; } # endif // ▁ Eigen ENDCOM { EigenVector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; } // ▁ PETSc ENDCOM # ifdef HAS_PETSC { PETScVector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; PETScVector y ; y . init ( layout_distributed ) ; CPPUNIT_ASSERT ( y . size ( ) == 203 ) ; } # endif } void test_get_local_empty ( ) { // ▁ Create ▁ local ▁ and ▁ distributed ▁ vector ▁ layouts ENDCOM const std :: vector < std :: size_t > dims ( 1 , 203 ) ; // ▁ Create ▁ local ▁ vector ▁ layout ENDCOM TensorLayout layout_local ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > local_range ( 1 , std :: make_pair ( 0 , 203 ) ) ; layout_local . init ( MPI_COMM_SELF , dims , 1 , local_range ) ; // ▁ Create ▁ distributed ▁ vector ▁ layout ENDCOM TensorLayout layout_distributed ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > ownership_range ( 1 , dolfin :: MPI :: local_range ( MPI_COMM_WORLD , 203 ) ) ; layout_distributed . init ( MPI_COMM_WORLD , dims , 1 , ownership_range ) ; // ▁ Vector ENDCOM # ifdef HAS_PETSC parameters [ " linear _ algebra _ backend " ] = " PETSc " ; { Vector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; Vector y ; y . init ( layout_distributed ) ; CPPUNIT_ASSERT ( y . size ( ) == 203 ) ; // : get _ local ( double * ▁ block , ▁ std : : size _ t ▁ m , ENDCOM // ▁ const ▁ dolfin : : la _ index * ▁ rows ) ▁ const ENDCOM double * block = NULL ; dolfin :: la_index * rows = NULL ; x . get_local ( block , 0 , rows ) ; y . get_local ( block , 0 , rows ) ; } # endif } } ; CPPUNIT_TEST_SUITE_REGISTRATION ( TestVector ) ; int main ( ) { DOLFIN_TEST ; } </DOCUMENT>
<DOCUMENT_ID="doorxp/ccjson/tree/master/cocos2d/cocos/audio/android/AudioResampler.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2007 ▁ The ▁ Android ▁ Open ▁ Source ▁ Project STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ # define LOG_TAG " AudioResampler " // # define ▁ LOG _ NDEBUG ▁ 0 ENDCOM # include < stdint . h > # include < stdlib . h > # include < sys / types . h > # include < pthread . h > # include < new > # include " audio / android / cutils / log . h " # include " audio / android / utils / Utils . h " // # include ▁ < cutils / properties . h > ENDCOM # include " audio / android / audio _ utils / include / audio _ utils / primitives . h " # include " audio / android / AudioResampler . h " // # include ▁ " audio / android / AudioResamplerSinc . h " ENDCOM # include " audio / android / AudioResamplerCubic . h " // # include ▁ " AudioResamplerDyn . h " ENDCOM // cjh ▁ # ifdef ▁ _ _ arm _ _ ENDCOM // ▁ # define ▁ ASM _ ARM _ RESAMP1 ▁ // ▁ enable ▁ asm ▁ optimisation ▁ for ▁ ResamplerOrder1 ENDCOM // # endif ENDCOM namespace cocos2d { namespace experimental { class AudioResamplerOrder1 : public AudioResampler { public : AudioResamplerOrder1 ( int inChannelCount , int32_t sampleRate ) : AudioResampler ( inChannelCount , sampleRate , LOW_QUALITY ) , mX0L ( 0 ) , mX0R ( 0 ) { } virtual size_t resample ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; private : // ▁ number ▁ of ▁ bits ▁ used ▁ in ▁ interpolation ▁ multiply ▁ - ▁ 15 ▁ bits ▁ avoids ▁ overflow ENDCOM static const int kNumInterpBits = 15 ; // ▁ bits ▁ to ▁ shift ▁ the ▁ phase ▁ fraction ▁ down ▁ to ▁ avoid ▁ overflow ENDCOM static const int kPreInterpShift = kNumPhaseBits - kNumInterpBits ; void init ( ) { } size_t resampleMono16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; size_t resampleStereo16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; # ifdef ASM_ARM_RESAMP1 // ▁ asm ▁ optimisation ▁ for ▁ ResamplerOrder1 ENDCOM void AsmMono16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) ; void AsmStereo16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) ; # endif // ▁ ASM _ ARM _ RESAMP1 ENDCOM static inline int32_t Interp ( int32_t x0 , int32_t x1 , uint32_t f ) { return x0 + ( ( ( x1 - x0 ) * ( int32_t ) ( f >> kPreInterpShift ) ) >> kNumInterpBits ) ; } static inline void Advance ( size_t * index , uint32_t * frac , uint32_t inc ) { * frac += inc ; * index += ( size_t ) ( * frac >> kNumPhaseBits ) ; * frac &= kPhaseMask ; } int mX0L ; int mX0R ; } ; /* static */ const double AudioResampler :: kPhaseMultiplier = 1L << AudioResampler :: kNumPhaseBits ; bool AudioResampler :: qualityIsSupported ( src_quality quality ) { switch ( quality ) { case DEFAULT_QUALITY : case LOW_QUALITY : case MED_QUALITY : case HIGH_QUALITY : case VERY_HIGH_QUALITY : return true ; default : return false ; } } static pthread_once_t once_control = PTHREAD_ONCE_INIT ; static AudioResampler :: src_quality defaultQuality = AudioResampler :: DEFAULT_QUALITY ; void AudioResampler :: init_routine ( ) { // ▁ int ▁ resamplerQuality ▁ = ▁ getSystemProperty ( " af . resampler . quality " ) ; ENDCOM // ▁ if ▁ ( resamplerQuality ▁ > ▁ 0 ) ▁ { ENDCOM // ▁ defaultQuality ▁ = ▁ ( src _ quality ) ▁ resamplerQuality ; ENDCOM // ▁ ALOGD ( " forcing ▁ AudioResampler ▁ quality ▁ to ▁ % d " , ▁ defaultQuality ) ; ENDCOM // ▁ if ▁ ( defaultQuality ▁ < ▁ DEFAULT _ QUALITY ▁ | | ▁ defaultQuality ▁ > ▁ VERY _ HIGH _ QUALITY ) ▁ { ENDCOM // ▁ defaultQuality ▁ = ▁ DEFAULT _ QUALITY ; ENDCOM } uint32_t AudioResampler :: qualityMHz ( src_quality quality ) { switch ( quality ) { default : case DEFAULT_QUALITY : case LOW_QUALITY : return 3 ; case MED_QUALITY : return 6 ; case HIGH_QUALITY : return 20 ; case VERY_HIGH_QUALITY : return 34 ; // ▁ case ▁ DYN _ LOW _ QUALITY : ENDCOM // ▁ return ▁ 4 ; ENDCOM // ▁ case ▁ DYN _ MED _ QUALITY : ENDCOM // ▁ return ▁ 6 ; ENDCOM // ▁ case ▁ DYN _ HIGH _ QUALITY : ENDCOM // ▁ return ▁ 12 ; ENDCOM } } static const uint32_t maxMHz = 130 ; // ▁ an ▁ arbitrary ▁ number ▁ that ▁ permits ▁ 3 ▁ VHQ , ▁ should ▁ be ▁ tunable ENDCOM static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER ; static uint32_t currentMHz = 0 ; AudioResampler * AudioResampler :: create ( audio_format_t format , int inChannelCount , int32_t sampleRate , src_quality quality ) { bool atFinalQuality ; if ( quality == DEFAULT_QUALITY ) { // ▁ read ▁ the ▁ resampler ▁ default ▁ quality ▁ property ▁ the ▁ first ▁ time ▁ it ▁ is ▁ needed ENDCOM int ok = pthread_once ( & once_control , init_routine ) ; if ( ok != 0 ) { ALOGE ( " % s ▁ pthread _ once ▁ failed : ▁ % d " , __func__ , ok ) ; } quality = defaultQuality ; atFinalQuality = false ; } else { atFinalQuality = true ; } /* ▁ if ▁ the ▁ caller ▁ requests ▁ DEFAULT _ QUALITY ▁ and ▁ af . resampler . property STRNEWLINE ▁ * ▁ has ▁ not ▁ been ▁ set , ▁ the ▁ target ▁ resampler ▁ quality ▁ is ▁ set ▁ to ▁ DYN _ MED _ QUALITY , STRNEWLINE ▁ * ▁ and ▁ allowed ▁ to ▁ " throttle " ▁ down ▁ to ▁ DYN _ LOW _ QUALITY ▁ if ▁ necessary STRNEWLINE ▁ * ▁ due ▁ to ▁ estimated ▁ CPU ▁ load ▁ of ▁ having ▁ too ▁ many ▁ active ▁ resamplers STRNEWLINE ▁ * ▁ ( the ▁ code ▁ below ▁ the ▁ if ) . STRNEWLINE ▁ */ if ( quality == DEFAULT_QUALITY ) { // cjh ▁ quality ▁ = ▁ DYN _ MED _ QUALITY ; ENDCOM } // ▁ naive ▁ implementation ▁ of ▁ CPU ▁ load ▁ throttling ▁ doesn ' t ▁ account ▁ for ▁ whether ▁ resampler ▁ is ▁ active ENDCOM pthread_mutex_lock ( & mutex ) ; for ( ; ; ) { uint32_t deltaMHz = qualityMHz ( quality ) ; uint32_t newMHz = currentMHz + deltaMHz ; if ( ( qualityIsSupported ( quality ) && newMHz <= maxMHz ) || atFinalQuality ) { ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % u ▁ MHz ▁ due ▁ to ▁ delta ▁ + % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; currentMHz = newMHz ; break ; } // ▁ not ▁ enough ▁ CPU ▁ available ▁ for ▁ proposed ▁ quality ▁ level , ▁ so ▁ try ▁ next ▁ lowest ▁ level ENDCOM switch ( quality ) { default : case LOW_QUALITY : atFinalQuality = true ; break ; case MED_QUALITY : quality = LOW_QUALITY ; break ; case HIGH_QUALITY : quality = MED_QUALITY ; break ; case VERY_HIGH_QUALITY : quality = HIGH_QUALITY ; break ; // ▁ case ▁ DYN _ LOW _ QUALITY : ENDCOM // ▁ atFinalQuality ▁ = ▁ true ; ENDCOM // ▁ break ; ENDCOM // ▁ case ▁ DYN _ MED _ QUALITY : ENDCOM // ▁ quality ▁ = ▁ DYN _ LOW _ QUALITY ; ENDCOM // ▁ break ; ENDCOM // ▁ case ▁ DYN _ HIGH _ QUALITY : ENDCOM // ▁ quality ▁ = ▁ DYN _ MED _ QUALITY ; ENDCOM // ▁ break ; ENDCOM } } pthread_mutex_unlock ( & mutex ) ; AudioResampler * resampler ; switch ( quality ) { default : case LOW_QUALITY : ALOGV ( " Create ▁ linear ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerOrder1 ( inChannelCount , sampleRate ) ; break ; case MED_QUALITY : ALOGV ( " Create ▁ cubic ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerCubic ( inChannelCount , sampleRate ) ; break ; case HIGH_QUALITY : ALOGV ( " Create ▁ HIGH _ QUALITY ▁ sinc ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; ALOG_ASSERT ( false , " HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; // ▁ Cocos2d - x ▁ only ▁ uses ▁ MED _ QUALITY , ▁ so ▁ we ▁ could ▁ remove ▁ Sinc ▁ relative ▁ files ENDCOM // ▁ resampler ▁ = ▁ new ▁ ( std : : nothrow ) ▁ AudioResamplerSinc ( inChannelCount , ▁ sampleRate ) ; ENDCOM break ; case VERY_HIGH_QUALITY : ALOGV ( " Create ▁ VERY _ HIGH _ QUALITY ▁ sinc ▁ Resampler ▁ = ▁ % d " , quality ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; // ▁ Cocos2d - x ▁ only ▁ uses ▁ MED _ QUALITY , ▁ so ▁ we ▁ could ▁ remove ▁ Sinc ▁ relative ▁ files ENDCOM // ▁ resampler ▁ = ▁ new ▁ ( std : : nothrow ) ▁ AudioResamplerSinc ( inChannelCount , ▁ sampleRate , ▁ quality ) ; ENDCOM ALOG_ASSERT ( false , " VERY _ HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; break ; } // ▁ initialize ▁ resampler ENDCOM resampler -> init ( ) ; return resampler ; } AudioResampler :: AudioResampler ( int inChannelCount , int32_t sampleRate , src_quality quality ) : mChannelCount ( inChannelCount ) , mSampleRate ( sampleRate ) , mInSampleRate ( sampleRate ) , mInputIndex ( 0 ) , mPhaseFraction ( 0 ) , mLocalTimeFreq ( 0 ) , mPTS ( AudioBufferProvider :: kInvalidPTS ) , mQuality ( quality ) { const int maxChannels = 2 ; // cjh ▁ quality ▁ < ▁ DYN _ LOW _ QUALITY ▁ ? ▁ 2 ▁ : ▁ 8 ; ENDCOM if ( inChannelCount < 1 || inChannelCount > maxChannels ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ format ▁ % d ▁ quality ▁ % d ▁ channels " , quality , inChannelCount ) ; } if ( sampleRate <= 0 ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ rate ▁ % d ▁ Hz " , sampleRate ) ; } // ▁ initialize ▁ common ▁ members ENDCOM mVolume [ 0 ] = mVolume [ 1 ] = 0 ; mBuffer . frameCount = 0 ; } AudioResampler :: ~ AudioResampler ( ) { pthread_mutex_lock ( & mutex ) ; src_quality quality = getQuality ( ) ; uint32_t deltaMHz = qualityMHz ( quality ) ; int32_t newMHz = currentMHz - deltaMHz ; ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % d ▁ MHz ▁ due ▁ to ▁ delta ▁ - % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; LOG_ALWAYS_FATAL_IF ( newMHz < 0 , " negative ▁ resampler ▁ load ▁ % d ▁ MHz " , newMHz ) ; currentMHz = newMHz ; pthread_mutex_unlock ( & mutex ) ; } void AudioResampler :: setSampleRate ( int32_t inSampleRate ) { mInSampleRate = inSampleRate ; mPhaseIncrement = ( uint32_t ) ( ( kPhaseMultiplier * inSampleRate ) / mSampleRate ) ; } void AudioResampler :: setVolume ( float left , float right ) { // ▁ TODO : ▁ Implement ▁ anti - zipper ▁ filter ENDCOM // ▁ convert ▁ to ▁ U4.12 ▁ for ▁ internal ▁ integer ▁ use ▁ ( round ▁ down ) ENDCOM // ▁ integer ▁ volume ▁ values ▁ are ▁ clamped ▁ to ▁ 0 ▁ to ▁ UNITY _ GAIN . ENDCOM mVolume [ 0 ] = u4_12_from_float ( clampFloatVol ( left ) ) ; mVolume [ 1 ] = u4_12_from_float ( clampFloatVol ( right ) ) ; } void AudioResampler :: setLocalTimeFreq ( uint64_t freq ) { mLocalTimeFreq = freq ; } void AudioResampler :: setPTS ( int64_t pts ) { mPTS = pts ; } int64_t AudioResampler :: calculateOutputPTS ( int outputFrameIndex ) { if ( mPTS == AudioBufferProvider :: kInvalidPTS ) { return AudioBufferProvider :: kInvalidPTS ; } else { return mPTS + ( ( outputFrameIndex * mLocalTimeFreq ) / mSampleRate ) ; } } void AudioResampler :: reset ( ) { mInputIndex = 0 ; mPhaseFraction = 0 ; mBuffer . frameCount = 0 ; } size_t AudioResamplerOrder1 :: resample ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { // ▁ should ▁ never ▁ happen , ▁ but ▁ we ▁ overflow ▁ if ▁ it ▁ does ENDCOM // ▁ ALOG _ ASSERT ( outFrameCount ▁ < ▁ 32767 ) ; ENDCOM // ▁ select ▁ the ▁ appropriate ▁ resampler ENDCOM switch ( mChannelCount ) { case 1 : return resampleMono16 ( out , outFrameCount , provider ) ; case 2 : return resampleStereo16 ( out , outFrameCount , provider ) ; default : LOG_ALWAYS_FATAL ( " invalid ▁ channel ▁ count : ▁ % d " , mChannelCount ) ; return 0 ; } } size_t AudioResamplerOrder1 :: resampleStereo16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; // ▁ ALOGE ( " starting ▁ resample ▁ % d ▁ frames , ▁ inputIndex = % d , ▁ phaseFraction = % d , ▁ phaseIncrement = % d " , ENDCOM // ▁ outFrameCount , ▁ inputIndex , ▁ phaseFraction , ▁ phaseIncrement ) ; ENDCOM while ( outputIndex < outputSampleCount ) { // ▁ buffer ▁ is ▁ empty , ▁ fetch ▁ a ▁ new ▁ one ENDCOM while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { goto resampleStereo16_exit ; } // ▁ ALOGE ( " New ▁ buffer ▁ fetched : ▁ % d ▁ frames " , ▁ mBuffer . frameCount ) ; ENDCOM if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; // ▁ mBuffer . frameCount ▁ = = ▁ 0 ▁ now ▁ so ▁ we ▁ reload ▁ a ▁ new ▁ buffer ENDCOM } int16_t * in = mBuffer . i16 ; // ▁ handle ▁ boundary ▁ case ENDCOM while ( inputIndex == 0 ) { // ▁ ALOGE ( " boundary ▁ case " ) ; ENDCOM out [ outputIndex ++ ] += vl * Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( mX0R , in [ 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } // ▁ process ▁ input ▁ samples ENDCOM // ▁ ALOGE ( " general ▁ case " ) ; ENDCOM # ifdef ASM_ARM_RESAMP1 // ▁ asm ▁ optimisation ▁ for ▁ ResamplerOrder1 ENDCOM if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; // ▁ 2 ▁ because ▁ 2 ▁ frames ▁ per ▁ loop ENDCOM maxInIdx = mBuffer . frameCount - 2 ; AsmStereo16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } # endif // ▁ ASM _ ARM _ RESAMP1 ENDCOM while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { out [ outputIndex ++ ] += vl * Interp ( in [ inputIndex * 2 - 2 ] , in [ inputIndex * 2 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( in [ inputIndex * 2 - 1 ] , in [ inputIndex * 2 + 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } // ▁ ALOGE ( " loop ▁ done ▁ - ▁ outputIndex = % d , ▁ inputIndex = % d " , ▁ outputIndex , ▁ inputIndex ) ; ENDCOM // ▁ if ▁ done ▁ with ▁ buffer , ▁ save ▁ samples ENDCOM if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; // ▁ ALOGE ( " buffer ▁ done , ▁ new ▁ input ▁ index ▁ % d " , ▁ inputIndex ) ; ENDCOM mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; // ▁ verify ▁ that ▁ the ▁ releaseBuffer ▁ resets ▁ the ▁ buffer ▁ frameCount ENDCOM // ▁ ALOG _ ASSERT ( mBuffer . frameCount ▁ = = ▁ 0 ) ; ENDCOM } } // ▁ ALOGE ( " output ▁ buffer ▁ full ▁ - ▁ outputIndex = % d , ▁ inputIndex = % d " , ▁ outputIndex , ▁ inputIndex ) ; ENDCOM resampleStereo16_exit : // ▁ save ▁ state ENDCOM mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex / 2 /* ▁ channels ▁ for ▁ stereo ▁ */ ; } size_t AudioResamplerOrder1 :: resampleMono16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; // ▁ ALOGE ( " starting ▁ resample ▁ % d ▁ frames , ▁ inputIndex = % d , ▁ phaseFraction = % d , ▁ phaseIncrement = % d " , ENDCOM // ▁ outFrameCount , ▁ inputIndex , ▁ phaseFraction , ▁ phaseIncrement ) ; ENDCOM while ( outputIndex < outputSampleCount ) { // ▁ buffer ▁ is ▁ empty , ▁ fetch ▁ a ▁ new ▁ one ENDCOM while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; goto resampleMono16_exit ; } // ▁ ALOGE ( " New ▁ buffer ▁ fetched : ▁ % d ▁ frames " , ▁ mBuffer . frameCount ) ; ENDCOM if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; // ▁ mBuffer . frameCount ▁ = = ▁ 0 ▁ now ▁ so ▁ we ▁ reload ▁ a ▁ new ▁ buffer ENDCOM } int16_t * in = mBuffer . i16 ; // ▁ handle ▁ boundary ▁ case ENDCOM while ( inputIndex == 0 ) { // ▁ ALOGE ( " boundary ▁ case " ) ; ENDCOM int32_t sample = Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } // ▁ process ▁ input ▁ samples ENDCOM // ▁ ALOGE ( " general ▁ case " ) ; ENDCOM # ifdef ASM_ARM_RESAMP1 // ▁ asm ▁ optimisation ▁ for ▁ ResamplerOrder1 ENDCOM if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; maxInIdx = ( int32_t ) mBuffer . frameCount - 2 ; AsmMono16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } # endif // ▁ ASM _ ARM _ RESAMP1 ENDCOM while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { int32_t sample = Interp ( in [ inputIndex - 1 ] , in [ inputIndex ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } // ▁ ALOGE ( " loop ▁ done ▁ - ▁ outputIndex = % d , ▁ inputIndex = % d " , ▁ outputIndex , ▁ inputIndex ) ; ENDCOM // ▁ if ▁ done ▁ with ▁ buffer , ▁ save ▁ samples ENDCOM if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; // ▁ ALOGE ( " buffer ▁ done , ▁ new ▁ input ▁ index ▁ % d " , ▁ inputIndex ) ; ENDCOM mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; // ▁ verify ▁ that ▁ the ▁ releaseBuffer ▁ resets ▁ the ▁ buffer ▁ frameCount ENDCOM // ▁ ALOG _ ASSERT ( mBuffer . frameCount ▁ = = ▁ 0 ) ; ENDCOM } } // ▁ ALOGE ( " output ▁ buffer ▁ full ▁ - ▁ outputIndex = % d , ▁ inputIndex = % d " , ▁ outputIndex , ▁ inputIndex ) ; ENDCOM resampleMono16_exit : // ▁ save ▁ state ENDCOM mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex ; } # ifdef ASM_ARM_RESAMP1 // ▁ asm ▁ optimisation ▁ for ▁ ResamplerOrder1 ENDCOM /* * * * * STRNEWLINE * STRNEWLINE * ▁ AsmMono16Loop STRNEWLINE * ▁ asm ▁ optimized ▁ monotonic ▁ loop ▁ version ; ▁ one ▁ loop ▁ is ▁ 2 ▁ frames STRNEWLINE * ▁ Input : STRNEWLINE * ▁ in ▁ : ▁ pointer ▁ on ▁ input ▁ samples STRNEWLINE * ▁ maxOutPt ▁ : ▁ pointer ▁ on ▁ first ▁ not ▁ filled STRNEWLINE * ▁ maxInIdx ▁ : ▁ index ▁ on ▁ first ▁ not ▁ used STRNEWLINE * ▁ outputIndex ▁ : ▁ pointer ▁ on ▁ current ▁ output ▁ index STRNEWLINE * ▁ out ▁ : ▁ pointer ▁ on ▁ output ▁ buffer STRNEWLINE * ▁ inputIndex ▁ : ▁ pointer ▁ on ▁ current ▁ input ▁ index STRNEWLINE * ▁ vl , ▁ vr ▁ : ▁ left ▁ and ▁ right ▁ gain STRNEWLINE * ▁ phaseFraction ▁ : ▁ pointer ▁ on ▁ current ▁ phase ▁ fraction STRNEWLINE * ▁ phaseIncrement STRNEWLINE * ▁ Output : STRNEWLINE * ▁ outputIndex ▁ : STRNEWLINE * ▁ out ▁ : ▁ updated ▁ buffer STRNEWLINE * ▁ inputIndex ▁ : ▁ index ▁ of ▁ next ▁ to ▁ use STRNEWLINE * ▁ phaseFraction ▁ : ▁ phase ▁ fraction ▁ for ▁ next ▁ interpolation STRNEWLINE * STRNEWLINE * * * * */ __attribute__ ( ( noinline ) ) void AudioResamplerOrder1 :: AsmMono16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) { ( void ) maxOutPt ; // ▁ remove ▁ unused ▁ parameter ▁ warnings ENDCOM ( void ) maxInIdx ; ( void ) outputIndex ; ( void ) out ; ( void ) inputIndex ; ( void ) vl ; ( void ) vr ; ( void ) phaseFraction ; ( void ) phaseIncrement ; ( void ) in ; # define MO_PARAM5 "36" // ▁ offset ▁ of ▁ parameter ▁ 5 ▁ ( outputIndex ) ENDCOM asm ( " stmfd ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ lr } \n " // ▁ get ▁ parameters ENDCOM " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 20 ] \n " // ▁ & phaseFraction ENDCOM " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ r6 ] \n " // ▁ phaseFraction ENDCOM " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 8 ] \n " // ▁ & inputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ r7 ] \n " // ▁ inputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r8 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 4 ] \n " // ▁ out ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 0 ] \n " // ▁ & outputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ r0 ] \n " // ▁ outputIndex ENDCOM " ▁ ▁ ▁ add ▁ r8 , ▁ r8 , ▁ r0 , ▁ asl ▁ # 2 \n " // ▁ curOut ENDCOM " ▁ ▁ ▁ ldr ▁ r9 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 24 ] \n " // ▁ phaseIncrement ENDCOM " ▁ ▁ ▁ ldr ▁ r10 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 12 ] \n " // ▁ vl ENDCOM " ▁ ▁ ▁ ldr ▁ r11 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 16 ] \n " // ▁ vr ENDCOM // ▁ r0 ▁ pin , ▁ x0 , ▁ Samp ENDCOM // ▁ r1 ▁ in ENDCOM // ▁ r2 ▁ maxOutPt ENDCOM // ▁ r3 ▁ maxInIdx ENDCOM // ▁ r4 ▁ x1 , ▁ i1 , ▁ i3 , ▁ Out1 ENDCOM // ▁ r5 ▁ out0 ENDCOM // ▁ r6 ▁ frac ENDCOM // ▁ r7 ▁ inputIndex ENDCOM // ▁ r8 ▁ curOut ENDCOM // ▁ r9 ▁ inc ENDCOM // ▁ r10 ▁ vl ENDCOM // ▁ r11 ▁ vr ENDCOM // ▁ r12 ENDCOM // ▁ r13 ▁ sp ENDCOM // ▁ r14 ENDCOM // ▁ the ▁ following ▁ loop ▁ works ▁ on ▁ 2 ▁ frames ENDCOM "1 : \n " " ▁ ▁ ▁ cmp ▁ r8 , ▁ r2 \n " // ▁ curOut ▁ - ▁ maxCurOut ENDCOM " ▁ ▁ ▁ bcs ▁ 2f \n " # define MO_ONE_FRAME " ▁ ▁ ▁ add ▁ r0 , ▁ r1 , ▁ r7 , ▁ asl ▁ # 1 \n " /* ▁ in ▁ + ▁ inputIndex ▁ */ " ▁ ▁ ▁ ldrsh ▁ r4 , ▁ [ r0 ] \n " /* ▁ in [ inputIndex ] ▁ */ " ▁ ▁ ▁ ldr ▁ r5 , ▁ [ r8 ] \n " /* ▁ out [ outputIndex ] ▁ */ " ▁ ▁ ▁ ldrsh ▁ r0 , ▁ [ r0 , ▁ # -2 ] \n " /* ▁ in [ inputIndex - 1 ] ▁ */ " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " /* ▁ phaseFraction ▁ & ▁ . . . ▁ */ " ▁ ▁ ▁ sub ▁ r4 , ▁ r4 , ▁ r0 \n " /* ▁ in [ inputIndex ] ▁ - ▁ in [ inputIndex - 1 ] ▁ */ " ▁ ▁ ▁ mov ▁ r4 , ▁ r4 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r4 , ▁ r4 , ▁ r6 \n " /* ▁ ( x1 - x0 ) * . . ▁ */ " ▁ ▁ ▁ add ▁ r6 , ▁ r6 , ▁ r9 \n " /* ▁ phaseFraction ▁ + ▁ phaseIncrement ▁ */ " ▁ ▁ ▁ add ▁ r0 , ▁ r0 , ▁ r4 \n " /* ▁ x0 ▁ - ▁ ( . . ) ▁ */ " ▁ ▁ ▁ mla ▁ r5 , ▁ r0 , ▁ r10 , ▁ r5 \n " /* ▁ vl * interp ▁ + ▁ out [ ] ▁ */ " ▁ ▁ ▁ ldr ▁ r4 , ▁ [ r8 , ▁ # 4 ] \n " /* ▁ out [ outputIndex + 1 ] ▁ */ " ▁ ▁ ▁ str ▁ r5 , ▁ [ r8 ] , ▁ # 4 \n " /* ▁ out [ outputIndex + + ] ▁ = ▁ . . . ▁ */ " ▁ ▁ ▁ mla ▁ r4 , ▁ r0 , ▁ r11 , ▁ r4 \n " /* ▁ vr * interp ▁ + ▁ out [ ] ▁ */ " ▁ ▁ ▁ add ▁ r7 , ▁ r7 , ▁ r6 , ▁ lsr ▁ # 30 \n " /* ▁ inputIndex ▁ + ▁ phaseFraction > > 30 ▁ */ " ▁ ▁ ▁ str ▁ r4 , ▁ [ r8 ] , ▁ # 4 \n " /* ▁ out [ outputIndex + + ] ▁ = ▁ . . . ▁ */ MO_ONE_FRAME // ▁ frame ▁ 1 ENDCOM MO_ONE_FRAME // ▁ frame ▁ 2 ENDCOM " ▁ ▁ ▁ cmp ▁ r7 , ▁ r3 \n " // ▁ inputIndex ▁ - ▁ maxInIdx ENDCOM " ▁ ▁ ▁ bcc ▁ 1b \n " "2 : \n " " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " // ▁ phaseFraction ▁ & ▁ . . . ENDCOM // ▁ save ▁ modified ▁ values ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 20 ] \n " // ▁ & phaseFraction ENDCOM " ▁ ▁ ▁ str ▁ r6 , ▁ [ r0 ] \n " // ▁ phaseFraction ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 8 ] \n " // ▁ & inputIndex ENDCOM " ▁ ▁ ▁ str ▁ r7 , ▁ [ r0 ] \n " // ▁ inputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 4 ] \n " // ▁ out ENDCOM " ▁ ▁ ▁ sub ▁ r8 , ▁ r0 \n " // ▁ curOut ▁ - ▁ out ENDCOM " ▁ ▁ ▁ asr ▁ r8 , ▁ # 2 \n " // ▁ new ▁ outputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 0 ] \n " // ▁ & outputIndex ENDCOM " ▁ ▁ ▁ str ▁ r8 , ▁ [ r0 ] \n " // ▁ save ▁ outputIndex ENDCOM " ▁ ▁ ▁ ldmfd ▁ ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ pc } \n " ) ; } /* * * * * STRNEWLINE * STRNEWLINE * ▁ AsmStereo16Loop STRNEWLINE * ▁ asm ▁ optimized ▁ stereo ▁ loop ▁ version ; ▁ one ▁ loop ▁ is ▁ 2 ▁ frames STRNEWLINE * ▁ Input : STRNEWLINE * ▁ in ▁ : ▁ pointer ▁ on ▁ input ▁ samples STRNEWLINE * ▁ maxOutPt ▁ : ▁ pointer ▁ on ▁ first ▁ not ▁ filled STRNEWLINE * ▁ maxInIdx ▁ : ▁ index ▁ on ▁ first ▁ not ▁ used STRNEWLINE * ▁ outputIndex ▁ : ▁ pointer ▁ on ▁ current ▁ output ▁ index STRNEWLINE * ▁ out ▁ : ▁ pointer ▁ on ▁ output ▁ buffer STRNEWLINE * ▁ inputIndex ▁ : ▁ pointer ▁ on ▁ current ▁ input ▁ index STRNEWLINE * ▁ vl , ▁ vr ▁ : ▁ left ▁ and ▁ right ▁ gain STRNEWLINE * ▁ phaseFraction ▁ : ▁ pointer ▁ on ▁ current ▁ phase ▁ fraction STRNEWLINE * ▁ phaseIncrement STRNEWLINE * ▁ Output : STRNEWLINE * ▁ outputIndex ▁ : STRNEWLINE * ▁ out ▁ : ▁ updated ▁ buffer STRNEWLINE * ▁ inputIndex ▁ : ▁ index ▁ of ▁ next ▁ to ▁ use STRNEWLINE * ▁ phaseFraction ▁ : ▁ phase ▁ fraction ▁ for ▁ next ▁ interpolation STRNEWLINE * STRNEWLINE * * * * */ __attribute__ ( ( noinline ) ) void AudioResamplerOrder1 :: AsmStereo16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) { ( void ) maxOutPt ; // ▁ remove ▁ unused ▁ parameter ▁ warnings ENDCOM ( void ) maxInIdx ; ( void ) outputIndex ; ( void ) out ; ( void ) inputIndex ; ( void ) vl ; ( void ) vr ; ( void ) phaseFraction ; ( void ) phaseIncrement ; ( void ) in ; # define ST_PARAM5 "40" // ▁ offset ▁ of ▁ parameter ▁ 5 ▁ ( outputIndex ) ENDCOM asm ( " stmfd ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ r12 , ▁ lr } \n " // ▁ get ▁ parameters ENDCOM " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 20 ] \n " // ▁ & phaseFraction ENDCOM " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ r6 ] \n " // ▁ phaseFraction ENDCOM " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 8 ] \n " // ▁ & inputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ r7 ] \n " // ▁ inputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r8 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 4 ] \n " // ▁ out ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 0 ] \n " // ▁ & outputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ r0 ] \n " // ▁ outputIndex ENDCOM " ▁ ▁ ▁ add ▁ r8 , ▁ r8 , ▁ r0 , ▁ asl ▁ # 2 \n " // ▁ curOut ENDCOM " ▁ ▁ ▁ ldr ▁ r9 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 24 ] \n " // ▁ phaseIncrement ENDCOM " ▁ ▁ ▁ ldr ▁ r10 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 12 ] \n " // ▁ vl ENDCOM " ▁ ▁ ▁ ldr ▁ r11 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 16 ] \n " // ▁ vr ENDCOM // ▁ r0 ▁ pin , ▁ x0 , ▁ Samp ENDCOM // ▁ r1 ▁ in ENDCOM // ▁ r2 ▁ maxOutPt ENDCOM // ▁ r3 ▁ maxInIdx ENDCOM // ▁ r4 ▁ x1 , ▁ i1 , ▁ i3 , ▁ out1 ENDCOM // ▁ r5 ▁ out0 ENDCOM // ▁ r6 ▁ frac ENDCOM // ▁ r7 ▁ inputIndex ENDCOM // ▁ r8 ▁ curOut ENDCOM // ▁ r9 ▁ inc ENDCOM // ▁ r10 ▁ vl ENDCOM // ▁ r11 ▁ vr ENDCOM // ▁ r12 ▁ temporary ENDCOM // ▁ r13 ▁ sp ENDCOM // ▁ r14 ENDCOM "3 : \n " " ▁ ▁ ▁ cmp ▁ r8 , ▁ r2 \n " // ▁ curOut ▁ - ▁ maxCurOut ENDCOM " ▁ ▁ ▁ bcs ▁ 4f \n " # define ST_ONE_FRAME " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " /* ▁ phaseFraction ▁ & ▁ . . . ▁ */ " ▁ ▁ ▁ add ▁ r0 , ▁ r1 , ▁ r7 , ▁ asl ▁ # 2 \n " /* ▁ in ▁ + ▁ 2 * inputIndex ▁ */ " ▁ ▁ ▁ ldrsh ▁ r4 , ▁ [ r0 ] \n " /* ▁ in [ 2 * inputIndex ] ▁ */ " ▁ ▁ ▁ ldr ▁ r5 , ▁ [ r8 ] \n " /* ▁ out [ outputIndex ] ▁ */ " ▁ ▁ ▁ ldrsh ▁ r12 , ▁ [ r0 , ▁ # -4 ] \n " /* ▁ in [ 2 * inputIndex - 2 ] ▁ */ " ▁ ▁ ▁ sub ▁ r4 , ▁ r4 , ▁ r12 \n " /* ▁ in [ 2 * InputIndex ] ▁ - ▁ in [ 2 * InputIndex - 2 ] ▁ */ " ▁ ▁ ▁ mov ▁ r4 , ▁ r4 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r4 , ▁ r4 , ▁ r6 \n " /* ▁ ( x1 - x0 ) * . . ▁ */ " ▁ ▁ ▁ add ▁ r12 , ▁ r12 , ▁ r4 \n " /* ▁ x0 ▁ - ▁ ( . . ) ▁ */ " ▁ ▁ ▁ mla ▁ r5 , ▁ r12 , ▁ r10 , ▁ r5 \n " /* ▁ vl * interp ▁ + ▁ out [ ] ▁ */ " ▁ ▁ ▁ ldr ▁ r4 , ▁ [ r8 , ▁ # 4 ] \n " /* ▁ out [ outputIndex + 1 ] ▁ */ " ▁ ▁ ▁ str ▁ r5 , ▁ [ r8 ] , ▁ # 4 \n " /* ▁ out [ outputIndex + + ] ▁ = ▁ . . . ▁ */ " ▁ ▁ ▁ ldrsh ▁ r12 , ▁ [ r0 , ▁ # + 2 ] \n " /* ▁ in [ 2 * inputIndex + 1 ] ▁ */ " ▁ ▁ ▁ ldrsh ▁ r0 , ▁ [ r0 , ▁ # -2 ] \n " /* ▁ in [ 2 * inputIndex - 1 ] ▁ */ " ▁ ▁ ▁ sub ▁ r12 , ▁ r12 , ▁ r0 \n " /* ▁ in [ 2 * InputIndex ] ▁ - ▁ in [ 2 * InputIndex - 2 ] ▁ */ " ▁ ▁ ▁ mov ▁ r12 , ▁ r12 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r12 , ▁ r12 , ▁ r6 \n " /* ▁ ( x1 - x0 ) * . . ▁ */ " ▁ ▁ ▁ add ▁ r12 , ▁ r0 , ▁ r12 \n " /* ▁ x0 ▁ - ▁ ( . . ) ▁ */ " ▁ ▁ ▁ mla ▁ r4 , ▁ r12 , ▁ r11 , ▁ r4 \n " /* ▁ vr * interp ▁ + ▁ out [ ] ▁ */ " ▁ ▁ ▁ str ▁ r4 , ▁ [ r8 ] , ▁ # 4 \n " /* ▁ out [ outputIndex + + ] ▁ = ▁ . . . ▁ */ " ▁ ▁ ▁ add ▁ r6 , ▁ r6 , ▁ r9 \n " /* ▁ phaseFraction ▁ + ▁ phaseIncrement ▁ */ " ▁ ▁ ▁ add ▁ r7 , ▁ r7 , ▁ r6 , ▁ lsr ▁ # 30 \n " /* ▁ inputIndex ▁ + ▁ phaseFraction > > 30 ▁ */ ST_ONE_FRAME // ▁ frame ▁ 1 ENDCOM ST_ONE_FRAME // ▁ frame ▁ 1 ENDCOM " ▁ ▁ ▁ cmp ▁ r7 , ▁ r3 \n " // ▁ inputIndex ▁ - ▁ maxInIdx ENDCOM " ▁ ▁ ▁ bcc ▁ 3b \n " "4 : \n " " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " // ▁ phaseFraction ▁ & ▁ . . . ENDCOM // ▁ save ▁ modified ▁ values ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 20 ] \n " // ▁ & phaseFraction ENDCOM " ▁ ▁ ▁ str ▁ r6 , ▁ [ r0 ] \n " // ▁ phaseFraction ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 8 ] \n " // ▁ & inputIndex ENDCOM " ▁ ▁ ▁ str ▁ r7 , ▁ [ r0 ] \n " // ▁ inputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 4 ] \n " // ▁ out ENDCOM " ▁ ▁ ▁ sub ▁ r8 , ▁ r0 \n " // ▁ curOut ▁ - ▁ out ENDCOM " ▁ ▁ ▁ asr ▁ r8 , ▁ # 2 \n " // ▁ new ▁ outputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 0 ] \n " // ▁ & outputIndex ENDCOM " ▁ ▁ ▁ str ▁ r8 , ▁ [ r0 ] \n " // ▁ save ▁ outputIndex ENDCOM " ▁ ▁ ▁ ldmfd ▁ ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ r12 , ▁ pc } \n " ) ; } # endif // ▁ ASM _ ARM _ RESAMP1 ENDCOM } } // ▁ namespace ▁ cocos2d ▁ { ▁ namespace ▁ experimental ▁ { ENDCOM </DOCUMENT>
<DOCUMENT_ID="Earlz/dobbscoin-source/tree/master/src/test/transaction_tests.cpp"> // ▁ Copyright ▁ ( c ) ▁ 2011-2014 ▁ The ▁ Dobbscoin ▁ Core ▁ developers ENDCOM // ▁ Distributed ▁ under ▁ the ▁ MIT / X11 ▁ software ▁ license , ▁ see ▁ the ▁ accompanying ENDCOM // ▁ file ▁ COPYING ▁ or ▁ http : // www . opensource . org / licenses / mit - license . php . ENDCOM # include " data / tx _ invalid . json . h " # include " data / tx _ valid . json . h " # include " clientversion . h " # include " key . h " # include " keystore . h " # include " main . h " # include " script / script . h " # include " script / script _ error . h " # include " core _ io . h " # include < map > # include < string > # include < boost / algorithm / string / classification . hpp > # include < boost / algorithm / string / split . hpp > # include < boost / test / unit_test . hpp > # include < boost / assign / list_of . hpp > # include " json / json _ spirit _ writer _ template . h " using namespace std ; using namespace json_spirit ; using namespace boost :: algorithm ; // ▁ In ▁ script _ tests . cpp ENDCOM extern Array read_json ( const std :: string & jsondata ) ; static std :: map < string , unsigned int > mapFlagNames = boost :: assign :: map_list_of ( string ( " NONE " ) , ( unsigned int ) SCRIPT_VERIFY_NONE ) ( string ( " P2SH " ) , ( unsigned int ) SCRIPT_VERIFY_P2SH ) ( string ( " STRICTENC " ) , ( unsigned int ) SCRIPT_VERIFY_STRICTENC ) ( string ( " DERSIG " ) , ( unsigned int ) SCRIPT_VERIFY_DERSIG ) ( string ( " LOW _ S " ) , ( unsigned int ) SCRIPT_VERIFY_LOW_S ) ( string ( " SIGPUSHONLY " ) , ( unsigned int ) SCRIPT_VERIFY_SIGPUSHONLY ) ( string ( " MINIMALDATA " ) , ( unsigned int ) SCRIPT_VERIFY_MINIMALDATA ) ( string ( " NULLDUMMY " ) , ( unsigned int ) SCRIPT_VERIFY_NULLDUMMY ) ( string ( " DISCOURAGE _ UPGRADABLE _ NOPS " ) , ( unsigned int ) SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS ) ; unsigned int ParseScriptFlags ( string strFlags ) { if ( strFlags . empty ( ) ) { return 0 ; } unsigned int flags = 0 ; vector < string > words ; split ( words , strFlags , is_any_of ( " , " ) ) ; BOOST_FOREACH ( string word , words ) { if ( ! mapFlagNames . count ( word ) ) BOOST_ERROR ( " Bad ▁ test : ▁ unknown ▁ verification ▁ flag ▁ ' " << word << " ' " ) ; flags |= mapFlagNames [ word ] ; } return flags ; } string FormatScriptFlags ( unsigned int flags ) { if ( flags == 0 ) { return " " ; } string ret ; std :: map < string , unsigned int > :: const_iterator it = mapFlagNames . begin ( ) ; while ( it != mapFlagNames . end ( ) ) { if ( flags & it -> second ) { ret += it -> first + " , " ; } it ++ ; } return ret . substr ( 0 , ret . size ( ) - 1 ) ; } BOOST_AUTO_TEST_SUITE ( transaction_tests ) BOOST_AUTO_TEST_CASE ( tx_valid ) { // ▁ Read ▁ tests ▁ from ▁ test / data / tx _ valid . json ENDCOM // ▁ Format ▁ is ▁ an ▁ array ▁ of ▁ arrays ENDCOM // ▁ Inner ▁ arrays ▁ are ▁ either ▁ [ ▁ " comment " ▁ ] ENDCOM // ▁ or ▁ [ [ [ prevout ▁ hash , ▁ prevout ▁ index , ▁ prevout ▁ scriptPubKey ] , ▁ [ input ▁ 2 ] , ▁ . . . ] , " ] , ▁ serializedTransaction , ▁ verifyFlags ENDCOM // ▁ . . . ▁ where ▁ all ▁ scripts ▁ are ▁ stringified ▁ scripts . ENDCOM // ▁ verifyFlags ▁ is ▁ a ▁ comma ▁ separated ▁ list ▁ of ▁ script ▁ verification ▁ flags ▁ to ▁ apply , ▁ or ▁ " NONE " ENDCOM Array tests = read_json ( std :: string ( json_tests :: tx_valid , json_tests :: tx_valid + sizeof ( json_tests :: tx_valid ) ) ) ; ScriptError err ; BOOST_FOREACH ( Value & tv , tests ) { Array test = tv . get_array ( ) ; string strTest = write_string ( tv , false ) ; if ( test [ 0 ] . type ( ) == array_type ) { if ( test . size ( ) != 3 || test [ 1 ] . type ( ) != str_type || test [ 2 ] . type ( ) != str_type ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } map < COutPoint , CScript > mapprevOutScriptPubKeys ; Array inputs = test [ 0 ] . get_array ( ) ; bool fValid = true ; BOOST_FOREACH ( Value & input , inputs ) { if ( input . type ( ) != array_type ) { fValid = false ; break ; } Array vinput = input . get_array ( ) ; if ( vinput . size ( ) != 3 ) { fValid = false ; break ; } mapprevOutScriptPubKeys [ COutPoint ( uint256 ( vinput [ 0 ] . get_str ( ) ) , vinput [ 1 ] . get_int ( ) ) ] = ParseScript ( vinput [ 2 ] . get_str ( ) ) ; } if ( ! fValid ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } string transaction = test [ 1 ] . get_str ( ) ; CDataStream stream ( ParseHex ( transaction ) , SER_NETWORK , PROTOCOL_VERSION ) ; CTransaction tx ; stream >> tx ; CValidationState state ; BOOST_CHECK_MESSAGE ( CheckTransaction ( tx , state ) , strTest ) ; BOOST_CHECK ( state . IsValid ( ) ) ; for ( unsigned int i = 0 ; i < tx . vin . size ( ) ; i ++ ) { if ( ! mapprevOutScriptPubKeys . count ( tx . vin [ i ] . prevout ) ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; break ; } unsigned int verify_flags = ParseScriptFlags ( test [ 2 ] . get_str ( ) ) ; BOOST_CHECK_MESSAGE ( VerifyScript ( tx . vin [ i ] . scriptSig , mapprevOutScriptPubKeys [ tx . vin [ i ] . prevout ] , verify_flags , TransactionSignatureChecker ( & tx , i ) , & err ) , strTest ) ; BOOST_CHECK_MESSAGE ( err == SCRIPT_ERR_OK , ScriptErrorString ( err ) ) ; } } } } BOOST_AUTO_TEST_CASE ( tx_invalid ) { // ▁ Read ▁ tests ▁ from ▁ test / data / tx _ invalid . json ENDCOM // ▁ Format ▁ is ▁ an ▁ array ▁ of ▁ arrays ENDCOM // ▁ Inner ▁ arrays ▁ are ▁ either ▁ [ ▁ " comment " ▁ ] ENDCOM // ▁ or ▁ [ [ [ prevout ▁ hash , ▁ prevout ▁ index , ▁ prevout ▁ scriptPubKey ] , ▁ [ input ▁ 2 ] , ▁ . . . ] , " ] , ▁ serializedTransaction , ▁ verifyFlags ENDCOM // ▁ . . . ▁ where ▁ all ▁ scripts ▁ are ▁ stringified ▁ scripts . ENDCOM // ▁ verifyFlags ▁ is ▁ a ▁ comma ▁ separated ▁ list ▁ of ▁ script ▁ verification ▁ flags ▁ to ▁ apply , ▁ or ▁ " NONE " ENDCOM Array tests = read_json ( std :: string ( json_tests :: tx_invalid , json_tests :: tx_invalid + sizeof ( json_tests :: tx_invalid ) ) ) ; ScriptError err ; BOOST_FOREACH ( Value & tv , tests ) { Array test = tv . get_array ( ) ; string strTest = write_string ( tv , false ) ; if ( test [ 0 ] . type ( ) == array_type ) { if ( test . size ( ) != 3 || test [ 1 ] . type ( ) != str_type || test [ 2 ] . type ( ) != str_type ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } map < COutPoint , CScript > mapprevOutScriptPubKeys ; Array inputs = test [ 0 ] . get_array ( ) ; bool fValid = true ; BOOST_FOREACH ( Value & input , inputs ) { if ( input . type ( ) != array_type ) { fValid = false ; break ; } Array vinput = input . get_array ( ) ; if ( vinput . size ( ) != 3 ) { fValid = false ; break ; } mapprevOutScriptPubKeys [ COutPoint ( uint256 ( vinput [ 0 ] . get_str ( ) ) , vinput [ 1 ] . get_int ( ) ) ] = ParseScript ( vinput [ 2 ] . get_str ( ) ) ; } if ( ! fValid ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } string transaction = test [ 1 ] . get_str ( ) ; CDataStream stream ( ParseHex ( transaction ) , SER_NETWORK , PROTOCOL_VERSION ) ; CTransaction tx ; stream >> tx ; CValidationState state ; fValid = CheckTransaction ( tx , state ) && state . IsValid ( ) ; for ( unsigned int i = 0 ; i < tx . vin . size ( ) && fValid ; i ++ ) { if ( ! mapprevOutScriptPubKeys . count ( tx . vin [ i ] . prevout ) ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; break ; } unsigned int verify_flags = ParseScriptFlags ( test [ 2 ] . get_str ( ) ) ; fValid = VerifyScript ( tx . vin [ i ] . scriptSig , mapprevOutScriptPubKeys [ tx . vin [ i ] . prevout ] , verify_flags , TransactionSignatureChecker ( & tx , i ) , & err ) ; } BOOST_CHECK_MESSAGE ( ! fValid , strTest ) ; BOOST_CHECK_MESSAGE ( err != SCRIPT_ERR_OK , ScriptErrorString ( err ) ) ; } } } BOOST_AUTO_TEST_CASE ( basic_transaction_tests ) { // ▁ Random ▁ real ▁ transaction ▁ ( e2769b09e784f32f62ef849763d4f45b98e07ba658647343b915ff832b110436 ) ENDCOM unsigned char ch [ ] = { 0x01 , 0x00 , 0x00 , 0x00 , 0x01 , 0x6b , 0xff , 0x7f , 0xcd , 0x4f , 0x85 , 0x65 , 0xef , 0x40 , 0x6d , 0xd5 , 0xd6 , 0x3d , 0x4f , 0xf9 , 0x4f , 0x31 , 0x8f , 0xe8 , 0x20 , 0x27 , 0xfd , 0x4d , 0xc4 , 0x51 , 0xb0 , 0x44 , 0x74 , 0x01 , 0x9f , 0x74 , 0xb4 , 0x00 , 0x00 , 0x00 , 0x00 , 0x8c , 0x49 , 0x30 , 0x46 , 0x02 , 0x21 , 0x00 , 0xda , 0x0d , 0xc6 , 0xae , 0xce , 0xfe , 0x1e , 0x06 , 0xef , 0xdf , 0x05 , 0x77 , 0x37 , 0x57 , 0xde , 0xb1 , 0x68 , 0x82 , 0x09 , 0x30 , 0xe3 , 0xb0 , 0xd0 , 0x3f , 0x46 , 0xf5 , 0xfc , 0xf1 , 0x50 , 0xbf , 0x99 , 0x0c , 0x02 , 0x21 , 0x00 , 0xd2 , 0x5b , 0x5c , 0x87 , 0x04 , 0x00 , 0x76 , 0xe4 , 0xf2 , 0x53 , 0xf8 , 0x26 , 0x2e , 0x76 , 0x3e , 0x2d , 0xd5 , 0x1e , 0x7f , 0xf0 , 0xbe , 0x15 , 0x77 , 0x27 , 0xc4 , 0xbc , 0x42 , 0x80 , 0x7f , 0x17 , 0xbd , 0x39 , 0x01 , 0x41 , 0x04 , 0xe6 , 0xc2 , 0x6e , 0xf6 , 0x7d , 0xc6 , 0x10 , 0xd2 , 0xcd , 0x19 , 0x24 , 0x84 , 0x78 , 0x9a , 0x6c , 0xf9 , 0xae , 0xa9 , 0x93 , 0x0b , 0x94 , 0x4b , 0x7e , 0x2d , 0xb5 , 0x34 , 0x2b , 0x9d , 0x9e , 0x5b , 0x9f , 0xf7 , 0x9a , 0xff , 0x9a , 0x2e , 0xe1 , 0x97 , 0x8d , 0xd7 , 0xfd , 0x01 , 0xdf , 0xc5 , 0x22 , 0xee , 0x02 , 0x28 , 0x3d , 0x3b , 0x06 , 0xa9 , 0xd0 , 0x3a , 0xcf , 0x80 , 0x96 , 0x96 , 0x8d , 0x7d , 0xbb , 0x0f , 0x91 , 0x78 , 0xff , 0xff , 0xff , 0xff , 0x02 , 0x8b , 0xa7 , 0x94 , 0x0e , 0x00 , 0x00 , 0x00 , 0x00 , 0x19 , 0x76 , 0xa9 , 0x14 , 0xba , 0xde , 0xec , 0xfd , 0xef , 0x05 , 0x07 , 0x24 , 0x7f , 0xc8 , 0xf7 , 0x42 , 0x41 , 0xd7 , 0x3b , 0xc0 , 0x39 , 0x97 , 0x2d , 0x7b , 0x88 , 0xac , 0x40 , 0x94 , 0xa8 , 0x02 , 0x00 , 0x00 , 0x00 , 0x00 , 0x19 , 0x76 , 0xa9 , 0x14 , 0xc1 , 0x09 , 0x32 , 0x48 , 0x3f , 0xec , 0x93 , 0xed , 0x51 , 0xf5 , 0xfe , 0x95 , 0xe7 , 0x25 , 0x59 , 0xf2 , 0xcc , 0x70 , 0x43 , 0xf9 , 0x88 , 0xac , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; vector < unsigned char > vch ( ch , ch + sizeof ( ch ) - 1 ) ; CDataStream stream ( vch , SER_DISK , CLIENT_VERSION ) ; CMutableTransaction tx ; stream >> tx ; CValidationState state ; BOOST_CHECK_MESSAGE ( CheckTransaction ( tx , state ) && state . IsValid ( ) , " Simple ▁ deserialized ▁ transaction ▁ should ▁ be ▁ valid . " ) ; // ▁ Check ▁ that ▁ duplicate ▁ txins ▁ fail ENDCOM tx . vin . push_back ( tx . vin [ 0 ] ) ; BOOST_CHECK_MESSAGE ( ! CheckTransaction ( tx , state ) || ! state . IsValid ( ) , " Transaction ▁ with ▁ duplicate ▁ txins ▁ should ▁ be ▁ invalid . " ) ; } // ▁ Helper : ▁ create ▁ two ▁ dummy ▁ transactions , ▁ each ▁ with ENDCOM // ▁ two ▁ outputs . ▁ The ▁ first ▁ has ▁ 11 ▁ and ▁ 50 ▁ CENT ▁ outputs ENDCOM // ▁ paid ▁ to ▁ a ▁ TX _ PUBKEY , ▁ the ▁ second ▁ 21 ▁ and ▁ 22 ▁ CENT ▁ outputs ENDCOM // ▁ paid ▁ to ▁ a ▁ TX _ PUBKEYHASH . ENDCOM static std :: vector < CMutableTransaction > SetupDummyInputs ( CBasicKeyStore & keystoreRet , CCoinsViewCache & coinsRet ) { std :: vector < CMutableTransaction > dummyTransactions ; dummyTransactions . resize ( 2 ) ; // ▁ Add ▁ some ▁ keys ▁ to ▁ the ▁ keystore : ENDCOM CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { key [ i ] . MakeNewKey ( i % 2 ) ; keystoreRet . AddKey ( key [ i ] ) ; } // ▁ Create ▁ some ▁ dummy ▁ input ▁ transactions ENDCOM dummyTransactions [ 0 ] . vout . resize ( 2 ) ; dummyTransactions [ 0 ] . vout [ 0 ] . nValue = 11 * CENT ; dummyTransactions [ 0 ] . vout [ 0 ] . scriptPubKey << ToByteVector ( key [ 0 ] . GetPubKey ( ) ) << OP_CHECKSIG ; dummyTransactions [ 0 ] . vout [ 1 ] . nValue = 50 * CENT ; dummyTransactions [ 0 ] . vout [ 1 ] . scriptPubKey << ToByteVector ( key [ 1 ] . GetPubKey ( ) ) << OP_CHECKSIG ; coinsRet . ModifyCoins ( dummyTransactions [ 0 ] . GetHash ( ) ) -> FromTx ( dummyTransactions [ 0 ] , 0 ) ; dummyTransactions [ 1 ] . vout . resize ( 2 ) ; dummyTransactions [ 1 ] . vout [ 0 ] . nValue = 21 * CENT ; dummyTransactions [ 1 ] . vout [ 0 ] . scriptPubKey = GetScriptForDestination ( key [ 2 ] . GetPubKey ( ) . GetID ( ) ) ; dummyTransactions [ 1 ] . vout [ 1 ] . nValue = 22 * CENT ; dummyTransactions [ 1 ] . vout [ 1 ] . scriptPubKey = GetScriptForDestination ( key [ 3 ] . GetPubKey ( ) . GetID ( ) ) ; coinsRet . ModifyCoins ( dummyTransactions [ 1 ] . GetHash ( ) ) -> FromTx ( dummyTransactions [ 1 ] , 0 ) ; return dummyTransactions ; } BOOST_AUTO_TEST_CASE ( test_Get ) { CBasicKeyStore keystore ; CCoinsView coinsDummy ; CCoinsViewCache coins ( & coinsDummy ) ; std :: vector < CMutableTransaction > dummyTransactions = SetupDummyInputs ( keystore , coins ) ; CMutableTransaction t1 ; t1 . vin . resize ( 3 ) ; t1 . vin [ 0 ] . prevout . hash = dummyTransactions [ 0 ] . GetHash ( ) ; t1 . vin [ 0 ] . prevout . n = 1 ; t1 . vin [ 0 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) ; t1 . vin [ 1 ] . prevout . hash = dummyTransactions [ 1 ] . GetHash ( ) ; t1 . vin [ 1 ] . prevout . n = 0 ; t1 . vin [ 1 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) << std :: vector < unsigned char > ( 33 , 4 ) ; t1 . vin [ 2 ] . prevout . hash = dummyTransactions [ 1 ] . GetHash ( ) ; t1 . vin [ 2 ] . prevout . n = 1 ; t1 . vin [ 2 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) << std :: vector < unsigned char > ( 33 , 4 ) ; t1 . vout . resize ( 2 ) ; t1 . vout [ 0 ] . nValue = 90 * CENT ; t1 . vout [ 0 ] . scriptPubKey << OP_1 ; BOOST_CHECK ( AreInputsStandard ( t1 , coins ) ) ; BOOST_CHECK_EQUAL ( coins . GetValueIn ( t1 ) , ( 50 + 21 + 22 ) * CENT ) ; // ▁ Adding ▁ extra ▁ junk ▁ to ▁ the ▁ scriptSig ▁ should ▁ make ▁ it ▁ non - standard : ENDCOM t1 . vin [ 0 ] . scriptSig << OP_11 ; BOOST_CHECK ( ! AreInputsStandard ( t1 , coins ) ) ; // ▁ . . . ▁ as ▁ should ▁ not ▁ having ▁ enough : ENDCOM t1 . vin [ 0 ] . scriptSig = CScript ( ) ; BOOST_CHECK ( ! AreInputsStandard ( t1 , coins ) ) ; } BOOST_AUTO_TEST_CASE ( test_IsStandard ) { LOCK ( cs_main ) ; CBasicKeyStore keystore ; CCoinsView coinsDummy ; CCoinsViewCache coins ( & coinsDummy ) ; std :: vector < CMutableTransaction > dummyTransactions = SetupDummyInputs ( keystore , coins ) ; CMutableTransaction t ; t . vin . resize ( 1 ) ; t . vin [ 0 ] . prevout . hash = dummyTransactions [ 0 ] . GetHash ( ) ; t . vin [ 0 ] . prevout . n = 1 ; t . vin [ 0 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) ; t . vout . resize ( 1 ) ; t . vout [ 0 ] . nValue = 90 * CENT ; CKey key ; key . MakeNewKey ( true ) ; t . vout [ 0 ] . scriptPubKey = GetScriptForDestination ( key . GetPubKey ( ) . GetID ( ) ) ; string reason ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . nValue = 501 ; // ▁ dust ENDCOM BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . nValue = 601 ; // ▁ not ▁ dust ENDCOM BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_1 ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; // ▁ 40 - byte ▁ TX _ NULL _ DATA ▁ ( standard ) ENDCOM t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; // ▁ 41 - byte ▁ TX _ NULL _ DATA ▁ ( non - standard ) ENDCOM t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3800" ) ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; // ▁ TX _ NULL _ DATA ▁ w / o ▁ PUSHDATA ENDCOM t . vout . resize ( 1 ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; // ▁ Only ▁ one ▁ TX _ NULL _ DATA ▁ permitted ▁ in ▁ all ▁ cases ENDCOM t . vout . resize ( 2 ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="eriser/Obxd/tree/master/JuceLibraryCode/modules/juce_box2d/box2d/Common/b2StackAllocator.cpp"> /* STRNEWLINE * ▁ Copyright ▁ ( c ) ▁ 2006-2009 ▁ Erin ▁ Catto ▁ http : // www . box2d . org STRNEWLINE * STRNEWLINE * ▁ This ▁ software ▁ is ▁ provided ▁ ' as - is ' , ▁ without ▁ any ▁ express ▁ or ▁ implied STRNEWLINE * ▁ warranty . ▁ In ▁ no ▁ event ▁ will ▁ the ▁ authors ▁ be ▁ held ▁ liable ▁ for ▁ any ▁ damages STRNEWLINE * ▁ arising ▁ from ▁ the ▁ use ▁ of ▁ this ▁ software . STRNEWLINE * ▁ Permission ▁ is ▁ granted ▁ to ▁ anyone ▁ to ▁ use ▁ this ▁ software ▁ for ▁ any ▁ purpose , STRNEWLINE * ▁ including ▁ commercial ▁ applications , ▁ and ▁ to ▁ alter ▁ it ▁ and ▁ redistribute ▁ it STRNEWLINE * ▁ freely , ▁ subject ▁ to ▁ the ▁ following ▁ restrictions : STRNEWLINE * ▁ 1 . ▁ The ▁ origin ▁ of ▁ this ▁ software ▁ must ▁ not ▁ be ▁ misrepresented ; ▁ you ▁ must ▁ not STRNEWLINE * ▁ claim ▁ that ▁ you ▁ wrote ▁ the ▁ original ▁ software . ▁ If ▁ you ▁ use ▁ this ▁ software STRNEWLINE * ▁ in ▁ a ▁ product , ▁ an ▁ acknowledgment ▁ in ▁ the ▁ product ▁ documentation ▁ would ▁ be STRNEWLINE * ▁ appreciated ▁ but ▁ is ▁ not ▁ required . STRNEWLINE * ▁ 2 . ▁ Altered ▁ source ▁ versions ▁ must ▁ be ▁ plainly ▁ marked ▁ as ▁ such , ▁ and ▁ must ▁ not ▁ be STRNEWLINE * ▁ misrepresented ▁ as ▁ being ▁ the ▁ original ▁ software . STRNEWLINE * ▁ 3 . ▁ This ▁ notice ▁ may ▁ not ▁ be ▁ removed ▁ or ▁ altered ▁ from ▁ any ▁ source ▁ distribution . STRNEWLINE */ # include " b2StackAllocator . h " # include " b2Math . h " b2StackAllocator :: b2StackAllocator ( ) { m_index = 0 ; m_allocation = 0 ; m_maxAllocation = 0 ; m_entryCount = 0 ; } b2StackAllocator :: ~ b2StackAllocator ( ) { b2Assert ( m_index == 0 ) ; b2Assert ( m_entryCount == 0 ) ; } void * b2StackAllocator :: Allocate ( int32 size ) { b2Assert ( m_entryCount < b2_maxStackEntries ) ; b2StackEntry * entry = m_entries + m_entryCount ; entry -> size = size ; if ( m_index + size > b2_stackSize ) { entry -> data = ( char * ) b2Alloc ( size ) ; entry -> usedMalloc = true ; } else { entry -> data = m_data + m_index ; entry -> usedMalloc = false ; m_index += size ; } m_allocation += size ; m_maxAllocation = b2Max ( m_maxAllocation , m_allocation ) ; ++ m_entryCount ; return entry -> data ; } void b2StackAllocator :: Free ( void * p ) { b2Assert ( m_entryCount > 0 ) ; b2StackEntry * entry = m_entries + m_entryCount - 1 ; b2Assert ( p == entry -> data ) ; if ( entry -> usedMalloc ) { b2Free ( p ) ; } else { m_index -= entry -> size ; } m_allocation -= entry -> size ; -- m_entryCount ; p = NULL ; } int32 b2StackAllocator :: GetMaxAllocation ( ) const { return m_maxAllocation ; } </DOCUMENT>
<DOCUMENT_ID="Deepakpatle/phantomjs/tree/master/src/qt/qtwebkit/Source/JavaScriptCore/dfg/DFGAbstractState.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2011 , ▁ 2012 , ▁ 2013 ▁ Apple ▁ Inc . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without STRNEWLINE ▁ * ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions STRNEWLINE ▁ * ▁ are ▁ met : STRNEWLINE ▁ * ▁ 1 . ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . STRNEWLINE ▁ * ▁ 2 . ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in ▁ the STRNEWLINE ▁ * ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the ▁ distribution . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ APPLE ▁ INC . ▁ ` ` AS ▁ IS ' ' ▁ AND ▁ ANY STRNEWLINE ▁ * ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ THE STRNEWLINE ▁ * ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR STRNEWLINE ▁ * ▁ PURPOSE ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ APPLE ▁ INC . ▁ OR STRNEWLINE ▁ * ▁ CONTRIBUTORS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , ▁ SPECIAL , STRNEWLINE ▁ * ▁ EXEMPLARY , ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ ( INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , STRNEWLINE ▁ * ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES ; ▁ LOSS ▁ OF ▁ USE , ▁ DATA , ▁ OR STRNEWLINE ▁ * ▁ PROFITS ; ▁ OR ▁ BUSINESS ▁ INTERRUPTION ) ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY ▁ THEORY STRNEWLINE ▁ * ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ CONTRACT , ▁ STRICT ▁ LIABILITY , ▁ OR ▁ TORT STRNEWLINE ▁ * ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE STRNEWLINE ▁ * ▁ OF ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . ▁ STRNEWLINE ▁ */ # include " config . h " # include " DFGAbstractState . h " # if ENABLE ( DFG_JIT ) # include " CodeBlock . h " # include " DFGBasicBlock . h " # include " GetByIdStatus . h " # include " Operations . h " # include " PutByIdStatus . h " # include " StringObject . h " namespace JSC { namespace DFG { AbstractState :: AbstractState ( Graph & graph ) : m_codeBlock ( graph . m_codeBlock ) , m_graph ( graph ) , m_variables ( m_codeBlock -> numParameters ( ) , graph . m_localVars ) , m_block ( 0 ) { } AbstractState :: ~ AbstractState ( ) { } void AbstractState :: beginBasicBlock ( BasicBlock * basicBlock ) { ASSERT ( ! m_block ) ; ASSERT ( basicBlock -> variablesAtHead . numberOfLocals ( ) == basicBlock -> valuesAtHead . numberOfLocals ( ) ) ; ASSERT ( basicBlock -> variablesAtTail . numberOfLocals ( ) == basicBlock -> valuesAtTail . numberOfLocals ( ) ) ; ASSERT ( basicBlock -> variablesAtHead . numberOfLocals ( ) == basicBlock -> variablesAtTail . numberOfLocals ( ) ) ; for ( size_t i = 0 ; i < basicBlock -> size ( ) ; i ++ ) forNode ( basicBlock -> at ( i ) ) . clear ( ) ; m_variables = basicBlock -> valuesAtHead ; m_haveStructures = false ; for ( size_t i = 0 ; i < m_variables . numberOfArguments ( ) ; ++ i ) { if ( m_variables . argument ( i ) . m_currentKnownStructure . isNeitherClearNorTop ( ) ) { m_haveStructures = true ; break ; } } for ( size_t i = 0 ; i < m_variables . numberOfLocals ( ) ; ++ i ) { if ( m_variables . local ( i ) . m_currentKnownStructure . isNeitherClearNorTop ( ) ) { m_haveStructures = true ; break ; } } basicBlock -> cfaShouldRevisit = false ; basicBlock -> cfaHasVisited = true ; m_block = basicBlock ; m_isValid = true ; m_foundConstants = false ; m_branchDirection = InvalidBranchDirection ; } void AbstractState :: initialize ( Graph & graph ) { BasicBlock * root = graph . m_blocks [ 0 ] . get ( ) ; root -> cfaShouldRevisit = true ; root -> cfaHasVisited = false ; root -> cfaFoundConstants = false ; for ( size_t i = 0 ; i < root -> valuesAtHead . numberOfArguments ( ) ; ++ i ) { Node * node = root -> variablesAtHead . argument ( i ) ; ASSERT ( node -> op ( ) == SetArgument ) ; if ( ! node -> variableAccessData ( ) -> shouldUnboxIfPossible ( ) ) { root -> valuesAtHead . argument ( i ) . makeTop ( ) ; continue ; } SpeculatedType prediction = node -> variableAccessData ( ) -> prediction ( ) ; if ( isInt32Speculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecInt32 ) ; else if ( isBooleanSpeculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecBoolean ) ; else if ( isCellSpeculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecCell ) ; else root -> valuesAtHead . argument ( i ) . makeTop ( ) ; root -> valuesAtTail . argument ( i ) . clear ( ) ; } for ( size_t i = 0 ; i < root -> valuesAtHead . numberOfLocals ( ) ; ++ i ) { Node * node = root -> variablesAtHead . local ( i ) ; if ( node && node -> variableAccessData ( ) -> isCaptured ( ) ) root -> valuesAtHead . local ( i ) . makeTop ( ) ; else root -> valuesAtHead . local ( i ) . clear ( ) ; root -> valuesAtTail . local ( i ) . clear ( ) ; } for ( BlockIndex blockIndex = 1 ; blockIndex < graph . m_blocks . size ( ) ; ++ blockIndex ) { BasicBlock * block = graph . m_blocks [ blockIndex ] . get ( ) ; if ( ! block ) continue ; if ( ! block -> isReachable ) continue ; block -> cfaShouldRevisit = false ; block -> cfaHasVisited = false ; block -> cfaFoundConstants = false ; for ( size_t i = 0 ; i < block -> valuesAtHead . numberOfArguments ( ) ; ++ i ) { block -> valuesAtHead . argument ( i ) . clear ( ) ; block -> valuesAtTail . argument ( i ) . clear ( ) ; } for ( size_t i = 0 ; i < block -> valuesAtHead . numberOfLocals ( ) ; ++ i ) { block -> valuesAtHead . local ( i ) . clear ( ) ; block -> valuesAtTail . local ( i ) . clear ( ) ; } if ( ! block -> isOSRTarget ) continue ; if ( block -> bytecodeBegin != graph . m_osrEntryBytecodeIndex ) continue ; for ( size_t i = 0 ; i < graph . m_mustHandleValues . size ( ) ; ++ i ) { AbstractValue value ; value . setMostSpecific ( graph . m_mustHandleValues [ i ] ) ; int operand = graph . m_mustHandleValues . operandForIndex ( i ) ; block -> valuesAtHead . operand ( operand ) . merge ( value ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ Initializing ▁ Block ▁ # % u , ▁ operand ▁ r % d , ▁ to ▁ " , blockIndex , operand ) ; block -> valuesAtHead . operand ( operand ) . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; # endif } block -> cfaShouldRevisit = true ; } } bool AbstractState :: endBasicBlock ( MergeMode mergeMode ) { ASSERT ( m_block ) ; BasicBlock * block = m_block ; // ▁ Save ▁ the ▁ block ▁ for ▁ successor ▁ merging . ENDCOM block -> cfaFoundConstants = m_foundConstants ; block -> cfaDidFinish = m_isValid ; block -> cfaBranchDirection = m_branchDirection ; if ( ! m_isValid ) { reset ( ) ; return false ; } bool changed = false ; if ( mergeMode != DontMerge || ! ASSERT_DISABLED ) { for ( size_t argument = 0 ; argument < block -> variablesAtTail . numberOfArguments ( ) ; ++ argument ) { # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ state ▁ for ▁ argument ▁ % zu . \n " , argument ) ; # endif AbstractValue & destination = block -> valuesAtTail . argument ( argument ) ; changed |= mergeStateAtTail ( destination , m_variables . argument ( argument ) , block -> variablesAtTail . argument ( argument ) ) ; } for ( size_t local = 0 ; local < block -> variablesAtTail . numberOfLocals ( ) ; ++ local ) { # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ state ▁ for ▁ local ▁ % zu . \n " , local ) ; # endif AbstractValue & destination = block -> valuesAtTail . local ( local ) ; changed |= mergeStateAtTail ( destination , m_variables . local ( local ) , block -> variablesAtTail . local ( local ) ) ; } } ASSERT ( mergeMode != DontMerge || ! changed ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Branch ▁ direction ▁ = ▁ % s \n " , branchDirectionToString ( m_branchDirection ) ) ; # endif reset ( ) ; if ( mergeMode != MergeToSuccessors ) return changed ; return mergeToSuccessors ( m_graph , block ) ; } void AbstractState :: reset ( ) { m_block = 0 ; m_isValid = false ; m_branchDirection = InvalidBranchDirection ; } AbstractState :: BooleanResult AbstractState :: booleanResult ( Node * node , AbstractValue & value ) { JSValue childConst = value . value ( ) ; if ( childConst ) { if ( childConst . toBoolean ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> globalExec ( ) ) ) return DefinitelyTrue ; return DefinitelyFalse ; } // ▁ Next ▁ check ▁ if ▁ we ▁ can ▁ fold ▁ because ▁ we ▁ know ▁ that ▁ the ▁ source ▁ is ▁ an ▁ object ▁ or ▁ string ▁ and ▁ does ▁ not ▁ equal ▁ undefined . ENDCOM if ( isCellSpeculation ( value . m_type ) && value . m_currentKnownStructure . hasSingleton ( ) ) { Structure * structure = value . m_currentKnownStructure . singleton ( ) ; if ( ! structure -> masqueradesAsUndefined ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) ) && structure -> typeInfo ( ) . type ( ) != StringType ) return DefinitelyTrue ; } return UnknownBooleanResult ; } bool AbstractState :: startExecuting ( Node * node ) { ASSERT ( m_block ) ; ASSERT ( m_isValid ) ; m_didClobber = false ; node -> setCanExit ( false ) ; if ( ! node -> shouldGenerate ( ) ) return false ; return true ; } bool AbstractState :: startExecuting ( unsigned indexInBlock ) { return startExecuting ( m_block -> at ( indexInBlock ) ) ; } void AbstractState :: executeEdges ( Node * node ) { DFG_NODE_DO_TO_CHILDREN ( m_graph , node , filterEdgeByUse ) ; } void AbstractState :: executeEdges ( unsigned indexInBlock ) { executeEdges ( m_block -> at ( indexInBlock ) ) ; } void AbstractState :: verifyEdge ( Node * , Edge edge ) { RELEASE_ASSERT ( ! ( forNode ( edge ) . m_type & ~ typeFilterFor ( edge . useKind ( ) ) ) ) ; } void AbstractState :: verifyEdges ( Node * node ) { DFG_NODE_DO_TO_CHILDREN ( m_graph , node , verifyEdge ) ; } bool AbstractState :: executeEffects ( unsigned indexInBlock , Node * node ) { if ( ! ASSERT_DISABLED ) verifyEdges ( node ) ; switch ( node -> op ( ) ) { case JSConstant : case WeakJSConstant : case PhantomArguments : { forNode ( node ) . set ( m_graph . valueOfJSConstant ( node ) ) ; break ; } case Identity : { forNode ( node ) = forNode ( node -> child1 ( ) ) ; break ; } case GetLocal : { VariableAccessData * variableAccessData = node -> variableAccessData ( ) ; if ( variableAccessData -> prediction ( ) == SpecNone ) { m_isValid = false ; break ; } AbstractValue value = m_variables . operand ( variableAccessData -> local ( ) ) ; if ( ! variableAccessData -> isCaptured ( ) ) { if ( value . isClear ( ) ) node -> setCanExit ( true ) ; } if ( value . value ( ) ) m_foundConstants = true ; forNode ( node ) = value ; break ; } case GetLocalUnlinked : { AbstractValue value = m_variables . operand ( node -> unlinkedLocal ( ) ) ; if ( value . value ( ) ) m_foundConstants = true ; forNode ( node ) = value ; break ; } case SetLocal : { m_variables . operand ( node -> local ( ) ) = forNode ( node -> child1 ( ) ) ; break ; } case MovHintAndCheck : { // ▁ Don ' t ▁ need ▁ to ▁ do ▁ anything . ▁ A ▁ MovHint ▁ is ▁ effectively ▁ a ▁ promise ▁ that ▁ the ▁ SetLocal ENDCOM // ▁ was ▁ dead . ENDCOM break ; } case MovHint : case ZombieHint : { RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } case SetArgument : // ▁ Assert ▁ that ▁ the ▁ state ▁ of ▁ arguments ▁ has ▁ been ▁ set . ENDCOM ASSERT ( ! m_block -> valuesAtHead . operand ( node -> local ( ) ) . isClear ( ) ) ; break ; case BitAnd : case BitOr : case BitXor : case BitRShift : case BitLShift : case BitURShift : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isInt32 ( ) && right . isInt32 ( ) ) { int32_t a = left . asInt32 ( ) ; int32_t b = right . asInt32 ( ) ; bool constantWasSet ; switch ( node -> op ( ) ) { case BitAnd : constantWasSet = trySetConstant ( node , JSValue ( a & b ) ) ; break ; case BitOr : constantWasSet = trySetConstant ( node , JSValue ( a | b ) ) ; break ; case BitXor : constantWasSet = trySetConstant ( node , JSValue ( a ^ b ) ) ; break ; case BitRShift : constantWasSet = trySetConstant ( node , JSValue ( a >> static_cast < uint32_t > ( b ) ) ) ; break ; case BitLShift : constantWasSet = trySetConstant ( node , JSValue ( a << static_cast < uint32_t > ( b ) ) ) ; break ; case BitURShift : constantWasSet = trySetConstant ( node , JSValue ( static_cast < uint32_t > ( a ) >> static_cast < uint32_t > ( b ) ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecInt32 ) ; break ; } case UInt32ToNumber : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { ASSERT ( child . isInt32 ( ) ) ; if ( trySetConstant ( node , JSValue ( child . asUInt32 ( ) ) ) ) { m_foundConstants = true ; break ; } } if ( ! node -> canSpeculateInteger ( ) ) forNode ( node ) . set ( SpecDouble ) ; else { forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; } break ; } case DoubleAsInt32 : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { double asDouble = child . asNumber ( ) ; int32_t asInt = JSC :: toInt32 ( asDouble ) ; if ( bitwise_cast < int64_t > ( static_cast < double > ( asInt ) ) == bitwise_cast < int64_t > ( asDouble ) && trySetConstant ( node , JSValue ( asInt ) ) ) { m_foundConstants = true ; break ; } } node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; } case ValueToInt32 : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { bool constantWasSet ; if ( child . isInt32 ( ) ) constantWasSet = trySetConstant ( node , child ) ; else constantWasSet = trySetConstant ( node , JSValue ( JSC :: toInt32 ( child . asDouble ( ) ) ) ) ; if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecInt32 ) ; break ; } case Int32ToDouble : case ForwardInt32ToDouble : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( JSValue :: EncodeAsDouble , child . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } if ( isInt32Speculation ( forNode ( node -> child1 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; } case ValueAdd : case ArithAdd : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) + right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : if ( isRealNumberSpeculation ( forNode ( node -> child1 ( ) ) . m_type ) && isRealNumberSpeculation ( forNode ( node -> child2 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT ( node -> op ( ) == ValueAdd ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . set ( SpecString | SpecInt32 | SpecNumber ) ; break ; } break ; } case MakeRope : { forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case ArithSub : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) - right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithNegate : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( - child . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithMul : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) * right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) || ! nodeCanIgnoreNegativeZero ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : if ( isRealNumberSpeculation ( forNode ( node -> child1 ( ) ) . m_type ) || isRealNumberSpeculation ( forNode ( node -> child2 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithIMul : { forNode ( node ) . set ( SpecInt32 ) ; break ; } case ArithDiv : case ArithMin : case ArithMax : case ArithMod : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) ) { double a = left . asNumber ( ) ; double b = right . asNumber ( ) ; bool constantWasSet ; switch ( node -> op ( ) ) { case ArithDiv : constantWasSet = trySetConstant ( node , JSValue ( a / b ) ) ; break ; case ArithMin : constantWasSet = trySetConstant ( node , JSValue ( a < b ? a : ( b <= a ? b : a + b ) ) ) ; break ; case ArithMax : constantWasSet = trySetConstant ( node , JSValue ( a > b ? a : ( b >= a ? b : a + b ) ) ) ; break ; case ArithMod : constantWasSet = trySetConstant ( node , JSValue ( fmod ( a , b ) ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; break ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithAbs : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( fabs ( child . asNumber ( ) ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithSqrt : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( sqrt ( child . asNumber ( ) ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecDouble ) ; break ; } case LogicalNot : { bool didSetConstant = false ; switch ( booleanResult ( node , forNode ( node -> child1 ( ) ) ) ) { case DefinitelyTrue : didSetConstant = trySetConstant ( node , jsBoolean ( false ) ) ; break ; case DefinitelyFalse : didSetConstant = trySetConstant ( node , jsBoolean ( true ) ) ; break ; default : break ; } if ( didSetConstant ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case BooleanUse : case Int32Use : case NumberUse : case UntypedUse : break ; case ObjectOrOtherUse : node -> setCanExit ( true ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( SpecBoolean ) ; break ; } case IsUndefined : case IsBoolean : case IsNumber : case IsString : case IsObject : case IsFunction : { node -> setCanExit ( node -> op ( ) == IsUndefined && m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> masqueradesAsUndefinedWatchpoint ( ) -> isStillValid ( ) ) ; JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child ) { bool constantWasSet ; switch ( node -> op ( ) ) { case IsUndefined : if ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> masqueradesAsUndefinedWatchpoint ( ) -> isStillValid ( ) ) { constantWasSet = trySetConstant ( node , jsBoolean ( child . isCell ( ) ? false : child . isUndefined ( ) ) ) ; } else { constantWasSet = trySetConstant ( node , jsBoolean ( child . isCell ( ) ? child . asCell ( ) -> structure ( ) -> masqueradesAsUndefined ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) ) : child . isUndefined ( ) ) ) ; } break ; case IsBoolean : constantWasSet = trySetConstant ( node , jsBoolean ( child . isBoolean ( ) ) ) ; break ; case IsNumber : constantWasSet = trySetConstant ( node , jsBoolean ( child . isNumber ( ) ) ) ; break ; case IsString : constantWasSet = trySetConstant ( node , jsBoolean ( isJSString ( child ) ) ) ; break ; case IsObject : if ( child . isNull ( ) || ! child . isObject ( ) ) { constantWasSet = trySetConstant ( node , jsBoolean ( child . isNull ( ) ) ) ; break ; } default : constantWasSet = false ; break ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecBoolean ) ; break ; } case TypeOf : { VM * vm = m_codeBlock -> vm ( ) ; JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; AbstractValue & abstractChild = forNode ( node -> child1 ( ) ) ; if ( child ) { JSValue typeString = jsTypeStringForValue ( * vm , m_codeBlock -> globalObjectFor ( node -> codeOrigin ) , child ) ; if ( trySetConstant ( node , typeString ) ) { m_foundConstants = true ; break ; } } else if ( isNumberSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . numberString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecNumber ) ; m_foundConstants = true ; break ; } } else if ( isStringSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . stringString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecString ) ; m_foundConstants = true ; break ; } } else if ( isFinalObjectSpeculation ( abstractChild . m_type ) || isArraySpeculation ( abstractChild . m_type ) || isArgumentsSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . objectString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecFinalObject | SpecArray | SpecArguments ) ; m_foundConstants = true ; break ; } } else if ( isFunctionSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . functionString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecFunction ) ; m_foundConstants = true ; break ; } } else if ( isBooleanSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . booleanString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecBoolean ) ; m_foundConstants = true ; break ; } } switch ( node -> child1 ( ) . useKind ( ) ) { case StringUse : case CellUse : node -> setCanExit ( true ) ; break ; case UntypedUse : break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case CompareLess : case CompareLessEq : case CompareGreater : case CompareGreaterEq : case CompareEq : case CompareEqConstant : { bool constantWasSet = false ; JSValue leftConst = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue rightConst = forNode ( node -> child2 ( ) ) . value ( ) ; if ( leftConst && rightConst && leftConst . isNumber ( ) && rightConst . isNumber ( ) ) { double a = leftConst . asNumber ( ) ; double b = rightConst . asNumber ( ) ; switch ( node -> op ( ) ) { case CompareLess : constantWasSet = trySetConstant ( node , jsBoolean ( a < b ) ) ; break ; case CompareLessEq : constantWasSet = trySetConstant ( node , jsBoolean ( a <= b ) ) ; break ; case CompareGreater : constantWasSet = trySetConstant ( node , jsBoolean ( a > b ) ) ; break ; case CompareGreaterEq : constantWasSet = trySetConstant ( node , jsBoolean ( a >= b ) ) ; break ; case CompareEq : constantWasSet = trySetConstant ( node , jsBoolean ( a == b ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; break ; } } if ( ! constantWasSet && ( node -> op ( ) == CompareEqConstant || node -> op ( ) == CompareEq ) ) { SpeculatedType leftType = forNode ( node -> child1 ( ) ) . m_type ; SpeculatedType rightType = forNode ( node -> child2 ( ) ) . m_type ; if ( ( isInt32Speculation ( leftType ) && isOtherSpeculation ( rightType ) ) || ( isOtherSpeculation ( leftType ) && isInt32Speculation ( rightType ) ) ) constantWasSet = trySetConstant ( node , jsBoolean ( false ) ) ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecBoolean ) ; // ▁ This ▁ is ▁ overly ▁ conservative . ▁ But ▁ the ▁ only ▁ thing ▁ this ▁ prevents ▁ is ▁ store ▁ elimination , ENDCOM // ▁ and ▁ how ▁ likely ▁ is ▁ it , ▁ really , ▁ that ▁ you ' ll ▁ have ▁ redundant ▁ stores ▁ across ▁ a ▁ comparison ENDCOM // ▁ operation ? ▁ Comparison ▁ operations ▁ are ▁ typically ▁ at ▁ the ▁ end ▁ of ▁ basic ▁ blocks , ▁ so ENDCOM // ▁ unless ▁ we ▁ have ▁ global ▁ store ▁ elimination ▁ ( super ▁ unlikely ▁ given ▁ how ▁ unprofitable ▁ that ENDCOM // ▁ optimization ▁ is ▁ to ▁ begin ▁ with ) , ▁ you ▁ aren ' t ▁ going ▁ to ▁ be ▁ wanting ▁ to ▁ store ▁ eliminate ENDCOM // ▁ across ▁ an ▁ equality ▁ op . ENDCOM node -> setCanExit ( true ) ; break ; } case CompareStrictEq : case CompareStrictEqConstant : { Node * leftNode = node -> child1 ( ) . node ( ) ; Node * rightNode = node -> child2 ( ) . node ( ) ; JSValue left = forNode ( leftNode ) . value ( ) ; JSValue right = forNode ( rightNode ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , jsBoolean ( left . asNumber ( ) == right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecBoolean ) ; node -> setCanExit ( true ) ; // ▁ This ▁ is ▁ overly ▁ conservative . ENDCOM break ; } case StringCharCodeAt : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; case StringFromCharCode : forNode ( node ) . set ( SpecString ) ; break ; case StringCharAt : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; case GetByVal : { node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . type ( ) ) { case Array :: SelectUsingPredictions : case Array :: Unprofiled : case Array :: Undecided : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; case Array :: ForceExit : m_isValid = false ; break ; case Array :: Generic : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case Array :: String : forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; case Array :: Arguments : forNode ( node ) . makeTop ( ) ; break ; case Array :: Int32 : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) { clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; } else forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Double : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) { clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; } else if ( node -> arrayMode ( ) . isSaneChain ( ) ) forNode ( node ) . set ( SpecDouble ) ; else forNode ( node ) . set ( SpecDoubleReal ) ; break ; case Array :: Contiguous : case Array :: ArrayStorage : case Array :: SlowPutArrayStorage : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case Array :: Int8Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Int16Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Int32Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint8Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint8ClampedArray : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint16Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint32Array : if ( node -> shouldSpeculateInteger ( ) ) forNode ( node ) . set ( SpecInt32 ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; case Array :: Float32Array : forNode ( node ) . set ( SpecDouble ) ; break ; case Array :: Float64Array : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case PutByVal : case PutByValAlias : { node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . modeForPut ( ) . type ( ) ) { case Array :: ForceExit : m_isValid = false ; break ; case Array :: Generic : clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Int32 : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Double : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Contiguous : case Array :: ArrayStorage : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: SlowPutArrayStorage : if ( node -> arrayMode ( ) . mayStoreToHole ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; default : break ; } break ; } case ArrayPush : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . set ( SpecNumber ) ; break ; case ArrayPop : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case RegExpExec : forNode ( node ) . makeTop ( ) ; break ; case RegExpTest : forNode ( node ) . set ( SpecBoolean ) ; break ; case Jump : break ; case Branch : { Node * child = node -> child1 ( ) . node ( ) ; BooleanResult result = booleanResult ( node , forNode ( child ) ) ; if ( result == DefinitelyTrue ) { m_branchDirection = TakeTrue ; break ; } if ( result == DefinitelyFalse ) { m_branchDirection = TakeFalse ; break ; } // ▁ FIXME : ▁ The ▁ above ▁ handles ▁ the ▁ trivial ▁ cases ▁ of ▁ sparse ▁ conditional ENDCOM // ▁ constant ▁ propagation , ▁ but ▁ we ▁ can ▁ do ▁ better : ENDCOM // ▁ We ▁ can ▁ specialize ▁ the ▁ source ▁ variable ' s ▁ value ▁ on ▁ each ▁ direction ▁ of ENDCOM // ▁ the ▁ branch . ENDCOM node -> setCanExit ( true ) ; // ▁ This ▁ is ▁ overly ▁ conservative . ENDCOM m_branchDirection = TakeBoth ; break ; } case Return : m_isValid = false ; break ; case Throw : case ThrowReferenceError : m_isValid = false ; node -> setCanExit ( true ) ; break ; case ToPrimitive : { JSValue childConst = forNode ( node -> child1 ( ) ) . value ( ) ; if ( childConst && childConst . isNumber ( ) && trySetConstant ( node , childConst ) ) { m_foundConstants = true ; break ; } ASSERT ( node -> child1 ( ) . useKind ( ) == UntypedUse ) ; AbstractValue & source = forNode ( node -> child1 ( ) ) ; AbstractValue & destination = forNode ( node ) ; // ▁ NB . ▁ The ▁ more ▁ canonical ▁ way ▁ of ▁ writing ▁ this ▁ would ▁ have ▁ been : ENDCOM // ▁ destination ▁ = ▁ source ; ENDCOM // ▁ if ▁ ( destination . m _ type ▁ & ▁ ! ( SpecNumber ▁ | ▁ SpecString ▁ | ▁ SpecBoolean ) ) ▁ { ENDCOM // ▁ destination . filter ( SpecNumber ▁ | ▁ SpecString ▁ | ▁ SpecBoolean ) ; ENDCOM // ▁ AbstractValue ▁ string ; ENDCOM // ▁ string . set ( vm - > stringStructure ) ; ENDCOM // ▁ destination . merge ( string ) ; ENDCOM // ▁ The ▁ reason ▁ why ▁ this ▁ would , ▁ in ▁ most ▁ other ▁ cases , ▁ have ▁ been ▁ better ▁ is ▁ that ENDCOM // ▁ then ▁ destination ▁ would ▁ preserve ▁ any ▁ non - SpeculatedType ▁ knowledge ▁ of ▁ source . ENDCOM // ▁ As ▁ it ▁ stands , ▁ the ▁ code ▁ below ▁ forgets ▁ any ▁ non - SpeculatedType ▁ knowledge ▁ that ENDCOM // ▁ source ▁ would ▁ have ▁ had . ▁ Fortunately , ▁ though , ▁ for ▁ things ▁ like ▁ strings ▁ and ENDCOM // ▁ numbers ▁ and ▁ booleans , ▁ we ▁ don ' t ▁ care ▁ about ▁ the ▁ non - SpeculatedType ▁ knowedge : ENDCOM // ▁ the ▁ structure ▁ won ' t ▁ tell ▁ us ▁ anything ▁ we ▁ don ' t ▁ already ▁ know , ▁ and ▁ neither ENDCOM // ▁ will ▁ ArrayModes . ▁ And ▁ if ▁ the ▁ source ▁ was ▁ a ▁ meaningful ▁ constant ▁ then ▁ we ENDCOM // ▁ would ▁ have ▁ handled ▁ that ▁ above . ▁ Unfortunately , ▁ this ▁ does ▁ mean ▁ that ENDCOM // ▁ ToPrimitive ▁ will ▁ currently ▁ forget ▁ string ▁ constants . ▁ But ▁ that ' s ▁ not ▁ a ▁ big ENDCOM // ▁ deal ▁ since ▁ we ▁ don ' t ▁ do ▁ any ▁ optimization ▁ on ▁ those ▁ currently . ENDCOM clobberWorld ( node -> codeOrigin , indexInBlock ) ; SpeculatedType type = source . m_type ; if ( type & ~ ( SpecNumber | SpecString | SpecBoolean ) ) { type &= ( SpecNumber | SpecString | SpecBoolean ) ; type |= SpecString ; } destination . set ( type ) ; break ; } case ToString : { switch ( node -> child1 ( ) . useKind ( ) ) { case StringObjectUse : // ▁ This ▁ also ▁ filters ▁ that ▁ the ▁ StringObject ▁ has ▁ the ▁ primordial ▁ StringObject ENDCOM // ▁ structure . ENDCOM forNode ( node -> child1 ( ) ) . filter ( m_graph . globalObjectFor ( node -> codeOrigin ) -> stringObjectStructure ( ) ) ; node -> setCanExit ( true ) ; // ▁ We ▁ could ▁ be ▁ more ▁ precise ▁ but ▁ it ' s ▁ likely ▁ not ▁ worth ▁ it . ENDCOM break ; case StringOrStringObjectUse : node -> setCanExit ( true ) ; // ▁ We ▁ could ▁ be ▁ more ▁ precise ▁ but ▁ it ' s ▁ likely ▁ not ▁ worth ▁ it . ENDCOM break ; case CellUse : case UntypedUse : clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case NewStringObject : { ASSERT ( node -> structure ( ) -> classInfo ( ) == & StringObject :: s_info ) ; forNode ( node ) . set ( node -> structure ( ) ) ; break ; } case NewArray : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> arrayStructureForIndexingTypeDuringAllocation ( node -> indexingType ( ) ) ) ; m_haveStructures = true ; break ; case NewArrayBuffer : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> arrayStructureForIndexingTypeDuringAllocation ( node -> indexingType ( ) ) ) ; m_haveStructures = true ; break ; case NewArrayWithSize : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecArray ) ; m_haveStructures = true ; break ; case NewRegexp : forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> regExpStructure ( ) ) ; m_haveStructures = true ; break ; case ConvertThis : { AbstractValue & source = forNode ( node -> child1 ( ) ) ; AbstractValue & destination = forNode ( node ) ; destination = source ; destination . merge ( SpecObjectOther ) ; break ; } case CreateThis : { forNode ( node ) . set ( SpecFinalObject ) ; break ; } case AllocationProfileWatchpoint : node -> setCanExit ( true ) ; break ; case NewObject : forNode ( node ) . set ( node -> structure ( ) ) ; m_haveStructures = true ; break ; case CreateActivation : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> activationStructure ( ) ) ; m_haveStructures = true ; break ; case CreateArguments : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> argumentsStructure ( ) ) ; m_haveStructures = true ; break ; case TearOffActivation : case TearOffArguments : // ▁ Does ▁ nothing ▁ that ▁ is ▁ user - visible . ENDCOM break ; case CheckArgumentsNotCreated : if ( isEmptySpeculation ( m_variables . operand ( m_graph . argumentsRegisterFor ( node -> codeOrigin ) ) . m_type ) ) m_foundConstants = true ; else node -> setCanExit ( true ) ; break ; case GetMyArgumentsLength : // ▁ We ▁ know ▁ that ▁ this ▁ executable ▁ does ▁ not ▁ escape ▁ its ▁ arguments , ▁ so ▁ we ▁ can ▁ optimize ENDCOM // ▁ the ▁ arguments ▁ a ▁ bit . ▁ Note ▁ that ▁ this ▁ is ▁ not ▁ sufficient ▁ to ▁ force ▁ constant ▁ folding ENDCOM // ▁ of ▁ GetMyArgumentsLength , ▁ because ▁ GetMyArgumentsLength ▁ is ▁ a ▁ clobbering ▁ operation . ENDCOM // ▁ We ▁ perform ▁ further ▁ optimizations ▁ on ▁ this ▁ later ▁ on . ENDCOM if ( node -> codeOrigin . inlineCallFrame ) forNode ( node ) . set ( jsNumber ( node -> codeOrigin . inlineCallFrame -> arguments . size ( ) - 1 ) ) ; else forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( ! isEmptySpeculation ( m_variables . operand ( m_graph . argumentsRegisterFor ( node -> codeOrigin ) ) . m_type ) ) ; break ; case GetMyArgumentsLengthSafe : // ▁ This ▁ potentially ▁ clobbers ▁ all ▁ structures ▁ if ▁ the ▁ arguments ▁ object ▁ had ▁ a ▁ getter ENDCOM // ▁ installed ▁ on ▁ the ▁ length ▁ property . ENDCOM clobberWorld ( node -> codeOrigin , indexInBlock ) ; // ▁ We ▁ currently ▁ make ▁ no ▁ guarantee ▁ about ▁ what ▁ this ▁ returns ▁ because ▁ it ▁ does ▁ not ENDCOM // ▁ speculate ▁ that ▁ the ▁ length ▁ property ▁ is ▁ actually ▁ a ▁ length . ENDCOM forNode ( node ) . makeTop ( ) ; break ; case GetMyArgumentByVal : node -> setCanExit ( true ) ; // ▁ We ▁ know ▁ that ▁ this ▁ executable ▁ does ▁ not ▁ escape ▁ its ▁ arguments , ▁ so ▁ we ▁ can ▁ optimize ENDCOM // ▁ the ▁ arguments ▁ a ▁ bit . ▁ Note ▁ that ▁ this ▁ ends ▁ up ▁ being ▁ further ▁ optimized ▁ by ▁ the ENDCOM // ▁ ArgumentsSimplificationPhase . ENDCOM forNode ( node ) . makeTop ( ) ; break ; case GetMyArgumentByValSafe : node -> setCanExit ( true ) ; // ▁ This ▁ potentially ▁ clobbers ▁ all ▁ structures ▁ if ▁ the ▁ property ▁ we ' re ▁ accessing ▁ has ENDCOM // ▁ a ▁ getter . ▁ We ▁ don ' t ▁ speculate ▁ against ▁ this . ENDCOM clobberWorld ( node -> codeOrigin , indexInBlock ) ; // ▁ And ▁ the ▁ result ▁ is ▁ unknown . ENDCOM forNode ( node ) . makeTop ( ) ; break ; case NewFunction : { AbstractValue & value = forNode ( node ) ; value = forNode ( node -> child1 ( ) ) ; if ( ! ( value . m_type & SpecEmpty ) ) { m_foundConstants = true ; break ; } value . set ( ( value . m_type & ~ SpecEmpty ) | SpecFunction ) ; break ; } case NewFunctionExpression : case NewFunctionNoCheck : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> functionStructure ( ) ) ; break ; case GetCallee : forNode ( node ) . set ( SpecFunction ) ; break ; case SetCallee : case SetMyScope : break ; case GetScope : // ▁ FIXME : ▁ We ▁ could ▁ get ▁ rid ▁ of ▁ these ▁ if ▁ we ▁ know ▁ that ▁ the ▁ JSFunction ▁ is ▁ a ▁ constant . ▁ https : // bugs . webkit . org / show _ bug . cgi ? id = 106202 ENDCOM case GetMyScope : case SkipTopScope : forNode ( node ) . set ( SpecCellOther ) ; break ; case SkipScope : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && trySetConstant ( node , JSValue ( jsCast < JSScope * > ( child . asCell ( ) ) -> next ( ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecCellOther ) ; break ; } case GetScopeRegisters : forNode ( node ) . clear ( ) ; // ▁ The ▁ result ▁ is ▁ not ▁ a ▁ JS ▁ value . ENDCOM break ; case GetScopedVar : forNode ( node ) . makeTop ( ) ; break ; case PutScopedVar : clobberCapturedVars ( node -> codeOrigin ) ; break ; case GetById : case GetByIdFlush : node -> setCanExit ( true ) ; if ( ! node -> prediction ( ) ) { m_isValid = false ; break ; } if ( isCellSpeculation ( node -> child1 ( ) -> prediction ( ) ) ) { if ( Structure * structure = forNode ( node -> child1 ( ) ) . bestProvenStructure ( ) ) { GetByIdStatus status = GetByIdStatus :: computeFor ( m_graph . m_vm , structure , m_graph . m_codeBlock -> identifier ( node -> identifierNumber ( ) ) ) ; if ( status . isSimple ( ) ) { // ▁ Assert ▁ things ▁ that ▁ we ▁ can ' t ▁ handle ▁ and ▁ that ▁ the ▁ computeFor ( ) ▁ method ENDCOM // ▁ above ▁ won ' t ▁ be ▁ able ▁ to ▁ return . ENDCOM ASSERT ( status . structureSet ( ) . size ( ) == 1 ) ; ASSERT ( status . chain ( ) . isEmpty ( ) ) ; if ( status . specificValue ( ) ) forNode ( node ) . set ( status . specificValue ( ) ) ; else forNode ( node ) . makeTop ( ) ; forNode ( node -> child1 ( ) ) . filter ( status . structureSet ( ) ) ; m_foundConstants = true ; break ; } } } clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GetArrayLength : node -> setCanExit ( true ) ; // ▁ Lies , ▁ but ▁ it ' s ▁ true ▁ for ▁ the ▁ common ▁ case ▁ of ▁ JSArray , ▁ so ▁ it ' s ▁ good ▁ enough . ENDCOM forNode ( node ) . set ( SpecInt32 ) ; break ; case CheckExecutable : { // ▁ FIXME : ▁ We ▁ could ▁ track ▁ executables ▁ in ▁ AbstractValue , ▁ which ▁ would ▁ allow ▁ us ▁ to ▁ get ▁ rid ▁ of ▁ these ▁ checks ENDCOM // ▁ more ▁ thoroughly . ▁ https : // bugs . webkit . org / show _ bug . cgi ? id = 106200 ENDCOM // ▁ FIXME : ▁ We ▁ could ▁ eliminate ▁ these ▁ entirely ▁ if ▁ we ▁ know ▁ the ▁ exact ▁ value ▁ that ▁ flows ▁ into ▁ this . ENDCOM // ▁ https : // bugs . webkit . org / show _ bug . cgi ? id = 106201 ENDCOM node -> setCanExit ( true ) ; break ; } case CheckStructure : case ForwardCheckStructure : { // ▁ FIXME : ▁ We ▁ should ▁ be ▁ able ▁ to ▁ propagate ▁ the ▁ structure ▁ sets ▁ of ▁ constants ▁ ( i . e . ▁ prototypes ) . ENDCOM AbstractValue & value = forNode ( node -> child1 ( ) ) ; ASSERT ( ! ( value . m_type & ~ SpecCell ) ) ; // ▁ Edge ▁ filtering ▁ should ▁ have ▁ already ▁ ensured ▁ this . ENDCOM // ▁ If ▁ this ▁ structure ▁ check ▁ is ▁ attempting ▁ to ▁ prove ▁ knowledge ▁ already ▁ held ▁ in ENDCOM // ▁ the ▁ futurePossibleStructure ▁ set ▁ then ▁ the ▁ constant ▁ folding ▁ phase ▁ should ENDCOM // ▁ turn ▁ this ▁ into ▁ a ▁ watchpoint ▁ instead . ENDCOM StructureSet & set = node -> structureSet ( ) ; if ( value . m_futurePossibleStructure . isSubsetOf ( set ) || value . m_currentKnownStructure . isSubsetOf ( set ) ) m_foundConstants = true ; if ( ! value . m_currentKnownStructure . isSubsetOf ( set ) ) node -> setCanExit ( true ) ; value . filter ( set ) ; m_haveStructures = true ; break ; } case StructureTransitionWatchpoint : case ForwardStructureTransitionWatchpoint : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; // ▁ It ' s ▁ only ▁ valid ▁ to ▁ issue ▁ a ▁ structure ▁ transition ▁ watchpoint ▁ if ▁ we ▁ already ENDCOM // ▁ know ▁ that ▁ the ▁ watchpoint ▁ covers ▁ a ▁ superset ▁ of ▁ the ▁ structures ▁ known ▁ to ENDCOM // ▁ belong ▁ to ▁ the ▁ set ▁ of ▁ future ▁ structures ▁ that ▁ this ▁ value ▁ may ▁ have . ENDCOM // ▁ Currently , ▁ we ▁ only ▁ issue ▁ singleton ▁ watchpoints ▁ ( that ▁ check ▁ one ▁ structure ) ENDCOM // ▁ and ▁ our ▁ futurePossibleStructure ▁ set ▁ can ▁ only ▁ contain ▁ zero , ▁ one , ▁ or ▁ an ENDCOM // ▁ infinity ▁ of ▁ structures . ENDCOM ASSERT ( value . m_futurePossibleStructure . isSubsetOf ( StructureSet ( node -> structure ( ) ) ) ) ; value . filter ( node -> structure ( ) ) ; m_haveStructures = true ; node -> setCanExit ( true ) ; break ; } case PutStructure : case PhantomPutStructure : if ( ! forNode ( node -> child1 ( ) ) . m_currentKnownStructure . isClear ( ) ) { clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . set ( node -> structureTransitionData ( ) . newStructure ) ; m_haveStructures = true ; } break ; case GetButterfly : case AllocatePropertyStorage : case ReallocatePropertyStorage : forNode ( node ) . clear ( ) ; // ▁ The ▁ result ▁ is ▁ not ▁ a ▁ JS ▁ value . ENDCOM break ; case CheckArray : { if ( node -> arrayMode ( ) . alreadyChecked ( m_graph , node , forNode ( node -> child1 ( ) ) ) ) { m_foundConstants = true ; break ; } node -> setCanExit ( true ) ; // ▁ Lies , ▁ but ▁ this ▁ is ▁ followed ▁ by ▁ operations ▁ ( like ▁ GetByVal ) ▁ that ▁ always ▁ exit , ▁ so ▁ there ▁ is ▁ no ▁ point ▁ in ▁ us ▁ trying ▁ to ▁ be ▁ clever ▁ here . ENDCOM switch ( node -> arrayMode ( ) . type ( ) ) { case Array :: String : forNode ( node -> child1 ( ) ) . filter ( SpecString ) ; break ; case Array :: Int32 : case Array :: Double : case Array :: Contiguous : case Array :: ArrayStorage : case Array :: SlowPutArrayStorage : break ; case Array :: Arguments : forNode ( node -> child1 ( ) ) . filter ( SpecArguments ) ; break ; case Array :: Int8Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt8Array ) ; break ; case Array :: Int16Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt16Array ) ; break ; case Array :: Int32Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt32Array ) ; break ; case Array :: Uint8Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint8Array ) ; break ; case Array :: Uint8ClampedArray : forNode ( node -> child1 ( ) ) . filter ( SpecUint8ClampedArray ) ; break ; case Array :: Uint16Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint16Array ) ; break ; case Array :: Uint32Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint32Array ) ; break ; case Array :: Float32Array : forNode ( node -> child1 ( ) ) . filter ( SpecFloat32Array ) ; break ; case Array :: Float64Array : forNode ( node -> child1 ( ) ) . filter ( SpecFloat64Array ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node -> child1 ( ) ) . filterArrayModes ( node -> arrayMode ( ) . arrayModesThatPassFiltering ( ) ) ; m_haveStructures = true ; break ; } case Arrayify : { if ( node -> arrayMode ( ) . alreadyChecked ( m_graph , node , forNode ( node -> child1 ( ) ) ) ) { m_foundConstants = true ; break ; } ASSERT ( node -> arrayMode ( ) . conversion ( ) == Array :: Convert || node -> arrayMode ( ) . conversion ( ) == Array :: RageConvert ) ; node -> setCanExit ( true ) ; clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . filterArrayModes ( node -> arrayMode ( ) . arrayModesThatPassFiltering ( ) ) ; m_haveStructures = true ; break ; } case ArrayifyToStructure : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; StructureSet set = node -> structure ( ) ; if ( value . m_futurePossibleStructure . isSubsetOf ( set ) || value . m_currentKnownStructure . isSubsetOf ( set ) ) m_foundConstants = true ; node -> setCanExit ( true ) ; clobberStructures ( indexInBlock ) ; value . filter ( set ) ; m_haveStructures = true ; break ; } case GetIndexedPropertyStorage : { forNode ( node ) . clear ( ) ; break ; } case GetByOffset : { forNode ( node ) . makeTop ( ) ; break ; } case PutByOffset : { break ; } case CheckFunction : { JSValue value = forNode ( node -> child1 ( ) ) . value ( ) ; if ( value == node -> function ( ) ) { m_foundConstants = true ; ASSERT ( value ) ; break ; } node -> setCanExit ( true ) ; // ▁ Lies ! ▁ We ▁ can ▁ do ▁ better . ENDCOM forNode ( node -> child1 ( ) ) . filterByValue ( node -> function ( ) ) ; break ; } case PutById : case PutByIdDirect : node -> setCanExit ( true ) ; if ( Structure * structure = forNode ( node -> child1 ( ) ) . bestProvenStructure ( ) ) { PutByIdStatus status = PutByIdStatus :: computeFor ( m_graph . m_vm , m_graph . globalObjectFor ( node -> codeOrigin ) , structure , m_graph . m_codeBlock -> identifier ( node -> identifierNumber ( ) ) , node -> op ( ) == PutByIdDirect ) ; if ( status . isSimpleReplace ( ) ) { forNode ( node -> child1 ( ) ) . filter ( structure ) ; m_foundConstants = true ; break ; } if ( status . isSimpleTransition ( ) ) { clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . set ( status . newStructure ( ) ) ; m_haveStructures = true ; m_foundConstants = true ; break ; } } clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case GetGlobalVar : forNode ( node ) . makeTop ( ) ; break ; case GlobalVarWatchpoint : node -> setCanExit ( true ) ; break ; case PutGlobalVar : case PutGlobalVarCheck : break ; case CheckHasInstance : node -> setCanExit ( true ) ; // ▁ Sadly , ▁ we ▁ don ' t ▁ propagate ▁ the ▁ fact ▁ that ▁ we ' ve ▁ done ▁ CheckHasInstance ENDCOM break ; case InstanceOf : node -> setCanExit ( true ) ; // ▁ Again , ▁ sadly , ▁ we ▁ don ' t ▁ propagate ▁ the ▁ fact ▁ that ▁ we ' ve ▁ done ▁ InstanceOf ENDCOM forNode ( node ) . set ( SpecBoolean ) ; break ; case Phi : case Flush : case PhantomLocal : case Breakpoint : break ; case Call : case Construct : case Resolve : case ResolveBase : case ResolveBaseStrictPut : case ResolveGlobal : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GarbageValue : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case ForceOSRExit : node -> setCanExit ( true ) ; m_isValid = false ; break ; case CheckWatchdogTimer : node -> setCanExit ( true ) ; break ; case Phantom : case InlineStart : case Nop : case CountExecution : break ; case LastNodeType : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } return m_isValid ; } bool AbstractState :: executeEffects ( unsigned indexInBlock ) { return executeEffects ( indexInBlock , m_block -> at ( indexInBlock ) ) ; } bool AbstractState :: execute ( unsigned indexInBlock ) { Node * node = m_block -> at ( indexInBlock ) ; if ( ! startExecuting ( node ) ) return true ; executeEdges ( node ) ; return executeEffects ( indexInBlock , node ) ; } inline void AbstractState :: clobberWorld ( const CodeOrigin & codeOrigin , unsigned indexInBlock ) { clobberCapturedVars ( codeOrigin ) ; clobberStructures ( indexInBlock ) ; } inline void AbstractState :: clobberCapturedVars ( const CodeOrigin & codeOrigin ) { if ( codeOrigin . inlineCallFrame ) { const BitVector & capturedVars = codeOrigin . inlineCallFrame -> capturedVars ; for ( size_t i = capturedVars . size ( ) ; i -- ; ) { if ( ! capturedVars . quickGet ( i ) ) continue ; m_variables . local ( i ) . makeTop ( ) ; } } else { for ( size_t i = m_codeBlock -> m_numVars ; i -- ; ) { if ( m_codeBlock -> isCaptured ( i ) ) m_variables . local ( i ) . makeTop ( ) ; } } for ( size_t i = m_variables . numberOfArguments ( ) ; i -- ; ) { if ( m_codeBlock -> isCaptured ( argumentToOperand ( i ) ) ) m_variables . argument ( i ) . makeTop ( ) ; } } inline void AbstractState :: clobberStructures ( unsigned indexInBlock ) { if ( ! m_haveStructures ) return ; for ( size_t i = indexInBlock + 1 ; i -- ; ) forNode ( m_block -> at ( i ) ) . clobberStructures ( ) ; for ( size_t i = m_variables . numberOfArguments ( ) ; i -- ; ) m_variables . argument ( i ) . clobberStructures ( ) ; for ( size_t i = m_variables . numberOfLocals ( ) ; i -- ; ) m_variables . local ( i ) . clobberStructures ( ) ; m_haveStructures = false ; m_didClobber = true ; } inline bool AbstractState :: mergeStateAtTail ( AbstractValue & destination , AbstractValue & inVariable , Node * node ) { if ( ! node ) return false ; AbstractValue source ; if ( node -> variableAccessData ( ) -> isCaptured ( ) ) { // ▁ If ▁ it ' s ▁ captured ▁ then ▁ we ▁ know ▁ that ▁ whatever ▁ value ▁ was ▁ stored ▁ into ▁ the ▁ variable ▁ last ▁ is ▁ the ENDCOM // ▁ one ▁ we ▁ care ▁ about . ▁ This ▁ is ▁ true ▁ even ▁ if ▁ the ▁ variable ▁ at ▁ tail ▁ is ▁ dead , ▁ which ▁ might ▁ happen ▁ if ENDCOM // ▁ the ▁ last ▁ thing ▁ we ▁ did ▁ to ▁ the ▁ variable ▁ was ▁ a ▁ GetLocal ▁ and ▁ then ▁ ended ▁ up ▁ now ▁ using ▁ the ENDCOM // ▁ GetLocal ' s ▁ result . ENDCOM source = inVariable ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Transfering ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " ▁ from ▁ last ▁ access ▁ due ▁ to ▁ captured ▁ variable . \n " ) ; # endif } else { # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ It ' s ▁ live , ▁ node ▁ @ % u . \n " , node -> index ( ) ) ; # endif switch ( node -> op ( ) ) { case Phi : case SetArgument : case PhantomLocal : case Flush : // ▁ The ▁ block ▁ transfers ▁ the ▁ value ▁ from ▁ head ▁ to ▁ tail . ENDCOM source = inVariable ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Transfering ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " ▁ from ▁ head ▁ to ▁ tail . \n " ) ; # endif break ; case GetLocal : // ▁ The ▁ block ▁ refines ▁ the ▁ value ▁ with ▁ additional ▁ speculations . ENDCOM source = forNode ( node ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Refining ▁ to ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; # endif break ; case SetLocal : // ▁ The ▁ block ▁ sets ▁ the ▁ variable , ▁ and ▁ potentially ▁ refines ▁ it , ▁ both ENDCOM // ▁ before ▁ and ▁ after ▁ setting ▁ it . ENDCOM if ( node -> variableAccessData ( ) -> shouldUseDoubleFormat ( ) ) { // ▁ FIXME : ▁ This ▁ unnecessarily ▁ loses ▁ precision . ENDCOM source . set ( SpecDouble ) ; } else source = forNode ( node -> child1 ( ) ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Setting ▁ to ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; # endif break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } } if ( destination == source ) { // ▁ Abstract ▁ execution ▁ did ▁ not ▁ change ▁ the ▁ output ▁ value ▁ of ▁ the ▁ variable , ▁ for ▁ this ENDCOM // ▁ basic ▁ block , ▁ on ▁ this ▁ iteration . ENDCOM # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Not ▁ changed ! \n " ) ; # endif return false ; } // ▁ Abstract ▁ execution ▁ reached ▁ a ▁ new ▁ conclusion ▁ about ▁ the ▁ speculations ▁ reached ▁ about ENDCOM // ▁ this ▁ variable ▁ after ▁ execution ▁ of ▁ this ▁ basic ▁ block . ▁ Update ▁ the ▁ state , ▁ and ▁ return ENDCOM // ▁ true ▁ to ▁ indicate ▁ that ▁ the ▁ fixpoint ▁ must ▁ go ▁ on ! ENDCOM destination = source ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Changed ! \n " ) ; # endif return true ; } inline bool AbstractState :: merge ( BasicBlock * from , BasicBlock * to ) { ASSERT ( from -> variablesAtTail . numberOfArguments ( ) == to -> variablesAtHead . numberOfArguments ( ) ) ; ASSERT ( from -> variablesAtTail . numberOfLocals ( ) == to -> variablesAtHead . numberOfLocals ( ) ) ; bool changed = false ; for ( size_t argument = 0 ; argument < from -> variablesAtTail . numberOfArguments ( ) ; ++ argument ) { AbstractValue & destination = to -> valuesAtHead . argument ( argument ) ; changed |= mergeVariableBetweenBlocks ( destination , from -> valuesAtTail . argument ( argument ) , to -> variablesAtHead . argument ( argument ) , from -> variablesAtTail . argument ( argument ) ) ; } for ( size_t local = 0 ; local < from -> variablesAtTail . numberOfLocals ( ) ; ++ local ) { AbstractValue & destination = to -> valuesAtHead . local ( local ) ; changed |= mergeVariableBetweenBlocks ( destination , from -> valuesAtTail . local ( local ) , to -> variablesAtHead . local ( local ) , from -> variablesAtTail . local ( local ) ) ; } if ( ! to -> cfaHasVisited ) changed = true ; to -> cfaShouldRevisit |= changed ; return changed ; } inline bool AbstractState :: mergeToSuccessors ( Graph & graph , BasicBlock * basicBlock ) { Node * terminal = basicBlock -> last ( ) ; ASSERT ( terminal -> isTerminal ( ) ) ; switch ( terminal -> op ( ) ) { case Jump : { ASSERT ( basicBlock -> cfaBranchDirection == InvalidBranchDirection ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> takenBlockIndex ( ) ) ; # endif return merge ( basicBlock , graph . m_blocks [ terminal -> takenBlockIndex ( ) ] . get ( ) ) ; } case Branch : { ASSERT ( basicBlock -> cfaBranchDirection != InvalidBranchDirection ) ; bool changed = false ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> takenBlockIndex ( ) ) ; # endif if ( basicBlock -> cfaBranchDirection != TakeFalse ) changed |= merge ( basicBlock , graph . m_blocks [ terminal -> takenBlockIndex ( ) ] . get ( ) ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> notTakenBlockIndex ( ) ) ; # endif if ( basicBlock -> cfaBranchDirection != TakeTrue ) changed |= merge ( basicBlock , graph . m_blocks [ terminal -> notTakenBlockIndex ( ) ] . get ( ) ) ; return changed ; } case Return : case Throw : case ThrowReferenceError : ASSERT ( basicBlock -> cfaBranchDirection == InvalidBranchDirection ) ; return false ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; return false ; } } inline bool AbstractState :: mergeVariableBetweenBlocks ( AbstractValue & destination , AbstractValue & source , Node * destinationNode , Node * sourceNode ) { if ( ! destinationNode ) return false ; ASSERT_UNUSED ( sourceNode , sourceNode ) ; // ▁ FIXME : ▁ We ▁ could ▁ do ▁ some ▁ sparse ▁ conditional ▁ propagation ▁ here ! ENDCOM return destination . merge ( source ) ; } void AbstractState :: dump ( PrintStream & out ) { bool first = true ; for ( size_t i = 0 ; i < m_block -> size ( ) ; ++ i ) { Node * node = m_block -> at ( i ) ; AbstractValue & value = forNode ( node ) ; if ( value . isClear ( ) ) continue ; if ( first ) first = false ; else out . printf ( " ▁ " ) ; out . printf ( " @ % lu : " , static_cast < unsigned long > ( node -> index ( ) ) ) ; value . dump ( out ) ; } } } } // ▁ namespace ▁ JSC : : DFG ENDCOM # endif // ▁ ENABLE ( DFG _ JIT ) ENDCOM </DOCUMENT>
<DOCUMENT_ID="Maximus-/WinObjC/tree/master/deps/3rdparty/icu/icu/source/layout/TibetanReordering.cpp"> /* STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ ( C ) ▁ Copyright ▁ IBM ▁ Corp . ▁ 1998-2007 ▁ - ▁ All ▁ Rights ▁ Reserved ▁ STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Developed ▁ at ▁ DIT ▁ - ▁ Government ▁ of ▁ Bhutan STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Contact ▁ person : ▁ Pema ▁ Geyleg ▁ - ▁ < pema _ geyleg @ druknet . bt > ▁ STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ file ▁ is ▁ a ▁ modification ▁ of ▁ the ▁ ICU ▁ file ▁ KhmerReordering . cpp STRNEWLINE ▁ * ▁ by ▁ Jens ▁ Herden ▁ and ▁ Javier ▁ Sola ▁ who ▁ have ▁ given ▁ all ▁ their ▁ possible ▁ rights ▁ to ▁ IBM ▁ and ▁ the ▁ Governement ▁ of ▁ Bhutan STRNEWLINE ▁ * ▁ A ▁ first ▁ module ▁ for ▁ Dzongkha ▁ was ▁ developed ▁ by ▁ Karunakar ▁ under ▁ Panlocalisation ▁ funding . STRNEWLINE ▁ * ▁ Assistance ▁ for ▁ this ▁ module ▁ has ▁ been ▁ received ▁ from ▁ Namgay ▁ Thinley , ▁ Christopher ▁ Fynn ▁ and ▁ Javier ▁ Sola STRNEWLINE ▁ * STRNEWLINE ▁ */ // # include ▁ < stdio . h > ENDCOM # include " LETypes . h " # include " OpenTypeTables . h " # include " TibetanReordering . h " # include " LEGlyphStorage . h " U_NAMESPACE_BEGIN // ▁ Characters ▁ that ▁ get ▁ refered ▁ to ▁ by ▁ name . . . ENDCOM enum { C_DOTTED_CIRCLE = 0x25CC , C_PRE_NUMBER_MARK = 0x0F3F } ; enum { // ▁ simple ▁ classes , ▁ they ▁ are ▁ used ▁ in ▁ the ▁ statetable ▁ ( in ▁ this ▁ file ) ▁ to ▁ control ▁ the ▁ length ▁ of ▁ a ▁ syllable ENDCOM // ▁ they ▁ are ▁ also ▁ used ▁ to ▁ know ▁ where ▁ a ▁ character ▁ should ▁ be ▁ placed ▁ ( location ▁ in ▁ reference ▁ to ▁ the ▁ base ▁ character ) ENDCOM // ▁ and ▁ also ▁ to ▁ know ▁ if ▁ a ▁ character , ▁ when ▁ independtly ▁ displayed , ▁ should ▁ be ▁ displayed ▁ with ▁ a ▁ dotted - circle ▁ to ENDCOM // ▁ indicate ▁ error ▁ in ▁ syllable ▁ construction ▁ ENDCOM _xx = TibetanClassTable :: CC_RESERVED , _ba = TibetanClassTable :: CC_BASE , _sj = TibetanClassTable :: CC_SUBJOINED | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _tp = TibetanClassTable :: CC_TSA_PHRU | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _ac = TibetanClassTable :: CC_A_CHUNG | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _cs = TibetanClassTable :: CC_COMP_SANSKRIT | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _ha = TibetanClassTable :: CC_HALANTA | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _bv = TibetanClassTable :: CC_BELOW_VOWEL | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _av = TibetanClassTable :: CC_ABOVE_VOWEL | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _an = TibetanClassTable :: CC_ANUSVARA | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _cb = TibetanClassTable :: CC_CANDRABINDU | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _vs = TibetanClassTable :: CC_VISARGA | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_AFTER , _as = TibetanClassTable :: CC_ABOVE_S_MARK | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _bs = TibetanClassTable :: CC_BELOW_S_MARK | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _di = TibetanClassTable :: CC_DIGIT | TibetanClassTable :: CF_DIGIT , _pd = TibetanClassTable :: CC_PRE_DIGIT_MARK | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_PREDIGIT | TibetanClassTable :: CF_POS_BEFORE , _bd = TibetanClassTable :: CC_POST_BELOW_DIGIT_M | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_AFTER } ; // ▁ Character ▁ class ▁ tables ▁ ENDCOM // _ xx ▁ Non ▁ Combining ▁ characters ENDCOM // _ ba ▁ Base ▁ Consonants ENDCOM // _ sj ▁ Subjoined ▁ consonants ENDCOM // _ tp ▁ Tsa ▁ - ▁ phru ENDCOM // _ ac ▁ A - chung , ▁ Vowel ▁ Lengthening ▁ mark ENDCOM // _ cs ▁ Precomposed ▁ Sanskrit ▁ vowel ▁ + ▁ subjoined ▁ consonants ENDCOM // _ ha ▁ Halanta / Virama ENDCOM // _ bv ▁ Below ▁ vowel ENDCOM // _ av ▁ above ▁ vowel ENDCOM // _ an ▁ Anusvara ENDCOM // _ cb ▁ Candrabindu ENDCOM // _ vs ▁ Visaraga / Post ▁ mark ENDCOM // _ as ▁ Upper ▁ Stress ▁ marks ENDCOM // _ bs ▁ Lower ▁ Stress ▁ marks ENDCOM // _ di ▁ Digit ENDCOM // _ pd ▁ Number ▁ pre ▁ combining , ▁ Needs ▁ reordering ENDCOM // _ bd ▁ Other ▁ number ▁ combining ▁ marks ENDCOM static const TibetanClassTable :: CharClass tibetanCharClasses [ ] = { // ▁ 0 ▁ 1 ▁ 2 ▁ 3 ▁ 4 ▁ 5 ▁ 6 ▁ 7 ▁ 8 ▁ 9 ▁ a ▁ b ▁ c ▁ d ▁ e ▁ f ENDCOM _xx , _ba , _xx , _xx , _ba , _ba , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , // ▁ 0F00 ▁ - ▁ 0F0F ▁ 0 ENDCOM _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _bd , _bd , _xx , _xx , _xx , _xx , _xx , _xx , // ▁ 0F10 ▁ - ▁ 0F1F ▁ 1 ENDCOM _di , _di , _di , _di , _di , _di , _di , _di , _di , _di , _xx , _xx , _xx , _xx , _xx , _xx , // ▁ 0F20 ▁ - ▁ 0F2F ▁ 2 ▁ ENDCOM _xx , _xx , _xx , _xx , _xx , _bs , _xx , _bs , _xx , _tp , _xx , _xx , _xx , _xx , _bd , _pd , // ▁ 0F30 ▁ - ▁ 0F3F ▁ 3 ▁ ENDCOM _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _xx , _ba , _ba , _ba , _ba , _ba , _ba , _ba , // ▁ 0F40 ▁ - ▁ 0F4F ▁ 4 ENDCOM _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , // ▁ 0F50 ▁ - ▁ 0F5F ▁ 5 ENDCOM _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _xx , _xx , _xx , _xx , _xx , // ▁ 0F60 ▁ - ▁ 0F6F ▁ 6 ENDCOM _xx , _ac , _av , _cs , _bv , _bv , _cs , _cs , _cs , _cs , _av , _av , _av , _av , _an , _vs , // ▁ 0F70 ▁ - ▁ 0F7F ▁ 7 ENDCOM _av , _cs , _cb , _cb , _ha , _xx , _as , _as , _ba , _ba , _ba , _ba , _xx , _xx , _xx , _xx , // ▁ 0F80 ▁ - ▁ 0F8F ▁ 8 ENDCOM _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _xx , _sj , _sj , _sj , _sj , _sj , _sj , _sj , // ▁ 0F90 ▁ - ▁ 0F9F ▁ 9 ENDCOM _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , // ▁ 0FA0 ▁ - ▁ 0FAF ▁ a ENDCOM _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _xx , _sj , _sj , // ▁ 0FB0 ▁ - ▁ 0FBF ▁ b ENDCOM _xx , _xx , _xx , _xx , _xx , _xx , _bs , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , // ▁ 0FC0 ▁ - ▁ 0FCF ▁ c ENDCOM _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , // ▁ 0FD0 ▁ - ▁ 0FDF ▁ d ENDCOM _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , // ▁ 0FE0 ▁ - ▁ 0FEF ▁ e ENDCOM _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , // ▁ 0FF0 ▁ - ▁ 0FFF ▁ f ▁ ENDCOM } ; // ▁ Tibetan ▁ Class ▁ Tables ENDCOM // ▁ The ▁ range ▁ of ▁ characters ▁ defined ▁ in ▁ the ▁ above ▁ table ▁ is ▁ defined ▁ here . ▁ For ▁ Tibetan ▁ 0F00 ▁ to ▁ 0FFF ENDCOM // ▁ Even ▁ if ▁ the ▁ Tibetan ▁ range ▁ is ▁ bigger , ▁ most ▁ of ▁ the ▁ characters ▁ are ▁ not ▁ combinable , ▁ and ▁ therefore ▁ treated ENDCOM // ▁ as ▁ _ xx ENDCOM static const TibetanClassTable tibetanClassTable = { 0x0F00 , 0x0FFF , tibetanCharClasses } ; // ▁ Below ▁ we ▁ define ▁ how ▁ a ▁ character ▁ in ▁ the ▁ input ▁ string ▁ is ▁ either ▁ in ▁ the ▁ tibetanCharClasses ▁ table ENDCOM // ▁ ( in ▁ which ▁ case ▁ we ▁ get ▁ its ▁ type ▁ back ) , ▁ or ▁ an ▁ unknown ▁ object ▁ in ▁ which ▁ case ▁ we ▁ get ▁ _ xx ▁ ( CC _ RESERVED ) ▁ back ENDCOM TibetanClassTable :: CharClass TibetanClassTable :: getCharClass ( LEUnicode ch ) const { if ( ch < firstChar || ch > lastChar ) { return CC_RESERVED ; } return classTable [ ch - firstChar ] ; } const TibetanClassTable * TibetanClassTable :: getTibetanClassTable ( ) { return & tibetanClassTable ; } class TibetanReorderingOutput : public UMemory { private : le_int32 fSyllableCount ; le_int32 fOutIndex ; LEUnicode * fOutChars ; LEGlyphStorage & fGlyphStorage ; public : TibetanReorderingOutput ( LEUnicode * outChars , LEGlyphStorage & glyphStorage ) : fSyllableCount ( 0 ) , fOutIndex ( 0 ) , fOutChars ( outChars ) , fGlyphStorage ( glyphStorage ) { // ▁ nothing ▁ else ▁ to ▁ do . . . ENDCOM } ~ TibetanReorderingOutput ( ) { // ▁ nothing ▁ to ▁ do ▁ here . . . ENDCOM } void reset ( ) { fSyllableCount += 1 ; } void writeChar ( LEUnicode ch , le_uint32 charIndex , FeatureMask featureMask ) { LEErrorCode success = LE_NO_ERROR ; fOutChars [ fOutIndex ] = ch ; fGlyphStorage . setCharIndex ( fOutIndex , charIndex , success ) ; fGlyphStorage . setAuxData ( fOutIndex , featureMask , success ) ; fOutIndex += 1 ; } le_int32 getOutputIndex ( ) { return fOutIndex ; } } ; // TODO ▁ remove ▁ unused ▁ flags ENDCOM # define ccmpFeatureTag LE_CCMP_FEATURE_TAG # define blwfFeatureTag LE_BLWF_FEATURE_TAG # define pstfFeatureTag LE_PSTF_FEATURE_TAG # define presFeatureTag LE_PRES_FEATURE_TAG # define blwsFeatureTag LE_BLWS_FEATURE_TAG # define abvsFeatureTag LE_ABVS_FEATURE_TAG # define pstsFeatureTag LE_PSTS_FEATURE_TAG # define blwmFeatureTag LE_BLWM_FEATURE_TAG # define abvmFeatureTag LE_ABVM_FEATURE_TAG # define distFeatureTag LE_DIST_FEATURE_TAG # define prefFeatureTag LE_PREF_FEATURE_TAG # define abvfFeatureTag LE_ABVF_FEATURE_TAG # define cligFeatureTag LE_CLIG_FEATURE_TAG # define mkmkFeatureTag LE_MKMK_FEATURE_TAG // ▁ Shaping ▁ features ENDCOM # define prefFeatureMask 0x80000000UL # define blwfFeatureMask 0x40000000UL # define abvfFeatureMask 0x20000000UL # define pstfFeatureMask 0x10000000UL # define presFeatureMask 0x08000000UL # define blwsFeatureMask 0x04000000UL # define abvsFeatureMask 0x02000000UL # define pstsFeatureMask 0x01000000UL # define cligFeatureMask 0x00800000UL # define ccmpFeatureMask 0x00040000UL // ▁ Positioning ▁ features ENDCOM # define distFeatureMask 0x00400000UL # define blwmFeatureMask 0x00200000UL # define abvmFeatureMask 0x00100000UL # define mkmkFeatureMask 0x00080000UL # define tagPref ( ccmpFeatureMask | prefFeatureMask | presFeatureMask | cligFeatureMask | distFeatureMask ) # define tagAbvf ( ccmpFeatureMask | abvfFeatureMask | abvsFeatureMask | cligFeatureMask | distFeatureMask | abvmFeatureMask | mkmkFeatureMask ) # define tagPstf ( ccmpFeatureMask | blwfFeatureMask | blwsFeatureMask | prefFeatureMask | presFeatureMask | pstfFeatureMask | pstsFeatureMask | cligFeatureMask | distFeatureMask | blwmFeatureMask ) # define tagBlwf ( ccmpFeatureMask | blwfFeatureMask | blwsFeatureMask | cligFeatureMask | distFeatureMask | blwmFeatureMask | mkmkFeatureMask ) # define tagDefault ( ccmpFeatureMask | prefFeatureMask | blwfFeatureMask | presFeatureMask | blwsFeatureMask | cligFeatureMask | distFeatureMask | abvmFeatureMask | blwmFeatureMask | mkmkFeatureMask ) // ▁ These ▁ are ▁ in ▁ the ▁ order ▁ in ▁ which ▁ the ▁ features ▁ need ▁ to ▁ be ▁ applied ENDCOM // ▁ for ▁ correct ▁ processing ENDCOM static const FeatureMap featureMap [ ] = { // ▁ Shaping ▁ features ENDCOM { ccmpFeatureTag , ccmpFeatureMask } , { prefFeatureTag , prefFeatureMask } , { blwfFeatureTag , blwfFeatureMask } , { abvfFeatureTag , abvfFeatureMask } , { pstfFeatureTag , pstfFeatureMask } , { presFeatureTag , presFeatureMask } , { blwsFeatureTag , blwsFeatureMask } , { abvsFeatureTag , abvsFeatureMask } , { pstsFeatureTag , pstsFeatureMask } , { cligFeatureTag , cligFeatureMask } , // ▁ Positioning ▁ features ENDCOM { distFeatureTag , distFeatureMask } , { blwmFeatureTag , blwmFeatureMask } , { abvmFeatureTag , abvmFeatureMask } , { mkmkFeatureTag , mkmkFeatureMask } , } ; static const le_int32 featureMapCount = LE_ARRAY_SIZE ( featureMap ) ; // ▁ The ▁ stateTable ▁ is ▁ used ▁ to ▁ calculate ▁ the ▁ end ▁ ( the ▁ length ) ▁ of ▁ a ▁ well ENDCOM // ▁ formed ▁ Tibetan ▁ Syllable . ▁ ENDCOM // ▁ Each ▁ horizontal ▁ line ▁ is ▁ ordered ▁ exactly ▁ the ▁ same ▁ way ▁ as ▁ the ▁ values ▁ in ▁ TibetanClassTable ENDCOM // ▁ CharClassValues ▁ in ▁ TibetanReordering . h ▁ This ▁ coincidence ▁ of ▁ values ▁ allows ▁ the ENDCOM // ▁ follow ▁ up ▁ of ▁ the ▁ table . ENDCOM // ▁ Each ▁ line ▁ corresponds ▁ to ▁ a ▁ state , ▁ which ▁ does ▁ not ▁ necessarily ▁ need ▁ to ▁ be ▁ a ▁ type ENDCOM // ▁ of ▁ component . . . ▁ for ▁ example , ▁ state ▁ 2 ▁ is ▁ a ▁ base , ▁ with ▁ is ▁ always ▁ a ▁ first ▁ character ENDCOM // ▁ in ▁ the ▁ syllable , ▁ but ▁ the ▁ state ▁ could ▁ be ▁ produced ▁ a ▁ consonant ▁ of ▁ any ▁ type ▁ when ENDCOM // ▁ it ▁ is ▁ the ▁ first ▁ character ▁ that ▁ is ▁ analysed ▁ ( in ▁ ground ▁ state ) . ENDCOM static const le_int8 tibetanStateTable [ ] [ TibetanClassTable :: CC_COUNT ] = { // Dzongkha ▁ state ▁ table ENDCOM // xx ▁ ba ▁ sj ▁ tp ▁ ac ▁ cs ▁ ha ▁ bv ▁ av ▁ an ▁ cb ▁ vs ▁ as ▁ bs ▁ di ▁ pd ▁ bd ENDCOM { 1 , 2 , 4 , 3 , 8 , 7 , 9 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , 20 , 21 , 21 , } , // ▁ 0 ▁ - ▁ ground ▁ state ENDCOM { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } , // ▁ 1 ▁ - ▁ exit ▁ state ▁ ( or ▁ sign ▁ to ▁ the ▁ right ▁ of ▁ the ▁ syllable ) ENDCOM { - 1 , - 1 , 4 , 3 , 8 , 7 , 9 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 2 ▁ - ▁ Base ▁ consonant ▁ ENDCOM { - 1 , - 1 , 5 , - 1 , 8 , 7 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 3 ▁ - ▁ Tsa ▁ phru ▁ after ▁ base ENDCOM { - 1 , - 1 , 4 , 6 , 8 , 7 , 9 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 4 ▁ - ▁ Subjoined ▁ consonant ▁ after ▁ base ▁ ENDCOM { - 1 , - 1 , 5 , - 1 , 8 , 7 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 5 ▁ - ▁ Subjoined ▁ consonant ▁ after ▁ tsa ▁ phru ENDCOM { - 1 , - 1 , - 1 , - 1 , 8 , 7 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 6 ▁ - ▁ Tsa ▁ phru ▁ after ▁ subjoined ▁ consonant ENDCOM { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 7 ▁ - ▁ Pre ▁ Composed ▁ Sanskrit ENDCOM { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 8 ▁ - ▁ A - chung ENDCOM { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 14 , 13 , 17 , - 1 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 9 ▁ - ▁ Halanta ENDCOM { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 11 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 10 ▁ - ▁ below ▁ vowel ▁ 1 ENDCOM { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 12 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 11 ▁ - ▁ below ▁ vowel ▁ 2 ENDCOM { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 12 ▁ - ▁ below ▁ vowel ▁ 3 ▁ ENDCOM { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 14 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 13 ▁ - ▁ Anusvara ▁ before ▁ vowel ENDCOM { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 15 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 14 ▁ - ▁ above ▁ vowel ▁ 1 ENDCOM { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 16 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 15 ▁ - ▁ above ▁ vowel ▁ 2 ENDCOM { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 16 ▁ - ▁ above ▁ vowel ▁ 3 ENDCOM { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 17 ▁ - ▁ Anusvara ▁ or ▁ Candrabindu ▁ after ▁ vowel ▁ ENDCOM { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 19 , 19 , - 1 , - 1 , - 1 , } , // ▁ 18 ▁ - ▁ Visarga ▁ ENDCOM { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } , // ▁ 19 ▁ - ▁ strss ▁ mark ENDCOM { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 21 , 21 , } , // ▁ 20 ▁ - ▁ digit ▁ ENDCOM { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } , // ▁ 21 ▁ - ▁ digit ▁ mark ENDCOM } ; const FeatureMap * TibetanReordering :: getFeatureMap ( le_int32 & count ) { count = featureMapCount ; return featureMap ; } // ▁ Given ▁ an ▁ input ▁ string ▁ of ▁ characters ▁ and ▁ a ▁ location ▁ in ▁ which ▁ to ▁ start ▁ looking ENDCOM // ▁ calculate , ▁ using ▁ the ▁ state ▁ table , ▁ which ▁ one ▁ is ▁ the ▁ last ▁ character ▁ of ▁ the ▁ syllable ENDCOM // ▁ that ▁ starts ▁ in ▁ the ▁ starting ▁ position . ENDCOM le_int32 TibetanReordering :: findSyllable ( const TibetanClassTable * classTable , const LEUnicode * chars , le_int32 prev , le_int32 charCount ) { le_int32 cursor = prev ; le_int8 state = 0 ; while ( cursor < charCount ) { TibetanClassTable :: CharClass charClass = ( classTable -> getCharClass ( chars [ cursor ] ) & TibetanClassTable :: CF_CLASS_MASK ) ; state = tibetanStateTable [ state ] [ charClass ] ; if ( state < 0 ) { break ; } cursor += 1 ; } return cursor ; } // ▁ This ▁ is ▁ the ▁ real ▁ reordering ▁ function ▁ as ▁ applied ▁ to ▁ the ▁ Tibetan ▁ language ENDCOM le_int32 TibetanReordering :: reorder ( const LEUnicode * chars , le_int32 charCount , le_int32 , LEUnicode * outChars , LEGlyphStorage & glyphStorage ) { const TibetanClassTable * classTable = TibetanClassTable :: getTibetanClassTable ( ) ; TibetanReorderingOutput output ( outChars , glyphStorage ) ; TibetanClassTable :: CharClass charClass ; le_int32 i , prev = 0 ; // ▁ This ▁ loop ▁ only ▁ exits ▁ when ▁ we ▁ reach ▁ the ▁ end ▁ of ▁ a ▁ run , ▁ which ▁ may ▁ contain ▁ ENDCOM // ▁ several ▁ syllables . ENDCOM while ( prev < charCount ) { le_int32 syllable = findSyllable ( classTable , chars , prev , charCount ) ; output . reset ( ) ; // ▁ shall ▁ we ▁ add ▁ a ▁ dotted ▁ circle ? ENDCOM // ▁ If ▁ in ▁ the ▁ position ▁ in ▁ which ▁ the ▁ base ▁ should ▁ be ▁ ( first ▁ char ▁ in ▁ the ▁ string ) ▁ there ▁ is ENDCOM // ▁ a ▁ character ▁ that ▁ has ▁ the ▁ Dotted ▁ circle ▁ flag ▁ ( a ▁ character ▁ that ▁ cannot ▁ be ▁ a ▁ base ) ENDCOM // ▁ then ▁ write ▁ a ▁ dotted ▁ circle ENDCOM if ( classTable -> getCharClass ( chars [ prev ] ) & TibetanClassTable :: CF_DOTTED_CIRCLE ) { output . writeChar ( C_DOTTED_CIRCLE , prev , tagDefault ) ; } // ▁ copy ▁ the ▁ rest ▁ to ▁ output , ▁ inverting ▁ the ▁ pre - number ▁ mark ▁ if ▁ present ▁ after ▁ a ▁ digit . ENDCOM for ( i = prev ; i < syllable ; i += 1 ) { charClass = classTable -> getCharClass ( chars [ i ] ) ; if ( ( TibetanClassTable :: CF_DIGIT & charClass ) && ( classTable -> getCharClass ( chars [ i + 1 ] ) & TibetanClassTable :: CF_PREDIGIT ) ) { output . writeChar ( C_PRE_NUMBER_MARK , i , tagPref ) ; output . writeChar ( chars [ i ] , i + 1 , tagPref ) ; i += 1 ; } else { switch ( charClass & TibetanClassTable :: CF_POS_MASK ) { // ▁ If ▁ the ▁ present ▁ character ▁ is ▁ a ▁ number , ▁ and ▁ the ▁ next ▁ character ▁ is ▁ a ▁ pre - number ▁ combining ▁ mark ENDCOM // ▁ then ▁ the ▁ two ▁ characters ▁ are ▁ reordered ENDCOM case TibetanClassTable :: CF_POS_ABOVE : output . writeChar ( chars [ i ] , i , tagAbvf ) ; break ; case TibetanClassTable :: CF_POS_AFTER : output . writeChar ( chars [ i ] , i , tagPstf ) ; break ; case TibetanClassTable :: CF_POS_BELOW : output . writeChar ( chars [ i ] , i , tagBlwf ) ; break ; default : // ▁ default ▁ - ▁ any ▁ other ▁ characters ENDCOM output . writeChar ( chars [ i ] , i , tagDefault ) ; break ; } // ▁ switch ENDCOM } // ▁ if ENDCOM } // ▁ for ENDCOM prev = syllable ; // ▁ move ▁ the ▁ pointer ▁ to ▁ the ▁ start ▁ of ▁ next ▁ syllable ENDCOM } return output . getOutputIndex ( ) ; } U_NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="SuslikV/obs-studio/tree/master/plugins/win-capture/graphics-hook/d3d9-capture.cpp"> # define _CRT_SECURE_NO_WARNINGS # include < d3d9 . h > # include < d3d11 . h > # include < dxgi . h > # include " graphics - hook . h " # include " . . / funchook . h " # include " d3d9 - patches . hpp " typedef HRESULT ( STDMETHODCALLTYPE * present_t ) ( IDirect3DDevice9 * , CONST RECT * , CONST RECT * , HWND , CONST RGNDATA * ) ; typedef HRESULT ( STDMETHODCALLTYPE * present_ex_t ) ( IDirect3DDevice9 * , CONST RECT * , CONST RECT * , HWND , CONST RGNDATA * , DWORD ) ; typedef HRESULT ( STDMETHODCALLTYPE * present_swap_t ) ( IDirect3DSwapChain9 * , CONST RECT * , CONST RECT * , HWND , CONST RGNDATA * , DWORD ) ; typedef HRESULT ( STDMETHODCALLTYPE * reset_t ) ( IDirect3DDevice9 * , D3DPRESENT_PARAMETERS * ) ; typedef HRESULT ( STDMETHODCALLTYPE * reset_ex_t ) ( IDirect3DDevice9 * , D3DPRESENT_PARAMETERS * , D3DDISPLAYMODEEX * ) ; typedef HRESULT ( WINAPI * createfactory1_t ) ( REFIID , void * * ) ; static struct func_hook present ; static struct func_hook present_ex ; static struct func_hook present_swap ; static struct func_hook reset ; static struct func_hook reset_ex ; struct d3d9_data { HMODULE d3d9 ; IDirect3DDevice9 * device ; /* ▁ do ▁ not ▁ release ▁ */ uint32_t cx ; uint32_t cy ; D3DFORMAT d3d9_format ; DXGI_FORMAT dxgi_format ; bool using_shtex : 1 ; bool using_scale : 1 ; volatile bool issued_queries [ NUM_BUFFERS ] ; union { /* ▁ shared ▁ texture ▁ */ struct { IDirect3DSurface9 * d3d9_copytex ; ID3D11Device * d3d11_device ; ID3D11DeviceContext * d3d11_context ; ID3D11Resource * d3d11_tex ; struct shtex_data * shtex_info ; HANDLE handle ; int patch ; } ; /* ▁ shared ▁ memory ▁ */ struct { IDirect3DSurface9 * copy_surfaces [ NUM_BUFFERS ] ; IDirect3DSurface9 * render_targets [ NUM_BUFFERS ] ; IDirect3DQuery9 * queries [ NUM_BUFFERS ] ; struct shmem_data * shmem_info ; bool texture_mapped [ NUM_BUFFERS ] ; uint32_t pitch ; int cur_tex ; int copy_wait ; } ; } ; } ; static struct d3d9_data data = { } ; static void d3d9_free ( ) { capture_free ( ) ; if ( data . using_shtex ) { if ( data . d3d11_tex ) data . d3d11_tex -> Release ( ) ; if ( data . d3d11_context ) data . d3d11_context -> Release ( ) ; if ( data . d3d11_device ) data . d3d11_device -> Release ( ) ; if ( data . d3d9_copytex ) data . d3d9_copytex -> Release ( ) ; } else { for ( size_t i = 0 ; i < NUM_BUFFERS ; i ++ ) { if ( data . copy_surfaces [ i ] ) { if ( data . texture_mapped [ i ] ) data . copy_surfaces [ i ] -> UnlockRect ( ) ; data . copy_surfaces [ i ] -> Release ( ) ; } if ( data . render_targets [ i ] ) data . render_targets [ i ] -> Release ( ) ; if ( data . queries [ i ] ) data . queries [ i ] -> Release ( ) ; } } memset ( & data , 0 , sizeof ( data ) ) ; hlog ( " - - - - - - - - - - - - - - - - - ▁ d3d9 ▁ capture ▁ freed ▁ - - - - - - - - - - - - - - - - - " ) ; } static DXGI_FORMAT d3d9_to_dxgi_format ( D3DFORMAT format ) { switch ( ( unsigned long ) format ) { case D3DFMT_A2B10G10R10 : return DXGI_FORMAT_R10G10B10A2_UNORM ; case D3DFMT_A8R8G8B8 : return DXGI_FORMAT_B8G8R8A8_UNORM ; case D3DFMT_X8R8G8B8 : return DXGI_FORMAT_B8G8R8X8_UNORM ; } return DXGI_FORMAT_UNKNOWN ; } const static D3D_FEATURE_LEVEL feature_levels [ ] = { D3D_FEATURE_LEVEL_11_0 , D3D_FEATURE_LEVEL_10_1 , D3D_FEATURE_LEVEL_10_0 , D3D_FEATURE_LEVEL_9_3 , } ; static inline bool shex_init_d3d11 ( ) { PFN_D3D11_CREATE_DEVICE create_device ; createfactory1_t create_factory ; D3D_FEATURE_LEVEL level_used ; IDXGIFactory * factory ; IDXGIAdapter * adapter ; HMODULE d3d11 ; HMODULE dxgi ; HRESULT hr ; d3d11 = load_system_library ( " d3d11 . dll " ) ; if ( ! d3d11 ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ load ▁ D3D11" ) ; return false ; } dxgi = load_system_library ( " dxgi . dll " ) ; if ( ! dxgi ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ load ▁ DXGI " ) ; return false ; } create_factory = ( createfactory1_t ) GetProcAddress ( dxgi , " CreateDXGIFactory1" ) ; if ( ! create_factory ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ CreateDXGIFactory1 ▁ address " ) ; return false ; } create_device = ( PFN_D3D11_CREATE_DEVICE ) GetProcAddress ( d3d11 , " D3D11CreateDevice " ) ; if ( ! create_device ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ D3D11CreateDevice ▁ address " ) ; return false ; } hr = create_factory ( __uuidof ( IDXGIFactory1 ) , ( void * * ) & factory ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ create ▁ factory ▁ object " , hr ) ; return false ; } hr = factory -> EnumAdapters ( 0 , & adapter ) ; factory -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ adapter " , hr ) ; return false ; } hr = create_device ( adapter , D3D_DRIVER_TYPE_UNKNOWN , nullptr , 0 , feature_levels , sizeof ( feature_levels ) / sizeof ( D3D_FEATURE_LEVEL ) , D3D11_SDK_VERSION , & data . d3d11_device , & level_used , & data . d3d11_context ) ; adapter -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ create ▁ D3D11 ▁ device " , hr ) ; return false ; } return true ; } static inline bool d3d9_shtex_init_shtex ( ) { IDXGIResource * res ; HRESULT hr ; D3D11_TEXTURE2D_DESC desc = { } ; desc . Width = data . cx ; desc . Height = data . cy ; desc . Format = data . dxgi_format ; desc . MipLevels = 1 ; desc . ArraySize = 1 ; desc . SampleDesc . Count = 1 ; desc . Usage = D3D11_USAGE_DEFAULT ; desc . MiscFlags = D3D11_RESOURCE_MISC_SHARED ; desc . BindFlags = D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE ; hr = data . d3d11_device -> CreateTexture2D ( & desc , nullptr , ( ID3D11Texture2D * * ) & data . d3d11_tex ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ create ▁ D3D11 ▁ texture " , hr ) ; return false ; } hr = data . d3d11_tex -> QueryInterface ( __uuidof ( IDXGIResource ) , ( void * * ) & res ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ query ▁ IDXGIResource " , hr ) ; return false ; } hr = res -> GetSharedHandle ( & data . handle ) ; res -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ get ▁ shared ▁ handle " , hr ) ; return false ; } return true ; } static inline bool d3d9_shtex_init_copytex ( ) { uint8_t * patch_addr = get_d3d9_patch_addr ( data . d3d9 , data . patch ) ; uint8_t saved_data [ MAX_PATCH_SIZE ] ; size_t patch_size = 0 ; IDirect3DTexture9 * tex ; DWORD protect_val ; HRESULT hr ; if ( patch_addr ) { patch_size = patch [ data . patch ] . size ; VirtualProtect ( patch_addr , patch_size , PAGE_EXECUTE_READWRITE , & protect_val ) ; memcpy ( saved_data , patch_addr , patch_size ) ; memcpy ( patch_addr , patch [ data . patch ] . data , patch_size ) ; } hr = data . device -> CreateTexture ( data . cx , data . cy , 1 , D3DUSAGE_RENDERTARGET , data . d3d9_format , D3DPOOL_DEFAULT , & tex , & data . handle ) ; if ( patch_addr && patch_size ) { memcpy ( patch_addr , saved_data , patch_size ) ; VirtualProtect ( patch_addr , patch_size , protect_val , & protect_val ) ; } if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ copytex : ▁ Failed ▁ to ▁ create ▁ shared ▁ texture " , hr ) ; return false ; } hr = tex -> GetSurfaceLevel ( 0 , & data . d3d9_copytex ) ; tex -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ copytex : ▁ Failed ▁ to ▁ get ▁ surface ▁ level " , hr ) ; return false ; } return true ; } static bool d3d9_shtex_init ( uint32_t cx , uint32_t cy , HWND window ) { data . using_shtex = true ; if ( ! shex_init_d3d11 ( ) ) { return false ; } if ( ! d3d9_shtex_init_shtex ( ) ) { return false ; } if ( ! d3d9_shtex_init_copytex ( ) ) { return false ; } if ( ! capture_init_shtex ( & data . shtex_info , window , cx , cy , data . cx , data . cy , data . dxgi_format , false , ( uintptr_t ) data . handle ) ) { return false ; } hlog ( " d3d9 ▁ shared ▁ texture ▁ capture ▁ successful " ) ; return true ; } static bool d3d9_shmem_init_buffers ( size_t buffer ) { HRESULT hr ; hr = data . device -> CreateOffscreenPlainSurface ( data . cx , data . cy , data . d3d9_format , D3DPOOL_SYSTEMMEM , & data . copy_surfaces [ buffer ] , nullptr ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ surface " , hr ) ; return false ; } if ( buffer == 0 ) { D3DLOCKED_RECT rect ; hr = data . copy_surfaces [ buffer ] -> LockRect ( & rect , nullptr , D3DLOCK_READONLY ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ lock ▁ " " buffer " , hr ) ; return false ; } data . pitch = rect . Pitch ; data . copy_surfaces [ buffer ] -> UnlockRect ( ) ; } hr = data . device -> CreateRenderTarget ( data . cx , data . cy , data . d3d9_format , D3DMULTISAMPLE_NONE , 0 , false , & data . render_targets [ buffer ] , nullptr ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ render ▁ " " target " , hr ) ; return false ; } hr = data . device -> CreateQuery ( D3DQUERYTYPE_EVENT , & data . queries [ buffer ] ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ query " , hr ) ; return false ; } return true ; } static bool d3d9_shmem_init ( uint32_t cx , uint32_t cy , HWND window ) { data . using_shtex = false ; for ( size_t i = 0 ; i < NUM_BUFFERS ; i ++ ) { if ( ! d3d9_shmem_init_buffers ( i ) ) { return false ; } } if ( ! capture_init_shmem ( & data . shmem_info , window , cx , cy , data . cx , data . cy , data . pitch , data . dxgi_format , false ) ) { return false ; } hlog ( " d3d9 ▁ memory ▁ capture ▁ successful " ) ; return true ; } static bool d3d9_get_swap_desc ( D3DPRESENT_PARAMETERS & pp ) { IDirect3DSwapChain9 * swap = nullptr ; HRESULT hr ; hr = data . device -> GetSwapChain ( 0 , & swap ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ get _ swap _ desc : ▁ Failed ▁ to ▁ get ▁ swap ▁ chain " , hr ) ; return false ; } hr = swap -> GetPresentParameters ( & pp ) ; swap -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ get _ swap _ desc : ▁ Failed ▁ to ▁ get ▁ " " presentation ▁ parameters " , hr ) ; return false ; } return true ; } static bool d3d9_init_format_backbuffer ( uint32_t & cx , uint32_t & cy , HWND & window ) { IDirect3DSurface9 * back_buffer = nullptr ; D3DPRESENT_PARAMETERS pp ; D3DSURFACE_DESC desc ; HRESULT hr ; if ( ! d3d9_get_swap_desc ( pp ) ) { return false ; } hr = data . device -> GetRenderTarget ( 0 , & back_buffer ) ; if ( FAILED ( hr ) ) { return false ; } hr = back_buffer -> GetDesc ( & desc ) ; back_buffer -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init _ format _ backbuffer : ▁ Failed ▁ to ▁ get ▁ " " backbuffer ▁ descriptor " , hr ) ; return false ; } data . d3d9_format = desc . Format ; data . dxgi_format = d3d9_to_dxgi_format ( desc . Format ) ; data . using_scale = global_hook_info -> use_scale ; window = pp . hDeviceWindow ; cx = desc . Width ; cy = desc . Height ; if ( data . using_scale ) { data . cx = global_hook_info -> cx ; data . cy = global_hook_info -> cy ; } else { data . cx = desc . Width ; data . cy = desc . Height ; } return true ; } static bool d3d9_init_format_swapchain ( uint32_t & cx , uint32_t & cy , HWND & window ) { D3DPRESENT_PARAMETERS pp ; if ( ! d3d9_get_swap_desc ( pp ) ) { return false ; } data . dxgi_format = d3d9_to_dxgi_format ( pp . BackBufferFormat ) ; data . d3d9_format = pp . BackBufferFormat ; data . using_scale = global_hook_info -> use_scale ; window = pp . hDeviceWindow ; cx = pp . BackBufferWidth ; cy = pp . BackBufferHeight ; if ( data . using_scale ) { data . cx = global_hook_info -> cx ; data . cy = global_hook_info -> cy ; } else { data . cx = pp . BackBufferWidth ; data . cy = pp . BackBufferHeight ; } return true ; } static void d3d9_init ( IDirect3DDevice9 * device ) { IDirect3DDevice9Ex * d3d9ex = nullptr ; bool success ; uint32_t cx = 0 ; uint32_t cy = 0 ; HWND window = nullptr ; HRESULT hr ; data . d3d9 = get_system_module ( " d3d9 . dll " ) ; data . device = device ; hr = device -> QueryInterface ( __uuidof ( IDirect3DDevice9Ex ) , ( void * * ) & d3d9ex ) ; if ( SUCCEEDED ( hr ) ) { d3d9ex -> Release ( ) ; data . patch = - 1 ; } else { data . patch = get_d3d9_patch ( data . d3d9 ) ; } if ( ! d3d9_init_format_backbuffer ( cx , cy , window ) ) { if ( ! d3d9_init_format_swapchain ( cx , cy , window ) ) { return ; } } if ( global_hook_info -> force_shmem || ( ! d3d9ex && data . patch == - 1 ) ) { success = d3d9_shmem_init ( cx , cy , window ) ; } else { success = d3d9_shtex_init ( cx , cy , window ) ; } if ( ! success ) d3d9_free ( ) ; } static inline HRESULT get_backbuffer ( IDirect3DDevice9 * device , IDirect3DSurface9 * * surface ) { static bool use_backbuffer = false ; static bool checked_exceptions = false ; if ( ! checked_exceptions ) { if ( _strcmpi ( get_process_name ( ) , " hotd _ ng . exe " ) == 0 ) use_backbuffer = true ; checked_exceptions = true ; } if ( use_backbuffer ) { return device -> GetBackBuffer ( 0 , 0 , D3DBACKBUFFER_TYPE_MONO , surface ) ; } else { return device -> GetRenderTarget ( 0 , surface ) ; } } static inline void d3d9_shtex_capture ( IDirect3DSurface9 * backbuffer ) { D3DTEXTUREFILTERTYPE filter ; HRESULT hr ; filter = data . using_scale ? D3DTEXF_LINEAR : D3DTEXF_NONE ; hr = data . device -> StretchRect ( backbuffer , nullptr , data . d3d9_copytex , nullptr , filter ) ; if ( FAILED ( hr ) ) hlog_hr ( " d3d9 _ shtex _ capture : ▁ StretchRect ▁ failed " , hr ) ; } static inline void d3d9_shmem_capture_queue_copy ( ) { for ( int i = 0 ; i < NUM_BUFFERS ; i ++ ) { IDirect3DSurface9 * target = data . copy_surfaces [ i ] ; D3DLOCKED_RECT rect ; HRESULT hr ; if ( ! data . issued_queries [ i ] ) { continue ; } if ( data . queries [ i ] -> GetData ( 0 , 0 , 0 ) != S_OK ) { continue ; } data . issued_queries [ i ] = false ; hr = target -> LockRect ( & rect , nullptr , D3DLOCK_READONLY ) ; if ( SUCCEEDED ( hr ) ) { data . texture_mapped [ i ] = true ; shmem_copy_data ( i , rect . pBits ) ; } break ; } } static inline void d3d9_shmem_capture ( IDirect3DSurface9 * backbuffer ) { D3DTEXTUREFILTERTYPE filter ; IDirect3DSurface9 * copy ; int next_tex ; HRESULT hr ; d3d9_shmem_capture_queue_copy ( ) ; next_tex = ( data . cur_tex == NUM_BUFFERS - 1 ) ? 0 : data . cur_tex + 1 ; filter = data . using_scale ? D3DTEXF_LINEAR : D3DTEXF_NONE ; copy = data . render_targets [ data . cur_tex ] ; hr = data . device -> StretchRect ( backbuffer , nullptr , copy , nullptr , filter ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ StretchRect ▁ failed " , hr ) ; return ; } if ( data . copy_wait < NUM_BUFFERS - 1 ) { data . copy_wait ++ ; } else { IDirect3DSurface9 * src = data . render_targets [ next_tex ] ; IDirect3DSurface9 * dst = data . copy_surfaces [ next_tex ] ; if ( shmem_texture_data_lock ( next_tex ) ) { dst -> UnlockRect ( ) ; data . texture_mapped [ next_tex ] = false ; shmem_texture_data_unlock ( next_tex ) ; } hr = data . device -> GetRenderTargetData ( src , dst ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ GetRenderTargetData ▁ " " failed " , hr ) ; } data . queries [ next_tex ] -> Issue ( D3DISSUE_END ) ; data . issued_queries [ next_tex ] = true ; } data . cur_tex = next_tex ; } static void d3d9_capture ( IDirect3DDevice9 * device , IDirect3DSurface9 * backbuffer ) { if ( capture_should_stop ( ) ) { d3d9_free ( ) ; } if ( capture_should_init ( ) ) { d3d9_init ( device ) ; } if ( capture_ready ( ) ) { if ( data . using_shtex ) d3d9_shtex_capture ( backbuffer ) ; else d3d9_shmem_capture ( backbuffer ) ; } } /* ▁ this ▁ is ▁ used ▁ just ▁ in ▁ case ▁ Present ▁ calls ▁ PresentEx ▁ or ▁ vise ▁ versa . ▁ */ static int present_recurse = 0 ; static inline void present_begin ( IDirect3DDevice9 * device , IDirect3DSurface9 * & backbuffer ) { HRESULT hr ; if ( ! present_recurse ) { hr = get_backbuffer ( device , & backbuffer ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ Failed ▁ to ▁ get ▁ " " backbuffer " , hr ) ; } if ( ! global_hook_info -> capture_overlay ) { d3d9_capture ( device , backbuffer ) ; } } present_recurse ++ ; } static inline void present_end ( IDirect3DDevice9 * device , IDirect3DSurface9 * backbuffer ) { present_recurse -- ; if ( ! present_recurse ) { if ( global_hook_info -> capture_overlay ) { if ( ! present_recurse ) d3d9_capture ( device , backbuffer ) ; } if ( backbuffer ) backbuffer -> Release ( ) ; } } static bool hooked_reset = false ; static void setup_reset_hooks ( IDirect3DDevice9 * device ) ; static HRESULT STDMETHODCALLTYPE hook_present ( IDirect3DDevice9 * device , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region ) { IDirect3DSurface9 * backbuffer = nullptr ; HRESULT hr ; if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; unhook ( & present ) ; present_t call = ( present_t ) present . call_addr ; hr = call ( device , src_rect , dst_rect , override_window , dirty_region ) ; rehook ( & present ) ; present_end ( device , backbuffer ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_present_ex ( IDirect3DDevice9 * device , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region , DWORD flags ) { IDirect3DSurface9 * backbuffer = nullptr ; HRESULT hr ; if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; unhook ( & present_ex ) ; present_ex_t call = ( present_ex_t ) present_ex . call_addr ; hr = call ( device , src_rect , dst_rect , override_window , dirty_region , flags ) ; rehook ( & present_ex ) ; present_end ( device , backbuffer ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_present_swap ( IDirect3DSwapChain9 * swap , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region , DWORD flags ) { IDirect3DSurface9 * backbuffer = nullptr ; IDirect3DDevice9 * device = nullptr ; HRESULT hr ; if ( ! present_recurse ) { hr = swap -> GetDevice ( & device ) ; if ( SUCCEEDED ( hr ) ) { device -> Release ( ) ; } } if ( device ) { if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; } unhook ( & present_swap ) ; present_swap_t call = ( present_swap_t ) present_swap . call_addr ; hr = call ( swap , src_rect , dst_rect , override_window , dirty_region , flags ) ; rehook ( & present_swap ) ; if ( device ) present_end ( device , backbuffer ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_reset ( IDirect3DDevice9 * device , D3DPRESENT_PARAMETERS * params ) { HRESULT hr ; if ( capture_active ( ) ) d3d9_free ( ) ; unhook ( & reset ) ; reset_t call = ( reset_t ) reset . call_addr ; hr = call ( device , params ) ; rehook ( & reset ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_reset_ex ( IDirect3DDevice9 * device , D3DPRESENT_PARAMETERS * params , D3DDISPLAYMODEEX * dmex ) { HRESULT hr ; if ( capture_active ( ) ) d3d9_free ( ) ; unhook ( & reset_ex ) ; reset_ex_t call = ( reset_ex_t ) reset_ex . call_addr ; hr = call ( device , params , dmex ) ; rehook ( & reset_ex ) ; return hr ; } static void setup_reset_hooks ( IDirect3DDevice9 * device ) { IDirect3DDevice9Ex * d3d9ex = nullptr ; uintptr_t * vtable = * ( uintptr_t * * ) device ; HRESULT hr ; hook_init ( & reset , ( void * ) vtable [ 16 ] , ( void * ) hook_reset , " IDirect3DDevice9 : : Reset " ) ; rehook ( & reset ) ; hr = device -> QueryInterface ( __uuidof ( IDirect3DDevice9Ex ) , ( void * * ) & d3d9ex ) ; if ( SUCCEEDED ( hr ) ) { hook_init ( & reset_ex , ( void * ) vtable [ 132 ] , ( void * ) hook_reset_ex , " IDirect3DDevice9Ex : : ResetEx " ) ; rehook ( & reset_ex ) ; d3d9ex -> Release ( ) ; } hooked_reset = true ; } typedef HRESULT ( WINAPI * d3d9create_ex_t ) ( UINT , IDirect3D9Ex * * ) ; static bool manually_get_d3d9_addrs ( HMODULE d3d9_module , void * * present_addr , void * * present_ex_addr , void * * present_swap_addr ) { d3d9create_ex_t create_ex ; D3DPRESENT_PARAMETERS pp ; HRESULT hr ; IDirect3DDevice9Ex * device ; IDirect3D9Ex * d3d9ex ; hlog ( " D3D9 ▁ values ▁ invalid , ▁ manually ▁ obtaining " ) ; create_ex = ( d3d9create_ex_t ) GetProcAddress ( d3d9_module , " Direct3DCreate9Ex " ) ; if ( ! create_ex ) { hlog ( " Failed ▁ to ▁ load ▁ Direct3DCreate9Ex " ) ; return false ; } if ( FAILED ( create_ex ( D3D_SDK_VERSION , & d3d9ex ) ) ) { hlog ( " Failed ▁ to ▁ create ▁ D3D9 ▁ context " ) ; return false ; } memset ( & pp , 0 , sizeof ( pp ) ) ; pp . Windowed = 1 ; pp . SwapEffect = D3DSWAPEFFECT_FLIP ; pp . BackBufferFormat = D3DFMT_A8R8G8B8 ; pp . BackBufferCount = 1 ; pp . hDeviceWindow = ( HWND ) dummy_window ; pp . PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE ; hr = d3d9ex -> CreateDeviceEx ( D3DADAPTER_DEFAULT , D3DDEVTYPE_HAL , dummy_window , D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_NOWINDOWCHANGES , & pp , NULL , & device ) ; d3d9ex -> Release ( ) ; if ( SUCCEEDED ( hr ) ) { uintptr_t * vtable = * ( uintptr_t * * ) device ; IDirect3DSwapChain9 * swap ; * present_addr = ( void * ) vtable [ 17 ] ; * present_ex_addr = ( void * ) vtable [ 121 ] ; hr = device -> GetSwapChain ( 0 , & swap ) ; if ( SUCCEEDED ( hr ) ) { vtable = * ( uintptr_t * * ) swap ; * present_swap_addr = ( void * ) vtable [ 3 ] ; swap -> Release ( ) ; } device -> Release ( ) ; } else { hlog ( " Failed ▁ to ▁ create ▁ D3D9 ▁ device " ) ; return false ; } return true ; } bool hook_d3d9 ( void ) { HMODULE d3d9_module = get_system_module ( " d3d9 . dll " ) ; uint32_t d3d9_size ; void * present_addr = nullptr ; void * present_ex_addr = nullptr ; void * present_swap_addr = nullptr ; if ( ! d3d9_module ) { return false ; } d3d9_size = module_size ( d3d9_module ) ; if ( global_hook_info -> offsets . d3d9 . present < d3d9_size && global_hook_info -> offsets . d3d9 . present_ex < d3d9_size && global_hook_info -> offsets . d3d9 . present_swap < d3d9_size ) { present_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present ) ; present_ex_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present_ex ) ; present_swap_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present_swap ) ; } else { if ( ! dummy_window ) { return false ; } if ( ! manually_get_d3d9_addrs ( d3d9_module , & present_addr , & present_ex_addr , & present_swap_addr ) ) { hlog ( " Failed ▁ to ▁ get ▁ D3D9 ▁ values " ) ; return true ; } } if ( ! present_addr && ! present_ex_addr && ! present_swap_addr ) { hlog ( " Invalid ▁ D3D9 ▁ values " ) ; return true ; } if ( present_swap_addr ) { hook_init ( & present_swap , present_swap_addr , ( void * ) hook_present_swap , " IDirect3DSwapChain9 : : Present " ) ; rehook ( & present_swap ) ; } if ( present_ex_addr ) { hook_init ( & present_ex , present_ex_addr , ( void * ) hook_present_ex , " IDirect3DDevice9Ex : : PresentEx " ) ; rehook ( & present_ex ) ; } if ( present_addr ) { hook_init ( & present , present_addr , ( void * ) hook_present , " IDirect3DDevice9 : : Present " ) ; rehook ( & present ) ; } hlog ( " Hooked ▁ D3D9" ) ; return true ; } </DOCUMENT>
<DOCUMENT_ID="geofl/JK2_1.02Source/tree/master/CODE-mp/server/sv_world.cpp"> // ▁ world . c ▁ - - ▁ world ▁ query ▁ functions ENDCOM # include " server . h " /*  STRNEWLINE = = = = =  STRNEWLINE SV _ ClipHandleForEntity STRNEWLINE  STRNEWLINE Returns ▁ a ▁ headnode ▁ that ▁ can ▁ be ▁ used ▁ for ▁ testing ▁ or ▁ clipping ▁ to ▁ a STRNEWLINE given ▁ entity . ▁ If ▁ the ▁ entity ▁ is ▁ a ▁ bsp ▁ model , ▁ the ▁ headnode ▁ will STRNEWLINE be ▁ returned , ▁ otherwise ▁ a ▁ custom ▁ box ▁ tree ▁ will ▁ be ▁ constructed .  STRNEWLINE = = = = =  STRNEWLINE */ clipHandle_t SV_ClipHandleForEntity ( const sharedEntity_t * ent ) { if ( ent -> r . bmodel ) { // ▁ explicit ▁ hulls ▁ in ▁ the ▁ BSP ▁ model ENDCOM return CM_InlineModel ( ent -> s . modelindex ) ; } if ( ent -> r . svFlags & SVF_CAPSULE ) { // ▁ create ▁ a ▁ temp ▁ capsule ▁ from ▁ bounding ▁ box ▁ sizes ENDCOM return CM_TempBoxModel ( ent -> r . mins , ent -> r . maxs , qtrue ) ; } // ▁ create ▁ a ▁ temp ▁ tree ▁ from ▁ bounding ▁ box ▁ sizes ENDCOM return CM_TempBoxModel ( ent -> r . mins , ent -> r . maxs , qfalse ) ; } /*  STRNEWLINE = = = = =  STRNEWLINE  STRNEWLINE ENTITY ▁ CHECKING STRNEWLINE  STRNEWLINE To ▁ avoid ▁ linearly ▁ searching ▁ through ▁ lists ▁ of ▁ entities ▁ during ▁ environment ▁ testing ,  STRNEWLINE the ▁ world ▁ is ▁ carved ▁ up ▁ with ▁ an ▁ evenly ▁ spaced , ▁ axially ▁ aligned ▁ bsp ▁ tree . ▁ Entities STRNEWLINE are ▁ kept ▁ in ▁ chains ▁ either ▁ at ▁ the ▁ final ▁ leafs , ▁ or ▁ at ▁ the ▁ first ▁ node ▁ that ▁ splits STRNEWLINE them , ▁ which ▁ prevents ▁ having ▁ to ▁ deal ▁ with ▁ multiple ▁ fragments ▁ of ▁ a ▁ single ▁ entity .  STRNEWLINE  STRNEWLINE = = = = =  STRNEWLINE */ typedef struct worldSector_s { int axis ; // ▁ - 1 ▁ = ▁ leaf ▁ node ENDCOM float dist ; struct worldSector_s * children [ 2 ] ; svEntity_t * entities ; } worldSector_t ; # define AREA_DEPTH 4 # define AREA_NODES 64 worldSector_t sv_worldSectors [ AREA_NODES ] ; int sv_numworldSectors ; /*  STRNEWLINE = = = = =  STRNEWLINE SV _ SectorList _ f STRNEWLINE = = = = =  STRNEWLINE */ void SV_SectorList_f ( void ) { int i , c ; worldSector_t * sec ; svEntity_t * ent ; for ( i = 0 ; i < AREA_NODES ; i ++ ) { sec = & sv_worldSectors [ i ] ; c = 0 ; for ( ent = sec -> entities ; ent ; ent = ent -> nextEntityInWorldSector ) { c ++ ; } Com_Printf ( " sector ▁ % i : ▁ % i ▁ entities \n " , i , c ) ; } } /*  STRNEWLINE = = = = =  STRNEWLINE SV _ CreateworldSector STRNEWLINE  STRNEWLINE Builds ▁ a ▁ uniformly ▁ subdivided ▁ tree ▁ for ▁ the ▁ given ▁ world ▁ size STRNEWLINE = = = = =  STRNEWLINE */ worldSector_t * SV_CreateworldSector ( int depth , vec3_t mins , vec3_t maxs ) { worldSector_t * anode ; vec3_t size ; vec3_t mins1 , maxs1 , mins2 , maxs2 ; anode = & sv_worldSectors [ sv_numworldSectors ] ; sv_numworldSectors ++ ; if ( depth == AREA_DEPTH ) { anode -> axis = - 1 ; anode -> children [ 0 ] = anode -> children [ 1 ] = NULL ; return anode ; } VectorSubtract ( maxs , mins , size ) ; if ( size [ 0 ] > size [ 1 ] ) { anode -> axis = 0 ; } else { anode -> axis = 1 ; } anode -> dist = 0.5 * ( maxs [ anode -> axis ] + mins [ anode -> axis ] ) ; VectorCopy ( mins , mins1 ) ; VectorCopy ( mins , mins2 ) ; VectorCopy ( maxs , maxs1 ) ; VectorCopy ( maxs , maxs2 ) ; maxs1 [ anode -> axis ] = mins2 [ anode -> axis ] = anode -> dist ; anode -> children [ 0 ] = SV_CreateworldSector ( depth + 1 , mins2 , maxs2 ) ; anode -> children [ 1 ] = SV_CreateworldSector ( depth + 1 , mins1 , maxs1 ) ; return anode ; } /*  STRNEWLINE = = = = =  STRNEWLINE SV _ ClearWorld STRNEWLINE  STRNEWLINE = = = = =  STRNEWLINE */ void SV_ClearWorld ( void ) { clipHandle_t h ; vec3_t mins , maxs ; Com_Memset ( sv_worldSectors , 0 , sizeof ( sv_worldSectors ) ) ; sv_numworldSectors = 0 ; // ▁ get ▁ world ▁ map ▁ bounds ENDCOM h = CM_InlineModel ( 0 ) ; CM_ModelBounds ( h , mins , maxs ) ; SV_CreateworldSector ( 0 , mins , maxs ) ; } /*  STRNEWLINE = = = = =  STRNEWLINE SV _ UnlinkEntity STRNEWLINE  STRNEWLINE = = = = =  STRNEWLINE */ void SV_UnlinkEntity ( sharedEntity_t * gEnt ) { svEntity_t * ent ; svEntity_t * scan ; worldSector_t * ws ; ent = SV_SvEntityForGentity ( gEnt ) ; gEnt -> r . linked = qfalse ; ws = ent -> worldSector ; if ( ! ws ) { return ; // ▁ not ▁ linked ▁ in ▁ anywhere ENDCOM } ent -> worldSector = NULL ; if ( ws -> entities == ent ) { ws -> entities = ent -> nextEntityInWorldSector ; return ; } for ( scan = ws -> entities ; scan ; scan = scan -> nextEntityInWorldSector ) { if ( scan -> nextEntityInWorldSector == ent ) { scan -> nextEntityInWorldSector = ent -> nextEntityInWorldSector ; return ; } } Com_Printf ( " WARNING : ▁ SV _ UnlinkEntity : ▁ not ▁ found ▁ in ▁ worldSector \n " ) ; } /*  STRNEWLINE = = = = =  STRNEWLINE SV _ LinkEntity STRNEWLINE  STRNEWLINE = = = = =  STRNEWLINE */ # define MAX_TOTAL_ENT_LEAFS 128 void SV_LinkEntity ( sharedEntity_t * gEnt ) { worldSector_t * node ; int leafs [ MAX_TOTAL_ENT_LEAFS ] ; int cluster ; int num_leafs ; int i , j , k ; int area ; int lastLeaf ; float * origin , * angles ; svEntity_t * ent ; ent = SV_SvEntityForGentity ( gEnt ) ; if ( ent -> worldSector ) { SV_UnlinkEntity ( gEnt ) ; // ▁ unlink ▁ from ▁ old ▁ position ENDCOM } // ▁ encode ▁ the ▁ size ▁ into ▁ the ▁ entityState _ t ▁ for ▁ client ▁ prediction ENDCOM if ( gEnt -> r . bmodel ) { gEnt -> s . solid = SOLID_BMODEL ; // ▁ a ▁ solid _ box ▁ will ▁ never ▁ create ▁ this ▁ value ENDCOM } else if ( gEnt -> r . contents & ( CONTENTS_SOLID | CONTENTS_BODY ) ) { // ▁ assume ▁ that ▁ x / y ▁ are ▁ equal ▁ and ▁ symetric ENDCOM i = gEnt -> r . maxs [ 0 ] ; if ( i < 1 ) i = 1 ; if ( i > 255 ) i = 255 ; // ▁ z ▁ is ▁ not ▁ symetric ENDCOM j = ( - gEnt -> r . mins [ 2 ] ) ; if ( j < 1 ) j = 1 ; if ( j > 255 ) j = 255 ; // ▁ and ▁ z ▁ maxs ▁ can ▁ be ▁ negative . . . ENDCOM k = ( gEnt -> r . maxs [ 2 ] + 32 ) ; if ( k < 1 ) k = 1 ; if ( k > 255 ) k = 255 ; gEnt -> s . solid = ( k << 16 ) | ( j << 8 ) | i ; } else { gEnt -> s . solid = 0 ; } // ▁ get ▁ the ▁ position ENDCOM origin = gEnt -> r . currentOrigin ; angles = gEnt -> r . currentAngles ; // ▁ set ▁ the ▁ abs ▁ box ENDCOM if ( gEnt -> r . bmodel && ( angles [ 0 ] || angles [ 1 ] || angles [ 2 ] ) ) { // ▁ expand ▁ for ▁ rotation ENDCOM float max ; int i ; max = RadiusFromBounds ( gEnt -> r . mins , gEnt -> r . maxs ) ; for ( i = 0 ; i < 3 ; i ++ ) { gEnt -> r . absmin [ i ] = origin [ i ] - max ; gEnt -> r . absmax [ i ] = origin [ i ] + max ; } } else { // ▁ normal ENDCOM VectorAdd ( origin , gEnt -> r . mins , gEnt -> r . absmin ) ; VectorAdd ( origin , gEnt -> r . maxs , gEnt -> r . absmax ) ; } // ▁ because ▁ movement ▁ is ▁ clipped ▁ an ▁ epsilon ▁ away ▁ from ▁ an ▁ actual ▁ edge , ENDCOM // ▁ we ▁ must ▁ fully ▁ check ▁ even ▁ when ▁ bounding ▁ boxes ▁ don ' t ▁ quite ▁ touch ENDCOM gEnt -> r . absmin [ 0 ] -= 1 ; gEnt -> r . absmin [ 1 ] -= 1 ; gEnt -> r . absmin [ 2 ] -= 1 ; gEnt -> r . absmax [ 0 ] += 1 ; gEnt -> r . absmax [ 1 ] += 1 ; gEnt -> r . absmax [ 2 ] += 1 ; // ▁ link ▁ to ▁ PVS ▁ leafs ENDCOM ent -> numClusters = 0 ; ent -> lastCluster = 0 ; ent -> areanum = - 1 ; ent -> areanum2 = - 1 ; // get ▁ all ▁ leafs , ▁ including ▁ solids ENDCOM num_leafs = CM_BoxLeafnums ( gEnt -> r . absmin , gEnt -> r . absmax , leafs , MAX_TOTAL_ENT_LEAFS , & lastLeaf ) ; // ▁ if ▁ none ▁ of ▁ the ▁ leafs ▁ were ▁ inside ▁ the ▁ map , ▁ the ENDCOM // ▁ entity ▁ is ▁ outside ▁ the ▁ world ▁ and ▁ can ▁ be ▁ considered ▁ unlinked ENDCOM if ( ! num_leafs ) { return ; } // ▁ set ▁ areas , ▁ even ▁ from ▁ clusters ▁ that ▁ don ' t ▁ fit ▁ in ▁ the ▁ entity ▁ array ENDCOM for ( i = 0 ; i < num_leafs ; i ++ ) { area = CM_LeafArea ( leafs [ i ] ) ; if ( area != - 1 ) { // ▁ doors ▁ may ▁ legally ▁ straggle ▁ two ▁ areas , ENDCOM // ▁ but ▁ nothing ▁ should ▁ evern ▁ need ▁ more ▁ than ▁ that ENDCOM if ( ent -> areanum != - 1 && ent -> areanum != area ) { if ( ent -> areanum2 != - 1 && ent -> areanum2 != area && sv . state == SS_LOADING ) { Com_DPrintf ( " Object ▁ % i ▁ touching ▁ 3 ▁ areas ▁ at ▁ % f ▁ % f ▁ % f \n " , gEnt -> s . number , gEnt -> r . absmin [ 0 ] , gEnt -> r . absmin [ 1 ] , gEnt -> r . absmin [ 2 ] ) ; } ent -> areanum2 = area ; } else { ent -> areanum = area ; } } } // ▁ store ▁ as ▁ many ▁ explicit ▁ clusters ▁ as ▁ we ▁ can ENDCOM ent -> numClusters = 0 ; for ( i = 0 ; i < num_leafs ; i ++ ) { cluster = CM_LeafCluster ( leafs [ i ] ) ; if ( cluster != - 1 ) { ent -> clusternums [ ent -> numClusters ++ ] = cluster ; if ( ent -> numClusters == MAX_ENT_CLUSTERS ) { break ; } } } // ▁ store ▁ off ▁ a ▁ last ▁ cluster ▁ if ▁ we ▁ need ▁ to ENDCOM if ( i != num_leafs ) { ent -> lastCluster = CM_LeafCluster ( lastLeaf ) ; } gEnt -> r . linkcount ++ ; // ▁ find ▁ the ▁ first ▁ world ▁ sector ▁ node ▁ that ▁ the ▁ ent ' s ▁ box ▁ crosses ENDCOM node = sv_worldSectors ; while ( 1 ) { if ( node -> axis == - 1 ) break ; if ( gEnt -> r . absmin [ node -> axis ] > node -> dist ) node = node -> children [ 0 ] ; else if ( gEnt -> r . absmax [ node -> axis ] < node -> dist ) node = node -> children [ 1 ] ; else break ; // ▁ crosses ▁ the ▁ node ENDCOM } // ▁ link ▁ it ▁ in ENDCOM ent -> worldSector = node ; ent -> nextEntityInWorldSector = node -> entities ; node -> entities = ent ; gEnt -> r . linked = qtrue ; } /*  STRNEWLINE = = = = =  STRNEWLINE  STRNEWLINE AREA ▁ QUERY STRNEWLINE  STRNEWLINE Fills ▁ in ▁ a ▁ list ▁ of ▁ all ▁ entities ▁ who ' s ▁ absmin ▁ / ▁ absmax ▁ intersects ▁ the ▁ given STRNEWLINE bounds . ▁ This ▁ does ▁ NOT ▁ mean ▁ that ▁ they ▁ actually ▁ touch ▁ in ▁ the ▁ case ▁ of ▁ bmodels .  STRNEWLINE = = = = =  STRNEWLINE */ typedef struct { const float * mins ; const float * maxs ; int * list ; int count , maxcount ; } areaParms_t ; /*  STRNEWLINE = = = = =  STRNEWLINE SV _ AreaEntities _ r STRNEWLINE  STRNEWLINE = = = = =  STRNEWLINE */ void SV_AreaEntities_r ( worldSector_t * node , areaParms_t * ap ) { svEntity_t * check , * next ; sharedEntity_t * gcheck ; int count ; count = 0 ; for ( check = node -> entities ; check ; check = next ) { next = check -> nextEntityInWorldSector ; gcheck = SV_GEntityForSvEntity ( check ) ; if ( gcheck -> r . absmin [ 0 ] > ap -> maxs [ 0 ] || gcheck -> r . absmin [ 1 ] > ap -> maxs [ 1 ] || gcheck -> r . absmin [ 2 ] > ap -> maxs [ 2 ] || gcheck -> r . absmax [ 0 ] < ap -> mins [ 0 ] || gcheck -> r . absmax [ 1 ] < ap -> mins [ 1 ] || gcheck -> r . absmax [ 2 ] < ap -> mins [ 2 ] ) { continue ; } if ( ap -> count == ap -> maxcount ) { Com_Printf ( " SV _ AreaEntities : ▁ MAXCOUNT \n " ) ; return ; } ap -> list [ ap -> count ] = check - sv . svEntities ; ap -> count ++ ; } if ( node -> axis == - 1 ) { return ; // ▁ terminal ▁ node ENDCOM } // ▁ recurse ▁ down ▁ both ▁ sides ENDCOM if ( ap -> maxs [ node -> axis ] > node -> dist ) { SV_AreaEntities_r ( node -> children [ 0 ] , ap ) ; } if ( ap -> mins [ node -> axis ] < node -> dist ) { SV_AreaEntities_r ( node -> children [ 1 ] , ap ) ; } } /*  STRNEWLINE = = = = =  STRNEWLINE SV _ AreaEntities STRNEWLINE = = = = =  STRNEWLINE */ int SV_AreaEntities ( const vec3_t mins , const vec3_t maxs , int * entityList , int maxcount ) { areaParms_t ap ; ap . mins = mins ; ap . maxs = maxs ; ap . list = entityList ; ap . count = 0 ; ap . maxcount = maxcount ; SV_AreaEntities_r ( sv_worldSectors , & ap ) ; return ap . count ; } typedef struct { vec3_t boxmins , boxmaxs ; // ▁ enclose ▁ the ▁ test ▁ object ▁ along ▁ entire ▁ move ENDCOM const float * mins ; const float * maxs ; // ▁ size ▁ of ▁ the ▁ moving ▁ object ENDCOM /*  STRNEWLINE Ghoul2 ▁ Insert ▁ Start STRNEWLINE */ vec3_t start ; vec3_t end ; int passEntityNum ; int contentmask ; int capsule ; int traceFlags ; int useLod ; trace_t trace ; // ▁ make ▁ sure ▁ nothing ▁ goes ▁ under ▁ here ▁ for ▁ Ghoul2 ▁ collision ▁ purposes ENDCOM /*  STRNEWLINE Ghoul2 ▁ Insert ▁ End STRNEWLINE */ } moveclip_t ; /*  STRNEWLINE = = = = =  STRNEWLINE SV _ ClipToEntity STRNEWLINE  STRNEWLINE = = = = =  STRNEWLINE */ void SV_ClipToEntity ( trace_t * trace , const vec3_t start , const vec3_t mins , const vec3_t maxs , const vec3_t end , int entityNum , int contentmask , int capsule ) { sharedEntity_t * touch ; clipHandle_t clipHandle ; float * origin , * angles ; touch = SV_GentityNum ( entityNum ) ; Com_Memset ( trace , 0 , sizeof ( trace_t ) ) ; // ▁ if ▁ it ▁ doesn ' t ▁ have ▁ any ▁ brushes ▁ of ▁ a ▁ type ▁ we ENDCOM // ▁ are ▁ looking ▁ for , ▁ ignore ▁ it ENDCOM if ( ! ( contentmask & touch -> r . contents ) ) { trace -> fraction = 1.0 ; return ; } // ▁ might ▁ intersect , ▁ so ▁ do ▁ an ▁ exact ▁ clip ENDCOM clipHandle = SV_ClipHandleForEntity ( touch ) ; origin = touch -> r . currentOrigin ; angles = touch -> r . currentAngles ; if ( ! touch -> r . bmodel ) { angles = vec3_origin ; // ▁ boxes ▁ don ' t ▁ rotate ENDCOM } CM_TransformedBoxTrace ( trace , ( float * ) start , ( float * ) end , ( float * ) mins , ( float * ) maxs , clipHandle , contentmask , origin , angles , capsule ) ; if ( trace -> fraction < 1 ) { trace -> entityNum = touch -> s . number ; } } /*  STRNEWLINE = = = = =  STRNEWLINE SV _ ClipMoveToEntities STRNEWLINE  STRNEWLINE = = = = =  STRNEWLINE */ void SV_ClipMoveToEntities ( moveclip_t * clip ) { int i , num ; int touchlist [ MAX_GENTITIES ] ; sharedEntity_t * touch ; int passOwnerNum ; trace_t trace , oldTrace ; clipHandle_t clipHandle ; float * origin , * angles ; int thisOwnerShared = 1 ; num = SV_AreaEntities ( clip -> boxmins , clip -> boxmaxs , touchlist , MAX_GENTITIES ) ; if ( clip -> passEntityNum != ENTITYNUM_NONE ) { passOwnerNum = ( SV_GentityNum ( clip -> passEntityNum ) ) -> r . ownerNum ; if ( passOwnerNum == ENTITYNUM_NONE ) { passOwnerNum = - 1 ; } } else { passOwnerNum = - 1 ; } if ( SV_GentityNum ( clip -> passEntityNum ) -> r . svFlags & SVF_OWNERNOTSHARED ) { thisOwnerShared = 0 ; } for ( i = 0 ; i < num ; i ++ ) { if ( clip -> trace . allsolid ) { return ; } touch = SV_GentityNum ( touchlist [ i ] ) ; // ▁ see ▁ if ▁ we ▁ should ▁ ignore ▁ this ▁ entity ENDCOM if ( clip -> passEntityNum != ENTITYNUM_NONE ) { if ( touchlist [ i ] == clip -> passEntityNum ) { continue ; // ▁ don ' t ▁ clip ▁ against ▁ the ▁ pass ▁ entity ENDCOM } if ( touch -> r . ownerNum == clip -> passEntityNum ) { if ( touch -> r . svFlags & SVF_OWNERNOTSHARED ) { if ( clip -> contentmask != ( MASK_SHOT | CONTENTS_LIGHTSABER ) && clip -> contentmask != ( MASK_SHOT ) ) { // it ' s ▁ not ▁ a ▁ laser ▁ hitting ▁ the ▁ other ▁ " missile " , ▁ don ' t ▁ care ▁ then ENDCOM continue ; } } else { continue ; // ▁ don ' t ▁ clip ▁ against ▁ own ▁ missiles ENDCOM } } if ( touch -> r . ownerNum == passOwnerNum && ! ( touch -> r . svFlags & SVF_OWNERNOTSHARED ) && ! thisOwnerShared ) { continue ; // ▁ don ' t ▁ clip ▁ against ▁ other ▁ missiles ▁ from ▁ our ▁ owner ENDCOM } } // ▁ if ▁ it ▁ doesn ' t ▁ have ▁ any ▁ brushes ▁ of ▁ a ▁ type ▁ we ENDCOM // ▁ are ▁ looking ▁ for , ▁ ignore ▁ it ENDCOM if ( ! ( clip -> contentmask & touch -> r . contents ) ) { continue ; } if ( ( clip -> contentmask == ( MASK_SHOT | CONTENTS_LIGHTSABER ) || clip -> contentmask == MASK_SHOT ) && ( touch -> r . contents > 0 && ( touch -> r . contents & CONTENTS_NOSHOT ) ) ) { continue ; } // ▁ might ▁ intersect , ▁ so ▁ do ▁ an ▁ exact ▁ clip ENDCOM clipHandle = SV_ClipHandleForEntity ( touch ) ; origin = touch -> r . currentOrigin ; angles = touch -> r . currentAngles ; if ( ! touch -> r . bmodel ) { angles = vec3_origin ; // ▁ boxes ▁ don ' t ▁ rotate ENDCOM } CM_TransformedBoxTrace ( & trace , ( float * ) clip -> start , ( float * ) clip -> end , ( float * ) clip -> mins , ( float * ) clip -> maxs , clipHandle , clip -> contentmask , origin , angles , clip -> capsule ) ; /*  STRNEWLINE Ghoul2 ▁ Insert ▁ Start STRNEWLINE */ // ▁ keep ▁ these ▁ older ▁ variables ▁ around ▁ for ▁ a ▁ bit , ▁ incase ▁ we ▁ need ▁ to ▁ replace ▁ them ▁ in ▁ the ▁ Ghoul2 ▁ Collision ▁ check ENDCOM oldTrace = clip -> trace ; /*  STRNEWLINE Ghoul2 ▁ Insert ▁ End STRNEWLINE */ if ( trace . allsolid ) { clip -> trace . allsolid = qtrue ; trace . entityNum = touch -> s . number ; } else if ( trace . startsolid ) { clip -> trace . startsolid = qtrue ; trace . entityNum = touch -> s . number ; } if ( trace . fraction < clip -> trace . fraction ) { qboolean oldStart ; // ▁ make ▁ sure ▁ we ▁ keep ▁ a ▁ startsolid ▁ from ▁ a ▁ previous ▁ trace ENDCOM oldStart = clip -> trace . startsolid ; trace . entityNum = touch -> s . number ; clip -> trace = trace ; clip -> trace . startsolid = ( qboolean ) ( ( unsigned ) clip -> trace . startsolid | ( unsigned ) oldStart ) ; } /*  STRNEWLINE Ghoul2 ▁ Insert ▁ Start STRNEWLINE */ # if 0 // ▁ decide ▁ if ▁ we ▁ should ▁ do ▁ the ▁ ghoul2 ▁ collision ▁ detection ▁ right ▁ here ENDCOM if ( ( trace . entityNum == touch -> s . number ) && ( clip -> traceFlags ) ) { // ▁ do ▁ we ▁ actually ▁ have ▁ a ▁ ghoul2 ▁ model ▁ here ? ENDCOM if ( touch -> s . ghoul2 ) { int oldTraceRecSize = 0 ; int newTraceRecSize = 0 ; int z ; // ▁ we ▁ have ▁ to ▁ do ▁ this ▁ because ▁ sometimes ▁ you ▁ may ▁ hit ▁ a ▁ model ' s ▁ bounding ▁ box , ▁ but ▁ not ▁ actually ▁ penetrate ▁ the ▁ Ghoul2 ▁ Models ▁ polygons ENDCOM // ▁ this ▁ is , ▁ needless ▁ to ▁ say , ▁ not ▁ good . ▁ So ▁ we ▁ must ▁ check ▁ to ▁ see ▁ if ▁ we ▁ did ▁ actually ▁ hit ▁ the ▁ model , ▁ and ▁ if ▁ not , ▁ reset ▁ the ▁ trace ▁ stuff ENDCOM // ▁ to ▁ what ▁ it ▁ was ▁ to ▁ begin ▁ with ENDCOM // ▁ set ▁ our ▁ trace ▁ record ▁ size ENDCOM for ( z = 0 ; z < MAX_G2_COLLISIONS ; z ++ ) { if ( clip -> trace . G2CollisionMap [ z ] . mEntityNum != - 1 ) { oldTraceRecSize ++ ; } } G2API_CollisionDetect ( & clip -> trace . G2CollisionMap [ 0 ] , * ( ( CGhoul2Info_v * ) touch -> s . ghoul2 ) , touch -> s . angles , touch -> s . origin , svs . time , touch -> s . number , clip -> start , clip -> end , touch -> s . modelScale , G2VertSpaceServer , clip -> traceFlags , clip -> useLod ) ; // ▁ set ▁ our ▁ new ▁ trace ▁ record ▁ size ENDCOM for ( z = 0 ; z < MAX_G2_COLLISIONS ; z ++ ) { if ( clip -> trace . G2CollisionMap [ z ] . mEntityNum != - 1 ) { newTraceRecSize ++ ; } } // ▁ did ▁ we ▁ actually ▁ touch ▁ this ▁ model ? ▁ If ▁ not , ▁ lets ▁ reset ▁ this ▁ ent ▁ as ▁ being ▁ hit . . ENDCOM if ( newTraceRecSize == oldTraceRecSize ) { clip -> trace = oldTrace ; } } } # endif /*  STRNEWLINE Ghoul2 ▁ Insert ▁ End STRNEWLINE */ } } /*  STRNEWLINE = = = = =  STRNEWLINE SV _ Trace STRNEWLINE  STRNEWLINE Moves ▁ the ▁ given ▁ mins / maxs ▁ volume ▁ through ▁ the ▁ world ▁ from ▁ start ▁ to ▁ end .  STRNEWLINE passEntityNum ▁ and ▁ entities ▁ owned ▁ by ▁ passEntityNum ▁ are ▁ explicitly ▁ not ▁ checked .  STRNEWLINE = = = = =  STRNEWLINE */ /*  STRNEWLINE Ghoul2 ▁ Insert ▁ Start STRNEWLINE */ void SV_Trace ( trace_t * results , const vec3_t start , const vec3_t mins , const vec3_t maxs , const vec3_t end , int passEntityNum , int contentmask , int capsule , int traceFlags , int useLod ) { /*  STRNEWLINE Ghoul2 ▁ Insert ▁ End STRNEWLINE */ moveclip_t clip ; int i ; if ( ! mins ) { mins = vec3_origin ; } if ( ! maxs ) { maxs = vec3_origin ; } Com_Memset ( & clip , 0 , sizeof ( moveclip_t ) ) ; // ▁ clip ▁ to ▁ world ENDCOM CM_BoxTrace ( & clip . trace , start , end , mins , maxs , 0 , contentmask , capsule ) ; clip . trace . entityNum = clip . trace . fraction != 1.0 ? ENTITYNUM_WORLD : ENTITYNUM_NONE ; if ( clip . trace . fraction == 0 ) { * results = clip . trace ; return ; // ▁ blocked ▁ immediately ▁ by ▁ the ▁ world ENDCOM } clip . contentmask = contentmask ; /*  STRNEWLINE Ghoul2 ▁ Insert ▁ Start STRNEWLINE */ VectorCopy ( start , clip . start ) ; clip . traceFlags = traceFlags ; clip . useLod = useLod ; /*  STRNEWLINE Ghoul2 ▁ Insert ▁ End STRNEWLINE */ // TABSYMBOL VectorCopy ( ▁ clip . trace . endpos , ▁ clip . end ▁ ) ; ENDCOM VectorCopy ( end , clip . end ) ; clip . mins = mins ; clip . maxs = maxs ; clip . passEntityNum = passEntityNum ; clip . capsule = capsule ; // ▁ create ▁ the ▁ bounding ▁ box ▁ of ▁ the ▁ entire ▁ move ENDCOM // ▁ we ▁ can ▁ limit ▁ it ▁ to ▁ the ▁ part ▁ of ▁ the ▁ move ▁ not ENDCOM // ▁ already ▁ clipped ▁ off ▁ by ▁ the ▁ world , ▁ which ▁ can ▁ be ENDCOM // ▁ a ▁ significant ▁ savings ▁ for ▁ line ▁ of ▁ sight ▁ and ▁ shot ▁ traces ENDCOM for ( i = 0 ; i < 3 ; i ++ ) { if ( end [ i ] > start [ i ] ) { clip . boxmins [ i ] = clip . start [ i ] + clip . mins [ i ] - 1 ; clip . boxmaxs [ i ] = clip . end [ i ] + clip . maxs [ i ] + 1 ; } else { clip . boxmins [ i ] = clip . end [ i ] + clip . mins [ i ] - 1 ; clip . boxmaxs [ i ] = clip . start [ i ] + clip . maxs [ i ] + 1 ; } } // ▁ clip ▁ to ▁ other ▁ solid ▁ entities ENDCOM SV_ClipMoveToEntities ( & clip ) ; * results = clip . trace ; } /*  STRNEWLINE = = = = =  STRNEWLINE SV _ PointContents STRNEWLINE = = = = =  STRNEWLINE */ int SV_PointContents ( const vec3_t p , int passEntityNum ) { int touch [ MAX_GENTITIES ] ; sharedEntity_t * hit ; int i , num ; int contents , c2 ; clipHandle_t clipHandle ; float * angles ; // ▁ get ▁ base ▁ contents ▁ from ▁ world ENDCOM contents = CM_PointContents ( p , 0 ) ; // ▁ or ▁ in ▁ contents ▁ from ▁ all ▁ the ▁ other ▁ entities ENDCOM num = SV_AreaEntities ( p , p , touch , MAX_GENTITIES ) ; for ( i = 0 ; i < num ; i ++ ) { if ( touch [ i ] == passEntityNum ) { continue ; } hit = SV_GentityNum ( touch [ i ] ) ; // ▁ might ▁ intersect , ▁ so ▁ do ▁ an ▁ exact ▁ clip ENDCOM clipHandle = SV_ClipHandleForEntity ( hit ) ; angles = hit -> s . angles ; if ( ! hit -> r . bmodel ) { angles = vec3_origin ; // ▁ boxes ▁ don ' t ▁ rotate ENDCOM } c2 = CM_TransformedPointContents ( p , clipHandle , hit -> s . origin , hit -> s . angles ) ; contents |= c2 ; } return contents ; } </DOCUMENT>
<DOCUMENT_ID="ericzhou2008/WinObjC/tree/master/deps/3rdparty/iculegacy/source/common/parsepos.cpp"> /* STRNEWLINE * * * * * STRNEWLINE * ▁ Copyright ▁ ( C ) ▁ 2003-2003 , ▁ International ▁ Business ▁ Machines STRNEWLINE * ▁ Corporation ▁ and ▁ others . ▁ All ▁ Rights ▁ Reserved . STRNEWLINE * * * * * STRNEWLINE */ # include " unicode / parsepos . h " U_NAMESPACE_BEGIN UOBJECT_DEFINE_RTTI_IMPLEMENTATION ( ParsePosition ) ParsePosition :: ~ ParsePosition ( ) { } ParsePosition * ParsePosition :: clone ( ) const { return new ParsePosition ( * this ) ; } U_NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="SatoshiMabuchi/Crystal/tree/master/ThirdParty/glm-0.9.8.5/test/core/core_type_length.cpp"> # include < glm / glm . hpp > int test_length_mat_non_squared ( ) { int Error = 0 ; Error += glm :: mat2x3 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: mat2x4 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: mat3x2 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: mat3x4 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: mat4x2 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: mat4x3 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dmat2x3 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dmat2x4 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dmat3x2 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dmat3x4 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dmat4x2 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dmat4x3 ( ) . length ( ) == 4 ? 0 : 1 ; return Error ; } int test_length_mat ( ) { int Error = 0 ; Error += glm :: mat2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: mat3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: mat4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: mat2x2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: mat3x3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: mat4x4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dmat2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dmat3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dmat4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dmat2x2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dmat3x3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dmat4x4 ( ) . length ( ) == 4 ? 0 : 1 ; return Error ; } int test_length_vec ( ) { int Error = 0 ; Error += glm :: vec2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: vec3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: vec4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: ivec2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: ivec3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: ivec4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: uvec2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: uvec3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: uvec4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dvec2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dvec3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dvec4 ( ) . length ( ) == 4 ? 0 : 1 ; return Error ; } int main ( ) { int Error = 0 ; Error += test_length_vec ( ) ; Error += test_length_mat ( ) ; Error += test_length_mat_non_squared ( ) ; return Error ; } </DOCUMENT>
<DOCUMENT_ID="DLR-SC/tigl/tree/master/src/generated/CPACSFarField.cpp"> // ▁ Copyright ▁ ( c ) ▁ 2018 ▁ RISC ▁ Software ▁ GmbH ENDCOM // ▁ This ▁ file ▁ was ▁ generated ▁ by ▁ CPACSGen ▁ from ▁ CPACS ▁ XML ▁ Schema ▁ ( c ) ▁ German ▁ Aerospace ▁ Center ▁ ( DLR / SC ) . ENDCOM // ▁ Do ▁ not ▁ edit , ▁ all ▁ changes ▁ are ▁ lost ▁ when ▁ files ▁ are ▁ re - generated . ENDCOM // ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ENDCOM // ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . ENDCOM // ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at ENDCOM // ▁ http : // www . apache . org / licenses / LICENSE - 2.0 ENDCOM // ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ENDCOM // ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ENDCOM // ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ENDCOM // ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ENDCOM // ▁ limitations ▁ under ▁ the ▁ License . ENDCOM # include " CPACSFarField . h " # include " CTiglError . h " # include " CTiglLogging . h " # include " TixiHelper . h " namespace tigl { namespace generated { CPACSFarField :: CPACSFarField ( ) : m_referenceLength ( 0 ) , m_multiplier ( 0 ) { } CPACSFarField :: ~ CPACSFarField ( ) { } void CPACSFarField :: ReadCPACS ( const TixiDocumentHandle & tixiHandle , const std :: string & xpath ) { // ▁ read ▁ element ▁ type ENDCOM if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / type " ) ) { m_type = stringToTiglFarFieldType ( tixi :: TixiGetElement < std :: string > ( tixiHandle , xpath + " / type " ) ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ type ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } // ▁ read ▁ element ▁ referenceLength ENDCOM if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / referenceLength " ) ) { m_referenceLength = tixi :: TixiGetElement < double > ( tixiHandle , xpath + " / referenceLength " ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ referenceLength ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } // ▁ read ▁ element ▁ multiplier ENDCOM if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / multiplier " ) ) { m_multiplier = tixi :: TixiGetElement < double > ( tixiHandle , xpath + " / multiplier " ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ multiplier ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } } void CPACSFarField :: WriteCPACS ( const TixiDocumentHandle & tixiHandle , const std :: string & xpath ) const { // ▁ write ▁ element ▁ type ENDCOM tixi :: TixiCreateElementIfNotExists ( tixiHandle , xpath + " / type " ) ; tixi :: TixiSaveElement ( tixiHandle , xpath + " / type " , TiglFarFieldTypeToString ( m_type ) ) ; // ▁ write ▁ element ▁ referenceLength ENDCOM tixi :: TixiCreateElementIfNotExists ( tixiHandle , xpath + " / referenceLength " ) ; tixi :: TixiSaveElement ( tixiHandle , xpath + " / referenceLength " , m_referenceLength ) ; // ▁ write ▁ element ▁ multiplier ENDCOM tixi :: TixiCreateElementIfNotExists ( tixiHandle , xpath + " / multiplier " ) ; tixi :: TixiSaveElement ( tixiHandle , xpath + " / multiplier " , m_multiplier ) ; } const TiglFarFieldType & CPACSFarField :: GetType ( ) const { return m_type ; } void CPACSFarField :: SetType ( const TiglFarFieldType & value ) { m_type = value ; } const double & CPACSFarField :: GetReferenceLength ( ) const { return m_referenceLength ; } void CPACSFarField :: SetReferenceLength ( const double & value ) { m_referenceLength = value ; } const double & CPACSFarField :: GetMultiplier ( ) const { return m_multiplier ; } void CPACSFarField :: SetMultiplier ( const double & value ) { m_multiplier = value ; } } // ▁ namespace ▁ generated ENDCOM } // ▁ namespace ▁ tigl ENDCOM </DOCUMENT>
<DOCUMENT_ID="ddark/ecl/tree/master/src/server/scripts/Northrend/zone_wintergrasp.cpp"> /* ▁ Copyright ▁ ( C ) ▁ 2008 ▁ - ▁ 2009 ▁ Trinity ▁ < http : // www . trinitycore . org / > STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or STRNEWLINE ▁ * ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software STRNEWLINE ▁ * ▁ Foundation , ▁ Inc . , ▁ 59 ▁ Temple ▁ Place , ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 ▁ USA STRNEWLINE ▁ */ # include " BattlefieldMgr . h " # include " BattlefieldWG . h " # include " Battlefield . h " # include " ScriptSystem . h " # include " WorldSession . h " # include " ObjectMgr . h " # include " Vehicle . h " # include " GameObjectAI . h " # include " ScriptedCreature . h " # include " ScriptedGossip . h " # include " SpellScript . h " # include " Player . h " # define GOSSIP_HELLO_DEMO1 " Build ▁ catapult . " # define GOSSIP_HELLO_DEMO2 " Build ▁ demolisher . " # define GOSSIP_HELLO_DEMO3 " Build ▁ siege ▁ engine . " # define GOSSIP_HELLO_DEMO4 " I ▁ cannot ▁ build ▁ more ! " enum WGqueuenpctext { WG_NPCQUEUE_TEXT_H_NOWAR = 14775 , WG_NPCQUEUE_TEXT_H_QUEUE = 14790 , WG_NPCQUEUE_TEXT_H_WAR = 14777 , WG_NPCQUEUE_TEXT_A_NOWAR = 14782 , WG_NPCQUEUE_TEXT_A_QUEUE = 14791 , WG_NPCQUEUE_TEXT_A_WAR = 14781 , WG_NPCQUEUE_TEXTOPTION_JOIN = 20077 , } ; enum Spells { // ▁ Demolisher ▁ engineers ▁ spells ENDCOM SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE = 61409 , SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE = 56662 , SPELL_BUILD_CATAPULT_FORCE = 56664 , SPELL_BUILD_DEMOLISHER_FORCE = 56659 , SPELL_ACTIVATE_CONTROL_ARMS = 49899 , SPELL_RIDE_WG_VEHICLE = 60968 , SPELL_VEHICLE_TELEPORT = 49759 , // ▁ Spirit ▁ guide ENDCOM SPELL_CHANNEL_SPIRIT_HEAL = 22011 , } ; enum CreatureIds { NPC_GOBLIN_MECHANIC = 30400 , NPC_GNOMISH_ENGINEER = 30499 , NPC_WINTERGRASP_CONTROL_ARMS = 27852 , NPC_WORLD_TRIGGER_LARGE_AOI_NOT_IMMUNE_PC_NPC = 23472 , } ; enum QuestIds { QUEST_BONES_AND_ARROWS_HORDE_ATT = 13193 , QUEST_JINXING_THE_WALLS_HORDE_ATT = 13202 , QUEST_SLAY_THEM_ALL_HORDE_ATT = 13180 , QUEST_FUELING_THE_DEMOLISHERS_HORDE_ATT = 13200 , QUEST_HEALING_WITH_ROSES_HORDE_ATT = 13201 , QUEST_DEFEND_THE_SIEGE_HORDE_ATT = 13223 , QUEST_BONES_AND_ARROWS_HORDE_DEF = 13199 , QUEST_WARDING_THE_WALLS_HORDE_DEF = 13192 , QUEST_SLAY_THEM_ALL_HORDE_DEF = 13178 , QUEST_FUELING_THE_DEMOLISHERS_HORDE_DEF = 13191 , QUEST_HEALING_WITH_ROSES_HORDE_DEF = 13194 , QUEST_TOPPLING_THE_TOWERS_HORDE_DEF = 13539 , QUEST_STOP_THE_SIEGE_HORDE_DEF = 13185 , QUEST_BONES_AND_ARROWS_ALLIANCE_ATT = 13196 , QUEST_WARDING_THE_WARRIORS_ALLIANCE_ATT = 13198 , QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_ATT = 13179 , QUEST_DEFEND_THE_SIEGE_ALLIANCE_ATT = 13222 , QUEST_A_RARE_HERB_ALLIANCE_ATT = 13195 , QUEST_BONES_AND_ARROWS_ALLIANCE_DEF = 13154 , QUEST_WARDING_THE_WARRIORS_ALLIANCE_DEF = 13153 , QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_DEF = 13177 , QUEST_SHOUTHERN_SABOTAGE_ALLIANCE_DEF = 13538 , QUEST_STOP_THE_SIEGE_ALLIANCE_DEF = 13186 , QUEST_A_RARE_HERB_ALLIANCE_DEF = 13156 , } ; uint8 const MAX_WINTERGRASP_VEHICLES = 4 ; uint32 const vehiclesList [ MAX_WINTERGRASP_VEHICLES ] = { NPC_WINTERGRASP_CATAPULT , NPC_WINTERGRASP_DEMOLISHER , NPC_WINTERGRASP_SIEGE_ENGINE_ALLIANCE , NPC_WINTERGRASP_SIEGE_ENGINE_HORDE } ; class npc_wg_demolisher_engineer : public CreatureScript { public : npc_wg_demolisher_engineer ( ) : CreatureScript ( " npc _ wg _ demolisher _ engineer " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; if ( CanBuild ( creature ) ) { if ( player -> HasAura ( SPELL_CORPORAL ) ) player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO1 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; else if ( player -> HasAura ( SPELL_LIEUTENANT ) ) { player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO1 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO2 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + 1 ) ; player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO3 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + 2 ) ; } } else player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO4 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + 9 ) ; player -> SEND_GOSSIP_MENU ( player -> GetGossipTextId ( creature ) , creature -> GetGUID ( ) ) ; return true ; } bool OnGossipSelect ( Player * player , Creature * creature , uint32 /* sender */ , uint32 action ) OVERRIDE { player -> CLOSE_GOSSIP_MENU ( ) ; if ( CanBuild ( creature ) ) { switch ( action - GOSSIP_ACTION_INFO_DEF ) { case 0 : creature -> CastSpell ( player , SPELL_BUILD_CATAPULT_FORCE , true ) ; break ; case 1 : creature -> CastSpell ( player , SPELL_BUILD_DEMOLISHER_FORCE , true ) ; break ; case 2 : creature -> CastSpell ( player , player -> GetTeamId ( ) == TEAM_ALLIANCE ? SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE : SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE , true ) ; break ; } if ( Creature * controlArms = creature -> FindNearestCreature ( NPC_WINTERGRASP_CONTROL_ARMS , 30.0f , true ) ) creature -> CastSpell ( controlArms , SPELL_ACTIVATE_CONTROL_ARMS , true ) ; } return true ; } private : bool CanBuild ( Creature * creature ) { Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return false ; switch ( creature -> GetEntry ( ) ) { case NPC_GOBLIN_MECHANIC : return ( wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_MAX_VEHICLE_H ) > wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_VEHICLE_H ) ) ; case NPC_GNOMISH_ENGINEER : return ( wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_MAX_VEHICLE_A ) > wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_VEHICLE_A ) ) ; default : return false ; } } } ; class npc_wg_spirit_guide : public CreatureScript { public : npc_wg_spirit_guide ( ) : CreatureScript ( " npc _ wg _ spirit _ guide " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; GraveyardVect graveyard = wintergrasp -> GetGraveyardVector ( ) ; for ( uint8 i = 0 ; i < graveyard . size ( ) ; i ++ ) if ( graveyard [ i ] -> GetControlTeamId ( ) == player -> GetTeamId ( ) ) player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , sObjectMgr -> GetTrinityStringForDBCLocale ( ( ( BfGraveyardWG * ) graveyard [ i ] ) -> GetTextId ( ) ) , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + i ) ; player -> SEND_GOSSIP_MENU ( player -> GetGossipTextId ( creature ) , creature -> GetGUID ( ) ) ; return true ; } bool OnGossipSelect ( Player * player , Creature * /* creature */ , uint32 /* sender */ , uint32 action ) OVERRIDE { player -> CLOSE_GOSSIP_MENU ( ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( wintergrasp ) { GraveyardVect gy = wintergrasp -> GetGraveyardVector ( ) ; for ( uint8 i = 0 ; i < gy . size ( ) ; i ++ ) if ( action - GOSSIP_ACTION_INFO_DEF == i && gy [ i ] -> GetControlTeamId ( ) == player -> GetTeamId ( ) ) if ( WorldSafeLocsEntry const * safeLoc = sWorldSafeLocsStore . LookupEntry ( gy [ i ] -> GetGraveyardId ( ) ) ) player -> TeleportTo ( safeLoc -> map_id , safeLoc -> x , safeLoc -> y , safeLoc -> z , 0 ) ; } return true ; } struct npc_wg_spirit_guideAI : public ScriptedAI { npc_wg_spirit_guideAI ( Creature * creature ) : ScriptedAI ( creature ) { } void UpdateAI ( uint32 /* diff */ ) OVERRIDE { if ( ! me -> HasUnitState ( UNIT_STATE_CASTING ) ) DoCast ( me , SPELL_CHANNEL_SPIRIT_HEAL ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const OVERRIDE { return new npc_wg_spirit_guideAI ( creature ) ; } } ; class npc_wg_queue : public CreatureScript { public : npc_wg_queue ( ) : CreatureScript ( " npc _ wg _ queue " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; if ( wintergrasp -> IsWarTime ( ) ) { player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , sObjectMgr -> GetTrinityStringForDBCLocale ( WG_NPCQUEUE_TEXTOPTION_JOIN ) , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; player -> SEND_GOSSIP_MENU ( wintergrasp -> GetDefenderTeam ( ) ? WG_NPCQUEUE_TEXT_H_WAR : WG_NPCQUEUE_TEXT_A_WAR , creature -> GetGUID ( ) ) ; } else { uint32 timer = wintergrasp -> GetTimer ( ) / 1000 ; player -> SendUpdateWorldState ( 4354 , time ( NULL ) + timer ) ; if ( timer < 15 * MINUTE ) { player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , sObjectMgr -> GetTrinityStringForDBCLocale ( WG_NPCQUEUE_TEXTOPTION_JOIN ) , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; player -> SEND_GOSSIP_MENU ( wintergrasp -> GetDefenderTeam ( ) ? WG_NPCQUEUE_TEXT_H_QUEUE : WG_NPCQUEUE_TEXT_A_QUEUE , creature -> GetGUID ( ) ) ; } else player -> SEND_GOSSIP_MENU ( wintergrasp -> GetDefenderTeam ( ) ? WG_NPCQUEUE_TEXT_H_NOWAR : WG_NPCQUEUE_TEXT_A_NOWAR , creature -> GetGUID ( ) ) ; } return true ; } bool OnGossipSelect ( Player * player , Creature * /* creature */ , uint32 /* sender */ , uint32 /* action */ ) OVERRIDE { player -> CLOSE_GOSSIP_MENU ( ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; if ( wintergrasp -> IsWarTime ( ) ) wintergrasp -> InvitePlayerToWar ( player ) ; else { uint32 timer = wintergrasp -> GetTimer ( ) / 1000 ; if ( timer < 15 * MINUTE ) wintergrasp -> InvitePlayerToQueue ( player ) ; } return true ; } } ; class go_wg_vehicle_teleporter : public GameObjectScript { public : go_wg_vehicle_teleporter ( ) : GameObjectScript ( " go _ wg _ vehicle _ teleporter " ) { } struct go_wg_vehicle_teleporterAI : public GameObjectAI { go_wg_vehicle_teleporterAI ( GameObject * gameObject ) : GameObjectAI ( gameObject ) , _checkTimer ( 1000 ) { } void UpdateAI ( uint32 diff ) OVERRIDE { if ( _checkTimer <= diff ) { if ( Battlefield * wg = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ) // ▁ Tabulation ▁ madness ▁ in ▁ the ▁ hole ! ENDCOM for ( uint8 i = 0 ; i < MAX_WINTERGRASP_VEHICLES ; i ++ ) if ( Creature * vehicleCreature = go -> FindNearestCreature ( vehiclesList [ i ] , 3.0f , true ) ) if ( ! vehicleCreature -> HasAura ( SPELL_VEHICLE_TELEPORT ) && vehicleCreature -> getFaction ( ) == WintergraspFaction [ wg -> GetDefenderTeam ( ) ] ) if ( Creature * teleportTrigger = vehicleCreature -> FindNearestCreature ( NPC_WORLD_TRIGGER_LARGE_AOI_NOT_IMMUNE_PC_NPC , 100.0f , true ) ) teleportTrigger -> CastSpell ( vehicleCreature , SPELL_VEHICLE_TELEPORT , true ) ; _checkTimer = 1000 ; } else _checkTimer -= diff ; } private : uint32 _checkTimer ; } ; GameObjectAI * GetAI ( GameObject * go ) const OVERRIDE { return new go_wg_vehicle_teleporterAI ( go ) ; } } ; class npc_wg_quest_giver : public CreatureScript { public : npc_wg_quest_giver ( ) : CreatureScript ( " npc _ wg _ quest _ giver " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; if ( creature -> IsQuestGiver ( ) ) { QuestRelationBounds objectQR = sObjectMgr -> GetCreatureQuestRelationBounds ( creature -> GetEntry ( ) ) ; QuestRelationBounds objectQIR = sObjectMgr -> GetCreatureQuestInvolvedRelationBounds ( creature -> GetEntry ( ) ) ; QuestMenu & qm = player -> PlayerTalkClass -> GetQuestMenu ( ) ; qm . ClearMenu ( ) ; for ( QuestRelations :: const_iterator i = objectQIR . first ; i != objectQIR . second ; ++ i ) { uint32 questId = i -> second ; QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( status == QUEST_STATUS_COMPLETE ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_INCOMPLETE ) qm . AddMenuItem ( questId , 4 ) ; // else ▁ if ▁ ( status ▁ = = ▁ QUEST _ STATUS _ AVAILABLE ) ENDCOM // ▁ qm . AddMenuItem ( quest _ id , ▁ 2 ) ; ENDCOM } for ( QuestRelations :: const_iterator i = objectQR . first ; i != objectQR . second ; ++ i ) { uint32 questId = i -> second ; Quest const * quest = sObjectMgr -> GetQuestTemplate ( questId ) ; if ( ! quest ) continue ; switch ( questId ) { // ▁ Horde ▁ attacker ENDCOM case QUEST_BONES_AND_ARROWS_HORDE_ATT : case QUEST_JINXING_THE_WALLS_HORDE_ATT : case QUEST_SLAY_THEM_ALL_HORDE_ATT : case QUEST_FUELING_THE_DEMOLISHERS_HORDE_ATT : case QUEST_HEALING_WITH_ROSES_HORDE_ATT : case QUEST_DEFEND_THE_SIEGE_HORDE_ATT : if ( wintergrasp -> GetAttackerTeam ( ) == TEAM_HORDE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; // ▁ Horde ▁ defender ENDCOM case QUEST_BONES_AND_ARROWS_HORDE_DEF : case QUEST_WARDING_THE_WALLS_HORDE_DEF : case QUEST_SLAY_THEM_ALL_HORDE_DEF : case QUEST_FUELING_THE_DEMOLISHERS_HORDE_DEF : case QUEST_HEALING_WITH_ROSES_HORDE_DEF : case QUEST_TOPPLING_THE_TOWERS_HORDE_DEF : case QUEST_STOP_THE_SIEGE_HORDE_DEF : if ( wintergrasp -> GetDefenderTeam ( ) == TEAM_HORDE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; // ▁ Alliance ▁ attacker ENDCOM case QUEST_BONES_AND_ARROWS_ALLIANCE_ATT : case QUEST_WARDING_THE_WARRIORS_ALLIANCE_ATT : case QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_ATT : case QUEST_DEFEND_THE_SIEGE_ALLIANCE_ATT : case QUEST_A_RARE_HERB_ALLIANCE_ATT : if ( wintergrasp -> GetAttackerTeam ( ) == TEAM_ALLIANCE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; // ▁ Alliance ▁ defender ENDCOM case QUEST_BONES_AND_ARROWS_ALLIANCE_DEF : case QUEST_WARDING_THE_WARRIORS_ALLIANCE_DEF : case QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_DEF : case QUEST_SHOUTHERN_SABOTAGE_ALLIANCE_DEF : case QUEST_STOP_THE_SIEGE_ALLIANCE_DEF : case QUEST_A_RARE_HERB_ALLIANCE_DEF : if ( wintergrasp -> GetDefenderTeam ( ) == TEAM_ALLIANCE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; default : QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; break ; } } } player -> SEND_GOSSIP_MENU ( player -> GetGossipTextId ( creature ) , creature -> GetGUID ( ) ) ; return true ; } } ; class spell_wintergrasp_force_building : public SpellScriptLoader { public : spell_wintergrasp_force_building ( ) : SpellScriptLoader ( " spell _ wintergrasp _ force _ building " ) { } class spell_wintergrasp_force_building_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_force_building_SpellScript ) ; bool Validate ( SpellInfo const * /* spell */ ) OVERRIDE { if ( ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_CATAPULT_FORCE ) || ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_DEMOLISHER_FORCE ) || ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE ) || ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE ) ) return false ; return true ; } void HandleScript ( SpellEffIndex effIndex ) { PreventHitDefaultEffect ( effIndex ) ; GetHitUnit ( ) -> CastSpell ( GetHitUnit ( ) , GetEffectValue ( ) , false ) ; } void Register ( ) OVERRIDE { OnEffectHitTarget += SpellEffectFn ( spell_wintergrasp_force_building_SpellScript :: HandleScript , EFFECT_0 , SPELL_EFFECT_SCRIPT_EFFECT ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_force_building_SpellScript ( ) ; } } ; class spell_wintergrasp_grab_passenger : public SpellScriptLoader { public : spell_wintergrasp_grab_passenger ( ) : SpellScriptLoader ( " spell _ wintergrasp _ grab _ passenger " ) { } class spell_wintergrasp_grab_passenger_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_grab_passenger_SpellScript ) ; void HandleScript ( SpellEffIndex /* effIndex */ ) { if ( Player * target = GetHitPlayer ( ) ) target -> CastSpell ( GetCaster ( ) , SPELL_RIDE_WG_VEHICLE , false ) ; } void Register ( ) OVERRIDE { OnEffectHitTarget += SpellEffectFn ( spell_wintergrasp_grab_passenger_SpellScript :: HandleScript , EFFECT_0 , SPELL_EFFECT_SCRIPT_EFFECT ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_grab_passenger_SpellScript ( ) ; } } ; class achievement_wg_didnt_stand_a_chance : public AchievementCriteriaScript { public : achievement_wg_didnt_stand_a_chance ( ) : AchievementCriteriaScript ( " achievement _ wg _ didnt _ stand _ a _ chance " ) { } bool OnCheck ( Player * source , Unit * target ) OVERRIDE { if ( ! target ) return false ; if ( Player * victim = target -> ToPlayer ( ) ) { if ( ! victim -> IsMounted ( ) ) return false ; if ( Vehicle * vehicle = source -> GetVehicle ( ) ) if ( vehicle -> GetVehicleInfo ( ) -> m_ID == 244 ) // ▁ Wintergrasp ▁ Tower ▁ Cannon ENDCOM return true ; } return false ; } } ; enum WgTeleport { SPELL_WINTERGRASP_TELEPORT_TRIGGER = 54643 , } ; class spell_wintergrasp_defender_teleport : public SpellScriptLoader { public : spell_wintergrasp_defender_teleport ( ) : SpellScriptLoader ( " spell _ wintergrasp _ defender _ teleport " ) { } class spell_wintergrasp_defender_teleport_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_defender_teleport_SpellScript ) ; SpellCastResult CheckCast ( ) { if ( Battlefield * wg = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ) if ( Player * target = GetExplTargetUnit ( ) -> ToPlayer ( ) ) // ▁ check ▁ if ▁ we ▁ are ▁ in ▁ Wintergrasp ▁ at ▁ all , ▁ SotA ▁ uses ▁ same ▁ teleport ▁ spells ENDCOM if ( ( target -> GetZoneId ( ) == 4197 && target -> GetTeamId ( ) != wg -> GetDefenderTeam ( ) ) || target -> HasAura ( SPELL_WINTERGRASP_TELEPORT_TRIGGER ) ) return SPELL_FAILED_BAD_TARGETS ; return SPELL_CAST_OK ; } void Register ( ) OVERRIDE { OnCheckCast += SpellCheckCastFn ( spell_wintergrasp_defender_teleport_SpellScript :: CheckCast ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_defender_teleport_SpellScript ( ) ; } } ; class spell_wintergrasp_defender_teleport_trigger : public SpellScriptLoader { public : spell_wintergrasp_defender_teleport_trigger ( ) : SpellScriptLoader ( " spell _ wintergrasp _ defender _ teleport _ trigger " ) { } class spell_wintergrasp_defender_teleport_trigger_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_defender_teleport_trigger_SpellScript ) ; void HandleDummy ( SpellEffIndex /* effindex */ ) { if ( Unit * target = GetHitUnit ( ) ) { WorldLocation loc ; target -> GetPosition ( & loc ) ; SetExplTargetDest ( loc ) ; } } void Register ( ) OVERRIDE { OnEffectHitTarget += SpellEffectFn ( spell_wintergrasp_defender_teleport_trigger_SpellScript :: HandleDummy , EFFECT_0 , SPELL_EFFECT_DUMMY ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_defender_teleport_trigger_SpellScript ( ) ; } } ; void AddSC_wintergrasp ( ) { new npc_wg_queue ( ) ; new npc_wg_spirit_guide ( ) ; new npc_wg_demolisher_engineer ( ) ; new go_wg_vehicle_teleporter ( ) ; new npc_wg_quest_giver ( ) ; new spell_wintergrasp_force_building ( ) ; new spell_wintergrasp_grab_passenger ( ) ; new achievement_wg_didnt_stand_a_chance ( ) ; new spell_wintergrasp_defender_teleport ( ) ; new spell_wintergrasp_defender_teleport_trigger ( ) ; } </DOCUMENT>
<DOCUMENT_ID="xdajog/samsung_sources_i927/tree/master/external/webkit/Source/WebKit2/Shared/DictionaryPopupInfo.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2011 ▁ Apple ▁ Inc . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without STRNEWLINE ▁ * ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions STRNEWLINE ▁ * ▁ are ▁ met : STRNEWLINE ▁ * ▁ 1 . ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . STRNEWLINE ▁ * ▁ 2 . ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in ▁ the STRNEWLINE ▁ * ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the ▁ distribution . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ APPLE ▁ INC . ▁ AND ▁ ITS ▁ CONTRIBUTORS ▁ ` ` AS ▁ IS ' ' STRNEWLINE ▁ * ▁ AND ▁ ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , STRNEWLINE ▁ * ▁ THE ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR STRNEWLINE ▁ * ▁ PURPOSE ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ APPLE ▁ INC . ▁ OR ▁ ITS ▁ CONTRIBUTORS STRNEWLINE ▁ * ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR STRNEWLINE ▁ * ▁ CONSEQUENTIAL ▁ DAMAGES ▁ ( INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ PROCUREMENT ▁ OF STRNEWLINE ▁ * ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES ; ▁ LOSS ▁ OF ▁ USE , ▁ DATA , ▁ OR ▁ PROFITS ; ▁ OR ▁ BUSINESS STRNEWLINE ▁ * ▁ INTERRUPTION ) ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY ▁ THEORY ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN STRNEWLINE ▁ * ▁ CONTRACT , ▁ STRICT ▁ LIABILITY , ▁ OR ▁ TORT ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) STRNEWLINE ▁ * ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE ▁ OF ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF STRNEWLINE ▁ * ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . STRNEWLINE ▁ */ # include " config . h " # include " DictionaryPopupInfo . h " # include " WebCoreArgumentCoders . h " # if PLATFORM ( MAC ) # include " ArgumentCodersCF . h " # endif namespace WebKit { void DictionaryPopupInfo :: encode ( CoreIPC :: ArgumentEncoder * encoder ) const { encoder -> encode ( origin ) ; encoder -> encode ( fontInfo ) ; encoder -> encodeEnum ( type ) ; # if PLATFORM ( MAC ) && ! defined ( BUILDING_ON_SNOW_LEOPARD ) CoreIPC :: encode ( encoder , options . get ( ) ) ; # endif } bool DictionaryPopupInfo :: decode ( CoreIPC :: ArgumentDecoder * decoder , DictionaryPopupInfo & result ) { if ( ! decoder -> decode ( result . origin ) ) return false ; if ( ! decoder -> decode ( result . fontInfo ) ) return false ; if ( ! decoder -> decodeEnum ( result . type ) ) return false ; # if PLATFORM ( MAC ) && ! defined ( BUILDING_ON_SNOW_LEOPARD ) if ( ! CoreIPC :: decode ( decoder , result . options ) ) return false ; # endif return true ; } } // ▁ namespace ▁ WebKit ENDCOM </DOCUMENT>
<DOCUMENT_ID="dgrat/ANNetGPGPU/tree/master/examples/designer/ANNetDesigner.cpp"> # include < QApplication > # include " gui / QMainWindow . h " int main ( int argc , char * argv [ ] ) { QApplication a ( argc , argv ) ; MainWindow w ; w . show ( ) ; return a . exec ( ) ; } </DOCUMENT>
<DOCUMENT_ID="tpltnt/uncrustify/tree/master/tests/output/cpp/30920-indent-off.cpp"> struct X { void operator - ( int ) ; void operator + ( int ) ; void operator ( ) ( ) ; } ; /* ▁ * INDENT - OFF * ▁ */ struct Y { void operator - ( int ) { } void operator + ( int ) { } void operator ( ) ( ) { } void func ( ) { auto x = " TABSYMBOL test\t ▁ TABSYMBOL ▁ TABSYMBOL ▁ TABSYMBOL TABSYMBOL . . . ▁ ▁ ▁ ? ? ? " ; } } ; /* ▁ * INDENT - ON * ▁ */ struct Y { void operator - ( int ) { } void operator + ( int ) { } void operator ( ) ( ) { } void func ( ) { auto x = " TABSYMBOL test\t ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . . . ▁ ▁ ▁ ? ? ? " ; } } ; </DOCUMENT>
<DOCUMENT_ID="gavoski/audacity/tree/master/lib-src/taglib/tests/test_map.cpp"> # include < cppunit / extensions / HelperMacros . h > # include < tstring . h > # include < tmap . h > using namespace std ; using namespace TagLib ; class TestMap : public CppUnit :: TestFixture { CPPUNIT_TEST_SUITE ( TestMap ) ; CPPUNIT_TEST ( testInsert ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void testInsert ( ) { Map < String , int > m ; m . insert ( " foo " , 3 ) ; CPPUNIT_ASSERT_EQUAL ( 3 , m [ " foo " ] ) ; m . insert ( " foo " , 7 ) ; CPPUNIT_ASSERT_EQUAL ( 7 , m [ " foo " ] ) ; } } ; CPPUNIT_TEST_SUITE_REGISTRATION ( TestMap ) ; </DOCUMENT>
<DOCUMENT_ID="SuperHex/psychic-aero/tree/master/base/HAL.cpp"> /* ▁ Hardware ▁ Abstract ▁ Layer ▁ */ # ifndef __HAL__ # define __HAL__ # include . . / config / config . h # include < avr / io . h > namespace base { template < class init_traits , class rw_traits > struct hal { typedef init_traits I ; typedef rw_traits RW ; public : hal ( ) { I :: init ( ) ; } virtual ~ hal ( ) ; virtual void write ( const unsigned char data ) { RW :: write ( data ) ; } virtual unsigned char read ( ) { return RW :: read ( ) ; } } ; struct skip_init { static void init ( ) { } } ; struct USART_default_init { static void init ( const long baudRate ) { long ubrr = F_CPU / 16 / baudRate - 1 ; // ▁ Set ▁ baud ▁ rate ENDCOM UBRR0H = ubrr >> 8 ; UBRR0L = ubrr ; // ▁ Enable ▁ receiver ▁ and ▁ transmitter ENDCOM UCSR0B = ( 1 << RXEN0 ) | ( 1 << TXEN0 ) ; // ▁ Set ▁ frame ▁ format : ▁ 8 ▁ data , ▁ 1 ▁ stop ▁ bit , ▁ no ▁ parity ▁ check . ENDCOM // ▁ For ▁ a ▁ custom ▁ setting , ▁ please ▁ refer ▁ Atmel ▁ Datasheet ▁ page ▁ 195 ENDCOM UCSR0C = ( 3 << UCSZ00 ) ; } } ; struct USART_8N1_RW { public : static void write ( const unsigned char data ) { // ▁ Wait ▁ until ▁ buffer ▁ empty ENDCOM while ( ! ( UCSR0A & ( 1 << UDRE0 ) ) ) ; // ▁ load ▁ and ▁ send ENDCOM UDR0 = data ; } static unsigned char read ( ) { // ▁ Wait ▁ until ▁ buffer ▁ empty ENDCOM while ( ! ( UCSR0A & ( 1 << RXC0 ) ) ) ; return UDR0 ; } } ; struct SPI_RW { static void write ( unsigned char data ) { // ▁ To ▁ start ▁ a ▁ SPI ▁ transmission , ▁ simply ▁ feed ▁ data ▁ into ▁ SPI ▁ Data ▁ Register ENDCOM SPDR = data ; // ▁ Wait ▁ until ▁ transmission ▁ complete ENDCOM while ( ! ( SPSR & ( 1 << SPIF ) ) ) ; } static unsigned char read ( ) { // ▁ Wait ▁ until ▁ receive ▁ complete ENDCOM while ( ! ( SPSR & ( 1 << SPIF ) ) ) ; return SPDR ; } } ; struct SPI_master_init { static void init ( ) { DDRB |= ( 1 << PB3 ) // ▁ set ▁ MOSI ▁ as ▁ output ENDCOM | ( 1 << PB5 ) // ▁ set ▁ SCK ▁ as ▁ output ENDCOM | ( 1 << PB2 ) ; // ▁ set ▁ SS ' ▁ as ▁ output ▁ since ▁ we ▁ have ▁ only ▁ one ▁ slave ENDCOM SPCR = ( 1 << SPE ) // ▁ enable ▁ SPI ENDCOM | ( 1 << MSTR ) // ▁ set ▁ SPI ▁ as ▁ master ENDCOM | ( 1 << SPR0 ) ; // ▁ set ▁ clock ▁ as ▁ F _ CPU ▁ / ▁ 16 ENDCOM } } ; struct SPI_slave_init { static void init ( ) { DDRB |= ( 1 << PB4 ) ; // ▁ set ▁ MISO ▁ as ▁ output , ▁ all ▁ other ▁ as ▁ input ENDCOM SPCR = ( 1 << SPE ) ; // ▁ enable ▁ SPI ENDCOM } } ; template < class T = USART_default_init > struct USART : public hal < skip_init , USART_8N1_RW > { public : USART ( const long Rate ) { T :: init ( Rate ) ; } virtual ~ USART ( ) ; } ; typedef USART < > Serial ; template < class T > struct SPI : public hal < T , SPI_RW > { } ; typedef SPI < SPI_master_init > SPIMaster ; typedef SPI < SPI_slave_init > SPISlave ; } # endif </DOCUMENT>
<DOCUMENT_ID="victorzhao/miniblink49/tree/master/third_party/WebKit/Source/core/html/HTMLContentElement.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2011 ▁ Google ▁ Inc . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without STRNEWLINE ▁ * ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions ▁ are STRNEWLINE ▁ * ▁ met : STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ * ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . STRNEWLINE ▁ * ▁ * ▁ Neither ▁ the ▁ name ▁ of ▁ Google ▁ Inc . ▁ nor ▁ the ▁ names ▁ of ▁ its STRNEWLINE ▁ * ▁ contributors ▁ may ▁ be ▁ used ▁ to ▁ endorse ▁ or ▁ promote ▁ products ▁ derived ▁ from STRNEWLINE ▁ * ▁ this ▁ software ▁ without ▁ specific ▁ prior ▁ written ▁ permission . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ THE ▁ COPYRIGHT ▁ HOLDERS ▁ AND ▁ CONTRIBUTORS STRNEWLINE ▁ * ▁ " AS ▁ IS " ▁ AND ▁ ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT STRNEWLINE ▁ * ▁ LIMITED ▁ TO , ▁ THE ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR STRNEWLINE ▁ * ▁ A ▁ PARTICULAR ▁ PURPOSE ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ▁ COPYRIGHT STRNEWLINE ▁ * ▁ OWNER ▁ OR ▁ CONTRIBUTORS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , STRNEWLINE ▁ * ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ ( INCLUDING , ▁ BUT ▁ NOT STRNEWLINE ▁ * ▁ LIMITED ▁ TO , ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES ; ▁ LOSS ▁ OF ▁ USE , STRNEWLINE ▁ * ▁ DATA , ▁ OR ▁ PROFITS ; ▁ OR ▁ BUSINESS ▁ INTERRUPTION ) ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY STRNEWLINE ▁ * ▁ THEORY ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ CONTRACT , ▁ STRICT ▁ LIABILITY , ▁ OR ▁ TORT STRNEWLINE ▁ * ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE STRNEWLINE ▁ * ▁ OF ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . STRNEWLINE ▁ */ # include " config . h " # include " core / html / HTMLContentElement . h " # include " core / HTMLNames . h " # include " core / css / SelectorChecker . h " # include " core / css / parser / CSSParser . h " # include " core / dom / QualifiedName . h " # include " core / dom / shadow / ElementShadow . h " # include " core / dom / shadow / ShadowRoot . h " # include " platform / RuntimeEnabledFeatures . h " namespace blink { using namespace HTMLNames ; PassRefPtrWillBeRawPtr < HTMLContentElement > HTMLContentElement :: create ( Document & document , PassOwnPtrWillBeRawPtr < HTMLContentSelectFilter > filter ) { return adoptRefWillBeNoop ( new HTMLContentElement ( document , filter ) ) ; } inline HTMLContentElement :: HTMLContentElement ( Document & document , PassOwnPtrWillBeRawPtr < HTMLContentSelectFilter > filter ) : InsertionPoint ( contentTag , document ) , m_shouldParseSelect ( false ) , m_isValidSelector ( true ) , m_filter ( filter ) { } HTMLContentElement :: ~ HTMLContentElement ( ) { } DEFINE_TRACE ( HTMLContentElement ) { visitor -> trace ( m_filter ) ; InsertionPoint :: trace ( visitor ) ; } void HTMLContentElement :: parseSelect ( ) { ASSERT ( m_shouldParseSelect ) ; CSSParser :: parseSelector ( CSSParserContext ( document ( ) , 0 ) , m_select , m_selectorList ) ; m_shouldParseSelect = false ; m_isValidSelector = validateSelect ( ) ; if ( ! m_isValidSelector ) { CSSSelectorList emptyList ; m_selectorList . adopt ( emptyList ) ; } } void HTMLContentElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name == selectAttr ) { if ( ShadowRoot * root = containingShadowRoot ( ) ) root -> owner ( ) -> willAffectSelector ( ) ; m_shouldParseSelect = true ; m_select = value ; } else { InsertionPoint :: parseAttribute ( name , value ) ; } } static inline bool includesDisallowedPseudoClass ( const CSSSelector & selector ) { if ( selector . pseudoType ( ) == CSSSelector :: PseudoNot ) { const CSSSelector * subSelector = selector . selectorList ( ) -> first ( ) ; return subSelector -> match ( ) == CSSSelector :: PseudoClass ; } return selector . match ( ) == CSSSelector :: PseudoClass ; } bool HTMLContentElement :: validateSelect ( ) const { ASSERT ( ! m_shouldParseSelect ) ; if ( m_select . isNull ( ) || m_select . isEmpty ( ) ) return true ; if ( ! m_selectorList . isValid ( ) ) return false ; for ( const CSSSelector * selector = m_selectorList . first ( ) ; selector ; selector = m_selectorList . next ( * selector ) ) { if ( ! selector -> isCompound ( ) ) return false ; for ( const CSSSelector * subSelector = selector ; subSelector ; subSelector = subSelector -> tagHistory ( ) ) { if ( includesDisallowedPseudoClass ( * subSelector ) ) return false ; } } return true ; } // ▁ TODO ( esprehn ) : ▁ element ▁ should ▁ really ▁ be ▁ const , ▁ but ▁ matching ▁ a ▁ selector ▁ is ▁ not ENDCOM // ▁ const ▁ for ▁ some ▁ SelectorCheckingModes ▁ ( mainly ▁ ResolvingStyle ) ▁ where ▁ it ▁ sets ENDCOM // ▁ dynamic ▁ restyle ▁ flags ▁ on ▁ elements . ENDCOM bool HTMLContentElement :: matchSelector ( Element & element ) const { SelectorChecker selectorChecker ( SelectorChecker :: QueryingRules ) ; SelectorChecker :: SelectorCheckingContext context ( & element , SelectorChecker :: VisitedMatchDisabled ) ; for ( const CSSSelector * selector = selectorList ( ) . first ( ) ; selector ; selector = CSSSelectorList :: next ( * selector ) ) { context . selector = selector ; if ( selectorChecker . match ( context ) ) return true ; } return false ; } } </DOCUMENT>
<DOCUMENT_ID="kingvuplus/enigma2/tree/master/lib/gui/einputstring.cpp"> # include < lib / gui / einputstring . h > DEFINE_REF ( eInputContentString ) ; eInputContentString :: eInputContentString ( ) { m_string = " bla " ; m_cursor = 0 ; m_input = 0 ; m_len = m_string . size ( ) ; } void eInputContentString :: getDisplay ( std :: string & res , int & cursor ) { res = m_string ; cursor = m_cursor ; } void eInputContentString :: moveCursor ( int dir ) { int old_cursor = m_cursor ; switch ( dir ) { case dirLeft : -- m_cursor ; break ; case dirRight : ++ m_cursor ; break ; case dirHome : m_cursor = 0 ; break ; case dirEnd : m_cursor = m_len ; break ; } if ( m_cursor < 0 ) m_cursor = 0 ; if ( m_cursor > m_len ) m_cursor = m_len ; if ( m_cursor != old_cursor ) if ( m_input ) m_input -> invalidate ( ) ; } int eInputContentString :: haveKey ( int code , int overwrite ) { int have_char = - 1 ; if ( code >= 0x8020 ) have_char = code & ~ 0x8000 ; if ( have_char != - 1 ) { if ( overwrite && m_cursor < m_len ) m_string [ m_cursor ] = have_char ; else { m_string . insert ( m_cursor , 1 , have_char ) ; ++ m_len ; } m_cursor ++ ; ASSERT ( m_cursor <= m_len ) ; if ( m_input ) m_input -> invalidate ( ) ; return 1 ; } return 0 ; } void eInputContentString :: deleteChar ( int dir ) { if ( dir == deleteForward ) { eDebug ( " forward " ) ; if ( m_cursor != m_len ) ++ m_cursor ; else return ; } /* ▁ backward ▁ delete ▁ at ▁ begin ▁ */ if ( ! m_cursor ) return ; if ( ! m_len ) return ; m_string . erase ( m_cursor - 1 , m_cursor ) ; m_len -- ; m_cursor -- ; if ( m_input ) m_input -> invalidate ( ) ; } int eInputContentString :: isValid ( ) { return 1 ; } void eInputContentString :: validate ( ) { } void eInputContentString :: setText ( const std :: string & str ) { m_string = str ; m_len = m_string . size ( ) ; if ( m_cursor > m_len ) m_cursor = m_len ; if ( m_input ) m_input -> invalidate ( ) ; } std :: string eInputContentString :: getText ( ) { return m_string ; } </DOCUMENT>
<DOCUMENT_ID="qtproject/qtwebkit/tree/master/Source/WebCore/html/HTMLFrameSetElement.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 1999 ▁ Lars ▁ Knoll ▁ ( knoll @ kde . org ) STRNEWLINE ▁ * ▁ ( C ) ▁ 1999 ▁ Antti ▁ Koivisto ▁ ( koivisto @ kde . org ) STRNEWLINE ▁ * ▁ ( C ) ▁ 2000 ▁ Simon ▁ Hausmann ▁ ( hausmann @ kde . org ) STRNEWLINE ▁ * ▁ ( C ) ▁ 2001 ▁ Dirk ▁ Mueller ▁ ( mueller @ kde . org ) STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2004 , ▁ 2006 , ▁ 2009 , ▁ 2010 ▁ Apple ▁ Inc . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ library ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or STRNEWLINE ▁ * ▁ modify ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Library ▁ General ▁ Public STRNEWLINE ▁ * ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either STRNEWLINE ▁ * ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ library ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU STRNEWLINE ▁ * ▁ Library ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Library ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ this ▁ library ; ▁ see ▁ the ▁ file ▁ COPYING . LIB . ▁ If ▁ not , ▁ write ▁ to STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , STRNEWLINE ▁ * ▁ Boston , ▁ MA ▁ 02110-1301 , ▁ USA . STRNEWLINE ▁ */ # include " config . h " # include " HTMLFrameSetElement . h " # include " CSSPropertyNames . h " # include " Document . h " # include " ElementIterator . h " # include " Event . h " # include " EventNames . h " # include " Frame . h " # include " FrameLoader . h " # include " FrameLoaderClient . h " # include " HTMLBodyElement . h " # include " HTMLNames . h " # include " Length . h " # include " MouseEvent . h " # include " RenderFrameSet . h " # include " Text . h " namespace WebCore { using namespace HTMLNames ; HTMLFrameSetElement :: HTMLFrameSetElement ( const QualifiedName & tagName , Document & document ) : HTMLElement ( tagName , document ) , m_totalRows ( 1 ) , m_totalCols ( 1 ) , m_border ( 6 ) , m_borderSet ( false ) , m_borderColorSet ( false ) , m_frameborder ( true ) , m_frameborderSet ( false ) , m_noresize ( false ) { ASSERT ( hasTagName ( framesetTag ) ) ; setHasCustomStyleResolveCallbacks ( ) ; } Ref < HTMLFrameSetElement > HTMLFrameSetElement :: create ( const QualifiedName & tagName , Document & document ) { return adoptRef ( * new HTMLFrameSetElement ( tagName , document ) ) ; } bool HTMLFrameSetElement :: isPresentationAttribute ( const QualifiedName & name ) const { if ( name == bordercolorAttr ) return true ; return HTMLElement :: isPresentationAttribute ( name ) ; } void HTMLFrameSetElement :: collectStyleForPresentationAttribute ( const QualifiedName & name , const AtomicString & value , MutableStyleProperties & style ) { if ( name == bordercolorAttr ) addHTMLColorToStyle ( style , CSSPropertyBorderColor , value ) ; else HTMLElement :: collectStyleForPresentationAttribute ( name , value , style ) ; } void HTMLFrameSetElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name == rowsAttr ) { // ▁ FIXME : ▁ What ▁ is ▁ the ▁ right ▁ thing ▁ to ▁ do ▁ when ▁ removing ▁ this ▁ attribute ? ENDCOM // ▁ Why ▁ not ▁ treat ▁ it ▁ the ▁ same ▁ way ▁ we ▁ treat ▁ setting ▁ it ▁ to ▁ the ▁ empty ▁ string ? ENDCOM if ( ! value . isNull ( ) ) { m_rowLengths = newLengthArray ( value . string ( ) , m_totalRows ) ; // ▁ FIXME : ▁ Would ▁ be ▁ nice ▁ to ▁ optimize ▁ the ▁ case ▁ where ▁ m _ rowLengths ▁ did ▁ not ▁ change . ENDCOM setNeedsStyleRecalc ( ) ; } return ; } if ( name == colsAttr ) { // ▁ FIXME : ▁ What ▁ is ▁ the ▁ right ▁ thing ▁ to ▁ do ▁ when ▁ removing ▁ this ▁ attribute ? ENDCOM // ▁ Why ▁ not ▁ treat ▁ it ▁ the ▁ same ▁ way ▁ we ▁ treat ▁ setting ▁ it ▁ to ▁ the ▁ empty ▁ string ? ENDCOM if ( ! value . isNull ( ) ) { m_colLengths = newLengthArray ( value . string ( ) , m_totalCols ) ; // ▁ FIXME : ▁ Would ▁ be ▁ nice ▁ to ▁ optimize ▁ the ▁ case ▁ where ▁ m _ colLengths ▁ did ▁ not ▁ change . ENDCOM setNeedsStyleRecalc ( ) ; } return ; } if ( name == frameborderAttr ) { if ( ! value . isNull ( ) ) { if ( equalLettersIgnoringASCIICase ( value , " no " ) || value == "0" ) { m_frameborder = false ; m_frameborderSet = true ; } else if ( equalLettersIgnoringASCIICase ( value , " yes " ) || value == "1" ) { m_frameborderSet = true ; } } else { m_frameborder = false ; m_frameborderSet = false ; } // ▁ FIXME : ▁ Do ▁ we ▁ need ▁ to ▁ trigger ▁ repainting ? ENDCOM return ; } if ( name == noresizeAttr ) { // ▁ FIXME : ▁ This ▁ should ▁ set ▁ m _ noresize ▁ to ▁ false ▁ if ▁ the ▁ value ▁ is ▁ null . ENDCOM m_noresize = true ; return ; } if ( name == borderAttr ) { if ( ! value . isNull ( ) ) { m_border = value . toInt ( ) ; m_borderSet = true ; } else m_borderSet = false ; // ▁ FIXME : ▁ Do ▁ we ▁ need ▁ to ▁ trigger ▁ repainting ? ENDCOM return ; } if ( name == bordercolorAttr ) { m_borderColorSet = ! value . isEmpty ( ) ; // ▁ FIXME : ▁ Clearly ▁ wrong : ▁ This ▁ can ▁ overwrite ▁ the ▁ value ▁ inherited ▁ from ▁ the ▁ parent ▁ frameset . ENDCOM // ▁ FIXME : ▁ Do ▁ we ▁ need ▁ to ▁ trigger ▁ repainting ? ENDCOM return ; } auto & eventName = HTMLBodyElement :: eventNameForWindowEventHandlerAttribute ( name ) ; if ( ! eventName . isNull ( ) ) { document ( ) . setWindowAttributeEventListener ( eventName , name , value ) ; return ; } HTMLElement :: parseAttribute ( name , value ) ; } bool HTMLFrameSetElement :: rendererIsNeeded ( const RenderStyle & style ) { // ▁ For ▁ compatibility , ▁ frames ▁ render ▁ even ▁ when ▁ display : ▁ none ▁ is ▁ set . ENDCOM // ▁ However , ▁ we ▁ delay ▁ creating ▁ a ▁ renderer ▁ until ▁ stylesheets ▁ have ▁ loaded . ▁ ENDCOM return style . isStyleAvailable ( ) ; } RenderPtr < RenderElement > HTMLFrameSetElement :: createElementRenderer ( Ref < RenderStyle > && style , const RenderTreePosition & ) { if ( style . get ( ) . hasContent ( ) ) return RenderElement :: createFor ( * this , WTFMove ( style ) ) ; return createRenderer < RenderFrameSet > ( * this , WTFMove ( style ) ) ; } HTMLFrameSetElement * HTMLFrameSetElement :: findContaining ( Element * descendant ) { return ancestorsOfType < HTMLFrameSetElement > ( * descendant ) . first ( ) ; } void HTMLFrameSetElement :: willAttachRenderers ( ) { // ▁ Inherit ▁ default ▁ settings ▁ from ▁ parent ▁ frameset . ENDCOM // ▁ FIXME : ▁ This ▁ is ▁ not ▁ dynamic . ENDCOM const HTMLFrameSetElement * containingFrameSet = findContaining ( this ) ; if ( ! containingFrameSet ) return ; if ( ! m_frameborderSet ) m_frameborder = containingFrameSet -> hasFrameBorder ( ) ; if ( m_frameborder ) { if ( ! m_borderSet ) m_border = containingFrameSet -> border ( ) ; if ( ! m_borderColorSet ) m_borderColorSet = containingFrameSet -> hasBorderColor ( ) ; } if ( ! m_noresize ) m_noresize = containingFrameSet -> noResize ( ) ; } void HTMLFrameSetElement :: defaultEventHandler ( Event * event ) { ASSERT ( event ) ; if ( is < MouseEvent > ( * event ) && ! m_noresize && is < RenderFrameSet > ( renderer ( ) ) ) { if ( downcast < RenderFrameSet > ( * renderer ( ) ) . userResize ( downcast < MouseEvent > ( event ) ) ) { event -> setDefaultHandled ( ) ; return ; } } HTMLElement :: defaultEventHandler ( event ) ; } bool HTMLFrameSetElement :: willRecalcStyle ( Style :: Change ) { if ( needsStyleRecalc ( ) && renderer ( ) ) { renderer ( ) -> setNeedsLayout ( ) ; clearNeedsStyleRecalc ( ) ; } return true ; } Node :: InsertionNotificationRequest HTMLFrameSetElement :: insertedInto ( ContainerNode & insertionPoint ) { HTMLElement :: insertedInto ( insertionPoint ) ; if ( insertionPoint . inDocument ( ) ) { if ( Frame * frame = document ( ) . frame ( ) ) frame -> loader ( ) . client ( ) . dispatchDidBecomeFrameset ( document ( ) . isFrameSet ( ) ) ; } return InsertionDone ; } void HTMLFrameSetElement :: removedFrom ( ContainerNode & insertionPoint ) { HTMLElement :: removedFrom ( insertionPoint ) ; if ( insertionPoint . inDocument ( ) ) { if ( Frame * frame = document ( ) . frame ( ) ) frame -> loader ( ) . client ( ) . dispatchDidBecomeFrameset ( document ( ) . isFrameSet ( ) ) ; } } } // ▁ namespace ▁ WebCore ENDCOM </DOCUMENT>
<DOCUMENT_ID="brunolauze/MonoNative/tree/master/MonoNative/mscorlib/System/Runtime/Remoting/Metadata/W3cXsd2001/mscorlib_System_Runtime_Remoting_Metadata_W3cXsd2001_SoapNmtoken.cpp"> # include < mscorlib / System / Runtime / Remoting / Metadata / W3cXsd2001 / mscorlib_System_Runtime_Remoting_Metadata_W3cXsd2001_SoapNmtoken . h > # include < mscorlib / System / mscorlib_System_Type . h > namespace mscorlib { namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 { Property < mscorlib :: System :: String , mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken > mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken :: XsdType ( & mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken :: get_XsdType , & mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken :: set_XsdType ) ; // Public ▁ Methods ENDCOM mscorlib :: System :: String SoapNmtoken :: GetXsdType ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " GetXsdType " , __native_object__ , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; } mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken SoapNmtoken :: Parse ( mscorlib :: System :: String value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( typeid ( value ) . name ( ) ) ; __parameters__ [ 0 ] = ( MonoObject * ) value ; MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " Parse " , NullMonoObject , 1 , __parameter_types__ , __parameters__ , NULL ) ; return mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken ( __result__ ) ; } mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken SoapNmtoken :: Parse ( const char * value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( " mscorlib " , " System " , " String " ) ; __parameters__ [ 0 ] = mono_string_new ( Global :: GetDomain ( ) , value ) ; MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " Parse " , NullMonoObject , 1 , __parameter_types__ , __parameters__ , NULL ) ; return mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken ( __result__ ) ; } mscorlib :: System :: String SoapNmtoken :: ToString ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " ToString " , __native_object__ , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; } // Get ▁ Set ▁ Properties ▁ Methods ENDCOM // TABSYMBOL Get / Set : Value ENDCOM mscorlib :: System :: String SoapNmtoken :: get_Value ( ) const { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " get _ Value " , __native_object__ , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; } void SoapNmtoken :: set_Value ( mscorlib :: System :: String value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( typeid ( value ) . name ( ) ) ; __parameters__ [ 0 ] = ( MonoObject * ) value ; Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " set _ Value " , __native_object__ , 1 , __parameter_types__ , __parameters__ , NULL ) ; } // Get ▁ Set ▁ Static ▁ Properties ▁ Methods ENDCOM // TABSYMBOL Get : XsdType ENDCOM mscorlib :: System :: String SoapNmtoken :: get_XsdType ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " get _ XsdType " , NullMonoObject , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; } void SoapNmtoken :: set_XsdType ( mscorlib :: System :: String value ) { throw ; } } } } } } } </DOCUMENT>
<DOCUMENT_ID="pduuubs/render3D/tree/master/libs/eigen/test/geo_transformations.cpp"> // ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Eigen , ▁ a ▁ lightweight ▁ C + + ▁ template ▁ library ENDCOM // ▁ for ▁ linear ▁ algebra . ENDCOM // ▁ Copyright ▁ ( C ) ▁ 2008-2009 ▁ Gael ▁ Guennebaud ▁ < gael . guennebaud @ inria . fr > ENDCOM // ▁ This ▁ Source ▁ Code ▁ Form ▁ is ▁ subject ▁ to ▁ the ▁ terms ▁ of ▁ the ▁ Mozilla ENDCOM // ▁ Public ▁ License ▁ v . ▁ 2.0 . ▁ If ▁ a ▁ copy ▁ of ▁ the ▁ MPL ▁ was ▁ not ▁ distributed ENDCOM // ▁ with ▁ this ▁ file , ▁ You ▁ can ▁ obtain ▁ one ▁ at ▁ http : // mozilla . org / MPL / 2.0 / . ENDCOM # include " main . h " # include < Eigen / Geometry > # include < Eigen / LU > # include < Eigen / SVD > template < typename T > Matrix < T , 2 , 1 > angleToVec ( T a ) { return Matrix < T , 2 , 1 > ( std :: cos ( a ) , std :: sin ( a ) ) ; } // ▁ This ▁ permits ▁ to ▁ workaround ▁ a ▁ bug ▁ in ▁ clang / llvm ▁ code ▁ generation . ENDCOM template < typename T > EIGEN_DONT_INLINE void dont_over_optimize ( T & x ) { volatile typename T :: Scalar tmp = x ( 0 ) ; x ( 0 ) = tmp ; } template < typename Scalar , int Mode , int Options > void non_projective_only ( ) { /* ▁ this ▁ test ▁ covers ▁ the ▁ following ▁ files : STRNEWLINE ▁ Cross . h ▁ Quaternion . h , ▁ Transform . cpp STRNEWLINE ▁ */ typedef Matrix < Scalar , 3 , 1 > Vector3 ; typedef Quaternion < Scalar > Quaternionx ; typedef AngleAxis < Scalar > AngleAxisx ; typedef Transform < Scalar , 3 , Mode , Options > Transform3 ; typedef DiagonalMatrix < Scalar , 3 > AlignedScaling3 ; typedef Translation < Scalar , 3 > Translation3 ; Vector3 v0 = Vector3 :: Random ( ) , v1 = Vector3 :: Random ( ) ; Transform3 t0 , t1 , t2 ; Scalar a = internal :: random < Scalar > ( - Scalar ( EIGEN_PI ) , Scalar ( EIGEN_PI ) ) ; Quaternionx q1 , q2 ; q1 = AngleAxisx ( a , v0 . normalized ( ) ) ; t0 = Transform3 :: Identity ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , Transform3 :: MatrixType :: Identity ( ) ) ; t0 . linear ( ) = q1 . toRotationMatrix ( ) ; v0 << 50 , 2 , 1 ; t0 . scale ( v0 ) ; VERIFY_IS_APPROX ( ( t0 * Vector3 ( 1 , 0 , 0 ) ) . template head < 3 > ( ) . norm ( ) , v0 . x ( ) ) ; t0 . setIdentity ( ) ; t1 . setIdentity ( ) ; v1 << 1 , 2 , 3 ; t0 . linear ( ) = q1 . toRotationMatrix ( ) ; t0 . pretranslate ( v0 ) ; t0 . scale ( v1 ) ; t1 . linear ( ) = q1 . conjugate ( ) . toRotationMatrix ( ) ; t1 . prescale ( v1 . cwiseInverse ( ) ) ; t1 . translate ( - v0 ) ; VERIFY ( ( t0 * t1 ) . matrix ( ) . isIdentity ( test_precision < Scalar > ( ) ) ) ; t1 . fromPositionOrientationScale ( v0 , q1 , v1 ) ; VERIFY_IS_APPROX ( t1 . matrix ( ) , t0 . matrix ( ) ) ; VERIFY_IS_APPROX ( t1 * v1 , t0 * v1 ) ; // ▁ translation ▁ * ▁ vector ENDCOM t0 . setIdentity ( ) ; t0 . translate ( v0 ) ; VERIFY_IS_APPROX ( ( t0 * v1 ) . template head < 3 > ( ) , Translation3 ( v0 ) * v1 ) ; // ▁ AlignedScaling ▁ * ▁ vector ENDCOM t0 . setIdentity ( ) ; t0 . scale ( v0 ) ; VERIFY_IS_APPROX ( ( t0 * v1 ) . template head < 3 > ( ) , AlignedScaling3 ( v0 ) * v1 ) ; } template < typename Scalar , int Mode , int Options > void transformations ( ) { /* ▁ this ▁ test ▁ covers ▁ the ▁ following ▁ files : STRNEWLINE ▁ Cross . h ▁ Quaternion . h , ▁ Transform . cpp STRNEWLINE ▁ */ using std :: cos ; using std :: abs ; typedef Matrix < Scalar , 3 , 3 > Matrix3 ; typedef Matrix < Scalar , 4 , 4 > Matrix4 ; typedef Matrix < Scalar , 2 , 1 > Vector2 ; typedef Matrix < Scalar , 3 , 1 > Vector3 ; typedef Matrix < Scalar , 4 , 1 > Vector4 ; typedef Quaternion < Scalar > Quaternionx ; typedef AngleAxis < Scalar > AngleAxisx ; typedef Transform < Scalar , 2 , Mode , Options > Transform2 ; typedef Transform < Scalar , 3 , Mode , Options > Transform3 ; typedef typename Transform3 :: MatrixType MatrixType ; typedef DiagonalMatrix < Scalar , 3 > AlignedScaling3 ; typedef Translation < Scalar , 2 > Translation2 ; typedef Translation < Scalar , 3 > Translation3 ; Vector3 v0 = Vector3 :: Random ( ) , v1 = Vector3 :: Random ( ) ; Matrix3 matrot1 , m ; Scalar a = internal :: random < Scalar > ( - Scalar ( EIGEN_PI ) , Scalar ( EIGEN_PI ) ) ; Scalar s0 = internal :: random < Scalar > ( ) , s1 = internal :: random < Scalar > ( ) ; while ( v0 . norm ( ) < test_precision < Scalar > ( ) ) v0 = Vector3 :: Random ( ) ; while ( v1 . norm ( ) < test_precision < Scalar > ( ) ) v1 = Vector3 :: Random ( ) ; VERIFY_IS_APPROX ( v0 , AngleAxisx ( a , v0 . normalized ( ) ) * v0 ) ; VERIFY_IS_APPROX ( - v0 , AngleAxisx ( Scalar ( EIGEN_PI ) , v0 . unitOrthogonal ( ) ) * v0 ) ; if ( abs ( cos ( a ) ) > test_precision < Scalar > ( ) ) { VERIFY_IS_APPROX ( cos ( a ) * v0 . squaredNorm ( ) , v0 . dot ( AngleAxisx ( a , v0 . unitOrthogonal ( ) ) * v0 ) ) ; } m = AngleAxisx ( a , v0 . normalized ( ) ) . toRotationMatrix ( ) . adjoint ( ) ; VERIFY_IS_APPROX ( Matrix3 :: Identity ( ) , m * AngleAxisx ( a , v0 . normalized ( ) ) ) ; VERIFY_IS_APPROX ( Matrix3 :: Identity ( ) , AngleAxisx ( a , v0 . normalized ( ) ) * m ) ; Quaternionx q1 , q2 ; q1 = AngleAxisx ( a , v0 . normalized ( ) ) ; q2 = AngleAxisx ( a , v1 . normalized ( ) ) ; // ▁ rotation ▁ matrix ▁ conversion ENDCOM matrot1 = AngleAxisx ( Scalar ( 0.1 ) , Vector3 :: UnitX ( ) ) * AngleAxisx ( Scalar ( 0.2 ) , Vector3 :: UnitY ( ) ) * AngleAxisx ( Scalar ( 0.3 ) , Vector3 :: UnitZ ( ) ) ; VERIFY_IS_APPROX ( matrot1 * v1 , AngleAxisx ( Scalar ( 0.1 ) , Vector3 ( 1 , 0 , 0 ) ) . toRotationMatrix ( ) * ( AngleAxisx ( Scalar ( 0.2 ) , Vector3 ( 0 , 1 , 0 ) ) . toRotationMatrix ( ) * ( AngleAxisx ( Scalar ( 0.3 ) , Vector3 ( 0 , 0 , 1 ) ) . toRotationMatrix ( ) * v1 ) ) ) ; // ▁ angle - axis ▁ conversion ENDCOM AngleAxisx aa = AngleAxisx ( q1 ) ; VERIFY_IS_APPROX ( q1 * v1 , Quaternionx ( aa ) * v1 ) ; // ▁ The ▁ following ▁ test ▁ is ▁ stable ▁ only ▁ if ▁ 2 * angle ▁ ! = ▁ angle ▁ and ▁ v1 ▁ is ▁ not ▁ colinear ▁ with ▁ axis ENDCOM if ( ( abs ( aa . angle ( ) ) > test_precision < Scalar > ( ) ) && ( abs ( aa . axis ( ) . dot ( v1 . normalized ( ) ) ) < ( Scalar ( 1 ) - Scalar ( 4 ) * test_precision < Scalar > ( ) ) ) ) { VERIFY ( ! ( q1 * v1 ) . isApprox ( Quaternionx ( AngleAxisx ( aa . angle ( ) * 2 , aa . axis ( ) ) ) * v1 ) ) ; } aa . fromRotationMatrix ( aa . toRotationMatrix ( ) ) ; VERIFY_IS_APPROX ( q1 * v1 , Quaternionx ( aa ) * v1 ) ; // ▁ The ▁ following ▁ test ▁ is ▁ stable ▁ only ▁ if ▁ 2 * angle ▁ ! = ▁ angle ▁ and ▁ v1 ▁ is ▁ not ▁ colinear ▁ with ▁ axis ENDCOM if ( ( abs ( aa . angle ( ) ) > test_precision < Scalar > ( ) ) && ( abs ( aa . axis ( ) . dot ( v1 . normalized ( ) ) ) < ( Scalar ( 1 ) - Scalar ( 4 ) * test_precision < Scalar > ( ) ) ) ) { VERIFY ( ! ( q1 * v1 ) . isApprox ( Quaternionx ( AngleAxisx ( aa . angle ( ) * 2 , aa . axis ( ) ) ) * v1 ) ) ; } // ▁ AngleAxis ENDCOM VERIFY_IS_APPROX ( AngleAxisx ( a , v1 . normalized ( ) ) . toRotationMatrix ( ) , Quaternionx ( AngleAxisx ( a , v1 . normalized ( ) ) ) . toRotationMatrix ( ) ) ; AngleAxisx aa1 ; m = q1 . toRotationMatrix ( ) ; aa1 = m ; VERIFY_IS_APPROX ( AngleAxisx ( m ) . toRotationMatrix ( ) , Quaternionx ( m ) . toRotationMatrix ( ) ) ; // ▁ Transform ENDCOM // ▁ TODO ▁ complete ▁ the ▁ tests ▁ ! ENDCOM a = 0 ; while ( abs ( a ) < Scalar ( 0.1 ) ) a = internal :: random < Scalar > ( - Scalar ( 0.4 ) * Scalar ( EIGEN_PI ) , Scalar ( 0.4 ) * Scalar ( EIGEN_PI ) ) ; q1 = AngleAxisx ( a , v0 . normalized ( ) ) ; Transform3 t0 , t1 , t2 ; // ▁ first ▁ test ▁ setIdentity ( ) ▁ and ▁ Identity ( ) ENDCOM t0 . setIdentity ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , Transform3 :: MatrixType :: Identity ( ) ) ; t0 . matrix ( ) . setZero ( ) ; t0 = Transform3 :: Identity ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , Transform3 :: MatrixType :: Identity ( ) ) ; t0 . setIdentity ( ) ; t1 . setIdentity ( ) ; v1 << 1 , 2 , 3 ; t0 . linear ( ) = q1 . toRotationMatrix ( ) ; t0 . pretranslate ( v0 ) ; t0 . scale ( v1 ) ; t1 . linear ( ) = q1 . conjugate ( ) . toRotationMatrix ( ) ; t1 . prescale ( v1 . cwiseInverse ( ) ) ; t1 . translate ( - v0 ) ; VERIFY ( ( t0 * t1 ) . matrix ( ) . isIdentity ( test_precision < Scalar > ( ) ) ) ; t1 . fromPositionOrientationScale ( v0 , q1 , v1 ) ; VERIFY_IS_APPROX ( t1 . matrix ( ) , t0 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) . rotate ( q1 . toRotationMatrix ( ) ) ; t1 . setIdentity ( ) ; t1 . scale ( v0 ) . rotate ( q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) . rotate ( AngleAxisx ( q1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; VERIFY_IS_APPROX ( t0 . scale ( a ) . matrix ( ) , t1 . scale ( Vector3 :: Constant ( a ) ) . matrix ( ) ) ; VERIFY_IS_APPROX ( t0 . prescale ( a ) . matrix ( ) , t1 . prescale ( Vector3 :: Constant ( a ) ) . matrix ( ) ) ; // ▁ More ▁ transform ▁ constructors , ▁ operator = , ▁ operator * = ENDCOM Matrix3 mat3 = Matrix3 :: Random ( ) ; Matrix4 mat4 ; mat4 << mat3 , Vector3 :: Zero ( ) , Vector4 :: Zero ( ) . transpose ( ) ; Transform3 tmat3 ( mat3 ) , tmat4 ( mat4 ) ; if ( Mode != int ( AffineCompact ) ) tmat4 . matrix ( ) ( 3 , 3 ) = Scalar ( 1 ) ; VERIFY_IS_APPROX ( tmat3 . matrix ( ) , tmat4 . matrix ( ) ) ; Scalar a3 = internal :: random < Scalar > ( - Scalar ( EIGEN_PI ) , Scalar ( EIGEN_PI ) ) ; Vector3 v3 = Vector3 :: Random ( ) . normalized ( ) ; AngleAxisx aa3 ( a3 , v3 ) ; Transform3 t3 ( aa3 ) ; Transform3 t4 ; t4 = aa3 ; VERIFY_IS_APPROX ( t3 . matrix ( ) , t4 . matrix ( ) ) ; t4 . rotate ( AngleAxisx ( - a3 , v3 ) ) ; VERIFY_IS_APPROX ( t4 . matrix ( ) , MatrixType :: Identity ( ) ) ; t4 *= aa3 ; VERIFY_IS_APPROX ( t3 . matrix ( ) , t4 . matrix ( ) ) ; do { v3 = Vector3 :: Random ( ) ; dont_over_optimize ( v3 ) ; } while ( v3 . cwiseAbs ( ) . minCoeff ( ) < NumTraits < Scalar > :: epsilon ( ) ) ; Translation3 tv3 ( v3 ) ; Transform3 t5 ( tv3 ) ; t4 = tv3 ; VERIFY_IS_APPROX ( t5 . matrix ( ) , t4 . matrix ( ) ) ; t4 . translate ( ( - v3 ) . eval ( ) ) ; VERIFY_IS_APPROX ( t4 . matrix ( ) , MatrixType :: Identity ( ) ) ; t4 *= tv3 ; VERIFY_IS_APPROX ( t5 . matrix ( ) , t4 . matrix ( ) ) ; AlignedScaling3 sv3 ( v3 ) ; Transform3 t6 ( sv3 ) ; t4 = sv3 ; VERIFY_IS_APPROX ( t6 . matrix ( ) , t4 . matrix ( ) ) ; t4 . scale ( v3 . cwiseInverse ( ) ) ; VERIFY_IS_APPROX ( t4 . matrix ( ) , MatrixType :: Identity ( ) ) ; t4 *= sv3 ; VERIFY_IS_APPROX ( t6 . matrix ( ) , t4 . matrix ( ) ) ; // ▁ matrix ▁ * ▁ transform ENDCOM VERIFY_IS_APPROX ( ( t3 . matrix ( ) * t4 ) . matrix ( ) , ( t3 * t4 ) . matrix ( ) ) ; // ▁ chained ▁ Transform ▁ product ENDCOM VERIFY_IS_APPROX ( ( ( t3 * t4 ) * t5 ) . matrix ( ) , ( t3 * ( t4 * t5 ) ) . matrix ( ) ) ; // ▁ check ▁ that ▁ Transform ▁ product ▁ doesn ' t ▁ have ▁ aliasing ▁ problems ENDCOM t5 = t4 ; t5 = t5 * t5 ; VERIFY_IS_APPROX ( t5 , t4 * t4 ) ; // ▁ 2D ▁ transformation ENDCOM Transform2 t20 , t21 ; Vector2 v20 = Vector2 :: Random ( ) ; Vector2 v21 = Vector2 :: Random ( ) ; for ( int k = 0 ; k < 2 ; ++ k ) if ( abs ( v21 [ k ] ) < Scalar ( 1e - 3 ) ) v21 [ k ] = Scalar ( 1e - 3 ) ; t21 . setIdentity ( ) ; t21 . linear ( ) = Rotation2D < Scalar > ( a ) . toRotationMatrix ( ) ; VERIFY_IS_APPROX ( t20 . fromPositionOrientationScale ( v20 , a , v21 ) . matrix ( ) , t21 . pretranslate ( v20 ) . scale ( v21 ) . matrix ( ) ) ; t21 . setIdentity ( ) ; t21 . linear ( ) = Rotation2D < Scalar > ( - a ) . toRotationMatrix ( ) ; VERIFY ( ( t20 . fromPositionOrientationScale ( v20 , a , v21 ) * ( t21 . prescale ( v21 . cwiseInverse ( ) ) . translate ( - v20 ) ) ) . matrix ( ) . isIdentity ( test_precision < Scalar > ( ) ) ) ; // ▁ Transform ▁ - ▁ new ▁ API ENDCOM // ▁ 3D ENDCOM t0 . setIdentity ( ) ; t0 . rotate ( q1 ) . scale ( v0 ) . translate ( v0 ) ; // ▁ mat ▁ * ▁ aligned ▁ scaling ▁ and ▁ mat ▁ * ▁ translation ENDCOM t1 = ( Matrix3 ( q1 ) * AlignedScaling3 ( v0 ) ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = ( Matrix3 ( q1 ) * Eigen :: Scaling ( v0 ) ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = ( q1 * Eigen :: Scaling ( v0 ) ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; // ▁ mat ▁ * ▁ transformation ▁ and ▁ aligned ▁ scaling ▁ * ▁ translation ENDCOM t1 = Matrix3 ( q1 ) * ( AlignedScaling3 ( v0 ) * Translation3 ( v0 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( s0 ) . translate ( v0 ) ; t1 = Eigen :: Scaling ( s0 ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prescale ( s0 ) ; t1 = Eigen :: Scaling ( s0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 = t3 ; t0 . scale ( s0 ) ; t1 = t3 * Eigen :: Scaling ( s0 , s0 , s0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prescale ( s0 ) ; t1 = Eigen :: Scaling ( s0 , s0 , s0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 = t3 ; t0 . scale ( s0 ) ; t1 = t3 * Eigen :: Scaling ( s0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prescale ( s0 ) ; t1 = Eigen :: Scaling ( s0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . prerotate ( q1 ) . prescale ( v0 ) . pretranslate ( v0 ) ; // ▁ translation ▁ * ▁ aligned ▁ scaling ▁ and ▁ transformation ▁ * ▁ mat ENDCOM t1 = ( Translation3 ( v0 ) * AlignedScaling3 ( v0 ) ) * Transform3 ( q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; // ▁ scaling ▁ * ▁ mat ▁ and ▁ translation ▁ * ▁ mat ENDCOM t1 = Translation3 ( v0 ) * ( AlignedScaling3 ( v0 ) * Transform3 ( q1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) . translate ( v0 ) . rotate ( q1 ) ; // ▁ translation ▁ * ▁ mat ▁ and ▁ aligned ▁ scaling ▁ * ▁ transformation ENDCOM t1 = AlignedScaling3 ( v0 ) * ( Translation3 ( v0 ) * Transform3 ( q1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; // ▁ transformation ▁ * ▁ aligned ▁ scaling ENDCOM t0 . scale ( v0 ) ; t1 *= AlignedScaling3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = AlignedScaling3 ( v0 ) * ( Translation3 ( v0 ) * Transform3 ( q1 ) ) ; t1 = t1 * v0 . asDiagonal ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; // ▁ transformation ▁ * ▁ translation ENDCOM t0 . translate ( v0 ) ; t1 = t1 * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; // ▁ translation ▁ * ▁ transformation ENDCOM t0 . pretranslate ( v0 ) ; t1 = Translation3 ( v0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; // ▁ transform ▁ * ▁ quaternion ENDCOM t0 . rotate ( q1 ) ; t1 = t1 * q1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; // ▁ translation ▁ * ▁ quaternion ENDCOM t0 . translate ( v1 ) . rotate ( q1 ) ; t1 = t1 * ( Translation3 ( v1 ) * q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; // ▁ aligned ▁ scaling ▁ * ▁ quaternion ENDCOM t0 . scale ( v1 ) . rotate ( q1 ) ; t1 = t1 * ( AlignedScaling3 ( v1 ) * q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; // ▁ quaternion ▁ * ▁ transform ENDCOM t0 . prerotate ( q1 ) ; t1 = q1 * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; // ▁ quaternion ▁ * ▁ translation ENDCOM t0 . rotate ( q1 ) . translate ( v1 ) ; t1 = t1 * ( q1 * Translation3 ( v1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; // ▁ quaternion ▁ * ▁ aligned ▁ scaling ENDCOM t0 . rotate ( q1 ) . scale ( v1 ) ; t1 = t1 * ( q1 * AlignedScaling3 ( v1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; // ▁ test ▁ transform ▁ inversion ENDCOM t0 . setIdentity ( ) ; t0 . translate ( v0 ) ; do { t0 . linear ( ) . setRandom ( ) ; } while ( t0 . linear ( ) . jacobiSvd ( ) . singularValues ( ) ( 2 ) < test_precision < Scalar > ( ) ) ; Matrix4 t044 = Matrix4 :: Zero ( ) ; t044 ( 3 , 3 ) = 1 ; t044 . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) = t0 . matrix ( ) ; VERIFY_IS_APPROX ( t0 . inverse ( Affine ) . matrix ( ) , t044 . inverse ( ) . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) ) ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) . rotate ( q1 ) ; t044 = Matrix4 :: Zero ( ) ; t044 ( 3 , 3 ) = 1 ; t044 . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) = t0 . matrix ( ) ; VERIFY_IS_APPROX ( t0 . inverse ( Isometry ) . matrix ( ) , t044 . inverse ( ) . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) ) ; Matrix3 mat_rotation , mat_scaling ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) . rotate ( q1 ) . scale ( v1 ) ; t0 . computeRotationScaling ( & mat_rotation , & mat_scaling ) ; VERIFY_IS_APPROX ( t0 . linear ( ) , mat_rotation * mat_scaling ) ; VERIFY_IS_APPROX ( mat_rotation * mat_rotation . adjoint ( ) , Matrix3 :: Identity ( ) ) ; VERIFY_IS_APPROX ( mat_rotation . determinant ( ) , Scalar ( 1 ) ) ; t0 . computeScalingRotation ( & mat_scaling , & mat_rotation ) ; VERIFY_IS_APPROX ( t0 . linear ( ) , mat_scaling * mat_rotation ) ; VERIFY_IS_APPROX ( mat_rotation * mat_rotation . adjoint ( ) , Matrix3 :: Identity ( ) ) ; VERIFY_IS_APPROX ( mat_rotation . determinant ( ) , Scalar ( 1 ) ) ; // ▁ test ▁ casting ENDCOM Transform < float , 3 , Mode > t1f = t1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( t1f . template cast < Scalar > ( ) , t1 ) ; Transform < double , 3 , Mode > t1d = t1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( t1d . template cast < Scalar > ( ) , t1 ) ; Translation3 tr1 ( v0 ) ; Translation < float , 3 > tr1f = tr1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( tr1f . template cast < Scalar > ( ) , tr1 ) ; Translation < double , 3 > tr1d = tr1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( tr1d . template cast < Scalar > ( ) , tr1 ) ; AngleAxis < float > aa1f = aa1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( aa1f . template cast < Scalar > ( ) , aa1 ) ; AngleAxis < double > aa1d = aa1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( aa1d . template cast < Scalar > ( ) , aa1 ) ; Rotation2D < Scalar > r2d1 ( internal :: random < Scalar > ( ) ) ; Rotation2D < float > r2d1f = r2d1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( r2d1f . template cast < Scalar > ( ) , r2d1 ) ; Rotation2D < double > r2d1d = r2d1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( r2d1d . template cast < Scalar > ( ) , r2d1 ) ; for ( int k = 0 ; k < 100 ; ++ k ) { Scalar angle = internal :: random < Scalar > ( - 100 , 100 ) ; Rotation2D < Scalar > rot2 ( angle ) ; VERIFY ( rot2 . smallestPositiveAngle ( ) >= 0 ) ; VERIFY ( rot2 . smallestPositiveAngle ( ) <= Scalar ( 2 ) * Scalar ( EIGEN_PI ) ) ; VERIFY_IS_APPROX ( angleToVec ( rot2 . smallestPositiveAngle ( ) ) , angleToVec ( rot2 . angle ( ) ) ) ; VERIFY ( rot2 . smallestAngle ( ) >= - Scalar ( EIGEN_PI ) ) ; VERIFY ( rot2 . smallestAngle ( ) <= Scalar ( EIGEN_PI ) ) ; VERIFY_IS_APPROX ( angleToVec ( rot2 . smallestAngle ( ) ) , angleToVec ( rot2 . angle ( ) ) ) ; Matrix < Scalar , 2 , 2 > rot2_as_mat ( rot2 ) ; Rotation2D < Scalar > rot3 ( rot2_as_mat ) ; VERIFY_IS_APPROX ( angleToVec ( rot2 . smallestAngle ( ) ) , angleToVec ( rot3 . angle ( ) ) ) ; } s0 = internal :: random < Scalar > ( - 100 , 100 ) ; s1 = internal :: random < Scalar > ( - 100 , 100 ) ; Rotation2D < Scalar > R0 ( s0 ) , R1 ( s1 ) ; t20 = Translation2 ( v20 ) * ( R0 * Eigen :: Scaling ( s0 ) ) ; t21 = Translation2 ( v20 ) * R0 * Eigen :: Scaling ( s0 ) ; VERIFY_IS_APPROX ( t20 , t21 ) ; t20 = Translation2 ( v20 ) * ( R0 * R0 . inverse ( ) * Eigen :: Scaling ( s0 ) ) ; t21 = Translation2 ( v20 ) * Eigen :: Scaling ( s0 ) ; VERIFY_IS_APPROX ( t20 , t21 ) ; VERIFY_IS_APPROX ( s0 , ( R0 . slerp ( 0 , R1 ) ) . angle ( ) ) ; VERIFY_IS_APPROX ( angleToVec ( R1 . smallestPositiveAngle ( ) ) , angleToVec ( ( R0 . slerp ( 1 , R1 ) ) . smallestPositiveAngle ( ) ) ) ; VERIFY_IS_APPROX ( R0 . smallestPositiveAngle ( ) , ( R0 . slerp ( 0.5 , R0 ) ) . smallestPositiveAngle ( ) ) ; if ( std :: cos ( s0 ) > 0 ) VERIFY_IS_MUCH_SMALLER_THAN ( ( R0 . slerp ( 0.5 , R0 . inverse ( ) ) ) . smallestAngle ( ) , Scalar ( 1 ) ) ; else VERIFY_IS_APPROX ( Scalar ( EIGEN_PI ) , ( R0 . slerp ( 0.5 , R0 . inverse ( ) ) ) . smallestPositiveAngle ( ) ) ; // ▁ Check ▁ path ▁ length ENDCOM Scalar l = 0 ; int path_steps = 100 ; for ( int k = 0 ; k < path_steps ; ++ k ) { Scalar a1 = R0 . slerp ( Scalar ( k ) / Scalar ( path_steps ) , R1 ) . angle ( ) ; Scalar a2 = R0 . slerp ( Scalar ( k + 1 ) / Scalar ( path_steps ) , R1 ) . angle ( ) ; l += std :: abs ( a2 - a1 ) ; } VERIFY ( l <= Scalar ( EIGEN_PI ) * ( Scalar ( 1 ) + NumTraits < Scalar > :: epsilon ( ) * Scalar ( path_steps / 2 ) ) ) ; // ▁ check ▁ basic ▁ features ENDCOM { Rotation2D < Scalar > r1 ; // ▁ default ▁ ctor ENDCOM r1 = Rotation2D < Scalar > ( s0 ) ; // ▁ copy ▁ assignment ENDCOM VERIFY_IS_APPROX ( r1 . angle ( ) , s0 ) ; Rotation2D < Scalar > r2 ( r1 ) ; // ▁ copy ▁ ctor ENDCOM VERIFY_IS_APPROX ( r2 . angle ( ) , s0 ) ; } { Transform3 t32 ( Matrix4 :: Random ( ) ) , t33 , t34 ; t34 = t33 = t32 ; t32 . scale ( v0 ) ; t33 *= AlignedScaling3 ( v0 ) ; VERIFY_IS_APPROX ( t32 . matrix ( ) , t33 . matrix ( ) ) ; t33 = t34 * AlignedScaling3 ( v0 ) ; VERIFY_IS_APPROX ( t32 . matrix ( ) , t33 . matrix ( ) ) ; } } template < typename A1 , typename A2 , typename P , typename Q , typename V , typename H > void transform_associativity_left ( const A1 & a1 , const A2 & a2 , const P & p , const Q & q , const V & v , const H & h ) { VERIFY_IS_APPROX ( q * ( a1 * v ) , ( q * a1 ) * v ) ; VERIFY_IS_APPROX ( q * ( a2 * v ) , ( q * a2 ) * v ) ; VERIFY_IS_APPROX ( q * ( p * h ) . hnormalized ( ) , ( ( q * p ) * h ) . hnormalized ( ) ) ; } template < typename A1 , typename A2 , typename P , typename Q , typename V , typename H > void transform_associativity2 ( const A1 & a1 , const A2 & a2 , const P & p , const Q & q , const V & v , const H & h ) { VERIFY_IS_APPROX ( a1 * ( q * v ) , ( a1 * q ) * v ) ; VERIFY_IS_APPROX ( a2 * ( q * v ) , ( a2 * q ) * v ) ; VERIFY_IS_APPROX ( p * ( q * v ) . homogeneous ( ) , ( p * q ) * v . homogeneous ( ) ) ; transform_associativity_left ( a1 , a2 , p , q , v , h ) ; } template < typename Scalar , int Dim , int Options , typename RotationType > void transform_associativity ( const RotationType & R ) { typedef Matrix < Scalar , Dim , 1 > VectorType ; typedef Matrix < Scalar , Dim + 1 , 1 > HVectorType ; typedef Matrix < Scalar , Dim , Dim > LinearType ; typedef Matrix < Scalar , Dim + 1 , Dim + 1 > MatrixType ; typedef Transform < Scalar , Dim , AffineCompact , Options > AffineCompactType ; typedef Transform < Scalar , Dim , Affine , Options > AffineType ; typedef Transform < Scalar , Dim , Projective , Options > ProjectiveType ; typedef DiagonalMatrix < Scalar , Dim > ScalingType ; typedef Translation < Scalar , Dim > TranslationType ; AffineCompactType A1c ; A1c . matrix ( ) . setRandom ( ) ; AffineCompactType A2c ; A2c . matrix ( ) . setRandom ( ) ; AffineType A1 ( A1c ) ; AffineType A2 ( A2c ) ; ProjectiveType P1 ; P1 . matrix ( ) . setRandom ( ) ; VectorType v1 = VectorType :: Random ( ) ; VectorType v2 = VectorType :: Random ( ) ; HVectorType h1 = HVectorType :: Random ( ) ; Scalar s1 = internal :: random < Scalar > ( ) ; LinearType L = LinearType :: Random ( ) ; MatrixType M = MatrixType :: Random ( ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , A2 , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , A2c , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , v1 . asDiagonal ( ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , ScalingType ( v1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , Scaling ( v1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , Scaling ( s1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , TranslationType ( v1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity_left ( A1c , A1 , P1 , L , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , R , v2 , h1 ) ) ; VERIFY_IS_APPROX ( A1 * ( M * h1 ) , ( A1 * M ) * h1 ) ; VERIFY_IS_APPROX ( A1c * ( M * h1 ) , ( A1c * M ) * h1 ) ; VERIFY_IS_APPROX ( P1 * ( M * h1 ) , ( P1 * M ) * h1 ) ; VERIFY_IS_APPROX ( M * ( A1 * h1 ) , ( M * A1 ) * h1 ) ; VERIFY_IS_APPROX ( M * ( A1c * h1 ) , ( M * A1c ) * h1 ) ; VERIFY_IS_APPROX ( M * ( P1 * h1 ) , ( ( M * P1 ) * h1 ) ) ; } template < typename Scalar > void transform_alignment ( ) { typedef Transform < Scalar , 3 , Projective , AutoAlign > Projective3a ; typedef Transform < Scalar , 3 , Projective , DontAlign > Projective3u ; EIGEN_ALIGN_MAX Scalar array1 [ 16 ] ; EIGEN_ALIGN_MAX Scalar array2 [ 16 ] ; EIGEN_ALIGN_MAX Scalar array3 [ 16 + 1 ] ; Scalar * array3u = array3 + 1 ; Projective3a * p1 = :: new ( reinterpret_cast < void * > ( array1 ) ) Projective3a ; Projective3u * p2 = :: new ( reinterpret_cast < void * > ( array2 ) ) Projective3u ; Projective3u * p3 = :: new ( reinterpret_cast < void * > ( array3u ) ) Projective3u ; p1 -> matrix ( ) . setRandom ( ) ; * p2 = * p1 ; * p3 = * p1 ; VERIFY_IS_APPROX ( p1 -> matrix ( ) , p2 -> matrix ( ) ) ; VERIFY_IS_APPROX ( p1 -> matrix ( ) , p3 -> matrix ( ) ) ; VERIFY_IS_APPROX ( ( * p1 ) * ( * p1 ) , ( * p2 ) * ( * p3 ) ) ; # if defined ( EIGEN_VECTORIZE ) && EIGEN_MAX_STATIC_ALIGN_BYTES > 0 if ( internal :: packet_traits < Scalar > :: Vectorizable ) VERIFY_RAISES_ASSERT ( ( :: new ( reinterpret_cast < void * > ( array3u ) ) Projective3a ) ) ; # endif } template < typename Scalar , int Dim , int Options > void transform_products ( ) { typedef Matrix < Scalar , Dim + 1 , Dim + 1 > Mat ; typedef Transform < Scalar , Dim , Projective , Options > Proj ; typedef Transform < Scalar , Dim , Affine , Options > Aff ; typedef Transform < Scalar , Dim , AffineCompact , Options > AffC ; Proj p ; p . matrix ( ) . setRandom ( ) ; Aff a ; a . linear ( ) . setRandom ( ) ; a . translation ( ) . setRandom ( ) ; AffC ac = a ; Mat p_m ( p . matrix ( ) ) , a_m ( a . matrix ( ) ) ; VERIFY_IS_APPROX ( ( p * p ) . matrix ( ) , p_m * p_m ) ; VERIFY_IS_APPROX ( ( a * a ) . matrix ( ) , a_m * a_m ) ; VERIFY_IS_APPROX ( ( p * a ) . matrix ( ) , p_m * a_m ) ; VERIFY_IS_APPROX ( ( a * p ) . matrix ( ) , a_m * p_m ) ; VERIFY_IS_APPROX ( ( ac * a ) . matrix ( ) , a_m * a_m ) ; VERIFY_IS_APPROX ( ( a * ac ) . matrix ( ) , a_m * a_m ) ; VERIFY_IS_APPROX ( ( p * ac ) . matrix ( ) , p_m * a_m ) ; VERIFY_IS_APPROX ( ( ac * p ) . matrix ( ) , a_m * p_m ) ; } void test_geo_transformations ( ) { for ( int i = 0 ; i < g_repeat ; i ++ ) { CALL_SUBTEST_1 ( ( transformations < double , Affine , AutoAlign > ( ) ) ) ; CALL_SUBTEST_1 ( ( non_projective_only < double , Affine , AutoAlign > ( ) ) ) ; CALL_SUBTEST_2 ( ( transformations < float , AffineCompact , AutoAlign > ( ) ) ) ; CALL_SUBTEST_2 ( ( non_projective_only < float , AffineCompact , AutoAlign > ( ) ) ) ; CALL_SUBTEST_2 ( ( transform_alignment < float > ( ) ) ) ; CALL_SUBTEST_3 ( ( transformations < double , Projective , AutoAlign > ( ) ) ) ; CALL_SUBTEST_3 ( ( transformations < double , Projective , DontAlign > ( ) ) ) ; CALL_SUBTEST_3 ( ( transform_alignment < double > ( ) ) ) ; CALL_SUBTEST_4 ( ( transformations < float , Affine , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_4 ( ( non_projective_only < float , Affine , RowMajor > ( ) ) ) ; CALL_SUBTEST_5 ( ( transformations < double , AffineCompact , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_5 ( ( non_projective_only < double , AffineCompact , RowMajor > ( ) ) ) ; CALL_SUBTEST_6 ( ( transformations < double , Projective , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_6 ( ( transformations < double , Projective , RowMajor | DontAlign > ( ) ) ) ; CALL_SUBTEST_7 ( ( transform_products < double , 3 , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_7 ( ( transform_products < float , 2 , AutoAlign > ( ) ) ) ; CALL_SUBTEST_8 ( ( transform_associativity < double , 2 , ColMajor > ( Rotation2D < double > ( internal :: random < double > ( ) * double ( EIGEN_PI ) ) ) ) ) ; CALL_SUBTEST_8 ( ( transform_associativity < double , 3 , ColMajor > ( Quaterniond :: UnitRandom ( ) ) ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="osgcc/ryzom/tree/master/ryzom/tools/leveldesign/georges_dll/form_dialog.cpp"> // ▁ Ryzom ▁ - ▁ MMORPG ▁ Framework ▁ < http : // dev . ryzom . com / projects / ryzom / > ENDCOM // ▁ Copyright ▁ ( C ) ▁ 2010 ▁ Winch ▁ Gate ▁ Property ▁ Limited ENDCOM // ▁ This ▁ program ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM // ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ▁ as ENDCOM // ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ENDCOM // ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM // ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM // ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM // ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM // ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM // ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ENDCOM // ▁ along ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . ENDCOM // ▁ form _ dialog . cpp ▁ : ▁ implementation ▁ file ENDCOM # include " stdafx . h " # include " georges _ edit . h " # include " georges _ edit _ view . h " # include " georges _ edit _ doc . h " # include " form _ dialog . h " # include " action . h " # include " left _ view . h " # include " nel / misc / path . h " # include " nel / georges / type . h " # include " nel / georges / form _ elm . h " using namespace std ; using namespace NLMISC ; using namespace NLGEORGES ; // ▁ Define ▁ this ▁ to ▁ show ▁ Formula ▁ value ▁ evaluation ▁ intstead ▁ of ▁ value ▁ evaluation ENDCOM // ▁ # define ▁ TEST _ EVAL _ FORMULA ENDCOM // ▁ CFormDialog ▁ dialog ENDCOM CFormDialog :: CFormDialog ( ) : CBaseDialog ( IDR_MAINFRAME ) { // { { AFX _ DATA _ INIT ( CFormDialog ) ENDCOM // ▁ NOTE : ▁ the ▁ ClassWizard ▁ will ▁ add ▁ member ▁ initialization ▁ here ENDCOM // } } AFX _ DATA _ INIT ENDCOM View = NULL ; WidgetIndexCount = 0 ; WidgetFocused = 0xffffffff ; } CFormDialog :: ~ CFormDialog ( ) { clear ( ) ; } void CFormDialog :: clear ( ) { unRegisterLastControl ( ) ; for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) delete Widgets [ i ] ; Widgets . clear ( ) ; WidgetFocused = 0xffffffff ; WidgetIndexCount = 0 ; } void CFormDialog :: DoDataExchange ( CDataExchange * pDX ) { CDialog :: DoDataExchange ( pDX ) ; // { { AFX _ DATA _ MAP ( CFormDialog ) ENDCOM // ▁ NOTE : ▁ the ▁ ClassWizard ▁ will ▁ add ▁ DDX ▁ and ▁ DDV ▁ calls ▁ here ENDCOM // } } AFX _ DATA _ MAP ENDCOM } BEGIN_MESSAGE_MAP ( CFormDialog , CDialog ) // { { AFX _ MSG _ MAP ( CFormDialog ) ENDCOM ON_WM_SIZE ( ) ON_WM_LBUTTONDOWN ( ) ON_WM_SETFOCUS ( ) ON_WM_KILLFOCUS ( ) // } } AFX _ MSG _ MAP ENDCOM END_MESSAGE_MAP ( ) // ▁ CFormDialog ▁ message ▁ handlers ENDCOM void CFormDialog :: OnSize ( UINT nType , int cx , int cy ) { CBaseDialog :: OnSize ( nType , cx , cy ) ; // ▁ TODO : ▁ Add ▁ your ▁ message ▁ handler ▁ code ▁ here ENDCOM } BOOL CFormDialog :: OnInitDialog ( ) { CBaseDialog :: OnInitDialog ( ) ; SetDefID ( 0xffffffff ) ; UpdateData ( FALSE ) ; return TRUE ; // ▁ return ▁ TRUE ▁ unless ▁ you ▁ set ▁ the ▁ focus ▁ to ▁ a ▁ control ENDCOM // ▁ EXCEPTION : ▁ OCX ▁ Property ▁ Pages ▁ should ▁ return ▁ FALSE ENDCOM } void CFormDialog :: OnOK ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateData ( ) ; if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onOk ( ) ; } } } void CFormDialog :: OnCancel ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateData ( ) ; if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onCancel ( ) ; return ; } } CBaseDialog :: OnCancel ( ) ; } CWnd * CFormDialog :: addTypeWidget ( const NLGEORGES :: CType & type , uint elmIndex , const char * title , const char * atomName , const char * typeFilename , RECT & currentPos , CForm & form , IFormWidget :: TTypeSrc typeWidget , const char * filenameExt , uint slot ) { // ▁ What ▁ kind ▁ of ▁ UI ▁ ? ENDCOM switch ( type . UIType ) { case CType :: FileBrowser : case CType :: Edit : case CType :: EditSpin : { // ▁ For ▁ edit ▁ type , ▁ use ▁ a ▁ memory ▁ combobox ENDCOM CFormMemCombo * memCombo = new CFormMemCombo ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; // ▁ Create ▁ a ▁ reg ▁ key ENDCOM string tfn = typeFilename ; string key = GEORGES_EDIT_BASE_REG_KEY " \\ " + strlwr ( typeFilename ) + " ▁ MemCombo " ; // ▁ Create ▁ the ▁ widget ENDCOM memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title , key . c_str ( ) , type . UIType == CType :: EditSpin , type . UIType == CType :: FileBrowser , filenameExt ) ; // ▁ Get ▁ from ▁ document ENDCOM memCombo -> getFromDocument ( form ) ; return & memCombo -> Combo ; } break ; case CType :: NonEditableCombo : { // ▁ For ▁ edit ▁ type , ▁ use ▁ a ▁ memory ▁ combobox ENDCOM CFormCombo * memCombo = new CFormCombo ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; // ▁ Create ▁ the ▁ widget ENDCOM memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; // ▁ Get ▁ from ▁ document ENDCOM memCombo -> getFromDocument ( form ) ; return & memCombo -> Combo ; } break ; case CType :: BigEdit : { // ▁ For ▁ edit ▁ type , ▁ use ▁ a ▁ memory ▁ combobox ENDCOM CFormBigEdit * memCombo = new CFormBigEdit ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; // ▁ Create ▁ the ▁ widget ENDCOM memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; // ▁ Get ▁ from ▁ document ENDCOM memCombo -> getFromDocument ( form ) ; return & memCombo -> Edit ; } break ; case CType :: ColorEdit : { // ▁ For ▁ edit ▁ type , ▁ use ▁ a ▁ memory ▁ combobox ENDCOM CColorEdit * memCombo = new CColorEdit ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; // ▁ Create ▁ the ▁ widget ENDCOM memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; // ▁ Get ▁ from ▁ document ENDCOM memCombo -> getFromDocument ( form ) ; return & memCombo -> Color ; } break ; } return NULL ; } void CFormDialog :: getVirtualDfnFromDocument ( const NLGEORGES :: CFormDfn * _dfn , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { // ▁ Clear ▁ the ▁ current ▁ dialog ENDCOM clear ( ) ; // ▁ Reserve ▁ some ▁ widget ▁ pointers ENDCOM Widgets . reserve ( 10 ) ; // ▁ Widget ▁ placement ENDCOM RECT currentPos ; getFirstItemPos ( currentPos ) ; // ▁ For ▁ edit ▁ type , ▁ use ▁ a ▁ memory ▁ combobox ENDCOM CFormMemCombo * memCombo = new CFormMemCombo ( this , 0xffffffff , structName , IFormWidget :: TypeVirtualDfn , slot ) ; Widgets . push_back ( memCombo ) ; // ▁ Create ▁ the ▁ widget ENDCOM memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Dfn : " , GEORGES_EDIT_BASE_REG_KEY " \\Virtual ▁ Dfn ▁ MemCombo " , false , true , " * . dfn " ) ; // ▁ Get ▁ from ▁ document ENDCOM memCombo -> getFromDocument ( * doc -> getFormPtr ( ) ) ; // ▁ Dfn ▁ selected ▁ ? ENDCOM if ( _dfn ) { // ▁ Get ▁ the ▁ parent ▁ DFN ENDCOM std :: vector < const CFormDfn * > arrayDfn ; arrayDfn . reserve ( _dfn -> countParentDfn ( ) ) ; _dfn -> getParentDfn ( arrayDfn ) ; // ▁ Element ▁ index ENDCOM uint elmIndex = 0 ; // ▁ For ▁ each ▁ DFN ENDCOM for ( uint dfnIndex = 0 ; dfnIndex < arrayDfn . size ( ) ; dfnIndex ++ ) { // ▁ Form ▁ must ▁ be ▁ editable ▁ only ▁ if ▁ all ▁ DFN ▁ and ▁ TYPE ▁ have ▁ been ▁ found ENDCOM nlassert ( arrayDfn [ dfnIndex ] ) ; // ▁ Ref ▁ on ▁ the ▁ DFN ENDCOM const CFormDfn & dfn = * arrayDfn [ dfnIndex ] ; // ▁ For ▁ each ▁ structure ▁ element ENDCOM for ( uint i = 0 ; i < dfn . getNumEntry ( ) ; i ++ ) { // ▁ Get ▁ a ▁ ref ▁ on ▁ the ▁ entry ENDCOM const CFormDfn :: CEntry & entry = dfn . getEntry ( i ) ; // ▁ Is ▁ it ▁ an ▁ atom ▁ ? ENDCOM if ( entry . getType ( ) == UFormDfn :: EntryType && ! entry . getArrayFlag ( ) ) { // ▁ Some ▁ string ENDCOM string title = entry . getName ( ) + " : " ; string atomName = string ( structName ) + " . " + entry . getName ( ) ; addTypeWidget ( * entry . getTypePtr ( ) , elmIndex , title . c_str ( ) , atomName . c_str ( ) , entry . getFilename ( ) . c_str ( ) , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeForm , entry . getFilenameExt ( ) . c_str ( ) , slot ) ; } // ▁ Next ▁ form ▁ index ENDCOM elmIndex ++ ; } } } // ▁ Register ▁ last ▁ control ▁ for ▁ tab ▁ selection ENDCOM registerLastControl ( ) ; } } } void CFormDialog :: getDfnFromDocument ( const NLGEORGES :: CFormDfn & _dfn , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { // ▁ Clear ▁ the ▁ current ▁ dialog ENDCOM clear ( ) ; // ▁ Reserve ▁ some ▁ widget ▁ pointers ENDCOM Widgets . reserve ( 10 ) ; // ▁ Widget ▁ placement ENDCOM RECT currentPos ; getFirstItemPos ( currentPos ) ; // ▁ Get ▁ the ▁ parent ▁ DFN ENDCOM std :: vector < const CFormDfn * > arrayDfn ; arrayDfn . reserve ( _dfn . countParentDfn ( ) ) ; _dfn . getParentDfn ( arrayDfn ) ; // ▁ For ▁ edit ▁ type , ▁ use ▁ a ▁ memory ▁ combobox ENDCOM if ( strcmp ( structName , " " ) == 0 ) { CListWidget * listWidget = new CListWidget ( this , 0xffffffff , " " , IFormWidget :: TypeFormParent , slot ) ; Widgets . push_back ( listWidget ) ; // ▁ Create ▁ the ▁ widget ENDCOM listWidget -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Parent ▁ Form : " , GEORGES_EDIT_BASE_REG_KEY " \\Parent ▁ Form ▁ MemCombo " , 1 ) ; // ▁ Add ▁ one ▁ column ENDCOM listWidget -> addColumn ( " Parent ▁ filename " ) ; // ▁ Get ▁ from ▁ document ENDCOM listWidget -> getFromDocument ( * doc -> getFormPtr ( ) ) ; } // ▁ store ▁ icon ▁ related ▁ infos ENDCOM CWnd * pWnd = NULL ; CWnd * pWndIcon = NULL ; CWnd * pWndIconColor = NULL ; CWnd * pWndIconBack = NULL ; CWnd * pWndIconBackColor = NULL ; CWnd * pWndIconOver = NULL ; CWnd * pWndIconOverColor = NULL ; CWnd * pWndIconOver2 = NULL ; CWnd * pWndIconOver2Color = NULL ; // ▁ Element ▁ index ENDCOM uint elmIndex = 0 ; // ▁ For ▁ each ▁ DFN ENDCOM for ( uint dfnIndex = 0 ; dfnIndex < arrayDfn . size ( ) ; dfnIndex ++ ) { // ▁ Form ▁ must ▁ be ▁ editable ▁ only ▁ if ▁ all ▁ DFN ▁ and ▁ TYPE ▁ have ▁ been ▁ found ENDCOM nlassert ( arrayDfn [ dfnIndex ] ) ; // ▁ Ref ▁ on ▁ the ▁ DFN ENDCOM const CFormDfn & dfn = * arrayDfn [ dfnIndex ] ; // ▁ For ▁ each ▁ structure ▁ element ENDCOM for ( uint i = 0 ; i < dfn . getNumEntry ( ) ; i ++ ) { // ▁ Get ▁ a ▁ ref ▁ on ▁ the ▁ entry ENDCOM const CFormDfn :: CEntry & entry = dfn . getEntry ( i ) ; // ▁ Is ▁ it ▁ an ▁ atom ▁ ? ENDCOM if ( entry . getType ( ) == UFormDfn :: EntryType && ! entry . getArrayFlag ( ) ) { // ▁ Some ▁ string ENDCOM string title = entry . getName ( ) + " : " ; string atomName = string ( structName ) + " . " + entry . getName ( ) ; pWnd = addTypeWidget ( * entry . getTypePtr ( ) , elmIndex , title . c_str ( ) , atomName . c_str ( ) , entry . getFilename ( ) . c_str ( ) , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeForm , entry . getFilenameExt ( ) . c_str ( ) , slot ) ; if ( entry . getName ( ) == " Icon " || entry . getName ( ) == " icon " ) pWndIcon = pWnd ; else if ( entry . getName ( ) == " IconColor " ) pWndIconColor = pWnd ; else if ( entry . getName ( ) == " IconBack " || entry . getName ( ) == " icon ▁ background " ) pWndIconBack = pWnd ; else if ( entry . getName ( ) == " IconBackColor " ) pWndIconBackColor = pWnd ; else if ( entry . getName ( ) == " IconOver " || entry . getName ( ) == " icon ▁ overlay " ) pWndIconOver = pWnd ; else if ( entry . getName ( ) == " IconOverColor " ) pWndIconOverColor = pWnd ; else if ( entry . getName ( ) == " IconOver2" || entry . getName ( ) == " icon ▁ overlay2" ) pWndIconOver2 = pWnd ; else if ( entry . getName ( ) == " IconOver2Color " ) pWndIconOver2Color = pWnd ; } // ▁ Next ▁ form ▁ index ENDCOM elmIndex ++ ; } } // ▁ Special ▁ case ▁ for ▁ " . Client " ▁ and ▁ " .3d " ▁ : ▁ add ▁ a ▁ widget ▁ to ▁ draw ▁ icons ENDCOM if ( ( string ( structName ) == " . Client " ) || ( string ( structName ) == " . 3d " ) ) { string title = " Icon ▁ bitmap : " ; CIconWidget * w = new CIconWidget ( this , elmIndex , " " , IFormWidget :: TypeFormParent , slot ) ; Widgets . push_back ( w ) ; // ▁ Create ▁ the ▁ widget ENDCOM w -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title . c_str ( ) ) ; w -> Icon . pWndIcon = pWndIcon ; w -> Icon . pWndIconColor = pWndIconColor ; w -> Icon . pWndIconBack = pWndIconBack ; w -> Icon . pWndIconBackColor = pWndIconBackColor ; w -> Icon . pWndIconOver = pWndIconOver ; w -> Icon . pWndIconOverColor = pWndIconOverColor ; w -> Icon . pWndIconOver2 = pWndIconOver2 ; w -> Icon . pWndIconOver2Color = pWndIconOver2Color ; } // ▁ Register ▁ last ▁ control ▁ for ▁ tab ▁ selection ENDCOM registerLastControl ( ) ; } } } void CFormDialog :: getArrayFromDocument ( const char * structName , uint structId , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { // ▁ Clear ▁ the ▁ current ▁ dialog ENDCOM clear ( ) ; // ▁ Reserve ▁ some ▁ widget ▁ pointers ENDCOM Widgets . reserve ( 10 ) ; // ▁ Widget ▁ placement ENDCOM RECT currentPos ; getFirstItemPos ( currentPos ) ; CFormMemCombo * memCombo = new CFormMemCombo ( this , structId , structName , IFormWidget :: TypeArray , slot ) ; Widgets . push_back ( memCombo ) ; // ▁ Create ▁ the ▁ widget ENDCOM memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Array ▁ size : " , GEORGES_EDIT_BASE_REG_KEY " \\Array ▁ Size ▁ MemCombo " , true , false , NULL ) ; // ▁ Get ▁ from ▁ document ENDCOM memCombo -> getFromDocument ( * doc -> getFormPtr ( ) ) ; // ▁ Register ▁ last ▁ control ▁ for ▁ tab ▁ selection ENDCOM registerLastControl ( ) ; } } } void CFormDialog :: getTypeFromDocument ( const NLGEORGES :: CType & _type , const char * name , const char * typeFilename , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { // ▁ Clear ▁ the ▁ current ▁ dialog ENDCOM clear ( ) ; // ▁ Reserve ▁ some ▁ widget ▁ pointers ENDCOM Widgets . reserve ( 10 ) ; // ▁ Widget ▁ placement ENDCOM RECT currentPos ; getFirstItemPos ( currentPos ) ; // ▁ Some ▁ string ENDCOM addTypeWidget ( _type , 0xffffffff , name , structName , typeFilename , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeType , NULL , slot ) ; // ▁ Register ▁ last ▁ control ▁ for ▁ tab ▁ selection ENDCOM registerLastControl ( ) ; } } } void CFormDialog :: updateLabels ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; } } void CFormDialog :: updateValues ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; Widgets [ i ] -> getFromDocument ( * ( View -> GetDocument ( ) -> getFormPtr ( ) ) ) ; } } void CFormDialog :: setToDocument ( uint widget ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { // ▁ discard ▁ CIconWidget ENDCOM CIconWidget * iconWidget = dynamic_cast < CIconWidget * > ( Widgets [ widget ] ) ; if ( iconWidget ) return ; // ▁ Check ▁ if ▁ this ▁ command ▁ will ▁ build ▁ a ▁ new ▁ array ▁ / ▁ virtual ▁ dfn ▁ that ▁ was ▁ inherited . . ENDCOM if ( Widgets [ widget ] -> getFormName ( ) != " NULL " ) { // ▁ Get ▁ current ▁ node ENDCOM const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( Widgets [ widget ] -> getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( Widgets [ widget ] -> getFormName ( ) . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; // ▁ Must ▁ create ▁ array ▁ or ▁ virtual ▁ dfn ▁ ? ENDCOM if ( parentVDfnArray ) { // ▁ Warn ▁ the ▁ user ENDCOM if ( ! theApp . yesNo ( " Warning , ▁ this ▁ action ▁ will ▁ create ▁ an ▁ array / virtual ▁ dfn ▁ over ▁ an ▁ inherited ▁ array / virtual ▁ dfn . \n Do ▁ you ▁ want ▁ to ▁ continue ▁ ? " ) ) // ▁ Quit ENDCOM return ; } } // ▁ Get ▁ the ▁ widget ▁ type ENDCOM IFormWidget :: TTypeSrc typeSrc = Widgets [ widget ] -> getSrcType ( ) ; if ( typeSrc == IFormWidget :: TypeForm ) { // ▁ Get ▁ the ▁ value ENDCOM std :: string result ; Widgets [ widget ] -> getValue ( result ) ; // ▁ Document ▁ modified ENDCOM doc -> modify ( new CActionString ( IAction :: FormValue , result . c_str ( ) , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeFormParent ) { // ▁ The ▁ form ENDCOM CForm * form = doc -> getFormPtr ( ) ; // ▁ Build ▁ an ▁ array ▁ of ▁ strings ENDCOM uint count = Widgets [ widget ] -> getNumValue ( ) ; vector < string > stringVector ( count ) ; for ( uint value = 0 ; value < count ; value ++ ) { // ▁ Get ▁ the ▁ result ENDCOM Widgets [ widget ] -> getValue ( stringVector [ value ] , value ) ; } // ▁ Modify ▁ document ENDCOM doc -> modify ( new CActionStringVector ( IAction :: FormParents , stringVector , * doc , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeArray ) { // ▁ Get ▁ the ▁ value ENDCOM std :: string result ; Widgets [ widget ] -> getValue ( result ) ; // ▁ Modify ▁ document ENDCOM doc -> modify ( new CActionBuffer ( IAction :: FormArraySize , NULL , 0 , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , result . c_str ( ) , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeType ) { // ▁ Get ▁ the ▁ result ▁ value ENDCOM std :: string result ; Widgets [ widget ] -> getValue ( result ) ; // ▁ Document ▁ is ▁ modified ▁ by ▁ this ▁ view ENDCOM doc -> modify ( new CActionString ( IAction :: FormTypeValue , result . c_str ( ) , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeVirtualDfn ) { // ▁ Get ▁ the ▁ value ENDCOM std :: string result ; Widgets [ widget ] -> getValue ( result ) ; // ▁ Modify ▁ the ▁ document ENDCOM doc -> modify ( new CActionBuffer ( IAction :: FormVirtualDfnName , NULL , 0 , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , result . c_str ( ) , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } } // ▁ Notify ▁ the ▁ plugin ▁ that ▁ the ▁ value ▁ has ▁ changed ENDCOM if ( ! Widgets [ widget ] -> getFormName ( ) . empty ( ) ) doc -> notifyPlugins ( Widgets [ widget ] -> getFormName ( ) . c_str ( ) ) ; } LRESULT CFormDialog :: WindowProc ( UINT message , WPARAM wParam , LPARAM lParam ) { switch ( message ) { case CL_CHANGED : { uint widgetId = getWidget ( wParam ) ; CColorEdit * colorEdit = safe_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; colorEdit -> Empty = false ; setToDocument ( getWidget ( wParam ) ) ; } break ; case MC_STRINGCHANGE : { setToDocument ( getWidget ( wParam ) ) ; } break ; case CBN_CHANGED : { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { CIconWidget * iconWidget = dynamic_cast < CIconWidget * > ( Widgets [ i ] ) ; if ( iconWidget ) iconWidget -> Icon . Invalidate ( ) ; } } break ; } return CDialog :: WindowProc ( message , wParam , lParam ) ; } void CFormDialog :: onOpenSelected ( ) { // ▁ Get ▁ the ▁ focus ▁ windows ENDCOM for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onOpenSelected ( ) ; /* CFormMemCombo ▁ * combo ▁ = ▁ dynamic _ cast < CFormMemCombo * > ▁ ( Widgets [ i ] ) ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL if ▁ ( combo ) STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL { STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL CString ▁ str ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL combo - > Combo . GetWindowText ▁ ( str ) ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL if ▁ ( combo - > Browse ▁ & & ▁ ( str ▁ ! = ▁ " " ) ) STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL { STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL std : : string ▁ str2 = CPath : : lookup ▁ ( ( const ▁ char * ) str , ▁ false , ▁ false ) ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL if ▁ ( str2 . empty ( ) ) STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL str2 ▁ = ▁ ( const ▁ char * ) str ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL theApp . OpenDocumentFile ▁ ( str2 . c _ str ▁ ( ) ) ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL } STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL } */ } } } CWnd * CFormDialog :: GetNextDlgTabItem ( CWnd * pWndCtl , BOOL bPrevious ) const { return NULL ; } void CFormDialog :: onFirstFocus ( ) { View -> SetFocus ( ) ; WidgetFocused = 0xffffffff ; } void CFormDialog :: onLastFocus ( ) { View -> setFocusLeftView ( ) ; WidgetFocused = 0xffffffff ; } int CFormDialog :: getWidget ( uint dialogId ) const { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> isDialog ( dialogId ) ) return i ; } return - 1 ; } BOOL CFormDialog :: OnCommand ( WPARAM wParam , LPARAM lParam ) { switch ( HIWORD ( wParam ) ) { case CBN_SETFOCUS : { onGetSubFocus ( LOWORD ( wParam ) ) ; } return TRUE ; case EN_SETFOCUS : { onGetSubFocus ( LOWORD ( wParam ) ) ; } return TRUE ; /* case ▁ CBN _ SELENDOK : STRNEWLINE TABSYMBOL TABSYMBOL { STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL // ▁ Look ▁ for ▁ the ▁ widget STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL int ▁ widgetId ▁ = ▁ getWidget ▁ ( LOWORD ( wParam ) ) ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL if ▁ ( widgetId ▁ ! = ▁ - 1 ) STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL setToDocument ▁ ( widgetId ) ; STRNEWLINE TABSYMBOL TABSYMBOL } STRNEWLINE TABSYMBOL TABSYMBOL return ▁ TRUE ; */ case CBN_SELCHANGE : { // ▁ Look ▁ for ▁ the ▁ widget ENDCOM int widgetId = getWidget ( LOWORD ( wParam ) ) ; if ( widgetId != - 1 ) setToDocument ( widgetId ) ; } return TRUE ; case EN_CHANGE : { // ▁ Look ▁ for ▁ the ▁ widget ENDCOM int widgetId = getWidget ( LOWORD ( wParam ) ) ; if ( widgetId != - 1 ) { CColorEdit * colorEdit = dynamic_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; if ( colorEdit ) { CString str ; colorEdit -> Edit . GetWindowText ( str ) ; sint r , g , b ; if ( sscanf ( str , " % d , % d , % d " , & r , & g , & b ) == 3 ) { clamp ( r , 0 , 255 ) ; clamp ( g , 0 , 255 ) ; clamp ( b , 0 , 255 ) ; CRGBA color ( r , g , b ) ; colorEdit -> Color . setColor ( color ) ; if ( r != 255 && g != 255 && b != 255 ) colorEdit -> Empty = false ; } } } } return TRUE ; case BN_CLICKED : { // ▁ Get ▁ the ▁ window ENDCOM int widgetId = getWidget ( LOWORD ( wParam ) ) ; // ▁ Dialog ▁ Pointer ENDCOM if ( widgetId != - 1 ) { if ( ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeForm ) || ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeType ) ) { CFormMemCombo * combo = dynamic_cast < CFormMemCombo * > ( Widgets [ widgetId ] ) ; if ( combo && IsWindow ( combo -> Browse ) ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { // ▁ Get ▁ current ▁ node ENDCOM const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( Widgets [ widgetId ] -> getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( Widgets [ widgetId ] -> getFormName ( ) . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; nlassert ( parentDfn ) ; // ▁ Get ▁ the ▁ current ▁ filename ▁ extension ENDCOM string ext = parentDfn -> getEntry ( indexDfn ) . getFilenameExt ( ) ; // ▁ Build ▁ a ▁ nice ▁ type ▁ name ENDCOM char typeName [ 512 ] ; smprintf ( typeName , 512 , " % s " , strlwr ( ext ) . c_str ( ) ) ; uint i = 0 ; while ( ( typeName [ i ] == ' . ' ) || ( typeName [ i ] == ' * ' ) ) i ++ ; if ( typeName [ i ] ) typeName [ i ] = toupper ( typeName [ i ] ) ; // ▁ Biuld ▁ the ▁ filter ▁ string ENDCOM char filter [ 512 ] ; smprintf ( filter , 512 , " % s ▁ Files ▁ ( % s ) | % s | All ▁ Files ( * . * ) | * . * | " , typeName + i , ext . c_str ( ) , ext . c_str ( ) ) ; // ▁ Open ▁ the ▁ dialog ENDCOM CFileDialog dlgFile ( TRUE , ext . c_str ( ) , ext . c_str ( ) , OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT , filter , theApp . m_pMainWnd ) ; if ( dlgFile . DoModal ( ) == IDOK ) { combo -> Combo . UpdateData ( ) ; combo -> Combo . SetWindowText ( dlgFile . GetFileName ( ) ) ; combo -> Combo . UpdateData ( FALSE ) ; setToDocument ( widgetId ) ; PostMessage ( CBN_CHANGED , 0 , 0 ) ; } } } else { // ▁ Reset ▁ button ▁ of ▁ color ▁ edit ▁ ? ENDCOM CColorEdit * colorEdit = dynamic_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; if ( colorEdit && IsWindow ( colorEdit -> Color ) ) { colorEdit -> Empty = true ; colorEdit -> Edit . SetWindowText ( " " ) ; setToDocument ( getWidget ( wParam ) ) ; updateValues ( ) ; } } } else if ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeVirtualDfn ) { CFormMemCombo * combo = dynamic_cast < CFormMemCombo * > ( Widgets [ widgetId ] ) ; if ( combo && IsWindow ( combo -> Browse ) ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { // ▁ Build ▁ the ▁ filter ▁ string ENDCOM char filter [ 512 ] ; smprintf ( filter , 512 , " Dfn ▁ Files ▁ ( * . dfn ) | * . dfn | All ▁ Files ( * . * ) | * . * | " ) ; // ▁ Open ▁ the ▁ dialog ENDCOM CFileDialog dlgFile ( TRUE , " * . dfn " , " * . dfn " , OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT , filter , theApp . m_pMainWnd ) ; if ( dlgFile . DoModal ( ) == IDOK ) { combo -> Combo . UpdateData ( ) ; combo -> Combo . SetWindowText ( dlgFile . GetFileName ( ) ) ; combo -> Combo . UpdateData ( FALSE ) ; setToDocument ( widgetId ) ; } } } } else if ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeFormParent ) { setToDocument ( widgetId ) ; } } } return TRUE ; } return CWnd :: OnCommand ( wParam , lParam ) ; } BOOL CFormDialog :: OnNotify ( WPARAM wParam , LPARAM lParam , LRESULT * pResult ) { LPNMHDR pnmh = ( LPNMHDR ) lParam ; // ▁ Get ▁ the ▁ CTRL ▁ ID ENDCOM int idCtrl = ( int ) wParam ; switch ( pnmh -> code ) { case NM_SETFOCUS : { onGetSubFocus ( idCtrl ) ; } break ; // ▁ Spinner ▁ control ENDCOM case UDN_DELTAPOS : { // ▁ Get ▁ the ▁ window ENDCOM for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> isDialog ( idCtrl ) ) { // ▁ Get ▁ the ▁ node ▁ type ENDCOM Widgets [ i ] -> getFormName ( ) ; // ▁ Get ▁ the ▁ structure ENDCOM LPNMUPDOWN lpnmud = ( LPNMUPDOWN ) lParam ; // ▁ Get ▁ a ▁ good ▁ pointer ENDCOM CFormMemCombo * combo = ( CFormMemCombo * ) Widgets [ i ] ; // ▁ Get ▁ the ▁ widget ▁ value ENDCOM float value ; CString str ; combo -> Combo . UpdateData ( ) ; combo -> Combo . GetWindowText ( str ) ; if ( sscanf ( str , " % f " , & value ) == 1 ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { // ▁ Get ▁ the ▁ node ENDCOM const CFormDfn * parentDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; uint lastElement ; bool array ; bool parentVDfnArray ; UFormDfn :: TEntryType type ; // ▁ Search ▁ for ▁ the ▁ node ENDCOM nlverify ( ( const CFormElm * ) ( doc -> getRootNode ( Widgets [ i ] -> getSlot ( ) ) ) -> getNodeByName ( Widgets [ i ] -> getFormName ( ) . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; // ▁ Todo : ▁ multiply ▁ here ▁ by ▁ the ▁ spinner ▁ precision ENDCOM float increment = 1 ; if ( nodeType ) sscanf ( nodeType -> Increment . c_str ( ) , " % f " , & increment ) ; value -= ( float ) ( lpnmud -> iDelta ) * increment ; // ▁ Print ▁ the ▁ result ENDCOM char result [ 512 ] ; sprintf ( result , " % g " , value ) ; // ▁ Set ▁ the ▁ windnow ▁ text ENDCOM combo -> Combo . SetWindowText ( result ) ; combo -> Combo . UpdateData ( FALSE ) ; // ▁ Update ▁ the ▁ widget ENDCOM setToDocument ( i ) ; } } break ; } } } break ; } return CDialog :: OnNotify ( wParam , lParam , pResult ) ; } void CFormDialog :: resizeWidgets ( ) { if ( Widgets . size ( ) ) { RECT viewRect ; View -> GetClientRect ( & viewRect ) ; uint virtualWidth = std :: max ( ( uint ) MinViewWidth , ( uint ) ( viewRect . right - viewRect . left ) ) ; // ▁ Refresh ▁ sizes ENDCOM CBaseDialog :: resizeWidgets ( virtualWidth , 0 ) ; // ▁ Get ▁ first ▁ item ▁ coordinate ENDCOM RECT currentPos ; getFirstItemPos ( currentPos ) ; // ▁ For ▁ each ▁ widgets ENDCOM uint bigWidgetCount [ 2 ] = { 0 , 0 } ; uint i ; uint biggestBottom [ 2 ] = { 0 , 0 } ; uint nextSplit = Widgets . size ( ) / 2 ; for ( i = 0 ; i < Widgets . size ( ) ; i ++ ) { uint column = ( i > nextSplit ) ? 1 : 0 ; Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , 0 , false ) ; if ( currentPos . bottom > ( int ) biggestBottom [ column ] ) { biggestBottom [ column ] = currentPos . bottom ; } if ( nextSplit == i ) { getNextColumn ( currentPos ) ; currentPos . top = 0 ; } } // ▁ Refresh ▁ sizes ENDCOM uint adjust [ 2 ] ; CBaseDialog :: resizeWidgets ( virtualWidth , biggestBottom [ 0 ] ) ; adjust [ 0 ] = AdjusteHeight ; CBaseDialog :: resizeWidgets ( virtualWidth , biggestBottom [ 1 ] ) ; adjust [ 1 ] = AdjusteHeight ; // ▁ Get ▁ first ▁ item ▁ coordinate ENDCOM currentPos ; getFirstItemPos ( currentPos ) ; uint adjustSum [ 2 ] = { bigWidgetCount [ 0 ] ? adjust [ 0 ] / bigWidgetCount [ 0 ] : 0 , bigWidgetCount [ 1 ] ? adjust [ 1 ] / bigWidgetCount [ 1 ] : 0 } ; biggestBottom [ 0 ] = 0 ; biggestBottom [ 1 ] = 0 ; for ( i = 0 ; i < Widgets . size ( ) - 1 ; i ++ ) { uint column = ( i > nextSplit ) ? 1 : 0 ; if ( Widgets [ i ] -> extendableHeight ( ) ) { Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , adjustSum [ column ] , true ) ; adjust [ column ] -= adjustSum [ column ] ; } else Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , 0 , true ) ; if ( currentPos . bottom > ( int ) biggestBottom [ column ] ) { biggestBottom [ column ] = currentPos . bottom ; } if ( nextSplit == i ) { getNextColumn ( currentPos ) ; currentPos . top = 0 ; } } uint column = ( i > nextSplit ) ? 1 : 0 ; Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , adjust [ column ] , true ) ; if ( currentPos . bottom > ( int ) biggestBottom [ column ] ) { biggestBottom [ column ] = currentPos . bottom ; } // ▁ Resize ▁ the ▁ current ▁ view ENDCOM View -> setViewSize ( virtualWidth , std :: max ( biggestBottom [ 0 ] , biggestBottom [ 1 ] ) + CGeorgesEditView :: WidgetTopMargin + CGeorgesEditView :: WidgetBottomMargin ) ; } } void CFormDialog :: getFromDocument ( ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { // ▁ Save ▁ current ▁ focus ENDCOM uint widgetFocus ; for ( widgetFocus = 0 ; widgetFocus < Widgets . size ( ) ; widgetFocus ++ ) { if ( Widgets [ widgetFocus ] -> haveFocus ( ) ) break ; } // ▁ Current ▁ selection ENDCOM CGeorgesEditDocSub * subObject = doc -> getSelectedObject ( ) ; // ▁ Get ▁ the ▁ node ENDCOM const CFormDfn * parentDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; uint lastElement ; bool array ; bool parentVDfnArray ; UFormDfn :: TEntryType type ; // ▁ Search ▁ for ▁ the ▁ node ENDCOM nlverify ( ( ( const CFormElm * ) ( doc -> getRootNode ( subObject -> getSlot ( ) ) ) ) -> getNodeByName ( subObject -> getFormName ( ) . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; // ▁ Should ▁ have ▁ a ▁ parent ▁ DFN , ▁ else ▁ it ▁ is ▁ the ▁ root ▁ element ENDCOM if ( parentDfn ) { // ▁ Is ▁ an ▁ array ▁ ? ENDCOM if ( array ) { // ▁ Must ▁ be ▁ a ▁ dfn ENDCOM nlassert ( ( type == UFormDfn :: EntryDfn ) || ( type == UFormDfn :: EntryType ) ) ; getArrayFromDocument ( subObject -> getFormName ( ) . c_str ( ) , lastElement , subObject -> getSlot ( ) ) ; } else { // ▁ Is ▁ a ▁ struct ▁ ? ENDCOM switch ( parentDfn -> getEntry ( lastElement ) . getType ( ) ) { // ▁ Type ENDCOM case UFormDfn :: EntryType : nlassert ( ! array ) ; nlassert ( nodeType ) ; nlassert ( parentDfn ) ; nlassert ( type == UFormDfn :: EntryType ) ; getTypeFromDocument ( * nodeType , ( parentDfn -> getEntry ( lastElement ) . getName ( ) + " : " ) . c_str ( ) , parentDfn -> getEntry ( lastElement ) . getFilename ( ) . c_str ( ) , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; break ; // ▁ Dfn ENDCOM case UFormDfn :: EntryDfn : nlassert ( ! array ) ; nlassert ( ( nodeDfn ) && ( type == UFormDfn :: EntryDfn ) ) ; getDfnFromDocument ( * nodeDfn , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; break ; // ▁ Virtual ▁ Dfn ENDCOM case UFormDfn :: EntryVirtualDfn : nlassert ( ! array ) ; getVirtualDfnFromDocument ( nodeDfn , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; break ; } } } else { nlassert ( ! array ) ; nlassert ( ( nodeDfn ) && ( type == UFormDfn :: EntryDfn ) ) ; getDfnFromDocument ( * nodeDfn , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; } // ▁ Update ▁ labels ENDCOM for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { // ▁ Update ▁ labels ENDCOM Widgets [ i ] -> updateLabel ( ) ; } // ▁ Set ▁ the ▁ focus ENDCOM if ( widgetFocus < Widgets . size ( ) ) { Widgets [ widgetFocus ] -> setFocus ( ) ; } // ▁ Resize ▁ the ▁ widgets ENDCOM resizeWidgets ( ) ; } } void CFormDialog :: getDfnName ( string & result ) const { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { // ▁ Get ▁ the ▁ DFN ▁ filename ENDCOM CString str = doc -> GetPathName ( ) ; char extension [ 512 ] ; _splitpath ( str , NULL , NULL , NULL , extension ) ; result = ( * extension == ' . ' ) ? extension + 1 : extension ; } else result = " " ; } void CFormDialog :: OnLButtonDown ( UINT nFlags , CPoint point ) { // ▁ Get ▁ the ▁ focus ENDCOM View -> TabCtrl . SetFocus ( ) ; CDialog :: OnLButtonDown ( nFlags , point ) ; } void CFormDialog :: onGetSubFocus ( uint id ) { // ▁ Get ▁ the ▁ widget ENDCOM int widget = getWidget ( id ) ; WidgetFocused = widget ; // ▁ Window ▁ view ENDCOM RECT widgetRect ; if ( Widgets [ widget ] -> getWindowRect ( widgetRect ) ) { View -> ScreenToClient ( & widgetRect ) ; // ▁ Scroll ▁ the ▁ view ▁ to ▁ be ▁ visible ENDCOM RECT viewRect ; View -> GetClientRect ( & viewRect ) ; int bottom = viewRect . bottom - viewRect . top ; if ( widgetRect . bottom > bottom ) { CPoint pt = View -> GetScrollPosition ( ) ; View -> ScrollToPosition ( CPoint ( pt . x , pt . y + widgetRect . bottom - bottom + 10 ) ) ; } if ( widgetRect . top < 0 ) { CPoint pt = View -> GetScrollPosition ( ) ; View -> ScrollToPosition ( CPoint ( pt . x , pt . y + widgetRect . top - 10 ) ) ; } } } void CFormDialog :: OnSetFocus ( CWnd * pNewWnd ) { CDialog :: OnSetFocus ( pNewWnd ) ; if ( WidgetFocused != 0xffffffff ) Widgets [ WidgetFocused ] -> setFocus ( ) ; } void CFormDialog :: OnKillFocus ( CWnd * pNewWnd ) { CDialog :: OnKillFocus ( pNewWnd ) ; } // ▁ IFormWidget ENDCOM IFormWidget :: IFormWidget ( CFormDialog * dialog , uint structId , const char * atomName , TTypeSrc typeSrc , uint slot ) { FormName = atomName ; Dialog = dialog ; StructId = structId ; SrcType = typeSrc ; Slot = slot ; } bool IFormWidget :: isDialog ( uint id ) const { return ( id >= FirstId ) && ( id <= LastId ) ; } ; uint IFormWidget :: getSlot ( ) const { return Slot ; } ; uint IFormWidget :: getStructId ( ) const { return StructId ; } void IFormWidget :: updateLabel ( ) { // ▁ Does ▁ the ▁ node ▁ in ▁ the ▁ same ▁ form ▁ ? ENDCOM CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; if ( doc ) { // ▁ Is ▁ the ▁ label ▁ a ▁ window ▁ ? ENDCOM if ( IsWindow ( Label ) ) { // ▁ No ▁ label ▁ for ▁ parent ▁ widget ENDCOM if ( SrcType != TypeFormParent ) { // ▁ Value ▁ type ▁ ? ENDCOM if ( ( SrcType == TypeForm ) || ( SrcType == TypeType ) ) { // ▁ Get ▁ the ▁ value ENDCOM std :: string result ; UFormElm :: TWhereIsValue where ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , & where ) ) ; // ▁ Get ▁ the ▁ value ▁ evaluated ENDCOM std :: string resultEvaluated ; # ifdef TEST_EVAL_FORMULA bool error = ! elm -> getValueByName ( resultEvaluated , FormName . c_str ( ) , UFormElm :: Formula , & where ) ; # else // ▁ TEST _ EVAL _ FORMULA ENDCOM bool error = ! elm -> getValueByName ( resultEvaluated , FormName . c_str ( ) , UFormElm :: Eval , & where ) ; # endif // ▁ TEST _ EVAL _ FORMULA ENDCOM // ▁ Complete ▁ the ▁ array ▁ ? ENDCOM string comp ; if ( error ) comp = " ▁ ( Value ▁ = ▁ Error ) " ; else { if ( resultEvaluated != result ) comp = " ▁ ( Value ▁ = ▁ \ " " + resultEvaluated + " \ " ) " ; } // ▁ Does ▁ the ▁ node ▁ exist ▁ ? ENDCOM switch ( where ) { case UFormElm :: ValueForm : Label . SetWindowText ( ( SavedLabel + comp ) . c_str ( ) ) ; break ; case UFormElm :: ValueParentForm : Label . SetWindowText ( ( SavedLabel + " ▁ ( in ▁ parent ▁ form ) " + comp ) . c_str ( ) ) ; break ; case UFormElm :: ValueDefaultDfn : Label . SetWindowText ( ( SavedLabel + " ▁ ( default ▁ DFN ▁ value ) " + comp ) . c_str ( ) ) ; break ; case UFormElm :: ValueDefaultType : Label . SetWindowText ( ( SavedLabel + " ▁ ( default ▁ TYPE ▁ value ) " + comp ) . c_str ( ) ) ; break ; } } else { // ▁ Get ▁ the ▁ node ENDCOM const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( FormName . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; // ▁ Does ▁ the ▁ node ▁ exist ▁ ? ENDCOM if ( node ) { // ▁ Same ▁ form ▁ ? ENDCOM if ( node -> getForm ( ) == doc -> getFormPtr ( ) ) { // ▁ The ▁ node ▁ exist ENDCOM Label . SetWindowText ( SavedLabel . c_str ( ) ) ; } else { // ▁ The ▁ node ▁ exist ▁ in ▁ the ▁ parent ▁ form ENDCOM Label . SetWindowText ( ( SavedLabel + " ▁ ( in ▁ parent ▁ form ) " ) . c_str ( ) ) ; } } else { // ▁ The ▁ node ▁ is ▁ empty ENDCOM Label . SetWindowText ( ( SavedLabel + " ▁ ( undefined ) " ) . c_str ( ) ) ; } } // ▁ Update ▁ widget ENDCOM Label . UpdateData ( FALSE ) ; } } } } IFormWidget :: TTypeSrc IFormWidget :: getSrcType ( ) const { return SrcType ; } bool IFormWidget :: extendableHeight ( ) const { return false ; } bool IFormWidget :: getNode ( const CFormDfn * * parentDfn , uint & lastElement , const CFormDfn * * nodeDfn , const CType * * nodeType , CFormElm * * node , UFormDfn :: TEntryType & type , bool & array ) const { // ▁ Get ▁ the ▁ document ENDCOM CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; if ( doc ) { // ▁ Return ▁ the ▁ node ENDCOM bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; return ( elm -> getNodeByName ( FormName . c_str ( ) , parentDfn , lastElement , nodeDfn , nodeType , node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; } return false ; } CFormElm * IFormWidget :: getFormElmNode ( ) const { const CFormDfn * parentDfn ; uint parentDfnIndex ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; if ( getNode ( & parentDfn , parentDfnIndex , & nodeDfn , & nodeType , & node , type , array ) ) { return node ; } return NULL ; } CFormElmStruct * IFormWidget :: getFormElmStructNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmStruct * > ( elm ) : NULL ; } CFormElmVirtualStruct * IFormWidget :: getFormElmVirtualStructNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmVirtualStruct * > ( elm ) : NULL ; } CFormElmArray * IFormWidget :: getFormElmArrayNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmArray * > ( elm ) : NULL ; } CFormElmAtom * IFormWidget :: getFormElmAtomNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmAtom * > ( elm ) : NULL ; } const string & IFormWidget :: getFormName ( ) const { return FormName ; } uint IFormWidget :: getNumValue ( ) { // ▁ Not ▁ implemented ▁ for ▁ this ▁ widget ENDCOM nlstop ; return 0 ; } void IFormWidget :: getValue ( std :: string & result ) { // ▁ Not ▁ implemented ▁ for ▁ this ▁ widget ENDCOM nlstop ; } void IFormWidget :: getValue ( std :: string & result , uint value ) { // ▁ Not ▁ implemented ▁ for ▁ this ▁ widget ENDCOM nlstop ; } bool IFormWidget :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Label ) ) { Label . GetWindowRect ( & rect ) ; return true ; } else return false ; } void IFormWidget :: onOpenSelected ( ) { string str ; getValue ( str ) ; std :: string str2 = CPath :: lookup ( str . c_str ( ) , false , false ) ; if ( str2 . empty ( ) ) str2 = str . c_str ( ) ; theApp . OpenDocumentFile ( str2 . c_str ( ) ) ; } // ▁ CFormMemCombo ENDCOM CFormMemCombo :: CFormMemCombo ( CFormDialog * dialog , uint structId , const char * atomName , TTypeSrc typeSrc , uint slot ) : IFormWidget ( dialog , structId , atomName , typeSrc , slot ) { UseSpinner = false ; FileBrowser = false ; } CFormMemCombo :: ~ CFormMemCombo ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Combo ) ) Combo . DestroyWindow ( ) ; if ( IsWindow ( Spin ) ) Spin . DestroyWindow ( ) ; if ( IsWindow ( Browse ) ) Browse . DestroyWindow ( ) ; } void CFormMemCombo :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label , const char * reg , bool useSpinner , bool fileBrowser , const char * filenameExt ) { // ▁ Get ▁ the ▁ doc ENDCOM CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; // ▁ Get ▁ the ▁ node ▁ type ▁ ( if ▁ any ) ENDCOM const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType = NULL ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( FormName . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; FirstId = dialog_index ; LastId = FirstId + 1 ; // ▁ Save ▁ the ▁ label ▁ ENDCOM SavedLabel = label ; // ▁ Create ▁ the ▁ type ▁ combo ENDCOM parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; UseSpinner = useSpinner ; FileBrowser = fileBrowser ; // ▁ Create ▁ the ▁ spinner ENDCOM if ( useSpinner ) { // ▁ Create ▁ the ▁ mem ▁ combobox ENDCOM parent -> setComboSpinSize ( currentPos ) ; Combo . create ( WS_CHILD | WS_TABSTOP , currentPos , parent , dialog_index , reg , theApp . RememberListSize ) ; parent -> initWidget ( Combo ) ; // ▁ Create ▁ the ▁ spin ENDCOM RECT spinPos = currentPos ; parent -> getNextSpinPos ( spinPos ) ; parent -> setSpinSize ( spinPos ) ; Spin . Create ( WS_CHILD | WS_VISIBLE , spinPos , parent , dialog_index + 1 ) ; // Spin . SetBuddy ▁ ( & Combo . ComboBox ) ; ENDCOM parent -> getNextPos ( currentPos ) ; } else if ( fileBrowser ) { // ▁ Create ▁ the ▁ mem ▁ combobox ENDCOM parent -> setComboBrowseSize ( currentPos ) ; Combo . create ( WS_CHILD | WS_TABSTOP , currentPos , parent , dialog_index , reg , theApp . RememberListSize ) ; parent -> initWidget ( Combo ) ; // ▁ Create ▁ the ▁ spin ENDCOM RECT spinPos = currentPos ; parent -> getNextBrowsePos ( spinPos ) ; parent -> setBrowseSize ( spinPos ) ; Browse . Create ( " . . . " , WS_CHILD | WS_VISIBLE | WS_TABSTOP , spinPos , parent , dialog_index + 1 ) ; parent -> initWidget ( Browse ) ; parent -> getNextPos ( currentPos ) ; // ▁ Set ▁ autocomplete ▁ mode ENDCOM if ( filenameExt ) { if ( strcmp ( filenameExt , " * . * " ) != 0 ) Combo . enableAutoCompleteExtension ( true , filenameExt ) ; } } else { // ▁ Create ▁ the ▁ mem ▁ combobox ENDCOM parent -> setComboSize ( currentPos , parent -> SmallWidget ) ; Combo . create ( WS_CHILD | WS_TABSTOP , currentPos , parent , dialog_index , reg , theApp . RememberListSize ) ; parent -> initWidget ( Combo ) ; parent -> getNextPos ( currentPos ) ; } // ▁ Get ▁ predefs ENDCOM if ( nodeType ) { for ( uint predef = 0 ; predef < nodeType -> Definitions . size ( ) ; predef ++ ) { Combo . addStaticStrings ( nodeType -> Definitions [ predef ] . Label . c_str ( ) ) ; } } dialog_index += 2 ; } void CFormMemCombo :: updateData ( bool update ) { Combo . UpdateData ( update ? TRUE : FALSE ) ; } bool CFormMemCombo :: haveFocus ( ) { return ( Combo . haveFocus ( ) ) ; } void CFormMemCombo :: setFocus ( ) { Combo . SetFocus ( ) ; } void CFormMemCombo :: onOk ( ) { Combo . onOK ( ) ; } void CFormMemCombo :: getValue ( std :: string & result ) { Combo . UpdateData ( ) ; CString str ; Combo . GetWindowText ( str ) ; Combo . UpdateData ( FALSE ) ; // ▁ Set ▁ the ▁ atom ▁ value ENDCOM result = ( const char * ) str ; } void CFormMemCombo :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; if ( ( SrcType == TypeForm ) || ( SrcType == TypeType ) ) { string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Combo . UpdateData ( ) ; Combo . SetWindowText ( result . c_str ( ) ) ; Combo . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } else if ( SrcType == TypeArray ) { const CFormDfn * parentDfn ; uint lastElement ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; nlverify ( ( ( const CFormElm * ) doc -> getRootNode ( getSlot ( ) ) ) -> getNodeByName ( FormName . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; nlassert ( array ) ; // ▁ Node ▁ exist ▁ ? ENDCOM Combo . UpdateData ( ) ; if ( node ) { CFormElmArray * arrayNode = safe_cast < CFormElmArray * > ( node ) ; char label [ 512 ] ; smprintf ( label , 512 , " % d " , arrayNode -> Elements . size ( ) ) ; Combo . SetWindowText ( label ) ; if ( arrayNode -> getForm ( ) == & form ) Label . SetWindowText ( " Array ▁ size : " ) ; else Label . SetWindowText ( " Array ▁ size : ▁ ( in ▁ parent ▁ form ) " ) ; } else { Combo . SetWindowText ( "0" ) ; } Combo . UpdateData ( FALSE ) ; } else if ( SrcType == TypeVirtualDfn ) { const CFormDfn * parentDfn ; uint lastElement ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; nlverify ( ( ( const CFormElm * ) doc -> getRootNode ( getSlot ( ) ) ) -> getNodeByName ( FormName . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; nlassert ( ! array ) ; // ▁ Node ▁ exist ▁ ? ENDCOM Combo . UpdateData ( ) ; if ( node ) { CFormElmVirtualStruct * virtualNode = safe_cast < CFormElmVirtualStruct * > ( node ) ; Combo . SetWindowText ( virtualNode -> DfnFilename . c_str ( ) ) ; } else { Combo . SetWindowText ( " " ) ; } Combo . UpdateData ( FALSE ) ; } } bool CFormMemCombo :: isWnd ( const CWnd * wnd ) const { return Combo . isWnd ( wnd ) ; } void CFormMemCombo :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { // ▁ Create ▁ the ▁ type ▁ combo ENDCOM Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; // ▁ Create ▁ the ▁ spinner ENDCOM if ( UseSpinner ) { // ▁ Create ▁ the ▁ mem ▁ combobox ENDCOM Dialog -> setComboSpinSize ( currentPos ) ; if ( resize ) { Combo . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } // ▁ Create ▁ the ▁ spin ENDCOM RECT spinPos = currentPos ; Dialog -> getNextSpinPos ( spinPos ) ; Dialog -> setSpinSize ( spinPos ) ; if ( resize ) { Spin . SetWindowPos ( NULL , spinPos . left , spinPos . top , spinPos . right - spinPos . left , spinPos . bottom - spinPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } } else if ( FileBrowser ) { // ▁ Create ▁ the ▁ mem ▁ combobox ENDCOM Dialog -> setComboBrowseSize ( currentPos ) ; if ( resize ) { Combo . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } // ▁ Create ▁ the ▁ spin ENDCOM RECT spinPos = currentPos ; Dialog -> getNextBrowsePos ( spinPos ) ; Dialog -> setBrowseSize ( spinPos ) ; if ( resize ) { Browse . SetWindowPos ( NULL , spinPos . left , spinPos . top , spinPos . right - spinPos . left , spinPos . bottom - spinPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } } else { // ▁ Create ▁ the ▁ mem ▁ combobox ENDCOM Dialog -> setComboSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { Combo . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } } Dialog -> getNextPos ( currentPos ) ; } bool CFormMemCombo :: getWindowRect ( RECT & rect ) const { if ( Combo ) { // ▁ Get ▁ parent ▁ rect ENDCOM RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; // ▁ Add ▁ my ▁ rect ENDCOM RECT myRect ; Combo . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } // ▁ CFormCombo ENDCOM CFormCombo :: CFormCombo ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { } CFormCombo :: ~ CFormCombo ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Combo ) ) Combo . DestroyWindow ( ) ; } void CFormCombo :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { // ▁ Get ▁ the ▁ doc ENDCOM CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; FirstId = dialog_index ; LastId = FirstId ; // ▁ Get ▁ the ▁ value ▁ for ▁ the ▁ type ▁ pointer ▁ ( if ▁ any ) ENDCOM const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( FormName . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; // ▁ Save ▁ the ▁ label ▁ ENDCOM SavedLabel = label ; // ▁ Create ▁ the ▁ type ▁ combo ENDCOM parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; // ▁ Create ▁ the ▁ mem ▁ combobox ENDCOM parent -> setComboSize ( currentPos , parent -> SmallWidget ) ; RECT comboPos = currentPos ; parent -> adjusteComboSize ( comboPos ) ; Combo . Create ( WS_CHILD | WS_VSCROLL | WS_VISIBLE | CBS_DROPDOWNLIST | CBS_HASSTRINGS | WS_CHILD | WS_TABSTOP , comboPos , parent , dialog_index ) ; parent -> initWidget ( Combo ) ; parent -> getNextPos ( currentPos ) ; // ▁ Get ▁ predefs ENDCOM if ( nodeType ) { Combo . InsertString ( 0 , " " ) ; for ( uint predef = 0 ; predef < nodeType -> Definitions . size ( ) ; predef ++ ) { Combo . InsertString ( predef + 1 , nodeType -> Definitions [ predef ] . Label . c_str ( ) ) ; } } dialog_index += 1 ; } void CFormCombo :: updateData ( bool update ) { Combo . UpdateData ( update ? TRUE : FALSE ) ; } bool CFormCombo :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Combo ) ; } return false ; } void CFormCombo :: setFocus ( ) { Combo . SetFocus ( ) ; } void CFormCombo :: onOk ( ) { // Combo . onOK ▁ ( ) ; ENDCOM } void CFormCombo :: getValue ( std :: string & result ) { Combo . UpdateData ( ) ; CString str ; Combo . GetWindowText ( str ) ; Combo . UpdateData ( FALSE ) ; // ▁ Set ▁ the ▁ atom ▁ value ENDCOM result = ( const char * ) str ; } void CFormCombo :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Combo . UpdateData ( ) ; uint itemCount = Combo . GetCount ( ) ; for ( uint i = 0 ; i < itemCount ; i ++ ) { CString item ; Combo . GetLBText ( i , item ) ; if ( item == result . c_str ( ) ) { Combo . SetCurSel ( i ) ; break ; } } Combo . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } bool CFormCombo :: isWnd ( const CWnd * wnd ) const { return & Combo == ( const CWnd * ) wnd ; } void CFormCombo :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { // ▁ Create ▁ the ▁ type ▁ combo ENDCOM Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; // ▁ Create ▁ the ▁ mem ▁ combobox ENDCOM Dialog -> setComboSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { RECT comboPos = currentPos ; Dialog -> adjusteComboSize ( comboPos ) ; Combo . SetWindowPos ( NULL , comboPos . left , comboPos . top , comboPos . right - comboPos . left , comboPos . bottom - comboPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CFormCombo :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Combo ) ) { // ▁ Get ▁ parent ▁ rect ENDCOM RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; // ▁ Add ▁ my ▁ rect ENDCOM RECT myRect ; Combo . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } // ▁ CFormBigEdit ENDCOM CFormBigEdit :: CFormBigEdit ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { } CFormBigEdit :: ~ CFormBigEdit ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Edit ) ) Edit . DestroyWindow ( ) ; } void CFormBigEdit :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { FirstId = dialog_index ; LastId = FirstId ; // ▁ Save ▁ the ▁ label ▁ ENDCOM SavedLabel = label ; // ▁ Create ▁ the ▁ type ▁ combo ENDCOM parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; // ▁ Create ▁ the ▁ mem ▁ combobox ENDCOM parent -> setBigEditSize ( currentPos , parent -> SmallWidget ) ; Edit . CreateEx ( WS_EX_CLIENTEDGE , _T ( " EDIT " ) , " " , WS_VSCROLL | ES_OEMCONVERT | ES_MULTILINE | ES_WANTRETURN | WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_AUTOHSCROLL | ES_AUTOVSCROLL , currentPos , parent , dialog_index ) ; parent -> initWidget ( Edit ) ; parent -> getNextPos ( currentPos ) ; dialog_index += 1 ; } void CFormBigEdit :: updateData ( bool update ) { Edit . UpdateData ( update ? TRUE : FALSE ) ; } bool CFormBigEdit :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Edit ) ; } return false ; } void CFormBigEdit :: setFocus ( ) { Edit . SetFocus ( ) ; } void CFormBigEdit :: onOk ( ) { // Combo . onOK ▁ ( ) ; ENDCOM } void CFormBigEdit :: getValue ( std :: string & result ) { Edit . UpdateData ( ) ; CString str ; Edit . GetWindowText ( str ) ; Edit . UpdateData ( FALSE ) ; // ▁ Set ▁ the ▁ atom ▁ value ENDCOM result = ( const char * ) str ; } void CFormBigEdit :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Edit . UpdateData ( ) ; Dialog -> setEditTextMultiLine ( Edit , result . c_str ( ) ) ; Edit . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } bool CFormBigEdit :: isWnd ( const CWnd * wnd ) const { return & Edit == wnd ; } void CFormBigEdit :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { if ( ! resize ) widgetCount ++ ; // ▁ Create ▁ the ▁ type ▁ combo ENDCOM Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; // ▁ Create ▁ the ▁ mem ▁ combobox ENDCOM Dialog -> setBigEditSize ( currentPos , Dialog -> SmallWidgetNotLimited , Dialog -> BigEditHeight + adjust ) ; if ( resize ) { Edit . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CFormBigEdit :: extendableHeight ( ) const { return true ; } bool CFormBigEdit :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Edit ) ) { // ▁ Get ▁ parent ▁ rect ENDCOM RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; // ▁ Add ▁ my ▁ rect ENDCOM RECT myRect ; Edit . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } // ▁ CColorEdit ENDCOM CColorEdit :: CColorEdit ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { Empty = true ; } CColorEdit :: ~ CColorEdit ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Color ) ) Color . DestroyWindow ( ) ; if ( IsWindow ( Edit ) ) Edit . DestroyWindow ( ) ; } void CColorEdit :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { FirstId = dialog_index ; LastId = FirstId + 2 ; // ▁ Save ▁ the ▁ label ▁ ENDCOM SavedLabel = label ; // ▁ Create ▁ the ▁ type ▁ combo ENDCOM parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; // ▁ Create ▁ the ▁ mem ▁ combobox ENDCOM parent -> setColorSize ( currentPos , parent -> SmallWidget ) ; Color . create ( WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index ) ; parent -> initWidget ( Color ) ; // ▁ Create ▁ the ▁ reset ▁ button ENDCOM RECT resetPos = currentPos ; parent -> getNextColorPos ( resetPos ) ; parent -> setResetColorSize ( resetPos ) ; Reset . Create ( " Reset " , WS_CHILD | WS_VISIBLE | WS_TABSTOP , resetPos , parent , dialog_index + 1 ) ; parent -> initWidget ( Reset ) ; parent -> getNextPosLabel ( currentPos ) ; // ▁ Create ▁ the ▁ Edit ENDCOM parent -> setBigEditSize ( currentPos , parent -> SmallWidget ) ; Edit . CreateEx ( WS_EX_CLIENTEDGE , _T ( " EDIT " ) , " " , ES_OEMCONVERT | ES_WANTRETURN | WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_AUTOHSCROLL , currentPos , parent , dialog_index + 2 ) ; parent -> initWidget ( Edit ) ; parent -> getNextPos ( currentPos ) ; Color . setEdit ( & Edit ) ; dialog_index += 3 ; } void CColorEdit :: updateData ( bool update ) { Color . UpdateData ( update ? TRUE : FALSE ) ; Edit . UpdateData ( update ? TRUE : FALSE ) ; } bool CColorEdit :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Color ) ; } return false ; } void CColorEdit :: setFocus ( ) { Color . SetFocus ( ) ; } void CColorEdit :: onOk ( ) { // ▁ Color . onOk ▁ ( ) ; ENDCOM } void CColorEdit :: getValue ( std :: string & result ) { if ( ! Empty ) { Color . UpdateData ( ) ; // ▁ Get ▁ the ▁ color ENDCOM CRGBA color = Color . getColor ( ) ; // ▁ Make ▁ a ▁ string ENDCOM char colorName [ 512 ] ; smprintf ( colorName , 512 , " % d , % d , % d " , color . R , color . G , color . B ) ; // ▁ Set ▁ the ▁ atom ▁ value ENDCOM result = colorName ; } else { result = " " ; } } void CColorEdit :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Color . UpdateData ( ) ; // ▁ Make ▁ a ▁ color ENDCOM sint r , g , b ; if ( sscanf ( result . c_str ( ) , " % d , % d , % d " , & r , & g , & b ) == 3 ) { clamp ( r , 0 , 255 ) ; clamp ( g , 0 , 255 ) ; clamp ( b , 0 , 255 ) ; CRGBA color ( r , g , b ) ; Color . setColor ( color ) ; if ( r != 255 && g != 255 && b != 255 ) Color . updateEdit ( ) ; } else { Color . setColor ( CRGBA :: Black ) ; Color . updateEdit ( ) ; } Color . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } bool CColorEdit :: isWnd ( const CWnd * wnd ) const { return & Color == wnd ; } void CColorEdit :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { // ▁ Create ▁ the ▁ type ▁ combo ENDCOM Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; // ▁ Create ▁ the ▁ mem ▁ combobox ENDCOM Dialog -> setColorSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { Color . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } // ▁ Create ▁ the ▁ spin ENDCOM RECT resetPos = currentPos ; Dialog -> getNextColorPos ( resetPos ) ; Dialog -> setResetColorSize ( resetPos ) ; if ( resize ) { Reset . SetWindowPos ( NULL , resetPos . left , resetPos . top , resetPos . right - resetPos . left , resetPos . bottom - resetPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; // ▁ Create ▁ the ▁ Edit ENDCOM Dialog -> setEditSize ( currentPos , Dialog -> SmallWidget , Dialog -> EditHeight ) ; if ( resize ) { Edit . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CColorEdit :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Color ) ) { // ▁ Get ▁ parent ▁ rect ENDCOM RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; // ▁ Add ▁ my ▁ rect ENDCOM RECT myRect ; Color . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } // ▁ CListWidget ENDCOM CListWidget :: CListWidget ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { ListCtrl . Ctrl = this ; } CListWidget :: ~ CListWidget ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( ListCtrl ) ) ListCtrl . DestroyWindow ( ) ; if ( IsWindow ( Button ) ) Button . DestroyWindow ( ) ; } void CListWidget :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label , const char * reg , uint divid ) { FirstId = dialog_index ; LastId = FirstId + 1 ; Divid = divid ; RegAdr = reg ; // ▁ Save ▁ the ▁ label ▁ ENDCOM SavedLabel = label ; // ▁ Create ▁ the ▁ type ▁ combo ENDCOM parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; // ▁ Create ▁ the ▁ mem ▁ combobox ENDCOM parent -> setListSize ( currentPos , parent -> SmallWidget ) ; ListCtrl . create ( WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index ) ; parent -> initWidget ( ListCtrl ) ; parent -> getNextPos ( currentPos ) ; // ▁ Create ▁ the ▁ assign ▁ parent ENDCOM parent -> setButtonSize ( currentPos , parent -> SmallWidget ) ; Button . Create ( " Assign ▁ parents " , WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index + 1 ) ; parent -> initWidget ( Button ) ; parent -> getNextPos ( currentPos ) ; dialog_index += 2 ; } void CListWidget :: addColumn ( const char * name ) { ListCtrl . insertColumn ( 0 , name ) ; ListCtrl . recalcColumn ( ) ; } void CListWidget :: onOk ( ) { ListCtrl . onOK ( ) ; } void CListWidget :: updateData ( bool update ) { ListCtrl . UpdateData ( update ) ; } bool CListWidget :: haveFocus ( ) { CWnd * wnd = Dialog -> GetFocus ( ) ; if ( wnd ) { return ( wnd -> GetParent ( ) == & ListCtrl ) ; } return false ; } void CListWidget :: setFocus ( ) { ListCtrl . SetFocus ( ) ; } void CListWidget :: getFromDocument ( NLGEORGES :: CForm & form ) { // ▁ Erase ▁ the ▁ list ENDCOM ListCtrl . ListCtrl . DeleteAllItems ( ) ; // ▁ For ▁ each ▁ parent ENDCOM for ( uint parent = 0 ; parent < form . getParentCount ( ) ; parent ++ ) { // ▁ Get ▁ the ▁ parent ▁ filename ENDCOM string filename = form . getParentFilename ( parent ) ; // ▁ Insert ▁ in ▁ the ▁ list ENDCOM ListCtrl . ListCtrl . InsertItem ( parent , filename . c_str ( ) ) ; ListCtrl . ListCtrl . UpdateData ( FALSE ) ; updateLabel ( ) ; } } uint CListWidget :: getNumValue ( ) { return ListCtrl . ListCtrl . GetItemCount ( ) ; } void CListWidget :: getValue ( std :: string & result , uint value ) { CString str = ListCtrl . ListCtrl . GetItemText ( value , 0 ) ; result = str ; } bool CListWidget :: isWnd ( const CWnd * wnd ) const { return ( ( ( & ListCtrl ) == wnd ) || ( ( & ListCtrl . ListCtrl ) == wnd ) ) ; } void CListWidget :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { if ( ! resize ) widgetCount ++ ; // ▁ Create ▁ the ▁ type ▁ combo ENDCOM Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; // ▁ Create ▁ the ▁ mem ▁ combobox ENDCOM Dialog -> setListSize ( currentPos , Dialog -> SmallWidgetNotLimited / Divid , Dialog -> ListHeight + adjust ) ; if ( resize ) { ListCtrl . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; ListCtrl . recalcColumn ( ) ; } Dialog -> getNextPos ( currentPos ) ; // ▁ Create ▁ the ▁ mem ▁ combobox ENDCOM Dialog -> setButtonSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { Button . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CListWidget :: extendableHeight ( ) const { return true ; } CEditListCtrl :: TItemEdit CListWidget :: CMyEditListCtrl :: getItemEditMode ( uint item , uint subItem ) { return CEditListCtrl :: EditMemCombo ; } void CListWidget :: CMyEditListCtrl :: getMemComboBoxProp ( uint item , uint subItem , std :: string & regAdr , bool & browse ) { regAdr = Ctrl -> RegAdr ; browse = true ; } void CListWidget :: CMyEditListCtrl :: getNewItemText ( uint item , uint subItem , std :: string & ret ) { Ctrl -> Dialog -> getDfnName ( ret ) ; ret = " default . " + ret ; } void CListWidget :: CMyEditListCtrl :: getBrowseInfo ( uint item , uint subItem , std :: string & defExt , std :: string & defFilename , std :: string & defDir , std :: string & filter ) { string ret ; Ctrl -> Dialog -> getDfnName ( ret ) ; defExt = " * . " + ret ; defFilename = defExt ; filter = " Form ▁ Files ▁ ( * . " + ret + " ) | * . " + ret + " | All ▁ Files ▁ ( * . * ) | * . * | | " ; defDir = theApp . RootSearchPath ; } bool CListWidget :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( ListCtrl ) ) { // ▁ Get ▁ parent ▁ rect ENDCOM RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; // ▁ Add ▁ my ▁ rect ENDCOM RECT myRect ; ListCtrl . ListCtrl . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } void CListWidget :: onOpenSelected ( ) { // ▁ For ▁ each ▁ selected ENDCOM POSITION pos = ListCtrl . ListCtrl . GetFirstSelectedItemPosition ( ) ; while ( pos ) { int nItem = ListCtrl . ListCtrl . GetNextSelectedItem ( pos ) ; // ▁ Get ▁ the ▁ string ENDCOM CString str = ListCtrl . ListCtrl . GetItemText ( nItem , 0 ) ; if ( str != " " ) { // ▁ Look ▁ for ▁ the ▁ file ENDCOM string name = CPath :: lookup ( ( const char * ) str , false , false ) ; if ( name . empty ( ) ) name = str ; // ▁ Open ▁ the ▁ file ENDCOM theApp . OpenDocumentFile ( name . c_str ( ) ) ; } } } // ▁ CIconWidget ENDCOM CIconWidget :: CIconWidget ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { } CIconWidget :: ~ CIconWidget ( ) { if ( IsWindow ( Icon ) ) Icon . DestroyWindow ( ) ; } void CIconWidget :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { FirstId = dialog_index ; LastId = FirstId ; // ▁ Save ▁ the ▁ label ▁ ENDCOM SavedLabel = label ; // ▁ Create ▁ the ▁ type ▁ combo ENDCOM parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; // ▁ Create ▁ the ▁ mem ▁ combobox ENDCOM parent -> setEditSize ( currentPos , parent -> IconHeight , parent -> IconHeight ) ; Icon . create ( WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index ) ; parent -> initWidget ( Icon ) ; parent -> getNextPos ( currentPos ) ; dialog_index += 1 ; } void CIconWidget :: updateData ( bool update ) { Icon . UpdateData ( update ? TRUE : FALSE ) ; } bool CIconWidget :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Icon ) ; } return false ; } void CIconWidget :: setFocus ( ) { Icon . SetFocus ( ) ; } void CIconWidget :: onOk ( ) { } void CIconWidget :: getValue ( std :: string & result ) { result = " " ; } void CIconWidget :: getFromDocument ( CForm & form ) { } bool CIconWidget :: isWnd ( const CWnd * wnd ) const { return & Icon == wnd ; } void CIconWidget :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { // ▁ Create ▁ the ▁ type ▁ combo ENDCOM Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; // ▁ Create ▁ the ▁ icon ENDCOM Dialog -> setEditSize ( currentPos , Dialog -> IconHeight , Dialog -> IconHeight ) ; if ( resize ) { Icon . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CIconWidget :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Icon ) ) { // ▁ Get ▁ parent ▁ rect ENDCOM RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; // ▁ Add ▁ my ▁ rect ENDCOM RECT myRect ; Icon . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } </DOCUMENT>
<DOCUMENT_ID="MestreLion/boinc-debian/tree/master/clientgui/BOINCGUIApp.cpp"> // ▁ This ▁ file ▁ is ▁ part ▁ of ▁ BOINC . ENDCOM // ▁ http : // boinc . berkeley . edu ENDCOM // ▁ Copyright ▁ ( C ) ▁ 2008 ▁ University ▁ of ▁ California ENDCOM // ▁ BOINC ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it ENDCOM // ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ENDCOM // ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation , ENDCOM // ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM // ▁ BOINC ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM // ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM // ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ENDCOM // ▁ See ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM // ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ENDCOM // ▁ along ▁ with ▁ BOINC . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . ENDCOM # if defined ( __GNUG__ ) && ! defined ( __APPLE__ ) # pragma implementation " BOINCGUIApp . h " # endif # ifdef __WXMAC__ # include < Carbon / Carbon . h > # include " filesys . h " # include " util . h " # if ( defined ( SANDBOX ) && defined ( _DEBUG ) ) # include " SetupSecurity . h " # endif # include " sandbox . h " # endif # include " stdwx . h " # include " diagnostics . h " # include " network . h " # include " util . h " # include " mfile . h " # include " miofile . h " # include " parse . h " # include " idlemon . h " # include " Events . h " # include " common / wxFlatNotebook . h " # include " BOINCInternetFSHandler . h " # include " LogBOINC . h " # include " BOINCGUIApp . h " # include " SkinManager . h " # include " MainDocument . h " # include " BOINCClientManager . h " # include " BOINCTaskBar . h " # include " BOINCBaseFrame . h " # include " AdvancedFrame . h " # include " DlgExitMessage . h " # include " DlgEventLog . h " # include " procinfo . h " # include " sg _ BoincSimpleFrame . h " DEFINE_EVENT_TYPE ( wxEVT_RPC_FINISHED ) IMPLEMENT_APP ( CBOINCGUIApp ) IMPLEMENT_DYNAMIC_CLASS ( CBOINCGUIApp , wxApp ) BEGIN_EVENT_TABLE ( CBOINCGUIApp , wxApp ) EVT_ACTIVATE_APP ( CBOINCGUIApp :: OnActivateApp ) EVT_RPC_FINISHED ( CBOINCGUIApp :: OnRPCFinished ) END_EVENT_TABLE ( ) bool s_bSkipExitConfirmation = false ; # ifdef __WXMAC__ // ▁ Set ▁ s _ bSkipExitConfirmation ▁ to ▁ true ▁ if ▁ cancelled ▁ because ▁ of ▁ logging ▁ out ▁ or ▁ shutting ▁ down ENDCOM OSErr QuitAppleEventHandler ( const AppleEvent * appleEvt , AppleEvent * reply , UInt32 refcon ) { DescType senderType ; Size actualSize ; ProcessSerialNumber SenderPSN ; ProcessInfoRec pInfo ; FSSpec fileSpec ; OSStatus anErr ; // ▁ Refuse ▁ to ▁ quit ▁ if ▁ a ▁ modal ▁ dialog ▁ is ▁ open . ▁ ENDCOM // ▁ Unfortunately , ▁ I ▁ know ▁ of ▁ no ▁ way ▁ to ▁ disable ▁ the ▁ Quit ▁ item ▁ in ▁ our ▁ Dock ▁ menu ENDCOM if ( wxGetApp ( ) . IsModalDialogDisplayed ( ) ) { SysBeep ( 4 ) ; return userCanceledErr ; } anErr = AEGetAttributePtr ( appleEvt , keyAddressAttr , typeProcessSerialNumber , & senderType , & SenderPSN , sizeof ( SenderPSN ) , & actualSize ) ; if ( anErr == noErr ) { pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; pInfo . processName = NULL ; pInfo . processAppSpec = & fileSpec ; anErr = GetProcessInformation ( & SenderPSN , & pInfo ) ; // ▁ Consider ▁ a ▁ Quit ▁ command ▁ from ▁ our ▁ Dock ▁ menu ▁ as ▁ coming ▁ from ▁ this ▁ application ENDCOM if ( ( pInfo . processSignature != ' dock ' ) && ( pInfo . processSignature != ' BNC ! ' ) ) { s_bSkipExitConfirmation = true ; // ▁ Not ▁ from ▁ our ▁ app , ▁ our ▁ dock ▁ icon ▁ or ▁ our ▁ taskbar ▁ icon ENDCOM wxGetApp ( ) . ExitMainLoop ( ) ; // ▁ Prevents ▁ wxMac ▁ from ▁ issuing ▁ events ▁ to ▁ closed ▁ frames ENDCOM } } return wxGetApp ( ) . MacHandleAEQuit ( ( AppleEvent * ) appleEvt , reply ) ; } # endif bool CBOINCGUIApp :: OnInit ( ) { // ▁ Initialize ▁ globals ENDCOM # ifdef SANDBOX g_use_sandbox = true ; # else g_use_sandbox = false ; # endif s_bSkipExitConfirmation = false ; m_bFilterEvents = false ; // ▁ Initialize ▁ class ▁ variables ENDCOM m_pLocale = NULL ; m_pSkinManager = NULL ; m_pFrame = NULL ; m_pDocument = NULL ; m_pTaskBarIcon = NULL ; m_pEventLog = NULL ; # ifdef __WXMAC__ m_pMacSystemMenu = NULL ; # endif m_strBOINCMGRExecutableName = wxEmptyString ; m_strBOINCMGRRootDirectory = wxEmptyString ; m_strBOINCMGRDataDirectory = wxEmptyString ; m_strHostNameArg = wxEmptyString ; m_strPasswordArg = wxEmptyString ; m_iRPCPortArg = GUI_RPC_PORT ; m_strBOINCArguments = wxEmptyString ; m_bGUIVisible = true ; m_bDebugSkins = false ; m_bMultipleInstancesOK = false ; m_bBOINCMGRAutoStarted = false ; m_iBOINCMGRDisableAutoStart = 0 ; m_iShutdownCoreClient = 0 ; m_iDisplayExitDialog = 1 ; m_iGUISelected = BOINC_SIMPLEGUI ; m_bSafeMessageBoxDisplayed = 0 ; # ifdef __WXMSW__ m_hClientLibraryDll = NULL ; # endif // ▁ Initialize ▁ local ▁ variables ENDCOM int iErrorCode = 0 ; int iSelectedLanguage = 0 ; bool bOpenEventLog = false ; wxString strDesiredSkinName = wxEmptyString ; wxString strDialogMessage = wxEmptyString ; bool success = false ; // ▁ Configure ▁ wxWidgets ▁ platform ▁ specific ▁ code ENDCOM # ifdef __WXMSW__ wxSystemOptions :: SetOption ( wxT ( " msw . staticbox . optimized - paint " ) , 0 ) ; # endif # ifdef __WXMAC__ // ▁ In ▁ wxMac - 2.8.7 , ▁ default ▁ wxListCtrl : : RefreshItem ( ) ▁ does ▁ not ▁ work ENDCOM // ▁ so ▁ use ▁ traditional ▁ generic ▁ implementation . ENDCOM // ▁ This ▁ has ▁ been ▁ fixed ▁ in ▁ wxMac - 2.8.8 , ▁ but ▁ the ▁ Mac ▁ native ▁ implementation : ENDCOM // ▁ - ▁ takes ▁ 3 ▁ times ▁ the ▁ CPU ▁ time ▁ as ▁ the ▁ Mac ▁ generic ▁ version . ENDCOM // ▁ - ▁ seems ▁ to ▁ always ▁ redraw ▁ entire ▁ control ▁ even ▁ if ▁ asked ▁ to ▁ refresh ▁ only ▁ one ▁ row . ENDCOM // ▁ - ▁ causes ▁ major ▁ flicker ▁ of ▁ progress ▁ bars , ▁ ( probably ▁ due ▁ to ▁ full ▁ redraws . ) ENDCOM wxSystemOptions :: SetOption ( wxT ( " mac . listctrl . always _ use _ generic " ) , 1 ) ; AEInstallEventHandler ( kCoreEventClass , kAEQuitApplication , NewAEEventHandlerUPP ( ( AEEventHandlerProcPtr ) QuitAppleEventHandler ) , 0 , false ) ; // ▁ Cache ▁ the ▁ current ▁ process ▁ serial ▁ number ENDCOM GetCurrentProcess ( & m_psnCurrentProcess ) ; # endif // ▁ Commandline ▁ parsing ▁ is ▁ done ▁ in ▁ wxApp : : OnInit ( ) ENDCOM if ( ! wxApp :: OnInit ( ) ) { return false ; } if ( g_use_sandbox ) { wxCHANGE_UMASK ( 2 ) ; // ▁ Set ▁ file ▁ creation ▁ mask ▁ to ▁ be ▁ writable ▁ by ▁ both ▁ user ▁ and ▁ group ENDCOM // ▁ Our ▁ umask ▁ will ▁ be ▁ inherited ▁ by ▁ all ▁ our ▁ child ▁ processes ENDCOM } // ▁ Setup ▁ application ▁ and ▁ company ▁ information ENDCOM SetAppName ( wxT ( " BOINC ▁ Manager " ) ) ; SetVendorName ( wxT ( " Space ▁ Sciences ▁ Laboratory , ▁ U . C . ▁ Berkeley " ) ) ; // ▁ Initialize ▁ the ▁ configuration ▁ storage ▁ module ENDCOM m_pConfig = new wxConfig ( GetAppName ( ) ) ; wxConfigBase :: Set ( m_pConfig ) ; wxASSERT ( m_pConfig ) ; // ▁ Restore ▁ Application ▁ State ENDCOM m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Read ( wxT ( " AutomaticallyShutdownClient " ) , & m_iShutdownCoreClient , 0L ) ; m_pConfig -> Read ( wxT ( " DisplayShutdownClientDialog " ) , & m_iDisplayExitDialog , 1L ) ; m_pConfig -> Read ( wxT ( " DisableAutoStart " ) , & m_iBOINCMGRDisableAutoStart , 0L ) ; m_pConfig -> Read ( wxT ( " Language " ) , & iSelectedLanguage , 0L ) ; m_pConfig -> Read ( wxT ( " GUISelection " ) , & m_iGUISelected , BOINC_SIMPLEGUI ) ; m_pConfig -> Read ( wxT ( " EventLogOpen " ) , & bOpenEventLog ) ; // ▁ Should ▁ we ▁ abort ▁ the ▁ BOINC ▁ Manager ▁ startup ▁ process ? ENDCOM if ( m_bBOINCMGRAutoStarted && m_iBOINCMGRDisableAutoStart ) { return false ; } // ▁ Detect ▁ where ▁ BOINC ▁ Manager ▁ executable ▁ name . ENDCOM DetectExecutableName ( ) ; // ▁ Detect ▁ where ▁ BOINC ▁ Manager ▁ was ▁ installed ▁ too . ENDCOM DetectRootDirectory ( ) ; // ▁ Detect ▁ where ▁ the ▁ BOINC ▁ Data ▁ files ▁ are . ENDCOM DetectDataDirectory ( ) ; // ▁ Switch ▁ the ▁ current ▁ directory ▁ to ▁ the ▁ BOINC ▁ Data ▁ directory ENDCOM if ( ! GetDataDirectory ( ) . IsEmpty ( ) ) { success = wxSetWorkingDirectory ( GetDataDirectory ( ) ) ; if ( ! success ) { if ( ! g_use_sandbox ) { if ( ! wxDirExists ( GetDataDirectory ( ) ) ) { success = wxMkdir ( GetDataDirectory ( ) , 0777 ) ; // ▁ Does ▁ nothing ▁ if ▁ dir ▁ exists ENDCOM } } } } if ( ! success ) iErrorCode = - 1016 ; // ▁ Initialize ▁ the ▁ BOINC ▁ Diagnostics ▁ Framework ENDCOM int dwDiagnosticsFlags = BOINC_DIAG_DUMPCALLSTACKENABLED | BOINC_DIAG_HEAPCHECKENABLED | BOINC_DIAG_MEMORYLEAKCHECKENABLED | # if defined ( __WXMSW__ ) || defined ( __WXMAC__ ) BOINC_DIAG_REDIRECTSTDERR | BOINC_DIAG_REDIRECTSTDOUT | # endif BOINC_DIAG_TRACETOSTDOUT ; diagnostics_init ( dwDiagnosticsFlags , " stdoutgui " , " stderrgui " ) ; // ▁ Enable ▁ Logging ▁ and ▁ Trace ▁ Masks ENDCOM m_pLog = new wxLogBOINC ( ) ; wxLog :: SetActiveTarget ( m_pLog ) ; m_pLog -> AddTraceMask ( wxT ( " Function ▁ Start / End " ) ) ; m_pLog -> AddTraceMask ( wxT ( " Function ▁ Status " ) ) ; // ▁ Initialize ▁ the ▁ internationalization ▁ module ENDCOM # ifdef __WXMSW__ // ▁ On ▁ Windows , ▁ set ▁ all ▁ locales ▁ for ▁ this ▁ thread ▁ on ▁ a ▁ per - thread ▁ basis ENDCOM _configthreadlocale ( _ENABLE_PER_THREAD_LOCALE ) ; # endif m_pLocale = new wxLocale ( ) ; wxASSERT ( m_pLocale ) ; // ▁ Look ▁ for ▁ the ▁ localization ▁ files ▁ by ▁ absolute ▁ and ▁ relative ▁ locations . ENDCOM // ▁ preference ▁ given ▁ to ▁ the ▁ absolute ▁ location . ENDCOM m_pLocale -> Init ( iSelectedLanguage ) ; if ( ! m_strBOINCMGRRootDirectory . IsEmpty ( ) ) { m_pLocale -> AddCatalogLookupPathPrefix ( wxString ( m_strBOINCMGRRootDirectory + wxT ( " locale " ) ) ) ; } m_pLocale -> AddCatalogLookupPathPrefix ( wxT ( " locale " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Manager " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Client " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Web " ) ) ; InitSupportedLanguages ( ) ; // ▁ Note : ▁ JAWS ▁ for ▁ Windows ▁ will ▁ only ▁ speak ▁ the ▁ context - sensitive ENDCOM // ▁ help ▁ if ▁ you ▁ use ▁ this ▁ help ▁ provider : ENDCOM wxHelpProvider :: Set ( new wxHelpControllerHelpProvider ( ) ) ; // ▁ Enable ▁ known ▁ image ▁ types ENDCOM wxInitAllImageHandlers ( ) ; // ▁ Enable ▁ additional ▁ file ▁ system ▁ type ▁ handlers ENDCOM wxFileSystem :: AddHandler ( new wxMemoryFSHandler ) ; m_pInternetFSHandler = new CBOINCInternetFSHandler ; wxFileSystem :: AddHandler ( m_pInternetFSHandler ) ; // ▁ Initialize ▁ the ▁ skin ▁ manager ENDCOM m_pSkinManager = new CSkinManager ( m_bDebugSkins ) ; wxASSERT ( m_pSkinManager ) ; // ▁ Load ▁ desired ▁ manager ▁ skin ENDCOM m_pConfig -> Read ( wxT ( " Skin " ) , & strDesiredSkinName , m_pSkinManager -> GetDefaultSkinName ( ) ) ; m_pSkinManager -> ReloadSkin ( strDesiredSkinName ) ; # ifdef SANDBOX // ▁ Make ▁ sure ▁ owners , ▁ groups ▁ and ▁ permissions ▁ are ▁ correct ▁ for ▁ the ▁ current ▁ setting ▁ of ▁ g _ use _ sandbox ENDCOM char path_to_error [ MAXPATHLEN ] ; path_to_error [ 0 ] = ' \0' ; if ( ! iErrorCode ) { # if ( defined ( __WXMAC__ ) && defined ( _DEBUG ) ) // ▁ TODO : ▁ implement ▁ this ▁ for ▁ other ▁ platforms ENDCOM // ▁ GDB ▁ can ' t ▁ attach ▁ to ▁ applications ▁ which ▁ are ▁ running ▁ as ▁ a ▁ different ▁ user ▁ ENDCOM // ▁ or ▁ group , ▁ so ▁ fix ▁ up ▁ data ▁ with ▁ current ▁ user ▁ and ▁ group ▁ during ▁ debugging ENDCOM if ( check_security ( g_use_sandbox , true ) ) { CreateBOINCUsersAndGroups ( ) ; SetBOINCDataOwnersGroupsAndPermissions ( ) ; SetBOINCAppOwnersGroupsAndPermissions ( NULL ) ; } # endif iErrorCode = check_security ( g_use_sandbox , true , path_to_error ) ; } if ( iErrorCode ) { ShowApplication ( true ) ; if ( iErrorCode == - 1099 ) { strDialogMessage . Printf ( _ ( " You ▁ currently ▁ are ▁ not ▁ authorized ▁ to ▁ manage ▁ the ▁ client . \n \n To ▁ run ▁ % s ▁ as ▁ this ▁ user , ▁ please : \n ▁ ▁ - ▁ reinstall ▁ % s ▁ answering ▁ \ " Yes\ " ▁ to ▁ the ▁ question ▁ about \n ▁ ▁ ▁ ▁ ▁ non - administrative ▁ users \n ▁ or \n ▁ ▁ - ▁ contact ▁ your ▁ administrator ▁ to ▁ add ▁ you ▁ to ▁ the ▁ ' boinc _ master ' \n ▁ ▁ ▁ ▁ ▁ user ▁ group . " ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) ) ; } else { strDialogMessage . Printf ( _ ( " % s ▁ ownership ▁ or ▁ permissions ▁ are ▁ not ▁ set ▁ properly ; ▁ please ▁ reinstall ▁ % s . \n ( Error ▁ code ▁ % d " ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , iErrorCode ) ; if ( path_to_error [ 0 ] ) { strDialogMessage += _ ( " ▁ at ▁ " ) ; strDialogMessage += wxString :: FromUTF8 ( path_to_error ) ; } strDialogMessage += _ ( " ) " ) ; fprintf ( stderr , " % ls ▁ ownership ▁ or ▁ permissions ▁ are ▁ not ▁ set ▁ properly ; ▁ please ▁ reinstall ▁ % ls . \n ( Error ▁ code ▁ % d ▁ at ▁ % s ) " , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , iErrorCode , path_to_error ) ; } wxMessageDialog * pDlg = new wxMessageDialog ( NULL , strDialogMessage , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , wxOK ) ; pDlg -> ShowModal ( ) ; if ( pDlg ) pDlg -> Destroy ( ) ; return false ; } # endif // ▁ SANDBOX ENDCOM # ifdef __WXMSW__ // ▁ Perform ▁ any ▁ last ▁ minute ▁ checks ▁ that ▁ should ▁ keep ▁ the ▁ manager ENDCOM // ▁ from ▁ starting ▁ up . ENDCOM wxString strRebootPendingFile = GetRootDirectory ( ) + wxFileName :: GetPathSeparator ( ) + wxT ( " RebootPending . txt " ) ; if ( wxFile :: Exists ( strRebootPendingFile ) ) { wxMessageDialog dialog ( NULL , _ ( " A ▁ reboot ▁ is ▁ required ▁ in ▁ order ▁ for ▁ BOINC ▁ to ▁ run ▁ properly . \n Please ▁ reboot ▁ your ▁ computer ▁ and ▁ try ▁ again . " ) , _ ( " BOINC ▁ Manager " ) , wxOK | wxICON_ERROR ) ; dialog . ShowModal ( ) ; return false ; } # endif // ▁ Detect ▁ if ▁ BOINC ▁ Manager ▁ is ▁ already ▁ running , ▁ if ▁ so , ▁ bring ▁ it ▁ into ▁ the ENDCOM // ▁ foreground ▁ and ▁ then ▁ exit . ENDCOM if ( ! m_bMultipleInstancesOK ) { if ( DetectDuplicateInstance ( ) ) { return false ; } } // ▁ Initialize ▁ the ▁ main ▁ document ENDCOM m_pDocument = new CMainDocument ( ) ; wxASSERT ( m_pDocument ) ; m_pDocument -> OnInit ( ) ; // ▁ Is ▁ there ▁ a ▁ condition ▁ in ▁ which ▁ the ▁ Simple ▁ GUI ▁ should ▁ not ▁ be ▁ used ? ENDCOM if ( BOINC_SIMPLEGUI == m_iGUISelected ) { // ▁ Screen ▁ too ▁ small ? ENDCOM if ( wxGetDisplaySize ( ) . GetHeight ( ) < 600 ) { m_iGUISelected = BOINC_ADVANCEDGUI ; } } // ▁ Initialize ▁ the ▁ task ▁ bar ▁ icon ENDCOM m_pTaskBarIcon = new CTaskBarIcon ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationDisconnectedIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationSnoozeIcon ( ) ) ; wxASSERT ( m_pTaskBarIcon ) ; # ifdef __WXMAC__ m_pMacSystemMenu = new CMacSystemMenu ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationDisconnectedIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationSnoozeIcon ( ) ) ; wxASSERT ( m_pMacSystemMenu ) ; # endif // ▁ Startup ▁ the ▁ System ▁ Idle ▁ Detection ▁ code ENDCOM IdleTrackerAttach ( ) ; # ifdef __WXMAC__ ProcessSerialNumber psn ; ProcessInfoRec pInfo ; OSStatus err ; memset ( & pInfo , 0 , sizeof ( pInfo ) ) ; pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; err = GetProcessInformation ( & m_psnCurrentProcess , & pInfo ) ; if ( ! err ) { psn = pInfo . processLauncher ; memset ( & pInfo , 0 , sizeof ( pInfo ) ) ; pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; err = GetProcessInformation ( & psn , & pInfo ) ; } // ▁ Don ' t ▁ open ▁ main ▁ window ▁ if ▁ we ▁ were ▁ started ▁ automatically ▁ at ▁ login ENDCOM if ( pInfo . processSignature == ' lgnw ' ) { // ▁ Login ▁ Window ▁ app ENDCOM m_bGUIVisible = false ; // ▁ If ▁ the ▁ system ▁ was ▁ just ▁ started , ▁ we ▁ usually ▁ get ▁ a ▁ " Connection ▁ ENDCOM // ▁ failed " ▁ error ▁ if ▁ we ▁ try ▁ to ▁ connect ▁ too ▁ soon , ▁ so ▁ delay ▁ a ▁ bit . ENDCOM sleep ( 10 ) ; } # endif // ▁ Show ▁ the ▁ UI ENDCOM SetActiveGUI ( m_iGUISelected , false ) ; if ( m_bGUIVisible ) { SetActiveGUI ( m_iGUISelected ) ; } else { ShowApplication ( false ) ; } if ( bOpenEventLog ) { DisplayEventLog ( m_bGUIVisible ) ; m_pFrame -> Raise ( ) ; } return true ; } int CBOINCGUIApp :: OnExit ( ) { // ▁ Shutdown ▁ the ▁ System ▁ Idle ▁ Detection ▁ code ENDCOM IdleTrackerDetach ( ) ; if ( m_pDocument ) { m_pDocument -> OnExit ( ) ; delete m_pDocument ; m_pDocument = NULL ; } m_pConfig -> SetPath ( wxT ( " / " ) ) ; if ( m_pSkinManager ) { m_pConfig -> Write ( wxT ( " Skin " ) , m_pSkinManager -> GetSelectedSkin ( ) ) ; delete m_pSkinManager ; } if ( m_pLocale ) { delete m_pLocale ; m_pLocale = NULL ; } if ( m_pEventLog ) { m_pEventLog -> Destroy ( ) ; m_pEventLog = NULL ; } // ▁ Save ▁ Application ▁ State ENDCOM m_pConfig -> Write ( wxT ( " AutomaticallyShutdownClient " ) , m_iShutdownCoreClient ) ; m_pConfig -> Write ( wxT ( " DisplayShutdownClientDialog " ) , m_iDisplayExitDialog ) ; m_pConfig -> Write ( wxT ( " DisableAutoStart " ) , m_iBOINCMGRDisableAutoStart ) ; diagnostics_finish ( ) ; return wxApp :: OnExit ( ) ; } // / ▁ Pass ▁ the ▁ command ▁ line ▁ parameters ▁ and ▁ discriptions ▁ to ▁ wxWidgets ▁ for ▁ displaying . ENDCOM void CBOINCGUIApp :: OnInitCmdLine ( wxCmdLineParser & parser ) { wxApp :: OnInitCmdLine ( parser ) ; static const wxCmdLineEntryDesc cmdLineDesc [ ] = { { wxCMD_LINE_SWITCH , wxT ( " a " ) , wxT ( " autostart " ) , _ ( " BOINC ▁ Manager ▁ was ▁ started ▁ by ▁ the ▁ operating ▁ system ▁ automatically " ) } , # if defined ( __WXMSW__ ) || defined ( __WXMAC__ ) { wxCMD_LINE_SWITCH , wxT ( " s " ) , wxT ( " systray " ) , _ ( " Startup ▁ BOINC ▁ so ▁ only ▁ the ▁ system ▁ tray ▁ icon ▁ is ▁ visible " ) } , # else { wxCMD_LINE_OPTION , wxT ( " e " ) , wxT ( " clientdir " ) , _ ( " Directory ▁ containing ▁ the ▁ BOINC ▁ Client ▁ executable " ) } , { wxCMD_LINE_OPTION , wxT ( " d " ) , wxT ( " datadir " ) , _ ( " BOINC ▁ data ▁ directory " ) } , # endif { wxCMD_LINE_OPTION , wxT ( " n " ) , wxT ( " namehost " ) , _ ( " Host ▁ name ▁ or ▁ IP ▁ address " ) } , { wxCMD_LINE_OPTION , wxT ( " g " ) , wxT ( " gui _ rpc _ port " ) , _ ( " GUI ▁ RPC ▁ port ▁ number " ) } , { wxCMD_LINE_OPTION , wxT ( " p " ) , wxT ( " password " ) , _ ( " Password " ) } , { wxCMD_LINE_OPTION , wxT ( " b " ) , wxT ( " boincargs " ) , _ ( " Startup ▁ BOINC ▁ with ▁ these ▁ optional ▁ arguments " ) } , { wxCMD_LINE_SWITCH , wxT ( " i " ) , wxT ( " insecure " ) , _ ( " disable ▁ BOINC ▁ security ▁ users ▁ and ▁ permissions " ) } , { wxCMD_LINE_SWITCH , wxT ( " c " ) , wxT ( " checkskins " ) , _ ( " set ▁ skin ▁ debugging ▁ mode ▁ to ▁ enable ▁ skin ▁ manager ▁ error ▁ messages " ) } , { wxCMD_LINE_SWITCH , wxT ( " m " ) , wxT ( " multiple " ) , _ ( " multiple ▁ instances ▁ of ▁ BOINC ▁ Manager ▁ allowed " ) } , # if ( defined ( __WXMAC__ ) && defined ( _DEBUG ) ) { wxCMD_LINE_OPTION , wxT ( " NSDocumentRevisionsDebugMode " ) , NULL , _ ( " Not ▁ used : ▁ workaround ▁ for ▁ bug ▁ in ▁ XCode ▁ 4.2" ) } , # endif { wxCMD_LINE_NONE } // DON ' T ▁ forget ▁ this ▁ line ! ! ENDCOM } ; parser . SetDesc ( cmdLineDesc ) ; } // / ▁ Parse ▁ command ▁ line ▁ parameters . ENDCOM bool CBOINCGUIApp :: OnCmdLineParsed ( wxCmdLineParser & parser ) { // ▁ Give ▁ default ▁ processing ▁ ( - ? , ▁ - - help ▁ and ▁ - - verbose ) ▁ the ▁ chance ▁ to ▁ do ▁ something . ENDCOM wxApp :: OnCmdLineParsed ( parser ) ; wxString portNum = wxEmptyString ; long longPort ; bool hostNameSpecified = false ; bool passwordSpecified = false ; parser . Found ( wxT ( " boincargs " ) , & m_strBOINCArguments ) ; if ( parser . Found ( wxT ( " autostart " ) ) ) { m_bBOINCMGRAutoStarted = true ; } # if defined ( __WXMSW__ ) || defined ( __WXMAC__ ) if ( parser . Found ( wxT ( " systray " ) ) ) { m_bGUIVisible = false ; } # endif if ( parser . Found ( wxT ( " insecure " ) ) ) { g_use_sandbox = false ; } if ( parser . Found ( wxT ( " checkskins " ) ) ) { m_bDebugSkins = true ; } if ( parser . Found ( wxT ( " multiple " ) ) ) { m_bMultipleInstancesOK = true ; } # if ! ( defined ( __WXMSW__ ) || defined ( __WXMAC__ ) ) if ( ! parser . Found ( wxT ( " clientdir " ) , & m_strBOINCMGRRootDirectory ) ) { m_strBOINCMGRRootDirectory = :: wxGetCwd ( ) ; } if ( m_strBOINCMGRRootDirectory . Last ( ) != ' / ' ) { m_strBOINCMGRRootDirectory . Append ( ' / ' ) ; } if ( ! parser . Found ( wxT ( " datadir " ) , & m_strBOINCMGRDataDirectory ) ) { m_strBOINCMGRDataDirectory = m_strBOINCMGRRootDirectory ; } if ( m_strBOINCMGRDataDirectory . Last ( ) != ' / ' ) { m_strBOINCMGRDataDirectory . Append ( ' / ' ) ; } # endif if ( parser . Found ( wxT ( " namehost " ) , & m_strHostNameArg ) ) { hostNameSpecified = true ; } else { m_strHostNameArg = wxT ( " localhost " ) ; } if ( parser . Found ( wxT ( " gui _ rpc _ port " ) , & portNum ) ) { if ( portNum . ToLong ( & longPort ) ) { m_iRPCPortArg = longPort ; } else { m_iRPCPortArg = GUI_RPC_PORT ; // ▁ conversion ▁ failed ENDCOM } } else { m_iRPCPortArg = GUI_RPC_PORT ; } if ( parser . Found ( wxT ( " password " ) , & m_strPasswordArg ) ) { passwordSpecified = true ; } else { m_strPasswordArg = wxEmptyString ; } if ( hostNameSpecified && passwordSpecified ) { m_bMultipleInstancesOK = true ; } return true ; } // / ▁ Detect ▁ if ▁ another ▁ instance ▁ of ▁ this ▁ application ▁ is ▁ running . ENDCOM // ▁ Returns ▁ true ▁ if ▁ there ▁ is , ▁ otherwise ▁ false ENDCOM bool CBOINCGUIApp :: DetectDuplicateInstance ( ) { # ifdef __WXMSW__ if ( CTaskBarIcon :: FireAppRestore ( ) ) { return true ; } # endif # ifdef __WXMAC__ ProcessSerialNumber PSN ; int iInstanceID = wxGetApp ( ) . IsAnotherInstanceRunning ( ) ; if ( iInstanceID ) { // ▁ Bring ▁ other ▁ instance ▁ to ▁ the ▁ front ▁ and ▁ exit ▁ this ▁ instance ENDCOM OSStatus err = GetProcessForPID ( iInstanceID , & PSN ) ; if ( ! err ) SetFrontProcess ( & PSN ) ; return true ; } # endif return false ; } // / ▁ Determines ▁ what ▁ name ▁ BOINC ▁ Manager ▁ is ▁ called . ENDCOM void CBOINCGUIApp :: DetectExecutableName ( ) { # ifdef __WXMSW__ TCHAR szPath [ MAX_PATH - 1 ] ; // ▁ change ▁ the ▁ current ▁ directory ▁ to ▁ the ▁ boinc ▁ install ▁ directory ENDCOM GetModuleFileName ( NULL , szPath , ( sizeof ( szPath ) / sizeof ( TCHAR ) ) ) ; TCHAR * pszProg = _tcsrchr ( szPath , ' \\ ' ) ; if ( pszProg ) { pszProg ++ ; } // ▁ Store ▁ the ▁ root ▁ directory ▁ for ▁ later ▁ use . ENDCOM m_strBOINCMGRExecutableName = pszProg ; # endif } // / ▁ Determines ▁ where ▁ the ▁ BOINC ▁ Manager ▁ is ▁ executing ▁ from . ENDCOM void CBOINCGUIApp :: DetectRootDirectory ( ) { # ifdef __WXMSW__ TCHAR szPath [ MAX_PATH - 1 ] ; // ▁ change ▁ the ▁ current ▁ directory ▁ to ▁ the ▁ boinc ▁ install ▁ directory ENDCOM GetModuleFileName ( NULL , szPath , ( sizeof ( szPath ) / sizeof ( TCHAR ) ) ) ; TCHAR * pszProg = _tcsrchr ( szPath , ' \\ ' ) ; if ( pszProg ) { szPath [ pszProg - szPath + 1 ] = 0 ; } // ▁ Store ▁ the ▁ root ▁ directory ▁ for ▁ later ▁ use . ENDCOM m_strBOINCMGRRootDirectory = szPath ; # endif } // / ▁ Determines ▁ where ▁ the ▁ BOINC ▁ data ▁ directory ▁ is . ENDCOM void CBOINCGUIApp :: DetectDataDirectory ( ) { # ifdef __WXMSW__ // ▁ Determine ▁ BOINCMgr ▁ Data ▁ Directory ENDCOM LONG lReturnValue ; HKEY hkSetupHive ; LPTSTR lpszRegistryValue = NULL ; DWORD dwSize = 0 ; // ▁ change ▁ the ▁ current ▁ directory ▁ to ▁ the ▁ boinc ▁ data ▁ directory ▁ if ▁ it ▁ exists ENDCOM lReturnValue = RegOpenKeyEx ( HKEY_LOCAL_MACHINE , _T ( " SOFTWARE\\Space ▁ Sciences ▁ Laboratory , ▁ U . C . ▁ Berkeley\\BOINC ▁ Setup " ) , 0 , KEY_READ , & hkSetupHive ) ; if ( lReturnValue == ERROR_SUCCESS ) { // ▁ How ▁ large ▁ does ▁ our ▁ buffer ▁ need ▁ to ▁ be ? ENDCOM lReturnValue = RegQueryValueEx ( hkSetupHive , _T ( " DATADIR " ) , NULL , NULL , NULL , & dwSize ) ; if ( lReturnValue != ERROR_FILE_NOT_FOUND ) { // ▁ Allocate ▁ the ▁ buffer ▁ space . ENDCOM lpszRegistryValue = ( LPTSTR ) malloc ( dwSize ) ; ( * lpszRegistryValue ) = NULL ; // ▁ Now ▁ get ▁ the ▁ data ENDCOM lReturnValue = RegQueryValueEx ( hkSetupHive , _T ( " DATADIR " ) , NULL , NULL , ( LPBYTE ) lpszRegistryValue , & dwSize ) ; // ▁ Store ▁ the ▁ root ▁ directory ▁ for ▁ later ▁ use . ENDCOM m_strBOINCMGRDataDirectory = lpszRegistryValue ; } } // ▁ Cleanup ENDCOM if ( hkSetupHive ) RegCloseKey ( hkSetupHive ) ; if ( lpszRegistryValue ) free ( lpszRegistryValue ) ; # endif # ifdef __WXMAC__ m_strBOINCMGRDataDirectory = wxT ( " / Library / Application ▁ Support / BOINC ▁ Data " ) ; # endif } void CBOINCGUIApp :: InitSupportedLanguages ( ) { wxInt32 iIndex = 0 ; const wxLanguageInfo * liLanguage = NULL ; // ▁ Prepare ▁ the ▁ array ENDCOM m_astrLanguages . Insert ( wxEmptyString , 0 , wxLANGUAGE_USER_DEFINED + 1 ) ; // ▁ These ▁ are ▁ just ▁ special ▁ tags ▁ so ▁ deal ▁ with ▁ them ▁ in ▁ a ▁ special ▁ way ENDCOM m_astrLanguages [ wxLANGUAGE_DEFAULT ] = _ ( " ( Automatic ▁ Detection ) " ) ; m_astrLanguages [ wxLANGUAGE_UNKNOWN ] = _ ( " ( Unknown ) " ) ; m_astrLanguages [ wxLANGUAGE_USER_DEFINED ] = _ ( " ( User ▁ Defined ) " ) ; for ( iIndex = 0 ; iIndex <= wxLANGUAGE_USER_DEFINED ; iIndex ++ ) { liLanguage = wxLocale :: GetLanguageInfo ( iIndex ) ; if ( liLanguage ) { m_astrLanguages [ iIndex ] = liLanguage -> Description ; } } } int CBOINCGUIApp :: IdleTrackerAttach ( ) { # ifdef __WXMSW__ :: attach_idle_monitor ( ) ; # endif return 0 ; } int CBOINCGUIApp :: IdleTrackerDetach ( ) { # ifdef __WXMSW__ :: detach_idle_monitor ( ) ; # endif return 0 ; } void CBOINCGUIApp :: OnActivateApp ( wxActivateEvent & event ) { # ifdef __WXMAC__ // ▁ Make ▁ sure ▁ any ▁ modal ▁ dialog ▁ ( such ▁ as ▁ Attach ▁ Wizard ) ▁ ends ▁ up ▁ in ▁ front . ENDCOM if ( IsModalDialogDisplayed ( ) ) { event . Skip ( ) ; return ; } # endif if ( event . GetActive ( ) ) { if ( m_pEventLog && ! m_pEventLog -> IsIconized ( ) ) { m_pEventLog -> Raise ( ) ; } if ( m_pFrame ) m_pFrame -> Raise ( ) ; } event . Skip ( ) ; } void CBOINCGUIApp :: OnRPCFinished ( CRPCFinishedEvent & event ) { CMainDocument * pDoc = wxGetApp ( ) . GetDocument ( ) ; wxASSERT ( pDoc ) ; wxASSERT ( wxDynamicCast ( pDoc , CMainDocument ) ) ; pDoc -> OnRPCComplete ( event ) ; } int CBOINCGUIApp :: UpdateSystemIdleDetection ( ) { # ifdef __WXMSW__ return get_idle_tick_count ( ) ; # else return TRUE ; # endif } int CBOINCGUIApp :: StartBOINCScreensaverTest ( ) { # ifdef __WXMSW__ wxString strExecute = wxEmptyString ; wxChar szExecutableDirectory [ 4096 ] ; memset ( szExecutableDirectory , 0 , sizeof ( szExecutableDirectory ) ) ; // ▁ On ▁ Windows ▁ the ▁ screensaver ▁ is ▁ located ▁ in ▁ the ▁ Windows ▁ directory . ENDCOM GetWindowsDirectory ( szExecutableDirectory , ( sizeof ( szExecutableDirectory ) / sizeof ( wxChar ) ) ) ; // ▁ Append ▁ boinc . scr ▁ to ▁ the ▁ end ▁ of ▁ the ▁ strExecute ▁ string ▁ and ▁ get ▁ ready ▁ to ▁ rock ENDCOM strExecute = wxT ( " \ " " ) + wxString ( szExecutableDirectory ) + wxT ( " \\boinc . scr\ " ▁ / t " ) ; :: wxExecute ( strExecute ) ; # endif return 0 ; } int CBOINCGUIApp :: StartBOINCDefaultScreensaverTest ( ) { # ifdef __WXMSW__ wxString strExecute = wxEmptyString ; strExecute = wxT ( " \ " " ) + m_strBOINCMGRRootDirectory + wxT ( " \\boincscr . exe\ " ▁ - - test " ) ; :: wxExecute ( strExecute ) ; # endif return 0 ; } // ▁ Display ▁ the ▁ Event ▁ Log , ▁ it ▁ is ▁ a ▁ modeless ▁ dialog ▁ not ▁ owned ▁ by ▁ any ENDCOM // ▁ other ▁ UI ▁ element . ENDCOM void CBOINCGUIApp :: DisplayEventLog ( bool bShowWindow ) { if ( m_pEventLog ) { if ( bShowWindow ) { if ( m_pEventLog -> IsIconized ( ) ) { m_pEventLog -> Iconize ( false ) ; } m_pEventLog -> Raise ( ) ; } } else { m_pEventLog = new CDlgEventLog ( ) ; if ( m_pEventLog ) { m_pEventLog -> Show ( bShowWindow ) ; if ( bShowWindow ) { m_pEventLog -> Raise ( ) ; } if ( m_pFrame ) { m_pFrame -> UpdateRefreshTimerInterval ( ) ; } } } } void CBOINCGUIApp :: OnEventLogClose ( ) { m_pEventLog = NULL ; if ( m_pFrame ) { m_pFrame -> UpdateRefreshTimerInterval ( ) ; } } // ▁ The ▁ skin ▁ has ▁ changed ▁ and ▁ all ▁ UI ▁ elements ▁ need ▁ to ▁ reload ▁ their ▁ bitmaps . ENDCOM void CBOINCGUIApp :: FireReloadSkin ( ) { if ( m_pFrame ) { m_pFrame -> FireReloadSkin ( ) ; } if ( m_pTaskBarIcon ) { m_pTaskBarIcon -> FireReloadSkin ( ) ; } } bool CBOINCGUIApp :: SetActiveGUI ( int iGUISelection , bool bShowWindow ) { wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ Function ▁ Begin " ) ) ; wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ GUI ▁ Selection : ▁ ' % d ' , ▁ Show : ▁ % d ' " ) , iGUISelection , ( int ) bShowWindow ) ; CBOINCBaseFrame * pNewFrame = NULL ; CBOINCBaseFrame * pOldFrame = m_pFrame ; wxInt32 iTop = 0 ; wxInt32 iLeft = 0 ; wxInt32 iHeight = 0 ; wxInt32 iWidth = 0 ; // ▁ Create ▁ the ▁ new ▁ window ENDCOM if ( ( iGUISelection != m_iGUISelected ) || ! m_pFrame ) { // ▁ Reterieve ▁ the ▁ desired ▁ window ▁ state ▁ before ▁ creating ▁ the ENDCOM // ▁ desired ▁ frames ENDCOM if ( BOINC_ADVANCEDGUI == iGUISelection ) { m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Read ( wxT ( " YPos " ) , & iTop , 30 ) ; m_pConfig -> Read ( wxT ( " XPos " ) , & iLeft , 30 ) ; m_pConfig -> Read ( wxT ( " Width " ) , & iWidth , 800 ) ; m_pConfig -> Read ( wxT ( " Height " ) , & iHeight , 600 ) ; } else { m_pConfig -> SetPath ( wxT ( " / Simple " ) ) ; m_pConfig -> Read ( wxT ( " YPos " ) , & iTop , 30 ) ; m_pConfig -> Read ( wxT ( " XPos " ) , & iLeft , 30 ) ; // ▁ We ▁ don ' t ▁ save ▁ Simple ▁ View ' s ▁ width ▁ & ▁ height ▁ since ▁ it ' s ▁ ENDCOM // ▁ window ▁ is ▁ not ▁ resizable , ▁ so ▁ don ' t ▁ try ▁ to ▁ read ▁ them ENDCOM # ifdef __WXMAC__ // ▁ m _ pConfig - > Read ( wxT ( " Width " ) , ▁ & iWidth , ▁ 409 ) ; ENDCOM // ▁ m _ pConfig - > Read ( wxT ( " Height " ) , ▁ & iHeight , ▁ 561 ) ; ENDCOM iWidth = 409 ; iHeight = 561 ; # else // ▁ m _ pConfig - > Read ( wxT ( " Width " ) , ▁ & iWidth , ▁ 416 ) ; ENDCOM // ▁ m _ pConfig - > Read ( wxT ( " Height " ) , ▁ & iHeight , ▁ 570 ) ; ENDCOM iWidth = 416 ; iHeight = 570 ; # endif } // ▁ Make ▁ sure ▁ that ▁ the ▁ new ▁ window ▁ is ▁ going ▁ to ▁ be ▁ visible ENDCOM // ▁ on ▁ a ▁ screen ENDCOM # ifdef __WXMAC__ if ( ! IsWindowOnScreen ( iLeft , iTop , iWidth , iHeight ) ) { iTop = iLeft = 30 ; } # else // ▁ If ▁ either ▁ co - ordinate ▁ is ▁ less ▁ then ▁ 0 ▁ then ▁ set ▁ it ▁ equal ▁ to ▁ 0 ▁ to ▁ ensure ENDCOM // ▁ it ▁ displays ▁ on ▁ the ▁ screen . ENDCOM if ( iLeft < 0 ) iLeft = 30 ; if ( iTop < 0 ) iTop = 30 ; // ▁ Read ▁ the ▁ size ▁ of ▁ the ▁ screen ENDCOM wxInt32 iMaxWidth = wxSystemSettings :: GetMetric ( wxSYS_SCREEN_X ) ; wxInt32 iMaxHeight = wxSystemSettings :: GetMetric ( wxSYS_SCREEN_Y ) ; // ▁ Max ▁ sure ▁ that ▁ it ▁ doesn ' t ▁ go ▁ off ▁ to ▁ the ▁ right ▁ or ▁ bottom ENDCOM if ( iLeft + iWidth > iMaxWidth ) iLeft = iMaxWidth - iWidth ; if ( iTop + iHeight > iMaxHeight ) iTop = iMaxHeight - iHeight ; # endif // ▁ Create ▁ the ▁ main ▁ window ENDCOM if ( BOINC_ADVANCEDGUI == iGUISelection ) { // ▁ Initialize ▁ the ▁ advanced ▁ gui ▁ window ENDCOM pNewFrame = new CAdvancedFrame ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon32 ( ) , wxPoint ( iLeft , iTop ) , wxSize ( iWidth , iHeight ) ) ; } else { // ▁ Initialize ▁ the ▁ simple ▁ gui ▁ window ENDCOM pNewFrame = new CSimpleFrame ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon32 ( ) , wxPoint ( iLeft , iTop ) , wxSize ( iWidth , iHeight ) ) ; } wxASSERT ( pNewFrame ) ; if ( pNewFrame ) { SetTopWindow ( pNewFrame ) ; // ▁ Store ▁ the ▁ new ▁ frame ▁ for ▁ future ▁ use ENDCOM m_pFrame = pNewFrame ; // ▁ Hide ▁ the ▁ old ▁ one ▁ if ▁ it ▁ exists . ▁ We ▁ must ▁ do ▁ this ▁ ENDCOM // ▁ after ▁ updating ▁ m _ pFrame ▁ to ▁ prevent ▁ Mac ▁ OSX ▁ from ENDCOM // ▁ hiding ▁ the ▁ application ENDCOM if ( pOldFrame ) pOldFrame -> Hide ( ) ; // ▁ Delete ▁ the ▁ old ▁ one ▁ if ▁ it ▁ exists ENDCOM // ▁ Note : ▁ this ▁ has ▁ the ▁ side ▁ effect ▁ of ▁ hiding ▁ the ▁ Event ▁ Log ENDCOM if ( pOldFrame ) pOldFrame -> Destroy ( ) ; } } // ▁ Show ▁ the ▁ new ▁ frame ▁ if ▁ needed ▁ ENDCOM if ( m_pFrame && bShowWindow ) { if ( m_pEventLog ) { m_pEventLog -> Show ( ) ; m_pEventLog -> Raise ( ) ; # ifdef __WXMSW__ :: SetForegroundWindow ( ( HWND ) m_pEventLog -> GetHWND ( ) ) ; # endif } if ( ! m_pFrame -> IsShown ( ) ) { m_pFrame -> Show ( ) ; } if ( m_pFrame -> IsIconized ( ) ) { m_pFrame -> Maximize ( false ) ; } m_pFrame -> Raise ( ) ; # ifdef __WXMSW__ :: SetForegroundWindow ( ( HWND ) m_pFrame -> GetHWND ( ) ) ; # endif } m_iGUISelected = iGUISelection ; m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Write ( wxT ( " GUISelection " ) , iGUISelection ) ; wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ Function ▁ End " ) ) ; return true ; } int CBOINCGUIApp :: ConfirmExit ( ) { CSkinAdvanced * pSkinAdvanced = wxGetApp ( ) . GetSkinManager ( ) -> GetAdvanced ( ) ; CMainDocument * pDoc = wxGetApp ( ) . GetDocument ( ) ; wxString strConnectedCompter = wxEmptyString ; bool bWasVisible ; int retval = 0 ; wxASSERT ( pDoc ) ; wxASSERT ( pSkinAdvanced ) ; wxASSERT ( wxDynamicCast ( pDoc , CMainDocument ) ) ; wxASSERT ( wxDynamicCast ( pSkinAdvanced , CSkinAdvanced ) ) ; pDoc -> GetConnectedComputerName ( strConnectedCompter ) ; if ( ! pDoc -> IsComputerNameLocal ( strConnectedCompter ) ) { // ▁ Don ' t ▁ shut ▁ down ▁ remote ▁ clients ▁ on ▁ Manager ▁ exit ENDCOM return 1 ; } // ▁ Don ' t ▁ run ▁ confirmation ▁ dialog ▁ if ▁ logging ▁ out ▁ or ▁ shutting ▁ down ▁ Mac , ▁ ENDCOM // ▁ or ▁ if ▁ emergency ▁ exit ▁ from ▁ AsyncRPCDlg ENDCOM if ( s_bSkipExitConfirmation ) return 1 ; // ▁ Don ' t ▁ run ▁ confirmation ▁ dialog ▁ if ▁ second ▁ instance ▁ of ▁ Manager ▁ ENDCOM if ( IsMgrMultipleInstance ( ) ) return 1 ; if ( ! m_iDisplayExitDialog ) { // ▁ Mac : ▁ User ▁ doesn ' t ▁ want ▁ to ▁ display ▁ the ▁ dialog ▁ and ▁ just ▁ wants ▁ to ▁ use ▁ their ▁ previous ▁ value . ENDCOM // ▁ Win ▁ & ▁ Linux : ▁ User ▁ doesn ' t ▁ want ▁ to ▁ display ▁ the ▁ dialog ▁ and ▁ wants ▁ to ▁ shutdown ▁ the ▁ client . ENDCOM return 1 ; } bWasVisible = IsApplicationVisible ( ) ; ShowApplication ( true ) ; CDlgExitMessage dlg ( NULL ) ; if ( ! pSkinAdvanced -> GetExitMessage ( ) . IsEmpty ( ) ) { dlg . m_DialogExitMessage -> SetLabel ( pSkinAdvanced -> GetExitMessage ( ) ) ; } # ifdef __WXMSW__ if ( m_iShutdownCoreClient ) { dlg . m_DialogShutdownCoreClient -> SetValue ( TRUE ) ; } # endif if ( m_iDisplayExitDialog ) { dlg . m_DialogDisplay -> SetValue ( FALSE ) ; } dlg . Fit ( ) ; dlg . Centre ( ) ; if ( wxID_OK == dlg . ShowModal ( ) ) { # ifdef __WXMAC__ s_bSkipExitConfirmation = true ; // ▁ Don ' t ▁ ask ▁ twice ▁ ( only ▁ affects ▁ Mac ) ENDCOM # else m_iShutdownCoreClient = dlg . m_DialogShutdownCoreClient -> GetValue ( ) ; # endif m_iDisplayExitDialog = ! dlg . m_DialogDisplay -> GetValue ( ) ; retval = true ; } if ( ! bWasVisible ) { ShowApplication ( false ) ; } return retval ; // ▁ User ▁ cancelled ▁ exit ENDCOM } // ▁ Use ▁ this ▁ instead ▁ of ▁ wxMessageBox ▁ from ▁ all ▁ tab ▁ Views ▁ to ▁ suppress ▁ ENDCOM // ▁ Periodic ▁ RPCs . ▁ See ▁ comment ▁ in ▁ CMainDocument : : RunPeriodicRPCs ( ) ENDCOM // ▁ for ▁ a ▁ fuller ▁ explanation . ENDCOM int CBOINCGUIApp :: SafeMessageBox ( const wxString & message , const wxString & caption , long style , wxWindow * parent , int x , int y ) { int retval ; m_bSafeMessageBoxDisplayed ++ ; retval = wxMessageBox ( message , caption , style , parent , x , y ) ; m_bSafeMessageBoxDisplayed -- ; return retval ; } // / ▁ Determines ▁ if ▁ another ▁ instance ▁ of ▁ BOINC ▁ Manager ▁ is ▁ running . ENDCOM // / ▁ @ return ENDCOM // / ▁ true ▁ if ▁ another ▁ instance ▁ of ▁ BOINC ▁ Manager ▁ is ▁ running , ▁ otherwise ▁ false . ENDCOM // / ▁ Note : ▁ will ▁ always ▁ return ▁ false ▁ on ▁ Win95 , ▁ Win98 , ▁ WinME ENDCOM int CBOINCGUIApp :: IsAnotherInstanceRunning ( ) { PROC_MAP pm ; int retval ; char myName [ 256 ] ; int otherInstanceID = 0 ; int myPid ; // ▁ Look ▁ for ▁ BOINC ▁ Manager ▁ in ▁ list ▁ of ▁ all ▁ running ▁ processes ENDCOM retval = procinfo_setup ( pm ) ; if ( retval ) return false ; // ▁ Should ▁ never ▁ happen ENDCOM # ifdef _WIN32 myPid = ( int ) GetCurrentProcessId ( ) ; # else myPid = getpid ( ) ; # endif // ▁ Get ▁ the ▁ name ▁ of ▁ this ▁ Application ENDCOM myName [ 0 ] = 0 ; PROC_MAP :: iterator i ; for ( i = pm . begin ( ) ; i != pm . end ( ) ; i ++ ) { PROCINFO & pi = i -> second ; if ( pi . id == myPid ) { strncpy ( myName , pi . command , sizeof ( myName ) ) ; break ; } } if ( myName [ 0 ] == 0 ) { return false ; // ▁ Should ▁ never ▁ happen ENDCOM } // ▁ Search ▁ process ▁ list ▁ for ▁ other ▁ applications ▁ with ▁ same ▁ name ENDCOM for ( i = pm . begin ( ) ; i != pm . end ( ) ; i ++ ) { PROCINFO & pi = i -> second ; if ( pi . id == myPid ) continue ; if ( ! strcmp ( pi . command , myName ) ) { otherInstanceID = pi . id ; break ; } } return otherInstanceID ; } // / ▁ Determines ▁ if ▁ the ▁ current ▁ process ▁ is ▁ visible . ENDCOM // / ▁ @ return ENDCOM // / ▁ true ▁ if ▁ the ▁ current ▁ process ▁ is ▁ visible , ▁ otherwise ▁ false . ENDCOM bool CBOINCGUIApp :: IsApplicationVisible ( ) { # ifdef __WXMAC__ if ( IsProcessVisible ( & m_psnCurrentProcess ) ) { return true ; } # endif return false ; } // / ▁ Shows ▁ or ▁ hides ▁ the ▁ current ▁ process . ENDCOM // / ▁ @ param ▁ bShow ENDCOM // / ▁ true ▁ will ▁ show ▁ the ▁ process , ▁ false ▁ will ▁ hide ▁ the ▁ process . ENDCOM # ifdef __WXMAC__ void CBOINCGUIApp :: ShowApplication ( bool bShow ) { if ( bShow ) { SetFrontProcess ( & m_psnCurrentProcess ) ; } else { ShowHideProcess ( & m_psnCurrentProcess , false ) ; } } # else void CBOINCGUIApp :: ShowApplication ( bool ) { } # endif bool CBOINCGUIApp :: ShowInterface ( ) { return SetActiveGUI ( m_iGUISelected , true ) ; } bool CBOINCGUIApp :: ShowNotifications ( ) { bool retval = false ; retval = SetActiveGUI ( m_iGUISelected , true ) ; if ( retval ) { GetFrame ( ) -> FireNotification ( ) ; GetDocument ( ) -> UpdateUnreadNoticeState ( ) ; } return retval ; } bool CBOINCGUIApp :: IsModalDialogDisplayed ( ) { if ( m_bSafeMessageBoxDisplayed ) return true ; // ▁ Search ▁ for ▁ the ▁ dialog ▁ by ▁ ID ▁ since ▁ all ▁ of ▁ BOINC ▁ Manager ' s ▁ ENDCOM // ▁ dialog ▁ IDs ▁ are ▁ 10000 . ENDCOM if ( wxDynamicCast ( wxWindow :: FindWindowById ( ID_ANYDIALOG ) , wxDialog ) ) { return true ; } if ( m_pDocument ) { if ( m_pDocument -> WaitingForRPC ( ) ) { return true ; } } return false ; } void CBOINCGUIApp :: DeleteTaskBarIcon ( ) { if ( m_pTaskBarIcon ) { delete m_pTaskBarIcon ; } m_pTaskBarIcon = NULL ; } # ifdef __WXMAC__ void CBOINCGUIApp :: DeleteMacSystemMenu ( ) { if ( m_pMacSystemMenu ) { delete m_pMacSystemMenu ; } m_pMacSystemMenu = NULL ; } # endif // ▁ Prevent ▁ recursive ▁ entry ▁ of ▁ CMainDocument : : RequestRPC ( ) ENDCOM int CBOINCGUIApp :: FilterEvent ( wxEvent & event ) { int theEventType ; wxDialog * theRPCWaitDialog ; wxObject * theObject ; if ( ! m_pDocument ) return - 1 ; theEventType = event . GetEventType ( ) ; if ( m_pDocument -> WaitingForRPC ( ) ) { // ▁ If ▁ in ▁ RPC ▁ Please ▁ Wait ▁ dialog , ▁ reject ▁ all ▁ command ▁ ENDCOM // ▁ and ▁ timer ▁ events ▁ except : ▁ ENDCOM // ▁ - ▁ RPC ▁ Finished ENDCOM // ▁ - ▁ those ▁ for ▁ that ▁ dialog ▁ or ▁ its ▁ children ENDCOM // ▁ - ▁ Open ▁ Manager ▁ menu ▁ item ▁ from ▁ system ▁ tray ▁ icon ENDCOM if ( ( theEventType == wxEVT_COMMAND_MENU_SELECTED ) && ( event . GetId ( ) == wxID_OPEN ) ) { return - 1 ; } theRPCWaitDialog = m_pDocument -> GetRPCWaitDialog ( ) ; theObject = event . GetEventObject ( ) ; while ( theObject ) { if ( ! theObject -> IsKindOf ( CLASSINFO ( wxWindow ) ) ) break ; if ( theObject == theRPCWaitDialog ) return - 1 ; theObject = ( ( wxWindow * ) theObject ) -> GetParent ( ) ; } // ▁ Continue ▁ with ▁ rest ▁ of ▁ filtering ▁ below ENDCOM } else { // ▁ Do ▁ limited ▁ filtering ▁ if ▁ shutting ▁ down ▁ to ▁ allow ▁ RPC ▁ ENDCOM // ▁ completion ▁ events ▁ but ▁ not ▁ events ▁ which ▁ start ▁ new ▁ RPCs ENDCOM if ( ! m_bFilterEvents ) return - 1 ; } // ▁ Allow ▁ all ▁ except ▁ Command , ▁ Timer ▁ and ▁ Mouse ▁ Moved ▁ events ENDCOM if ( event . IsCommandEvent ( ) ) { return false ; } if ( theEventType == wxEVT_TIMER ) { return false ; } # ifdef __WXMSW__ if ( theEventType == wxEVT_TASKBAR_MOVE ) { return false ; } # endif return - 1 ; } </DOCUMENT>
<DOCUMENT_ID="jeppeter/mysql56/tree/master/storage/ndb/src/cw/cpcd/Monitor.cpp"> /* STRNEWLINE ▁ Copyright ▁ ( C ) ▁ 2003-2006 ▁ MySQL ▁ AB , ▁ 2009 ▁ Sun ▁ Microsystems , ▁ Inc . STRNEWLINE ▁ All ▁ rights ▁ reserved . ▁ Use ▁ is ▁ subject ▁ to ▁ license ▁ terms . STRNEWLINE STRNEWLINE ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ version ▁ 2 ▁ of ▁ the ▁ License . STRNEWLINE STRNEWLINE ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE STRNEWLINE ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software STRNEWLINE ▁ Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ St , ▁ Fifth ▁ Floor , ▁ Boston , ▁ MA ▁ 02110-1301 ▁ USA STRNEWLINE */ # include < ndb_global . h > # include < NdbThread . h > # include < NdbOut . hpp > # include < NdbSleep . h > # include " CPCD . hpp " # include " common . hpp " static void * monitor_thread_create_wrapper ( void * arg ) { CPCD :: Monitor * mon = ( CPCD :: Monitor * ) arg ; mon -> run ( ) ; return NULL ; } CPCD :: Monitor :: Monitor ( CPCD * cpcd , int poll ) { m_cpcd = cpcd ; m_pollingInterval = poll ; m_changeCondition = NdbCondition_Create ( ) ; m_changeMutex = NdbMutex_Create ( ) ; m_monitorThread = NdbThread_Create ( monitor_thread_create_wrapper , ( NDB_THREAD_ARG * ) this , 0 , // ▁ default ▁ stack ▁ size ENDCOM " ndb _ cpcd _ monitor " , NDB_THREAD_PRIO_MEAN ) ; m_monitorThreadQuitFlag = false ; } CPCD :: Monitor :: ~ Monitor ( ) { NdbThread_Destroy ( & m_monitorThread ) ; NdbCondition_Destroy ( m_changeCondition ) ; NdbMutex_Destroy ( m_changeMutex ) ; } void CPCD :: Monitor :: run ( ) { while ( 1 ) { NdbMutex_Lock ( m_changeMutex ) ; NdbCondition_WaitTimeout ( m_changeCondition , m_changeMutex , m_pollingInterval * 1000 ) ; MutexVector < CPCD :: Process * > & proc = * m_cpcd -> getProcessList ( ) ; proc . lock ( ) ; for ( size_t i = 0 ; i < proc . size ( ) ; i ++ ) { proc [ i ] -> monitor ( ) ; } proc . unlock ( ) ; NdbMutex_Unlock ( m_changeMutex ) ; } } void CPCD :: Monitor :: signal ( ) { NdbCondition_Signal ( m_changeCondition ) ; } template class MutexVector < CPCD :: Process * > ; </DOCUMENT>
<DOCUMENT_ID="asuradaimao/dolphin/tree/master/Source/Core/Core/PowerPC/Interpreter/Interpreter_Integer.cpp"> // ▁ Copyright ▁ 2008 ▁ Dolphin ▁ Emulator ▁ Project ENDCOM // ▁ Licensed ▁ under ▁ GPLv2 + ENDCOM // ▁ Refer ▁ to ▁ the ▁ license . txt ▁ file ▁ included . ENDCOM # include " Core / PowerPC / Interpreter / Interpreter . h " void Interpreter :: Helper_UpdateCR0 ( u32 value ) { s64 sign_extended = ( s64 ) ( s32 ) value ; u64 cr_val = ( u64 ) sign_extended ; cr_val = ( cr_val & ~ ( 1ull << 61 ) ) | ( ( u64 ) GetXER_SO ( ) << 61 ) ; PowerPC :: ppcState . cr_val [ 0 ] = cr_val ; } void Interpreter :: Helper_UpdateCRx ( int idx , u32 value ) { s64 sign_extended = ( s64 ) ( s32 ) value ; u64 cr_val = ( u64 ) sign_extended ; cr_val = ( cr_val & ~ ( 1ull << 61 ) ) | ( ( u64 ) GetXER_SO ( ) << 61 ) ; PowerPC :: ppcState . cr_val [ idx ] = cr_val ; } u32 Interpreter :: Helper_Carry ( u32 _uValue1 , u32 _uValue2 ) { return _uValue2 > ( ~ _uValue1 ) ; } u32 Interpreter :: Helper_Mask ( int mb , int me ) { // first ▁ make ▁ 0011111 ▁ part ENDCOM u32 begin = 0xFFFFFFFF >> mb ; // then ▁ make ▁ 000001111 ▁ part , ▁ which ▁ is ▁ used ▁ to ▁ flip ▁ the ▁ bits ▁ of ▁ the ▁ first ▁ one ENDCOM u32 end = me < 31 ? ( 0xFFFFFFFF >> ( me + 1 ) ) : 0 ; // do ▁ the ▁ bitflip ENDCOM u32 mask = begin ^ end ; // and ▁ invert ▁ if ▁ backwards ENDCOM if ( me < mb ) return ~ mask ; else return mask ; } void Interpreter :: addi ( UGeckoInstruction _inst ) { if ( _inst . RA ) rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + _inst . SIMM_16 ; else rGPR [ _inst . RD ] = _inst . SIMM_16 ; } void Interpreter :: addic ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 imm = ( u32 ) ( s32 ) _inst . SIMM_16 ; // ▁ TODO ( ector ) : ▁ verify ▁ this ▁ thing ENDCOM rGPR [ _inst . RD ] = a + imm ; SetCarry ( Helper_Carry ( a , imm ) ) ; } void Interpreter :: addic_rc ( UGeckoInstruction _inst ) { addic ( _inst ) ; Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addis ( UGeckoInstruction _inst ) { if ( _inst . RA ) rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + ( _inst . SIMM_16 << 16 ) ; else rGPR [ _inst . RD ] = ( _inst . SIMM_16 << 16 ) ; } void Interpreter :: andi_rc ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & _inst . UIMM ; Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: andis_rc ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & ( ( u32 ) _inst . UIMM << 16 ) ; Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: cmpi ( UGeckoInstruction _inst ) { Helper_UpdateCRx ( _inst . CRFD , rGPR [ _inst . RA ] - _inst . SIMM_16 ) ; } void Interpreter :: cmpli ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = _inst . UIMM ; int f ; if ( a < b ) f = 0x8 ; else if ( a > b ) f = 0x4 ; else f = 0x2 ; // equals ENDCOM if ( GetXER_SO ( ) ) f |= 0x1 ; SetCRField ( _inst . CRFD , f ) ; } void Interpreter :: mulli ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = ( s32 ) rGPR [ _inst . RA ] * _inst . SIMM_16 ; } void Interpreter :: ori ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | _inst . UIMM ; } void Interpreter :: oris ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | ( _inst . UIMM << 16 ) ; } void Interpreter :: subfic ( UGeckoInstruction _inst ) { /* TABSYMBOL u32 ▁ rra ▁ = ▁ ~ rGPR [ _ inst . RA ] ; STRNEWLINE TABSYMBOL s32 ▁ immediate ▁ = ▁ ( s16 ) _ inst . SIMM _ 16 ▁ + ▁ 1 ; STRNEWLINE STRNEWLINE // TABSYMBOL # define ▁ CALC _ XER _ CA ( X , Y ) ▁ ( ( ( X ) ▁ + ▁ ( Y ) ▁ < ▁ X ) ▁ ? ▁ SET _ XER _ CA ▁ : ▁ CLEAR _ XER _ CA ) STRNEWLINE TABSYMBOL if ▁ ( ( rra ▁ + ▁ immediate ) ▁ < ▁ rra ) STRNEWLINE TABSYMBOL TABSYMBOL SetCarry ( 1 ) ; STRNEWLINE TABSYMBOL else STRNEWLINE TABSYMBOL TABSYMBOL SetCarry ( 0 ) ; STRNEWLINE STRNEWLINE TABSYMBOL rGPR [ _ inst . RD ] ▁ = ▁ rra ▁ - ▁ immediate ; STRNEWLINE */ s32 immediate = _inst . SIMM_16 ; rGPR [ _inst . RD ] = immediate - ( int ) rGPR [ _inst . RA ] ; SetCarry ( ( rGPR [ _inst . RA ] == 0 ) || ( Helper_Carry ( 0 - rGPR [ _inst . RA ] , immediate ) ) ) ; } void Interpreter :: twi ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = _inst . SIMM_16 ; s32 TO = _inst . TO ; DEBUG_LOG ( POWERPC , " twi ▁ rA ▁ % x ▁ SIMM ▁ % x ▁ TO ▁ % 0x " , a , b , TO ) ; if ( ( ( a < b ) && ( TO & 0x10 ) ) || ( ( a > b ) && ( TO & 0x08 ) ) || ( ( a == b ) && ( TO & 0x04 ) ) || ( ( ( u32 ) a < ( u32 ) b ) && ( TO & 0x02 ) ) || ( ( ( u32 ) a > ( u32 ) b ) && ( TO & 0x01 ) ) ) { PowerPC :: ppcState . Exceptions |= EXCEPTION_PROGRAM ; PowerPC :: CheckExceptions ( ) ; m_EndBlock = true ; // ▁ Dunno ▁ about ▁ this ENDCOM } } void Interpreter :: xori ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ _inst . UIMM ; } void Interpreter :: xoris ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ ( _inst . UIMM << 16 ) ; } void Interpreter :: rlwimix ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = ( rGPR [ _inst . RA ] & ~ mask ) | ( _rotl ( rGPR [ _inst . RS ] , _inst . SH ) & mask ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: rlwinmx ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = _rotl ( rGPR [ _inst . RS ] , _inst . SH ) & mask ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: rlwnmx ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = _rotl ( rGPR [ _inst . RS ] , rGPR [ _inst . RB ] & 0x1F ) & mask ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: andx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: andcx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & ~ rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: cmp ( UGeckoInstruction _inst ) { s32 a = ( s32 ) rGPR [ _inst . RA ] ; s32 b = ( s32 ) rGPR [ _inst . RB ] ; int fTemp ; if ( a < b ) fTemp = 0x8 ; else if ( a > b ) fTemp = 0x4 ; else // ▁ Equals ENDCOM fTemp = 0x2 ; if ( GetXER_SO ( ) ) fTemp |= 0x1 ; SetCRField ( _inst . CRFD , fTemp ) ; } void Interpreter :: cmpl ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 fTemp ; if ( a < b ) fTemp = 0x8 ; else if ( a > b ) fTemp = 0x4 ; else // ▁ Equals ENDCOM fTemp = 0x2 ; if ( GetXER_SO ( ) ) fTemp |= 0x1 ; SetCRField ( _inst . CRFD , fTemp ) ; } void Interpreter :: cntlzwx ( UGeckoInstruction _inst ) { u32 val = rGPR [ _inst . RS ] ; u32 mask = 0x80000000 ; int i = 0 ; for ( ; i < 32 ; i ++ , mask >>= 1 ) { if ( val & mask ) break ; } rGPR [ _inst . RA ] = i ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: eqvx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] ^ rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: extsbx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ( u32 ) ( s32 ) ( s8 ) rGPR [ _inst . RS ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: extshx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ( u32 ) ( s32 ) ( s16 ) rGPR [ _inst . RS ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: nandx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] & rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: norx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] | rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: orx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: orcx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | ( ~ rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: slwx ( UGeckoInstruction _inst ) { u32 amount = rGPR [ _inst . RB ] ; rGPR [ _inst . RA ] = ( amount & 0x20 ) ? 0 : rGPR [ _inst . RS ] << ( amount & 0x1f ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: srawx ( UGeckoInstruction _inst ) { int rb = rGPR [ _inst . RB ] ; if ( rb & 0x20 ) { if ( rGPR [ _inst . RS ] & 0x80000000 ) { rGPR [ _inst . RA ] = 0xFFFFFFFF ; SetCarry ( 1 ) ; } else { rGPR [ _inst . RA ] = 0x00000000 ; SetCarry ( 0 ) ; } } else { int amount = rb & 0x1f ; if ( amount == 0 ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ; SetCarry ( 0 ) ; } else { s32 rrs = rGPR [ _inst . RS ] ; rGPR [ _inst . RA ] = rrs >> amount ; if ( ( rrs < 0 ) && ( rrs << ( 32 - amount ) ) ) SetCarry ( 1 ) ; else SetCarry ( 0 ) ; } } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: srawix ( UGeckoInstruction _inst ) { int amount = _inst . SH ; if ( amount != 0 ) { s32 rrs = rGPR [ _inst . RS ] ; rGPR [ _inst . RA ] = rrs >> amount ; if ( ( rrs < 0 ) && ( rrs << ( 32 - amount ) ) ) SetCarry ( 1 ) ; else SetCarry ( 0 ) ; } else { SetCarry ( 0 ) ; rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: srwx ( UGeckoInstruction _inst ) { u32 amount = rGPR [ _inst . RB ] ; rGPR [ _inst . RA ] = ( amount & 0x20 ) ? 0 : ( rGPR [ _inst . RS ] >> ( amount & 0x1f ) ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: tw ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = rGPR [ _inst . RB ] ; s32 TO = _inst . TO ; DEBUG_LOG ( POWERPC , " tw ▁ rA ▁ % 0x ▁ rB ▁ % 0x ▁ TO ▁ % 0x " , a , b , TO ) ; if ( ( ( a < b ) && ( TO & 0x10 ) ) || ( ( a > b ) && ( TO & 0x08 ) ) || ( ( a == b ) && ( TO & 0x04 ) ) || ( ( ( u32 ) a < ( u32 ) b ) && ( TO & 0x02 ) ) || ( ( ( u32 ) a > ( u32 ) b ) && ( TO & 0x01 ) ) ) { PowerPC :: ppcState . Exceptions |= EXCEPTION_PROGRAM ; PowerPC :: CheckExceptions ( ) ; m_EndBlock = true ; // ▁ Dunno ▁ about ▁ this ENDCOM } } void Interpreter :: xorx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: addx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + rGPR [ _inst . RB ] ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addcx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = a + b ; SetCarry ( Helper_Carry ( a , b ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addcx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; int b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = a + b + carry ; SetCarry ( Helper_Carry ( a , b ) || ( carry != 0 && Helper_Carry ( a + b , carry ) ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addmex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; rGPR [ _inst . RD ] = a + carry - 1 ; SetCarry ( Helper_Carry ( a , carry - 1 ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addmex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addzex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; rGPR [ _inst . RD ] = a + carry ; SetCarry ( Helper_Carry ( a , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addzex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: divwx ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = rGPR [ _inst . RB ] ; if ( b == 0 || ( ( u32 ) a == 0x80000000 && b == - 1 ) ) { if ( _inst . OE ) { // ▁ should ▁ set ▁ OV ENDCOM PanicAlert ( " OE : ▁ divwx " ) ; } if ( ( ( u32 ) a & 0x80000000 ) && b == 0 ) rGPR [ _inst . RD ] = - 1 ; else rGPR [ _inst . RD ] = 0 ; } else { rGPR [ _inst . RD ] = ( u32 ) ( a / b ) ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: divwux ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; if ( b == 0 ) { if ( _inst . OE ) { // ▁ should ▁ set ▁ OV ENDCOM PanicAlert ( " OE : ▁ divwux " ) ; } rGPR [ _inst . RD ] = 0 ; } else { rGPR [ _inst . RD ] = a / b ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: mulhwx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( u64 ) ( ( ( s64 ) ( s32 ) a * ( s64 ) ( s32 ) b ) ) >> 32 ) ; // ▁ This ▁ can ▁ be ▁ done ▁ better . ▁ Not ▁ in ▁ plain ▁ C / C + + ▁ though . ENDCOM rGPR [ _inst . RD ] = d ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: mulhwux ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( ( u64 ) a * ( u64 ) b ) >> 32 ) ; rGPR [ _inst . RD ] = d ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: mullwx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( s32 ) a * ( s32 ) b ) ; rGPR [ _inst . RD ] = d ; if ( _inst . OE ) PanicAlert ( " OE : ▁ mullwx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: negx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = ( ~ rGPR [ _inst . RA ] ) + 1 ; if ( rGPR [ _inst . RD ] == 0x80000000 ) { if ( _inst . OE ) PanicAlert ( " OE : ▁ negx " ) ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = rGPR [ _inst . RB ] - rGPR [ _inst . RA ] ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfcx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = b - a ; SetCarry ( a == 0 || Helper_Carry ( b , 0 - a ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfcx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + b + carry ; SetCarry ( Helper_Carry ( ~ a , b ) || Helper_Carry ( ( ~ a ) + b , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } // ▁ sub ▁ from ▁ minus ▁ one ENDCOM void Interpreter :: subfmex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + carry - 1 ; SetCarry ( Helper_Carry ( ~ a , carry - 1 ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfmex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } // ▁ sub ▁ from ▁ zero ENDCOM void Interpreter :: subfzex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + carry ; SetCarry ( Helper_Carry ( ~ a , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfzex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } </DOCUMENT>
<DOCUMENT_ID="CharlieMarshall/xbmc/tree/master/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagMicroDVD.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2005-2013 ▁ Team ▁ XBMC STRNEWLINE ▁ * ▁ http : // xbmc . org STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ Program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 , ▁ or ▁ ( at ▁ your ▁ option ) STRNEWLINE ▁ * ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ Program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ XBMC ; ▁ see ▁ the ▁ file ▁ COPYING . ▁ If ▁ not , ▁ see STRNEWLINE ▁ * ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ * STRNEWLINE ▁ */ # include " DVDSubtitleTagMicroDVD . h " # include " DVDCodecs / Overlay / DVDOverlayText . h " # include " utils / StdString . h " # include " utils / StringUtils . h " void CDVDSubtitleTagMicroDVD :: ConvertLine ( CDVDOverlayText * pOverlay , const char * line , int len ) { CStdString strUTF8 ; strUTF8 . assign ( line , len ) ; m_flag [ FLAG_BOLD ] = 0 ; m_flag [ FLAG_ITALIC ] = 0 ; m_flag [ FLAG_COLOR ] = 0 ; int machine_status = 1 ; size_t pos = 0 ; while ( machine_status > 0 ) { if ( machine_status == 1 ) { if ( strUTF8 [ pos ] == ' { ' ) { size_t pos2 , pos3 ; if ( ( ( pos2 = strUTF8 . find ( ' : ' , pos ) ) != CStdString :: npos ) && ( ( pos3 = strUTF8 . find ( ' } ' , pos2 ) ) != CStdString :: npos ) ) { CStdString tagName = strUTF8 . substr ( pos + 1 , pos2 - pos - 1 ) ; CStdString tagValue = strUTF8 . substr ( pos2 + 1 , pos3 - pos2 - 1 ) ; StringUtils :: ToLower ( tagValue ) ; strUTF8 . erase ( pos , pos3 - pos + 1 ) ; if ( ( tagName == " Y " ) || ( tagName == " y " ) ) { if ( ( tagValue == " b " ) && ( m_flag [ FLAG_BOLD ] == 0 ) ) { m_flag [ FLAG_BOLD ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ B ] " ) ; pos += 3 ; } else if ( ( tagValue == " i " ) && ( m_flag [ FLAG_ITALIC ] == 0 ) ) { m_flag [ FLAG_ITALIC ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ I ] " ) ; pos += 3 ; } } else if ( ( tagName == " C " ) || ( tagName == " c " ) ) { if ( ( tagValue [ 0 ] == ' $ ' ) && ( tagValue . size ( ) == 7 ) ) { bool bHex = true ; for ( int i = 1 ; i < 7 ; i ++ ) { char temp = tagValue [ i ] ; if ( ! ( ( '0' <= temp && temp <= '9' ) || ( ' a ' <= temp && temp <= ' f ' ) || ( ' A ' <= temp && temp <= ' F ' ) ) ) { bHex = false ; break ; } } if ( bHex && ( m_flag [ FLAG_COLOR ] == 0 ) ) { CStdString tempColorTag = " [ COLOR ▁ " ; tempColorTag += " FF " ; tempColorTag += tagValue . substr ( 1 , 6 ) ; tempColorTag += " ] " ; m_flag [ FLAG_COLOR ] = ( tagName == " C " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , tempColorTag ) ; pos += tempColorTag . length ( ) ; } } } } else machine_status = 2 ; } else if ( strUTF8 [ pos ] == ' / ' ) { if ( m_flag [ FLAG_ITALIC ] == 0 ) { m_flag [ FLAG_ITALIC ] = TAG_ONE_LINE ; strUTF8 . replace ( pos , 1 , " [ I ] " ) ; pos += 3 ; } else strUTF8 . erase ( pos , 1 ) ; } else machine_status = 2 ; } else if ( machine_status == 2 ) { size_t pos4 ; if ( ( pos4 = strUTF8 . find ( ' | ' , pos ) ) != CStdString :: npos ) { pos = pos4 ; if ( m_flag [ FLAG_BOLD ] == TAG_ONE_LINE ) { m_flag [ FLAG_BOLD ] = 0 ; strUTF8 . insert ( pos , " [ / B ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_ITALIC ] == TAG_ONE_LINE ) { m_flag [ FLAG_ITALIC ] = 0 ; strUTF8 . insert ( pos , " [ / I ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_COLOR ] == TAG_ONE_LINE ) { m_flag [ FLAG_COLOR ] = 0 ; strUTF8 . insert ( pos , " [ / COLOR ] " ) ; pos += 8 ; } strUTF8 . replace ( pos , 1 , " [ CR ] " ) ; pos += 4 ; machine_status = 1 ; } else { if ( m_flag [ FLAG_BOLD ] != 0 ) strUTF8 . append ( " [ / B ] " ) ; if ( m_flag [ FLAG_ITALIC ] != 0 ) strUTF8 . append ( " [ / I ] " ) ; if ( m_flag [ FLAG_COLOR ] != 0 ) strUTF8 . append ( " [ / COLOR ] " ) ; machine_status = 0 ; } } } if ( strUTF8 . empty ( ) ) return ; if ( strUTF8 [ strUTF8 . size ( ) - 1 ] == ' \n ' ) strUTF8 . erase ( strUTF8 . size ( ) - 1 ) ; // ▁ add ▁ a ▁ new ▁ text ▁ element ▁ to ▁ our ▁ container ENDCOM pOverlay -> AddElement ( new CDVDOverlayText :: CElementText ( strUTF8 . c_str ( ) ) ) ; } </DOCUMENT>
<DOCUMENT_ID="murraymeehan/marsyas/tree/master/src/otherlibs/ANN/kd_pr_search.cpp"> // ▁ File : TABSYMBOL TABSYMBOL TABSYMBOL kd _ pr _ search . cpp ENDCOM // ▁ Programmer : TABSYMBOL TABSYMBOL Sunil ▁ Arya ▁ and ▁ David ▁ Mount ENDCOM // ▁ Description : TABSYMBOL TABSYMBOL Priority ▁ search ▁ for ▁ kd - trees ENDCOM // ▁ Last ▁ modified : TABSYMBOL 01/04/05 ▁ ( Version ▁ 1.0 ) ENDCOM // ▁ Copyright ▁ ( c ) ▁ 1997-2005 ▁ University ▁ of ▁ Maryland ▁ and ▁ Sunil ▁ Arya ▁ and ENDCOM // ▁ David ▁ Mount . ▁ All ▁ Rights ▁ Reserved . ENDCOM // ▁ This ▁ software ▁ and ▁ related ▁ documentation ▁ is ▁ part ▁ of ▁ the ▁ Approximate ENDCOM // ▁ Nearest ▁ Neighbor ▁ Library ▁ ( ANN ) . ▁ This ▁ software ▁ is ▁ provided ▁ under ENDCOM // ▁ the ▁ provisions ▁ of ▁ the ▁ Lesser ▁ GNU ▁ Public ▁ License ▁ ( LGPL ) . ▁ See ▁ the ENDCOM // ▁ file ▁ . . / ReadMe . txt ▁ for ▁ further ▁ information . ENDCOM // ▁ The ▁ University ▁ of ▁ Maryland ▁ ( U . M . ) ▁ and ▁ the ▁ authors ▁ make ▁ no ENDCOM // ▁ representations ▁ about ▁ the ▁ suitability ▁ or ▁ fitness ▁ of ▁ this ▁ software ▁ for ENDCOM // ▁ any ▁ purpose . ▁ It ▁ is ▁ provided ▁ " as ▁ is " ▁ without ▁ express ▁ or ▁ implied ENDCOM // ▁ warranty . ENDCOM // ▁ History : ENDCOM // TABSYMBOL Revision ▁ 0.1 ▁ 03/04/98 ENDCOM // TABSYMBOL TABSYMBOL Initial ▁ release ENDCOM # include " kd _ pr _ search . h " // ▁ kd ▁ priority ▁ search ▁ declarations ENDCOM // TABSYMBOL Approximate ▁ nearest ▁ neighbor ▁ searching ▁ by ▁ priority ▁ search . ENDCOM // TABSYMBOL TABSYMBOL The ▁ kd - tree ▁ is ▁ searched ▁ for ▁ an ▁ approximate ▁ nearest ▁ neighbor . ENDCOM // TABSYMBOL TABSYMBOL The ▁ point ▁ is ▁ returned ▁ through ▁ one ▁ of ▁ the ▁ arguments , ▁ and ▁ the ENDCOM // TABSYMBOL TABSYMBOL distance ▁ returned ▁ is ▁ the ▁ SQUARED ▁ distance ▁ to ▁ this ▁ point . ENDCOM // TABSYMBOL TABSYMBOL The ▁ method ▁ used ▁ for ▁ searching ▁ the ▁ kd - tree ▁ is ▁ called ▁ priority ENDCOM // TABSYMBOL TABSYMBOL search . ▁ ( It ▁ is ▁ described ▁ in ▁ Arya ▁ and ▁ Mount , ▁ ` ` Algorithms ▁ for ENDCOM // TABSYMBOL TABSYMBOL fast ▁ vector ▁ quantization , ' ' ▁ Proc . ▁ of ▁ DCC ▁ ' 93 : ▁ Data ▁ Compression ENDCOM // TABSYMBOL TABSYMBOL Conference } , ▁ eds . ▁ J . ▁ A . ▁ Storer ▁ and ▁ M . ▁ Cohn , ▁ IEEE ▁ Press , ▁ 1993 , ENDCOM // TABSYMBOL TABSYMBOL 381 - - 390 . ) ENDCOM // TABSYMBOL TABSYMBOL The ▁ cell ▁ of ▁ the ▁ kd - tree ▁ containing ▁ the ▁ query ▁ point ▁ is ▁ located , ENDCOM // TABSYMBOL TABSYMBOL and ▁ cells ▁ are ▁ visited ▁ in ▁ increasing ▁ order ▁ of ▁ distance ▁ from ▁ the ENDCOM // TABSYMBOL TABSYMBOL query ▁ point . ▁ This ▁ is ▁ done ▁ by ▁ placing ▁ each ▁ subtree ▁ which ▁ has ENDCOM // TABSYMBOL TABSYMBOL NOT ▁ been ▁ visited ▁ in ▁ a ▁ priority ▁ queue , ▁ according ▁ to ▁ the ▁ closest ENDCOM // TABSYMBOL TABSYMBOL distance ▁ of ▁ the ▁ corresponding ▁ enclosing ▁ rectangle ▁ from ▁ the ENDCOM // TABSYMBOL TABSYMBOL query ▁ point . ▁ The ▁ search ▁ stops ▁ when ▁ the ▁ distance ▁ to ▁ the ▁ nearest ENDCOM // TABSYMBOL TABSYMBOL remaining ▁ rectangle ▁ exceeds ▁ the ▁ distance ▁ to ▁ the ▁ nearest ▁ point ENDCOM // TABSYMBOL TABSYMBOL seen ▁ by ▁ a ▁ factor ▁ of ▁ more ▁ than ▁ 1 / ( 1 + eps ) . ▁ ( Implying ▁ that ▁ any ENDCOM // TABSYMBOL TABSYMBOL point ▁ found ▁ subsequently ▁ in ▁ the ▁ search ▁ cannot ▁ be ▁ closer ▁ by ▁ more ENDCOM // TABSYMBOL TABSYMBOL than ▁ this ▁ factor . ) ENDCOM // TABSYMBOL TABSYMBOL The ▁ main ▁ entry ▁ point ▁ is ▁ annkPriSearch ( ) ▁ which ▁ sets ▁ things ▁ up ▁ and ENDCOM // TABSYMBOL TABSYMBOL then ▁ call ▁ the ▁ recursive ▁ routine ▁ ann _ pri _ search ( ) . ▁ This ▁ is ▁ a ENDCOM // TABSYMBOL TABSYMBOL recursive ▁ routine ▁ which ▁ performs ▁ the ▁ processing ▁ for ▁ one ▁ node ▁ in ENDCOM // TABSYMBOL TABSYMBOL the ▁ kd - tree . ▁ There ▁ are ▁ two ▁ versions ▁ of ▁ this ▁ virtual ▁ procedure , ENDCOM // TABSYMBOL TABSYMBOL one ▁ for ▁ splitting ▁ nodes ▁ and ▁ one ▁ for ▁ leaves . ▁ When ▁ a ▁ splitting ▁ node ENDCOM // TABSYMBOL TABSYMBOL is ▁ visited , ▁ we ▁ determine ▁ which ▁ child ▁ to ▁ continue ▁ the ▁ search ▁ on ENDCOM // TABSYMBOL TABSYMBOL ( the ▁ closer ▁ one ) , ▁ and ▁ insert ▁ the ▁ other ▁ child ▁ into ▁ the ▁ priority ENDCOM // TABSYMBOL TABSYMBOL queue . ▁ When ▁ a ▁ leaf ▁ is ▁ visited , ▁ we ▁ compute ▁ the ▁ distances ▁ to ▁ the ENDCOM // TABSYMBOL TABSYMBOL points ▁ in ▁ the ▁ buckets , ▁ and ▁ update ▁ information ▁ on ▁ the ▁ closest ENDCOM // TABSYMBOL TABSYMBOL points . ENDCOM // TABSYMBOL TABSYMBOL Some ▁ trickery ▁ is ▁ used ▁ to ▁ incrementally ▁ update ▁ the ▁ distance ▁ from ENDCOM // TABSYMBOL TABSYMBOL a ▁ kd - tree ▁ rectangle ▁ to ▁ the ▁ query ▁ point . ▁ This ▁ comes ▁ about ▁ from ENDCOM // TABSYMBOL TABSYMBOL the ▁ fact ▁ that ▁ which ▁ each ▁ successive ▁ split , ▁ only ▁ one ▁ component ENDCOM // TABSYMBOL TABSYMBOL ( along ▁ the ▁ dimension ▁ that ▁ is ▁ split ) ▁ of ▁ the ▁ squared ▁ distance ▁ to ENDCOM // TABSYMBOL TABSYMBOL the ▁ child ▁ rectangle ▁ is ▁ different ▁ from ▁ the ▁ squared ▁ distance ▁ to ENDCOM // TABSYMBOL TABSYMBOL the ▁ parent ▁ rectangle . ENDCOM // TABSYMBOL TABSYMBOL To ▁ keep ▁ argument ▁ lists ▁ short , ▁ a ▁ number ▁ of ▁ global ▁ variables ENDCOM // TABSYMBOL TABSYMBOL are ▁ maintained ▁ which ▁ are ▁ common ▁ to ▁ all ▁ the ▁ recursive ▁ calls . ENDCOM // TABSYMBOL TABSYMBOL These ▁ are ▁ given ▁ below . ENDCOM double ANNprEps ; // ▁ the ▁ error ▁ bound ENDCOM int ANNprDim ; // ▁ dimension ▁ of ▁ space ENDCOM ANNpoint ANNprQ ; // ▁ query ▁ point ENDCOM double ANNprMaxErr ; // ▁ max ▁ tolerable ▁ squared ▁ error ENDCOM ANNpointArray ANNprPts ; // ▁ the ▁ points ENDCOM ANNpr_queue * ANNprBoxPQ ; // ▁ priority ▁ queue ▁ for ▁ boxes ENDCOM ANNmin_k * ANNprPointMK ; // ▁ set ▁ of ▁ k ▁ closest ▁ points ENDCOM // TABSYMBOL annkPriSearch ▁ - ▁ priority ▁ search ▁ for ▁ k ▁ nearest ▁ neighbors ENDCOM void ANNkd_tree :: annkPriSearch ( ANNpoint q , // ▁ query ▁ point ENDCOM int k , // ▁ number ▁ of ▁ near ▁ neighbors ▁ to ▁ return ENDCOM ANNidxArray nn_idx , // ▁ nearest ▁ neighbor ▁ indices ▁ ( returned ) ENDCOM ANNdistArray dd , // ▁ dist ▁ to ▁ near ▁ neighbors ▁ ( returned ) ENDCOM double eps ) // ▁ error ▁ bound ▁ ( ignored ) ENDCOM { // ▁ max ▁ tolerable ▁ squared ▁ error ENDCOM ANNprMaxErr = ANN_POW ( 1.0 + eps ) ; ANN_FLOP ( 2 ) // ▁ increment ▁ floating ▁ ops ENDCOM ANNprDim = dim ; // ▁ copy ▁ arguments ▁ to ▁ static ▁ equivs ENDCOM ANNprQ = q ; ANNprPts = pts ; ANNptsVisited = 0 ; // ▁ initialize ▁ count ▁ of ▁ points ▁ visited ENDCOM ANNprPointMK = new ANNmin_k ( k ) ; // ▁ create ▁ set ▁ for ▁ closest ▁ k ▁ points ENDCOM // ▁ distance ▁ to ▁ root ▁ box ENDCOM ANNdist box_dist = annBoxDistance ( q , bnd_box_lo , bnd_box_hi , dim ) ; ANNprBoxPQ = new ANNpr_queue ( n_pts ) ; // ▁ create ▁ priority ▁ queue ▁ for ▁ boxes ENDCOM ANNprBoxPQ -> insert ( box_dist , root ) ; // ▁ insert ▁ root ▁ in ▁ priority ▁ queue ENDCOM while ( ANNprBoxPQ -> non_empty ( ) && ( ! ( ANNmaxPtsVisited != 0 && ANNptsVisited > ANNmaxPtsVisited ) ) ) { ANNkd_ptr np ; // ▁ next ▁ box ▁ from ▁ prior ▁ queue ENDCOM // ▁ extract ▁ closest ▁ box ▁ from ▁ queue ENDCOM ANNprBoxPQ -> extr_min ( box_dist , ( void * & ) np ) ; ANN_FLOP ( 2 ) // ▁ increment ▁ floating ▁ ops ENDCOM if ( box_dist * ANNprMaxErr >= ANNprPointMK -> max_key ( ) ) break ; np -> ann_pri_search ( box_dist ) ; // ▁ search ▁ this ▁ subtree . ENDCOM } for ( int i = 0 ; i < k ; i ++ ) { // ▁ extract ▁ the ▁ k - th ▁ closest ▁ points ENDCOM dd [ i ] = ANNprPointMK -> ith_smallest_key ( i ) ; nn_idx [ i ] = ANNprPointMK -> ith_smallest_info ( i ) ; } delete ANNprPointMK ; // ▁ deallocate ▁ closest ▁ point ▁ set ENDCOM delete ANNprBoxPQ ; // ▁ deallocate ▁ priority ▁ queue ENDCOM } // TABSYMBOL kd _ split : : ann _ pri _ search ▁ - ▁ search ▁ a ▁ splitting ▁ node ENDCOM void ANNkd_split :: ann_pri_search ( ANNdist box_dist ) { ANNdist new_dist ; // ▁ distance ▁ to ▁ child ▁ visited ▁ later ENDCOM // ▁ distance ▁ to ▁ cutting ▁ plane ENDCOM ANNcoord cut_diff = ANNprQ [ cut_dim ] - cut_val ; if ( cut_diff < 0 ) { // ▁ left ▁ of ▁ cutting ▁ plane ENDCOM ANNcoord box_diff = cd_bnds [ ANN_LO ] - ANNprQ [ cut_dim ] ; if ( box_diff < 0 ) // ▁ within ▁ bounds ▁ - ▁ ignore ENDCOM box_diff = 0 ; // ▁ distance ▁ to ▁ further ▁ box ENDCOM new_dist = ( ANNdist ) ANN_SUM ( box_dist , ANN_DIFF ( ANN_POW ( box_diff ) , ANN_POW ( cut_diff ) ) ) ; if ( child [ ANN_HI ] != KD_TRIVIAL ) // ▁ enqueue ▁ if ▁ not ▁ trivial ENDCOM ANNprBoxPQ -> insert ( new_dist , child [ ANN_HI ] ) ; // ▁ continue ▁ with ▁ closer ▁ child ENDCOM child [ ANN_LO ] -> ann_pri_search ( box_dist ) ; } else { // ▁ right ▁ of ▁ cutting ▁ plane ENDCOM ANNcoord box_diff = ANNprQ [ cut_dim ] - cd_bnds [ ANN_HI ] ; if ( box_diff < 0 ) // ▁ within ▁ bounds ▁ - ▁ ignore ENDCOM box_diff = 0 ; // ▁ distance ▁ to ▁ further ▁ box ENDCOM new_dist = ( ANNdist ) ANN_SUM ( box_dist , ANN_DIFF ( ANN_POW ( box_diff ) , ANN_POW ( cut_diff ) ) ) ; if ( child [ ANN_LO ] != KD_TRIVIAL ) // ▁ enqueue ▁ if ▁ not ▁ trivial ENDCOM ANNprBoxPQ -> insert ( new_dist , child [ ANN_LO ] ) ; // ▁ continue ▁ with ▁ closer ▁ child ENDCOM child [ ANN_HI ] -> ann_pri_search ( box_dist ) ; } ANN_SPL ( 1 ) // ▁ one ▁ more ▁ splitting ▁ node ▁ visited ENDCOM ANN_FLOP ( 8 ) // ▁ increment ▁ floating ▁ ops ENDCOM } // TABSYMBOL kd _ leaf : : ann _ pri _ search ▁ - ▁ search ▁ points ▁ in ▁ a ▁ leaf ▁ node ENDCOM // TABSYMBOL TABSYMBOL This ▁ is ▁ virtually ▁ identical ▁ to ▁ the ▁ ann _ search ▁ for ▁ standard ▁ search . ENDCOM void ANNkd_leaf :: ann_pri_search ( ANNdist box_dist ) { register ANNdist dist ; // ▁ distance ▁ to ▁ data ▁ point ENDCOM register ANNcoord * pp ; // ▁ data ▁ coordinate ▁ pointer ENDCOM register ANNcoord * qq ; // ▁ query ▁ coordinate ▁ pointer ENDCOM register ANNdist min_dist ; // ▁ distance ▁ to ▁ k - th ▁ closest ▁ point ENDCOM register ANNcoord t ; register int d ; min_dist = ANNprPointMK -> max_key ( ) ; // ▁ k - th ▁ smallest ▁ distance ▁ so ▁ far ENDCOM for ( int i = 0 ; i < n_pts ; i ++ ) { // ▁ check ▁ points ▁ in ▁ bucket ENDCOM pp = ANNprPts [ bkt [ i ] ] ; // ▁ first ▁ coord ▁ of ▁ next ▁ data ▁ point ENDCOM qq = ANNprQ ; // ▁ first ▁ coord ▁ of ▁ query ▁ point ENDCOM dist = 0 ; for ( d = 0 ; d < ANNprDim ; d ++ ) { ANN_COORD ( 1 ) // ▁ one ▁ more ▁ coordinate ▁ hit ENDCOM ANN_FLOP ( 4 ) // ▁ increment ▁ floating ▁ ops ENDCOM t = * ( qq ++ ) - * ( pp ++ ) ; // ▁ compute ▁ length ▁ and ▁ adv ▁ coordinate ENDCOM // ▁ exceeds ▁ dist ▁ to ▁ k - th ▁ smallest ? ENDCOM if ( ( dist = ANN_SUM ( dist , ANN_POW ( t ) ) ) > min_dist ) { break ; } } if ( d >= ANNprDim && // ▁ among ▁ the ▁ k ▁ best ? ENDCOM ( ANN_ALLOW_SELF_MATCH || dist != 0 ) ) { // ▁ and ▁ no ▁ self - match ▁ problem ENDCOM // ▁ add ▁ it ▁ to ▁ the ▁ list ENDCOM ANNprPointMK -> insert ( dist , bkt [ i ] ) ; min_dist = ANNprPointMK -> max_key ( ) ; } } ANN_LEAF ( 1 ) // ▁ one ▁ more ▁ leaf ▁ node ▁ visited ENDCOM ANN_PTS ( n_pts ) // ▁ increment ▁ points ▁ visited ENDCOM ANNptsVisited += n_pts ; // ▁ increment ▁ number ▁ of ▁ points ▁ visited ENDCOM } </DOCUMENT>
<DOCUMENT_ID="ElvishArtisan/rivendell/tree/master/ripcd/btsrc8iii.cpp"> // ▁ btsrc8iii . cpp ENDCOM // ▁ A ▁ Rivendell ▁ switcher ▁ driver ▁ for ▁ the ▁ BroadcastTools ▁ SRC - 8 ▁ III ENDCOM // ▁ ( C ) ▁ Copyright ▁ 2002-2019 ▁ Fred ▁ Gleason ▁ < fredg @ paravelsystems . com > ENDCOM // ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM // ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ version ▁ 2 ▁ as ENDCOM // ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation . ENDCOM // ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM // ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM // ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM // ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM // ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ENDCOM // ▁ License ▁ along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ENDCOM // ▁ Foundation , ▁ Inc . , ▁ 675 ▁ Mass ▁ Ave , ▁ Cambridge , ▁ MA ▁ 02139 , ▁ USA . ENDCOM # include < stdlib . h > # include < qtimer . h > # include < rdapplication . h > # include " btsrc8iii . h " # include " globals . h " BtSrc8Iii :: BtSrc8Iii ( RDMatrix * matrix , QObject * parent ) : Switcher ( matrix , parent ) { // ▁ Initialize ▁ Data ▁ Structures ENDCOM bt_istate = 0 ; for ( int i = 0 ; i < BTSRC8III_GPIO_PINS ; i ++ ) { bt_gpi_state [ i ] = false ; bt_gpi_mask [ i ] = false ; } // ▁ Get ▁ Matrix ▁ Parameters ENDCOM bt_matrix = matrix -> matrix ( ) ; bt_gpis = matrix -> gpis ( ) ; bt_gpos = matrix -> gpos ( ) ; // ▁ Initialize ▁ the ▁ TTY ▁ Port ENDCOM RDTty * tty = new RDTty ( rda -> station ( ) -> name ( ) , matrix -> port ( RDMatrix :: Primary ) ) ; bt_device = new RDTTYDevice ( ) ; if ( tty -> active ( ) ) { bt_device -> setName ( tty -> port ( ) ) ; bt_device -> setSpeed ( tty -> baudRate ( ) ) ; bt_device -> setWordLength ( tty -> dataBits ( ) ) ; bt_device -> setParity ( tty -> parity ( ) ) ; bt_device -> open ( QIODevice :: Unbuffered | QIODevice :: ReadWrite ) ; } delete tty ; // ▁ Interval ▁ OneShots ENDCOM bt_gpi_oneshot = new RDOneShot ( this ) ; connect ( bt_gpi_oneshot , SIGNAL ( timeout ( int ) ) , this , SLOT ( gpiOneshotData ( int ) ) ) ; bt_gpo_oneshot = new RDOneShot ( this ) ; connect ( bt_gpo_oneshot , SIGNAL ( timeout ( int ) ) , this , SLOT ( gpoOneshotData ( int ) ) ) ; // ▁ The ▁ Poll ▁ Timer ENDCOM QTimer * timer = new QTimer ( this , " poll _ timer " ) ; connect ( timer , SIGNAL ( timeout ( ) ) , this , SLOT ( processStatus ( ) ) ) ; timer -> start ( BTSRC8III_POLL_INTERVAL ) ; } BtSrc8Iii :: ~ BtSrc8Iii ( ) { delete bt_device ; delete bt_gpi_oneshot ; delete bt_gpo_oneshot ; } RDMatrix :: Type BtSrc8Iii :: type ( ) { return RDMatrix :: BtSrc8III ; } unsigned BtSrc8Iii :: gpiQuantity ( ) { return bt_gpis ; } unsigned BtSrc8Iii :: gpoQuantity ( ) { return bt_gpos ; } bool BtSrc8Iii :: primaryTtyActive ( ) { return true ; } bool BtSrc8Iii :: secondaryTtyActive ( ) { return false ; } void BtSrc8Iii :: processCommand ( RDMacro * cmd ) { char str [ 9 ] ; switch ( cmd -> command ( ) ) { case RDMacro :: GO : if ( ( cmd -> argQuantity ( ) != 5 ) || ( ( cmd -> arg ( 1 ) . lower ( ) != " i " ) && ( cmd -> arg ( 1 ) . lower ( ) != " o " ) ) || ( cmd -> arg ( 2 ) . toInt ( ) < 1 ) || ( cmd -> arg ( 3 ) . toInt ( ) > bt_gpos ) || ( cmd -> arg ( 2 ) . toInt ( ) > bt_gpos ) || ( ( cmd -> arg ( 3 ) . toInt ( ) != 1 ) && ( cmd -> arg ( 3 ) . toInt ( ) != 0 ) && ( cmd -> arg ( 1 ) . lower ( ) != " i " ) ) || ( ( cmd -> arg ( 3 ) . toInt ( ) != 1 ) && ( cmd -> arg ( 3 ) . toInt ( ) != 0 ) && ( cmd -> arg ( 3 ) . toInt ( ) != - 1 ) && ( cmd -> arg ( 1 ) . lower ( ) == " i " ) ) || ( cmd -> arg ( 4 ) . toInt ( ) < 0 ) ) { cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; return ; } if ( cmd -> arg ( 3 ) . toInt ( ) == 0 ) { // ▁ Turn ▁ OFF ENDCOM if ( cmd -> arg ( 4 ) . toInt ( ) == 0 ) { if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , false ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = false ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dF \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) ) ; bt_device -> write ( str , 8 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , false ) ; } } else { if ( cmd -> echoRequested ( ) ) { cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; } return ; } } else { if ( cmd -> arg ( 3 ) . toInt ( ) == - 1 ) { // ▁ Clear ▁ input ENDCOM bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = false ; bt_device -> write ( " * 0SPA \n " , 7 ) ; } else { if ( cmd -> arg ( 4 ) . toInt ( ) == 0 ) { // ▁ Turn ▁ ON ENDCOM if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( ! bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dL \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) ) ; bt_device -> write ( str , 8 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; } } else { // ▁ Pulse ENDCOM if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( ! bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; bt_gpi_oneshot -> start ( cmd -> arg ( 2 ) . toInt ( ) - 1 , 500 ) ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dP % 02d \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) , cmd -> arg ( 4 ) . toInt ( ) / 100 + 1 ) ; bt_device -> write ( str , 10 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpo_oneshot -> start ( cmd -> arg ( 2 ) . toInt ( ) - 1 , 500 ) ; } } } } if ( cmd -> echoRequested ( ) ) { cmd -> acknowledge ( true ) ; emit rmlEcho ( cmd ) ; } break ; default : cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; break ; } } void BtSrc8Iii :: processStatus ( ) { char buffer [ 256 ] ; int n ; int gpi ; while ( ( n = bt_device -> read ( buffer , 255 ) ) > 0 ) { for ( int i = 0 ; i < n ; i ++ ) { switch ( bt_istate ) { case 0 : if ( buffer [ i ] == ' S ' ) { bt_istate = 1 ; } break ; case 1 : if ( buffer [ i ] == ( BTSRC8III_UNIT_ID + '0' ) ) { bt_istate = 2 ; } else { bt_istate = 0 ; } break ; case 2 : if ( buffer [ i ] == ' P ' ) { bt_istate = 3 ; } else { bt_istate = 0 ; } break ; case 3 : if ( buffer [ i ] == ' , ' ) { bt_istate = 4 ; } else { bt_istate = 0 ; } break ; case 4 : if ( buffer [ i ] == ' A ' ) { bt_istate = 5 ; } else { bt_istate = 0 ; } break ; case 5 : case 7 : case 9 : case 11 : case 13 : case 15 : case 17 : case 19 : if ( buffer [ i ] == ' , ' ) { bt_istate ++ ; } else { bt_istate = 0 ; } break ; case 6 : case 8 : case 10 : case 12 : case 14 : case 16 : case 18 : case 20 : if ( buffer [ i ] == '0' ) { gpi = ( bt_istate - 6 ) / 2 ; if ( bt_gpi_state [ gpi ] && ( ! bt_gpi_mask [ gpi ] ) ) { emit gpiChanged ( bt_matrix , gpi , false ) ; bt_gpi_state [ gpi ] = false ; } bt_istate ++ ; } if ( buffer [ i ] == '1' ) { gpi = ( bt_istate - 6 ) / 2 ; if ( ( ! bt_gpi_state [ gpi ] ) && ( ! bt_gpi_mask [ gpi ] ) ) { emit gpiChanged ( bt_matrix , gpi , true ) ; bt_gpi_state [ gpi ] = true ; } bt_istate ++ ; } break ; default : bt_istate = 0 ; } } } } void BtSrc8Iii :: gpiOneshotData ( int value ) { bt_gpi_mask [ value ] = false ; bt_device -> write ( " * 0SPA " , 5 ) ; } void BtSrc8Iii :: gpoOneshotData ( int value ) { emit gpoChanged ( bt_matrix , value , false ) ; } </DOCUMENT>
<DOCUMENT_ID="Shutok/OregonCustom/tree/master/dep/g3dlite/source/Color3.cpp"> /* * STRNEWLINE ▁ @ file ▁ Color3 . cpp STRNEWLINE STRNEWLINE ▁ Color ▁ class . STRNEWLINE STRNEWLINE ▁ @ author ▁ Morgan ▁ McGuire , ▁ http : // graphics . cs . williams . edu STRNEWLINE STRNEWLINE ▁ @ created ▁ 2001-06-02 STRNEWLINE ▁ @ edited ▁ 2010-01-28 STRNEWLINE ▁ */ # include " G3D / platform . h " # include < stdlib . h > # include " G3D / Color3 . h " # include " G3D / Vector3 . h " # include " G3D / format . h " # include " G3D / BinaryInput . h " # include " G3D / BinaryOutput . h " # include " G3D / Color3uint8 . h " # include " G3D / Any . h " # include " G3D / stringutils . h " namespace G3D { Color3 :: Color3 ( const Any & any ) { * this = Color3 :: zero ( ) ; any . verifyName ( " Color3" ) ; std :: string name = toLower ( any . name ( ) ) ; switch ( any . type ( ) ) { case Any :: TABLE : for ( Any :: AnyTable :: Iterator it = any . table ( ) . begin ( ) ; it . hasMore ( ) ; ++ it ) { const std :: string & key = toLower ( it -> key ) ; if ( key == " r " ) { r = it -> value ; } else if ( key == " g " ) { g = it -> value ; } else if ( key == " b " ) { b = it -> value ; } else { any . verify ( false , " Illegal ▁ key : ▁ " + it -> key ) ; } } break ; case Any :: ARRAY : if ( name == " color3" ) { any . verifySize ( 3 ) ; r = any [ 0 ] ; g = any [ 1 ] ; b = any [ 2 ] ; } else if ( name == " color3 : : one " ) { any . verifySize ( 0 ) ; * this = one ( ) ; } else if ( name == " color3 : : zero " ) { any . verifySize ( 0 ) ; * this = zero ( ) ; } else if ( name == " color3 : : fromargb " ) { * this = Color3 :: fromARGB ( ( int ) any [ 0 ] . number ( ) ) ; } else { any . verify ( false , " Expected ▁ Color3 ▁ constructor " ) ; } break ; default : any . verify ( false , " Bad ▁ Color3 ▁ constructor " ) ; } } Color3 :: operator Any ( ) const { Any a ( Any :: ARRAY , " Color3" ) ; a . append ( r , g , b ) ; return a ; } Color3 Color3 :: ansiMap ( uint32 i ) { static const Color3 map [ ] = { Color3 :: black ( ) , Color3 :: red ( ) * 0.75f , Color3 :: green ( ) * 0.75f , Color3 :: yellow ( ) * 0.75f , Color3 :: blue ( ) * 0.75f , Color3 :: purple ( ) * 0.75f , Color3 :: cyan ( ) * 0.75f , Color3 :: white ( ) * 0.75f , Color3 :: white ( ) * 0.90f , Color3 :: red ( ) , Color3 :: green ( ) , Color3 :: yellow ( ) , Color3 :: blue ( ) , Color3 :: purple ( ) , Color3 :: cyan ( ) , Color3 :: white ( ) } ; return map [ i & 15 ] ; } Color3 Color3 :: pastelMap ( uint32 i ) { uint32 x = Crypto :: crc32 ( & i , sizeof ( uint32 ) ) ; // ▁ Create ▁ fairly ▁ bright , ▁ saturated ▁ colors ENDCOM Vector3 v ( ( ( x >> 22 ) & 1023 ) / 1023.0f , ( ( ( x >> 11 ) & 2047 ) / 2047.0f ) * 0.5f + 0.25f , ( ( x & 2047 ) / 2047.0f ) * 0.75f + 0.25f ) ; return Color3 :: fromHSV ( v ) ; } const Color3 & Color3 :: red ( ) { static Color3 c ( 1.0f , 0.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: green ( ) { static Color3 c ( 0.0f , 1.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: blue ( ) { static Color3 c ( 0.0f , 0.0f , 1.0f ) ; return c ; } const Color3 & Color3 :: purple ( ) { static Color3 c ( 0.7f , 0.0f , 1.0f ) ; return c ; } const Color3 & Color3 :: cyan ( ) { static Color3 c ( 0.0f , 0.7f , 1.0f ) ; return c ; } const Color3 & Color3 :: yellow ( ) { static Color3 c ( 1.0f , 1.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: brown ( ) { static Color3 c ( 0.5f , 0.5f , 0.0f ) ; return c ; } const Color3 & Color3 :: orange ( ) { static Color3 c ( 1.0f , 0.5f , 0.0f ) ; return c ; } const Color3 & Color3 :: black ( ) { static Color3 c ( 0.0f , 0.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: zero ( ) { static Color3 c ( 0.0f , 0.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: one ( ) { static Color3 c ( 1.0f , 1.0f , 1.0f ) ; return c ; } const Color3 & Color3 :: gray ( ) { static Color3 c ( 0.7f , 0.7f , 0.7f ) ; return c ; } const Color3 & Color3 :: white ( ) { static Color3 c ( 1 , 1 , 1 ) ; return c ; } bool Color3 :: isFinite ( ) const { return G3D :: isFinite ( r ) && G3D :: isFinite ( g ) && G3D :: isFinite ( b ) ; } Color3 :: Color3 ( BinaryInput & bi ) { deserialize ( bi ) ; } void Color3 :: deserialize ( BinaryInput & bi ) { r = bi . readFloat32 ( ) ; g = bi . readFloat32 ( ) ; b = bi . readFloat32 ( ) ; } void Color3 :: serialize ( BinaryOutput & bo ) const { bo . writeFloat32 ( r ) ; bo . writeFloat32 ( g ) ; bo . writeFloat32 ( b ) ; } const Color3 & Color3 :: wheelRandom ( ) { static const Color3 colorArray [ 8 ] = { Color3 :: blue ( ) , Color3 :: red ( ) , Color3 :: green ( ) , Color3 :: orange ( ) , Color3 :: yellow ( ) , Color3 :: cyan ( ) , Color3 :: purple ( ) , Color3 :: brown ( ) } ; return colorArray [ iRandom ( 0 , 7 ) ] ; } size_t Color3 :: hashCode ( ) const { unsigned int rhash = ( * ( int * ) ( void * ) ( & r ) ) ; unsigned int ghash = ( * ( int * ) ( void * ) ( & g ) ) ; unsigned int bhash = ( * ( int * ) ( void * ) ( & b ) ) ; return rhash + ( ghash * 37 ) + ( bhash * 101 ) ; } Color3 :: Color3 ( const Vector3 & v ) { r = v . x ; g = v . y ; b = v . z ; } Color3 :: Color3 ( const class Color3uint8 & other ) { r = other . r / 255.0f ; g = other . g / 255.0f ; b = other . b / 255.0f ; } Color3 Color3 :: fromARGB ( uint32 x ) { return Color3 ( ( float ) ( ( x >> 16 ) & 0xFF ) , ( float ) ( ( x >> 8 ) & 0xFF ) , ( float ) ( x & 0xFF ) ) / 255.0f ; } Color3 Color3 :: random ( ) { return Color3 ( uniformRandom ( ) , uniformRandom ( ) , uniformRandom ( ) ) . direction ( ) ; } Color3 & Color3 :: operator /= ( float fScalar ) { if ( fScalar != 0.0f ) { float fInvScalar = 1.0f / fScalar ; r *= fInvScalar ; g *= fInvScalar ; b *= fInvScalar ; } else { r = ( float ) G3D :: finf ( ) ; g = ( float ) G3D :: finf ( ) ; b = ( float ) G3D :: finf ( ) ; } return * this ; } float Color3 :: unitize ( float fTolerance ) { float fLength = length ( ) ; if ( fLength > fTolerance ) { float fInvLength = 1.0f / fLength ; r *= fInvLength ; g *= fInvLength ; b *= fInvLength ; } else { fLength = 0.0f ; } return fLength ; } Color3 Color3 :: fromHSV ( const Vector3 & _hsv ) { debugAssertM ( ( _hsv . x <= 1.0f && _hsv . x >= 0.0f ) && ( _hsv . y <= 1.0f && _hsv . y >= 0.0f ) && ( _hsv . z <= 1.0f && _hsv . z >= 0.0f ) , " H , S , V ▁ must ▁ be ▁ between ▁ [ 0,1 ] " ) ; const int i = iMin ( 5 , G3D :: iFloor ( 6.0 * _hsv . x ) ) ; const float f = 6.0f * _hsv . x - i ; const float m = _hsv . z * ( 1.0f - ( _hsv . y ) ) ; const float n = _hsv . z * ( 1.0f - ( _hsv . y * f ) ) ; const float k = _hsv . z * ( 1.0f - ( _hsv . y * ( 1 - f ) ) ) ; switch ( i ) { case 0 : return Color3 ( _hsv . z , k , m ) ; case 1 : return Color3 ( n , _hsv . z , m ) ; case 2 : return Color3 ( m , _hsv . z , k ) ; case 3 : return Color3 ( m , n , _hsv . z ) ; case 4 : return Color3 ( k , m , _hsv . z ) ; case 5 : return Color3 ( _hsv . z , m , n ) ; default : debugAssertM ( false , " fell ▁ through ▁ switch . . " ) ; } return Color3 :: black ( ) ; } Vector3 Color3 :: toHSV ( const Color3 & _rgb ) { debugAssertM ( ( _rgb . r <= 1.0f && _rgb . r >= 0.0f ) && ( _rgb . g <= 1.0f && _rgb . g >= 0.0f ) && ( _rgb . b <= 1.0f && _rgb . b >= 0.0f ) , " R , G , B ▁ must ▁ be ▁ between ▁ [ 0,1 ] " ) ; Vector3 hsv = Vector3 :: zero ( ) ; hsv . z = G3D :: max ( G3D :: max ( _rgb . r , _rgb . g ) , _rgb . b ) ; if ( G3D :: fuzzyEq ( hsv . z , 0.0f ) ) { return hsv ; } const float x = G3D :: min ( G3D :: min ( _rgb . r , _rgb . g ) , _rgb . b ) ; hsv . y = ( hsv . z - x ) / hsv . z ; if ( G3D :: fuzzyEq ( hsv . y , 0.0f ) ) { return hsv ; } Vector3 rgbN ; rgbN . x = ( hsv . z - _rgb . r ) / ( hsv . z - x ) ; rgbN . y = ( hsv . z - _rgb . g ) / ( hsv . z - x ) ; rgbN . z = ( hsv . z - _rgb . b ) / ( hsv . z - x ) ; if ( _rgb . r == hsv . z ) { // ▁ note ▁ from ▁ the ▁ max ▁ we ▁ know ▁ that ▁ it ▁ exactly ▁ equals ▁ one ▁ of ▁ the ▁ three . ENDCOM hsv . x = ( _rgb . g == x ) ? 5.0f + rgbN . z : 1.0f - rgbN . y ; } else if ( _rgb . g == hsv . z ) { hsv . x = ( _rgb . b == x ) ? 1.0f + rgbN . x : 3.0f - rgbN . z ; } else { hsv . x = ( _rgb . r == x ) ? 3.0f + rgbN . y : 5.0f - rgbN . x ; } hsv . x /= 6.0f ; return hsv ; } Color3 Color3 :: jetColorMap ( const float & val ) { debugAssertM ( val <= 1.0f && val >= 0.0f , " value ▁ should ▁ be ▁ in ▁ [ 0,1 ] " ) ; // truncated ▁ triangles ▁ where ▁ sides ▁ have ▁ slope ▁ 4 ENDCOM Color3 jet ; jet . r = G3D :: min ( 4.0f * val - 1.5f , - 4.0f * val + 4.5f ) ; jet . g = G3D :: min ( 4.0f * val - 0.5f , - 4.0f * val + 3.5f ) ; jet . b = G3D :: min ( 4.0f * val + 0.5f , - 4.0f * val + 2.5f ) ; jet . r = G3D :: clamp ( jet . r , 0.0f , 1.0f ) ; jet . g = G3D :: clamp ( jet . g , 0.0f , 1.0f ) ; jet . b = G3D :: clamp ( jet . b , 0.0f , 1.0f ) ; return jet ; } std :: string Color3 :: toString ( ) const { return G3D :: format ( " ( % g , ▁ % g , ▁ % g ) " , r , g , b ) ; } Color3 Color3 :: rainbowColorMap ( float hue ) { return fromHSV ( Vector3 ( hue , 1.0f , 1.0f ) ) ; } } ; // ▁ namespace ENDCOM </DOCUMENT>
<DOCUMENT_ID="weolar/miniblink49/tree/master/gen/blink/bindings/core/v8/V8VideoTrackList.cpp"> // ▁ Copyright ▁ 2014 ▁ The ▁ Chromium ▁ Authors . ▁ All ▁ rights ▁ reserved . ENDCOM // ▁ Use ▁ of ▁ this ▁ source ▁ code ▁ is ▁ governed ▁ by ▁ a ▁ BSD - style ▁ license ▁ that ▁ can ▁ be ENDCOM // ▁ found ▁ in ▁ the ▁ LICENSE ▁ file . ENDCOM // ▁ This ▁ file ▁ has ▁ been ▁ auto - generated ▁ by ▁ code _ generator _ v8 . py . ▁ DO ▁ NOT ▁ MODIFY ! ENDCOM # include " config . h " # include " V8VideoTrackList . h " # include " bindings / core / v8 / ExceptionState . h " # include " bindings / core / v8 / V8AbstractEventListener . h " # include " bindings / core / v8 / V8DOMConfiguration . h " # include " bindings / core / v8 / V8EventListenerList . h " # include " bindings / core / v8 / V8GCController . h " # include " bindings / core / v8 / V8ObjectConstructor . h " # include " bindings / core / v8 / V8VideoTrack . h " # include " core / dom / ContextFeatures . h " # include " core / dom / Document . h " # include " core / dom / Element . h " # include " platform / RuntimeEnabledFeatures . h " # include " platform / TraceEvent . h " # include " wtf / GetPtr . h " # include " wtf / RefPtr . h " namespace blink { // ▁ Suppress ▁ warning : ▁ global ▁ constructors , ▁ because ▁ struct ▁ WrapperTypeInfo ▁ is ▁ trivial ENDCOM // ▁ and ▁ does ▁ not ▁ depend ▁ on ▁ another ▁ global ▁ objects . ENDCOM # if defined ( COMPONENT_BUILD ) && defined ( WIN32 ) && COMPILER ( CLANG ) # pragma clang diagnostic push # pragma clang diagnostic ignored " - Wglobal - constructors " # endif const WrapperTypeInfo V8VideoTrackList :: wrapperTypeInfo = { gin :: kEmbedderBlink , V8VideoTrackList :: domTemplate , V8VideoTrackList :: refObject , V8VideoTrackList :: derefObject , V8VideoTrackList :: trace , 0 , V8VideoTrackList :: visitDOMWrapper , V8VideoTrackList :: preparePrototypeObject , V8VideoTrackList :: installConditionallyEnabledProperties , " VideoTrackList " , & V8EventTarget :: wrapperTypeInfo , WrapperTypeInfo :: WrapperTypeObjectPrototype , WrapperTypeInfo :: ObjectClassId , WrapperTypeInfo :: InheritFromEventTarget , WrapperTypeInfo :: Dependent , WrapperTypeInfo :: WillBeGarbageCollectedObject } ; # if defined ( COMPONENT_BUILD ) && defined ( WIN32 ) && COMPILER ( CLANG ) # pragma clang diagnostic pop # endif // ▁ This ▁ static ▁ member ▁ must ▁ be ▁ declared ▁ by ▁ DEFINE _ WRAPPERTYPEINFO ▁ in ▁ VideoTrackList . h . ENDCOM // ▁ For ▁ details , ▁ see ▁ the ▁ comment ▁ of ▁ DEFINE _ WRAPPERTYPEINFO ▁ in ENDCOM // ▁ bindings / core / v8 / ScriptWrappable . h . ENDCOM const WrapperTypeInfo & VideoTrackList :: s_wrapperTypeInfo = V8VideoTrackList :: wrapperTypeInfo ; namespace VideoTrackListV8Internal { static void lengthAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; v8SetReturnValueUnsigned ( info , impl -> length ( ) ) ; } static void lengthAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: lengthAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void selectedIndexAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; v8SetReturnValueInt ( info , impl -> selectedIndex ( ) ) ; } static void selectedIndexAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: selectedIndexAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onchangeAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; EventListener * cppValue ( impl -> onchange ( ) ) ; v8SetReturnValue ( info , cppValue ? v8 :: Local < v8 :: Value > ( V8AbstractEventListener :: cast ( cppValue ) -> getListenerObject ( impl -> executionContext ( ) ) ) : v8 :: Local < v8 :: Value > ( v8 :: Null ( info . GetIsolate ( ) ) ) ) ; } static void onchangeAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: onchangeAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onchangeAttributeSetter ( v8 :: Local < v8 :: Value > v8Value , const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; moveEventListenerToNewWrapper ( info . GetIsolate ( ) , holder , impl -> onchange ( ) , v8Value , V8VideoTrackList :: eventListenerCacheIndex ) ; impl -> setOnchange ( V8EventListenerList :: getEventListener ( ScriptState :: current ( info . GetIsolate ( ) ) , v8Value , true , ListenerFindOrCreate ) ) ; } static void onchangeAttributeSetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Value > v8Value = info [ 0 ] ; TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMSetter " ) ; VideoTrackListV8Internal :: onchangeAttributeSetter ( v8Value , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onaddtrackAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; EventListener * cppValue ( impl -> onaddtrack ( ) ) ; v8SetReturnValue ( info , cppValue ? v8 :: Local < v8 :: Value > ( V8AbstractEventListener :: cast ( cppValue ) -> getListenerObject ( impl -> executionContext ( ) ) ) : v8 :: Local < v8 :: Value > ( v8 :: Null ( info . GetIsolate ( ) ) ) ) ; } static void onaddtrackAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: onaddtrackAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onaddtrackAttributeSetter ( v8 :: Local < v8 :: Value > v8Value , const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; moveEventListenerToNewWrapper ( info . GetIsolate ( ) , holder , impl -> onaddtrack ( ) , v8Value , V8VideoTrackList :: eventListenerCacheIndex ) ; impl -> setOnaddtrack ( V8EventListenerList :: getEventListener ( ScriptState :: current ( info . GetIsolate ( ) ) , v8Value , true , ListenerFindOrCreate ) ) ; } static void onaddtrackAttributeSetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Value > v8Value = info [ 0 ] ; TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMSetter " ) ; VideoTrackListV8Internal :: onaddtrackAttributeSetter ( v8Value , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onremovetrackAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; EventListener * cppValue ( impl -> onremovetrack ( ) ) ; v8SetReturnValue ( info , cppValue ? v8 :: Local < v8 :: Value > ( V8AbstractEventListener :: cast ( cppValue ) -> getListenerObject ( impl -> executionContext ( ) ) ) : v8 :: Local < v8 :: Value > ( v8 :: Null ( info . GetIsolate ( ) ) ) ) ; } static void onremovetrackAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: onremovetrackAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onremovetrackAttributeSetter ( v8 :: Local < v8 :: Value > v8Value , const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; moveEventListenerToNewWrapper ( info . GetIsolate ( ) , holder , impl -> onremovetrack ( ) , v8Value , V8VideoTrackList :: eventListenerCacheIndex ) ; impl -> setOnremovetrack ( V8EventListenerList :: getEventListener ( ScriptState :: current ( info . GetIsolate ( ) ) , v8Value , true , ListenerFindOrCreate ) ) ; } static void onremovetrackAttributeSetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Value > v8Value = info [ 0 ] ; TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMSetter " ) ; VideoTrackListV8Internal :: onremovetrackAttributeSetter ( v8Value , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void getTrackByIdMethod ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { if ( UNLIKELY ( info . Length ( ) < 1 ) ) { V8ThrowException :: throwException ( createMinimumArityTypeErrorForMethod ( info . GetIsolate ( ) , " getTrackById " , " VideoTrackList " , 1 , info . Length ( ) ) , info . GetIsolate ( ) ) ; return ; } VideoTrackList * impl = V8VideoTrackList :: toImpl ( info . Holder ( ) ) ; V8StringResource < > id ; { id = info [ 0 ] ; if ( ! id . prepare ( ) ) return ; } v8SetReturnValue ( info , impl -> getTrackById ( id ) ) ; } static void getTrackByIdMethodCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMMethod " ) ; VideoTrackListV8Internal :: getTrackByIdMethod ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void indexedPropertyGetter ( uint32_t index , const v8 :: PropertyCallbackInfo < v8 :: Value > & info ) { VideoTrackList * impl = V8VideoTrackList :: toImpl ( info . Holder ( ) ) ; RefPtrWillBeRawPtr < VideoTrack > result = impl -> anonymousIndexedGetter ( index ) ; if ( ! result ) return ; v8SetReturnValueFast ( info , WTF :: getPtr ( result . release ( ) ) , impl ) ; } static void indexedPropertyGetterCallback ( uint32_t index , const v8 :: PropertyCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMIndexedProperty " ) ; VideoTrackListV8Internal :: indexedPropertyGetter ( index , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } } // ▁ namespace ▁ VideoTrackListV8Internal ENDCOM void V8VideoTrackList :: visitDOMWrapper ( v8 :: Isolate * isolate , ScriptWrappable * scriptWrappable , const v8 :: Persistent < v8 :: Object > & wrapper ) { VideoTrackList * impl = scriptWrappable -> toImpl < VideoTrackList > ( ) ; // ▁ The ▁ owner ( ) ▁ method ▁ may ▁ return ▁ a ▁ reference ▁ or ▁ a ▁ pointer . ENDCOM if ( Node * owner = WTF :: getPtr ( impl -> owner ( ) ) ) { Node * root = V8GCController :: opaqueRootForGC ( isolate , owner ) ; isolate -> SetReferenceFromGroup ( v8 :: UniqueId ( reinterpret_cast < intptr_t > ( root ) ) , wrapper ) ; return ; } } static const V8DOMConfiguration :: AccessorConfiguration V8VideoTrackListAccessors [ ] = { { " length " , VideoTrackListV8Internal :: lengthAttributeGetterCallback , 0 , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , { " selectedIndex " , VideoTrackListV8Internal :: selectedIndexAttributeGetterCallback , 0 , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , { " onchange " , VideoTrackListV8Internal :: onchangeAttributeGetterCallback , VideoTrackListV8Internal :: onchangeAttributeSetterCallback , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , { " onaddtrack " , VideoTrackListV8Internal :: onaddtrackAttributeGetterCallback , VideoTrackListV8Internal :: onaddtrackAttributeSetterCallback , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , { " onremovetrack " , VideoTrackListV8Internal :: onremovetrackAttributeGetterCallback , VideoTrackListV8Internal :: onremovetrackAttributeSetterCallback , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , } ; static const V8DOMConfiguration :: MethodConfiguration V8VideoTrackListMethods [ ] = { { " getTrackById " , VideoTrackListV8Internal :: getTrackByIdMethodCallback , 0 , 1 , V8DOMConfiguration :: ExposedToAllScripts } , } ; static void installV8VideoTrackListTemplate ( v8 :: Local < v8 :: FunctionTemplate > functionTemplate , v8 :: Isolate * isolate ) { functionTemplate -> ReadOnlyPrototype ( ) ; v8 :: Local < v8 :: Signature > defaultSignature ; if ( ! RuntimeEnabledFeatures :: audioVideoTracksEnabled ( ) ) defaultSignature = V8DOMConfiguration :: installDOMClassTemplate ( isolate , functionTemplate , " VideoTrackList " , V8EventTarget :: domTemplate ( isolate ) , V8VideoTrackList :: internalFieldCount , 0 , 0 , 0 , 0 , 0 , 0 ) ; else defaultSignature = V8DOMConfiguration :: installDOMClassTemplate ( isolate , functionTemplate , " VideoTrackList " , V8EventTarget :: domTemplate ( isolate ) , V8VideoTrackList :: internalFieldCount , 0 , 0 , V8VideoTrackListAccessors , WTF_ARRAY_LENGTH ( V8VideoTrackListAccessors ) , V8VideoTrackListMethods , WTF_ARRAY_LENGTH ( V8VideoTrackListMethods ) ) ; v8 :: Local < v8 :: ObjectTemplate > instanceTemplate = functionTemplate -> InstanceTemplate ( ) ; ALLOW_UNUSED_LOCAL ( instanceTemplate ) ; v8 :: Local < v8 :: ObjectTemplate > prototypeTemplate = functionTemplate -> PrototypeTemplate ( ) ; ALLOW_UNUSED_LOCAL ( prototypeTemplate ) ; { v8 :: IndexedPropertyHandlerConfiguration config ( VideoTrackListV8Internal :: indexedPropertyGetterCallback , 0 , 0 , 0 , indexedPropertyEnumerator < VideoTrackList > ) ; functionTemplate -> InstanceTemplate ( ) -> SetHandler ( config ) ; } // ▁ Custom ▁ toString ▁ template ENDCOM functionTemplate -> Set ( v8AtomicString ( isolate , " toString " ) , V8PerIsolateData :: from ( isolate ) -> toStringTemplate ( ) ) ; } v8 :: Local < v8 :: FunctionTemplate > V8VideoTrackList :: domTemplate ( v8 :: Isolate * isolate ) { return V8DOMConfiguration :: domClassTemplate ( isolate , const_cast < WrapperTypeInfo * > ( & wrapperTypeInfo ) , installV8VideoTrackListTemplate ) ; } bool V8VideoTrackList :: hasInstance ( v8 :: Local < v8 :: Value > v8Value , v8 :: Isolate * isolate ) { return V8PerIsolateData :: from ( isolate ) -> hasInstance ( & wrapperTypeInfo , v8Value ) ; } v8 :: Local < v8 :: Object > V8VideoTrackList :: findInstanceInPrototypeChain ( v8 :: Local < v8 :: Value > v8Value , v8 :: Isolate * isolate ) { return V8PerIsolateData :: from ( isolate ) -> findInstanceInPrototypeChain ( & wrapperTypeInfo , v8Value ) ; } VideoTrackList * V8VideoTrackList :: toImplWithTypeCheck ( v8 :: Isolate * isolate , v8 :: Local < v8 :: Value > value ) { return hasInstance ( value , isolate ) ? toImpl ( v8 :: Local < v8 :: Object > :: Cast ( value ) ) : 0 ; } void V8VideoTrackList :: refObject ( ScriptWrappable * scriptWrappable ) { # if ! ENABLE ( OILPAN ) scriptWrappable -> toImpl < VideoTrackList > ( ) -> ref ( ) ; # endif } void V8VideoTrackList :: derefObject ( ScriptWrappable * scriptWrappable ) { # if ! ENABLE ( OILPAN ) scriptWrappable -> toImpl < VideoTrackList > ( ) -> deref ( ) ; # endif } } // ▁ namespace ▁ blink ENDCOM </DOCUMENT>
<DOCUMENT_ID="hacklab-turku/luumuhillo/tree/master/source/main.cpp"> # include " game . hpp " # include " server . hpp " # ifdef _WIN32 # include < Windows . h > # endif int main ( int argc , char * * argv ) { if ( game . start ( ) != 0 ) return - 1 ; int retcode = game . getServer ( ) -> start ( ) ; if ( retcode == 0 ) { // ▁ Fix ▁ crash - on - exit ▁ bug ▁ on ▁ Windows ▁ by ▁ calling ▁ TerminateProcess ▁ manually ENDCOM # ifdef _WIN32 TerminateProcess ( GetCurrentProcess ( ) , EXIT_SUCCESS ) ; # endif return 0 ; } else return retcode ; } </DOCUMENT>
<DOCUMENT_ID="cesarmarinhorj/phantomjs/tree/master/src/qt/qtwebkit/Source/WTF/wtf/text/Base64.cpp"> /* STRNEWLINE ▁ Copyright ▁ ( C ) ▁ 2000-2001 ▁ Dawit ▁ Alemayehu ▁ < adawit @ kde . org > STRNEWLINE ▁ Copyright ▁ ( C ) ▁ 2006 ▁ Alexey ▁ Proskuryakov ▁ < ap @ webkit . org > STRNEWLINE ▁ Copyright ▁ ( C ) ▁ 2007 , ▁ 2008 ▁ Apple ▁ Inc . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ Copyright ▁ ( C ) ▁ 2010 ▁ Patrick ▁ Gansterer ▁ < paroga @ paroga . com > STRNEWLINE STRNEWLINE ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ ( LGPL ) STRNEWLINE ▁ version ▁ 2 ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation . STRNEWLINE STRNEWLINE ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE STRNEWLINE ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Library ▁ General ▁ Public STRNEWLINE ▁ License ▁ along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software STRNEWLINE ▁ Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , ▁ Boston , ▁ MA ▁ 02110-1301 , ▁ USA . STRNEWLINE STRNEWLINE ▁ This ▁ code ▁ is ▁ based ▁ on ▁ the ▁ java ▁ implementation ▁ in ▁ HTTPClient STRNEWLINE ▁ package ▁ by ▁ Ronald ▁ Tschalär ▁ Copyright ▁ ( C ) ▁ 1996-1999 . STRNEWLINE */ # include " config . h " # include " Base64 . h " # include < limits . h > # include < wtf / StringExtras . h > # include < wtf / text / WTFString . h > namespace WTF { static const char base64EncMap [ 64 ] = { 0x41 , 0x42 , 0x43 , 0x44 , 0x45 , 0x46 , 0x47 , 0x48 , 0x49 , 0x4A , 0x4B , 0x4C , 0x4D , 0x4E , 0x4F , 0x50 , 0x51 , 0x52 , 0x53 , 0x54 , 0x55 , 0x56 , 0x57 , 0x58 , 0x59 , 0x5A , 0x61 , 0x62 , 0x63 , 0x64 , 0x65 , 0x66 , 0x67 , 0x68 , 0x69 , 0x6A , 0x6B , 0x6C , 0x6D , 0x6E , 0x6F , 0x70 , 0x71 , 0x72 , 0x73 , 0x74 , 0x75 , 0x76 , 0x77 , 0x78 , 0x79 , 0x7A , 0x30 , 0x31 , 0x32 , 0x33 , 0x34 , 0x35 , 0x36 , 0x37 , 0x38 , 0x39 , 0x2B , 0x2F } ; static const char base64DecMap [ 128 ] = { 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x3E , 0x00 , 0x00 , 0x00 , 0x3F , 0x34 , 0x35 , 0x36 , 0x37 , 0x38 , 0x39 , 0x3A , 0x3B , 0x3C , 0x3D , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0A , 0x0B , 0x0C , 0x0D , 0x0E , 0x0F , 0x10 , 0x11 , 0x12 , 0x13 , 0x14 , 0x15 , 0x16 , 0x17 , 0x18 , 0x19 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x1A , 0x1B , 0x1C , 0x1D , 0x1E , 0x1F , 0x20 , 0x21 , 0x22 , 0x23 , 0x24 , 0x25 , 0x26 , 0x27 , 0x28 , 0x29 , 0x2A , 0x2B , 0x2C , 0x2D , 0x2E , 0x2F , 0x30 , 0x31 , 0x32 , 0x33 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; String base64Encode ( const char * data , unsigned length , Base64EncodePolicy policy ) { Vector < char > result ; base64Encode ( data , length , result , policy ) ; return String ( result . data ( ) , result . size ( ) ) ; } void base64Encode ( const char * data , unsigned len , Vector < char > & out , Base64EncodePolicy policy ) { out . clear ( ) ; if ( ! len ) return ; // ▁ If ▁ the ▁ input ▁ string ▁ is ▁ pathologically ▁ large , ▁ just ▁ return ▁ nothing . ENDCOM // ▁ Note : ▁ Keep ▁ this ▁ in ▁ sync ▁ with ▁ the ▁ " outLength " ▁ computation ▁ below . ENDCOM // ▁ Rather ▁ than ▁ being ▁ perfectly ▁ precise , ▁ this ▁ is ▁ a ▁ bit ▁ conservative . ENDCOM const unsigned maxInputBufferSize = UINT_MAX / 77 * 76 / 4 * 3 - 2 ; if ( len > maxInputBufferSize ) return ; unsigned sidx = 0 ; unsigned didx = 0 ; unsigned outLength = ( ( len + 2 ) / 3 ) * 4 ; // ▁ Deal ▁ with ▁ the ▁ 76 ▁ character ▁ per ▁ line ▁ limit ▁ specified ▁ in ▁ RFC ▁ 2045 . ENDCOM bool insertLFs = ( policy == Base64InsertLFs && outLength > 76 ) ; if ( insertLFs ) outLength += ( ( outLength - 1 ) / 76 ) ; int count = 0 ; out . grow ( outLength ) ; // ▁ 3 - byte ▁ to ▁ 4 - byte ▁ conversion ▁ + ▁ 0-63 ▁ to ▁ ascii ▁ printable ▁ conversion ENDCOM if ( len > 1 ) { while ( sidx < len - 2 ) { if ( insertLFs ) { if ( count && ! ( count % 76 ) ) out [ didx ++ ] = ' \n ' ; count += 4 ; } out [ didx ++ ] = base64EncMap [ ( data [ sidx ] >> 2 ) & 077 ] ; out [ didx ++ ] = base64EncMap [ ( ( data [ sidx + 1 ] >> 4 ) & 017 ) | ( ( data [ sidx ] << 4 ) & 077 ) ] ; out [ didx ++ ] = base64EncMap [ ( ( data [ sidx + 2 ] >> 6 ) & 003 ) | ( ( data [ sidx + 1 ] << 2 ) & 077 ) ] ; out [ didx ++ ] = base64EncMap [ data [ sidx + 2 ] & 077 ] ; sidx += 3 ; } } if ( sidx < len ) { if ( insertLFs && ( count > 0 ) && ! ( count % 76 ) ) out [ didx ++ ] = ' \n ' ; out [ didx ++ ] = base64EncMap [ ( data [ sidx ] >> 2 ) & 077 ] ; if ( sidx < len - 1 ) { out [ didx ++ ] = base64EncMap [ ( ( data [ sidx + 1 ] >> 4 ) & 017 ) | ( ( data [ sidx ] << 4 ) & 077 ) ] ; out [ didx ++ ] = base64EncMap [ ( data [ sidx + 1 ] << 2 ) & 077 ] ; } else out [ didx ++ ] = base64EncMap [ ( data [ sidx ] << 4 ) & 077 ] ; } // ▁ Add ▁ padding ENDCOM while ( didx < out . size ( ) ) { out [ didx ] = ' = ' ; ++ didx ; } } bool base64Decode ( const Vector < char > & in , Vector < char > & out , Base64DecodePolicy policy ) { out . clear ( ) ; // ▁ If ▁ the ▁ input ▁ string ▁ is ▁ pathologically ▁ large , ▁ just ▁ return ▁ nothing . ENDCOM if ( in . size ( ) > UINT_MAX ) return false ; return base64Decode ( in . data ( ) , in . size ( ) , out , policy ) ; } template < typename T > static inline bool base64DecodeInternal ( const T * data , unsigned len , Vector < char > & out , Base64DecodePolicy policy ) { out . clear ( ) ; if ( ! len ) return true ; out . grow ( len ) ; bool sawEqualsSign = false ; unsigned outLength = 0 ; for ( unsigned idx = 0 ; idx < len ; ++ idx ) { unsigned ch = data [ idx ] ; if ( ch == ' = ' ) sawEqualsSign = true ; else if ( ( '0' <= ch && ch <= '9' ) || ( ' A ' <= ch && ch <= ' Z ' ) || ( ' a ' <= ch && ch <= ' z ' ) || ch == ' + ' || ch == ' / ' ) { if ( sawEqualsSign ) return false ; out [ outLength ] = base64DecMap [ ch ] ; ++ outLength ; } else if ( policy == Base64FailOnInvalidCharacter || ( policy == Base64IgnoreWhitespace && ! isSpaceOrNewline ( ch ) ) ) return false ; } if ( ! outLength ) return ! sawEqualsSign ; // ▁ Valid ▁ data ▁ is ▁ ( n ▁ * ▁ 4 ▁ + ▁ [ 0,2,3 ] ) ▁ characters ▁ long . ENDCOM if ( ( outLength % 4 ) == 1 ) return false ; // ▁ 4 - byte ▁ to ▁ 3 - byte ▁ conversion ENDCOM outLength -= ( outLength + 3 ) / 4 ; if ( ! outLength ) return false ; unsigned sidx = 0 ; unsigned didx = 0 ; if ( outLength > 1 ) { while ( didx < outLength - 2 ) { out [ didx ] = ( ( ( out [ sidx ] << 2 ) & 255 ) | ( ( out [ sidx + 1 ] >> 4 ) & 003 ) ) ; out [ didx + 1 ] = ( ( ( out [ sidx + 1 ] << 4 ) & 255 ) | ( ( out [ sidx + 2 ] >> 2 ) & 017 ) ) ; out [ didx + 2 ] = ( ( ( out [ sidx + 2 ] << 6 ) & 255 ) | ( out [ sidx + 3 ] & 077 ) ) ; sidx += 4 ; didx += 3 ; } } if ( didx < outLength ) out [ didx ] = ( ( ( out [ sidx ] << 2 ) & 255 ) | ( ( out [ sidx + 1 ] >> 4 ) & 003 ) ) ; if ( ++ didx < outLength ) out [ didx ] = ( ( ( out [ sidx + 1 ] << 4 ) & 255 ) | ( ( out [ sidx + 2 ] >> 2 ) & 017 ) ) ; if ( outLength < out . size ( ) ) out . shrink ( outLength ) ; return true ; } bool base64Decode ( const char * data , unsigned len , Vector < char > & out , Base64DecodePolicy policy ) { return base64DecodeInternal < char > ( data , len , out , policy ) ; } bool base64Decode ( const String & in , Vector < char > & out , Base64DecodePolicy policy ) { return base64DecodeInternal < UChar > ( in . characters ( ) , in . length ( ) , out , policy ) ; } } // ▁ namespace ▁ WTF ENDCOM </DOCUMENT>
<DOCUMENT_ID="ricardogsilva/QGIS/tree/master/src/core/qgsproxyprogresstask.cpp"> /* * * * * STRNEWLINE ▁ qgsproxyprogresstask . cpp STRNEWLINE ▁ - - - - - STRNEWLINE ▁ begin ▁ : ▁ August ▁ 2018 STRNEWLINE ▁ copyright ▁ : ▁ ( C ) ▁ 2018 ▁ by ▁ Nyall ▁ Dawson STRNEWLINE ▁ email ▁ : ▁ nyall ▁ dot ▁ dawson ▁ at ▁ gmail ▁ dot ▁ com STRNEWLINE ▁ * * * * */ /* * * * * STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ * STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ * STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ * STRNEWLINE ▁ * ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ▁ * STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * * * * */ # include " qgsproxyprogresstask . h " QgsProxyProgressTask :: QgsProxyProgressTask ( const QString & description ) : QgsTask ( description , QgsTask :: Flags ( ) ) { } void QgsProxyProgressTask :: finalize ( bool result ) { mResult = result ; mNotFinishedWaitCondition . wakeAll ( ) ; } bool QgsProxyProgressTask :: run ( ) { mNotFinishedMutex . lock ( ) ; mNotFinishedWaitCondition . wait ( & mNotFinishedMutex ) ; mNotFinishedMutex . unlock ( ) ; return mResult ; } void QgsProxyProgressTask :: setProxyProgress ( double progress ) { QMetaObject :: invokeMethod ( this , " setProgress " , Qt :: AutoConnection , Q_ARG ( double , progress ) ) ; } // ▁ QgsScopedProxyProgressTask ENDCOM QgsScopedProxyProgressTask :: QgsScopedProxyProgressTask ( const QString & description ) : mTask ( new QgsProxyProgressTask ( description ) ) { QgsApplication :: taskManager ( ) -> addTask ( mTask ) ; } QgsScopedProxyProgressTask :: ~ QgsScopedProxyProgressTask ( ) { mTask -> finalize ( true ) ; } void QgsScopedProxyProgressTask :: setProgress ( double progress ) { mTask -> setProxyProgress ( progress ) ; } </DOCUMENT>
<DOCUMENT_ID="basic60/ARCUS/tree/master/source/kernel/interruption/idt.cpp"> # include " types . h " # include " idt . h " # include " string . h " # include " print _ charmode . h " # include " port . h " # include " keyboard . h " idtEntry idtEntries [ 256 ] ; // ▁ 中断描述符表 ENDCOM interruptHandler_t interruptHandler [ 256 ] ; idtPtr iptr ; // ▁ IDTR ENDCOM extern " C " void idtFlush ( uint64 addr ) ; void initIDT ( ) { memset ( ( uint8 * ) idtEntries , 0 , sizeof ( idtEntries ) ) ; iptr . limit = sizeof ( idtEntries ) - 1 ; iptr . base = ( uint64 ) & idtEntries ; /* ▁ ICW1 ▁ - ▁ begin ▁ initialization ▁ */ writePort ( 0x20 , 0x11 ) ; writePort ( 0xA0 , 0x11 ) ; // ▁ 设置主片 ▁ IRQ ▁ 从 ▁ 0x20(32 ) ▁ 号中断开始 ENDCOM writePort ( 0x21 , 0x20 ) ; // ▁ 设置从片 ▁ IRQ ▁ 从 ▁ 0x28(40 ) ▁ 号中断开始 ENDCOM writePort ( 0xA1 , 0x28 ) ; // ▁ 设置主片和从片按照 ▁ 8086 ▁ 的方式工作 ENDCOM writePort ( 0x21 , 0x01 ) ; writePort ( 0xA1 , 0x01 ) ; // ▁ 设置主从片允许中断 ENDCOM writePort ( 0x21 , 0x00 ) ; writePort ( 0xA1 , 0x00 ) ; idtSetEntity ( 0 , ( uint64 ) isr0 , 0x08 , 0x8E ) ; idtSetEntity ( 1 , ( uint64 ) isr1 , 0x08 , 0x8E ) ; idtSetEntity ( 2 , ( uint64 ) isr2 , 0x08 , 0x8E ) ; idtSetEntity ( 3 , ( uint64 ) isr3 , 0x08 , 0x8E ) ; idtSetEntity ( 4 , ( uint64 ) isr4 , 0x08 , 0x8E ) ; idtSetEntity ( 5 , ( uint64 ) isr5 , 0x08 , 0x8E ) ; idtSetEntity ( 6 , ( uint64 ) isr6 , 0x08 , 0x8E ) ; idtSetEntity ( 7 , ( uint64 ) isr7 , 0x08 , 0x8E ) ; idtSetEntity ( 8 , ( uint64 ) isr8 , 0x08 , 0x8E ) ; idtSetEntity ( 9 , ( uint64 ) isr9 , 0x08 , 0x8E ) ; idtSetEntity ( 10 , ( uint64 ) isr10 , 0x08 , 0x8E ) ; idtSetEntity ( 11 , ( uint64 ) isr11 , 0x08 , 0x8E ) ; idtSetEntity ( 12 , ( uint64 ) isr12 , 0x08 , 0x8E ) ; idtSetEntity ( 13 , ( uint64 ) isr13 , 0x08 , 0x8E ) ; idtSetEntity ( 14 , ( uint64 ) isr14 , 0x08 , 0x8E ) ; idtSetEntity ( 15 , ( uint64 ) isr15 , 0x08 , 0x8E ) ; idtSetEntity ( 16 , ( uint64 ) isr16 , 0x08 , 0x8E ) ; idtSetEntity ( 17 , ( uint64 ) isr17 , 0x08 , 0x8E ) ; idtSetEntity ( 18 , ( uint64 ) isr18 , 0x08 , 0x8E ) ; idtSetEntity ( 19 , ( uint64 ) isr19 , 0x08 , 0x8E ) ; idtSetEntity ( 20 , ( uint64 ) isr20 , 0x08 , 0x8E ) ; idtSetEntity ( 21 , ( uint64 ) isr21 , 0x08 , 0x8E ) ; idtSetEntity ( 22 , ( uint64 ) isr22 , 0x08 , 0x8E ) ; idtSetEntity ( 23 , ( uint64 ) isr23 , 0x08 , 0x8E ) ; idtSetEntity ( 24 , ( uint64 ) isr24 , 0x08 , 0x8E ) ; idtSetEntity ( 25 , ( uint64 ) isr25 , 0x08 , 0x8E ) ; idtSetEntity ( 26 , ( uint64 ) isr26 , 0x08 , 0x8E ) ; idtSetEntity ( 27 , ( uint64 ) isr27 , 0x08 , 0x8E ) ; idtSetEntity ( 28 , ( uint64 ) isr27 , 0x08 , 0x8E ) ; idtSetEntity ( 29 , ( uint64 ) isr29 , 0x08 , 0x8E ) ; idtSetEntity ( 30 , ( uint64 ) isr30 , 0x08 , 0x8E ) ; idtSetEntity ( 31 , ( uint64 ) isr31 , 0x08 , 0x8E ) ; idtSetEntity ( 32 , ( uint64 ) irq0 , 0x08 , 0x8E ) ; idtSetEntity ( 33 , ( uint64 ) irq1 , 0x08 , 0x8E ) ; idtSetEntity ( 34 , ( uint64 ) irq2 , 0x08 , 0x8E ) ; idtSetEntity ( 35 , ( uint64 ) irq3 , 0x08 , 0x8E ) ; idtSetEntity ( 36 , ( uint64 ) irq4 , 0x08 , 0x8E ) ; idtSetEntity ( 37 , ( uint64 ) irq5 , 0x08 , 0x8E ) ; idtSetEntity ( 38 , ( uint64 ) irq6 , 0x08 , 0x8E ) ; idtSetEntity ( 39 , ( uint64 ) irq7 , 0x08 , 0x8E ) ; idtSetEntity ( 40 , ( uint64 ) irq8 , 0x08 , 0x8E ) ; idtSetEntity ( 41 , ( uint64 ) irq9 , 0x08 , 0x8E ) ; idtSetEntity ( 42 , ( uint64 ) irq10 , 0x08 , 0x8E ) ; idtSetEntity ( 43 , ( uint64 ) irq11 , 0x08 , 0x8E ) ; idtSetEntity ( 44 , ( uint64 ) irq12 , 0x08 , 0x8E ) ; idtSetEntity ( 45 , ( uint64 ) irq13 , 0x08 , 0x8E ) ; idtSetEntity ( 46 , ( uint64 ) irq14 , 0x08 , 0x8E ) ; idtSetEntity ( 47 , ( uint64 ) irq15 , 0x08 , 0x8E ) ; idtFlush ( ( uint64 ) & iptr ) ; printStr ( " Initializing ▁ interruption ▁ finished . \n " , color_white ) ; } void isrHandler ( ptRegs * regs ) { // ▁ printDecimal ( regs - > intNum , color _ red ) ; ENDCOM if ( interruptHandler [ regs -> intNum ] ) interruptHandler [ regs -> intNum ] ( regs ) ; else { // ▁ printStr ( " Handeler ▁ not ▁ exist ! " , color _ lightwhite ) ; ENDCOM // ▁ printNum ( regs - > rip , color _ lightwhite ) ; ENDCOM } } void irqHandler ( ptRegs * regs ) { if ( regs -> intNum > 40 ) { writePort ( 0xA0 , 0x20 ) ; // ▁ 发送重设信号给从片 ENDCOM } // ▁ 发送重设信号给主片 ENDCOM writePort ( 0x20 , 0x20 ) ; if ( interruptHandler [ regs -> intNum ] ) { interruptHandler [ regs -> intNum ] ( regs ) ; } } void registerInterruptHandler ( uint8 n , interruptHandler_t h ) { interruptHandler [ n ] = h ; } void idtSetEntity ( uint8 num , uint64 base , uint16 selector , uint8 flags ) { idtEntries [ num ] . offset1 = base & 0xffff ; idtEntries [ num ] . offset2 = ( base >> 16 ) & 0xffff ; idtEntries [ num ] . offset3 = ( base >> 32 ) & 0xffffffff ; idtEntries [ num ] . selector = selector ; idtEntries [ num ] . typeAttr = flags ; } </DOCUMENT>
<DOCUMENT_ID="Residentik/TestingRepo/tree/master/src/server/scripts/EasternKingdoms/BlackrockMountain/BlackrockDepths/boss_high_interrogator_gerstahn.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2008-2014 ▁ TrinityCore ▁ < http : // www . trinitycore . org / > STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2006-2009 ▁ ScriptDev2 ▁ < https : // scriptdev2 . svn . sourceforge . net / > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it STRNEWLINE ▁ * ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the STRNEWLINE ▁ * ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your STRNEWLINE ▁ * ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT STRNEWLINE ▁ * ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or STRNEWLINE ▁ * ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for STRNEWLINE ▁ * ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along STRNEWLINE ▁ * ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ */ # include " ScriptMgr . h " # include " ScriptedCreature . h " enum Spells { SPELL_SHADOWWORDPAIN = 10894 , SPELL_MANABURN = 10876 , SPELL_PSYCHICSCREAM = 8122 , SPELL_SHADOWSHIELD = 22417 } ; class boss_high_interrogator_gerstahn : public CreatureScript { public : boss_high_interrogator_gerstahn ( ) : CreatureScript ( " boss _ high _ interrogator _ gerstahn " ) { } CreatureAI * GetAI ( Creature * creature ) const OVERRIDE { return new boss_high_interrogator_gerstahnAI ( creature ) ; } struct boss_high_interrogator_gerstahnAI : public ScriptedAI { boss_high_interrogator_gerstahnAI ( Creature * creature ) : ScriptedAI ( creature ) { } uint32 ShadowWordPain_Timer ; uint32 ManaBurn_Timer ; uint32 PsychicScream_Timer ; uint32 ShadowShield_Timer ; void Reset ( ) OVERRIDE { ShadowWordPain_Timer = 4000 ; ManaBurn_Timer = 14000 ; PsychicScream_Timer = 32000 ; ShadowShield_Timer = 8000 ; } void EnterCombat ( Unit * /* who */ ) OVERRIDE { } void UpdateAI ( uint32 diff ) OVERRIDE { // Return ▁ since ▁ we ▁ have ▁ no ▁ target ENDCOM if ( ! UpdateVictim ( ) ) return ; // ShadowWordPain _ Timer ENDCOM if ( ShadowWordPain_Timer <= diff ) { if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 100 , true ) ) DoCast ( target , SPELL_SHADOWWORDPAIN ) ; ShadowWordPain_Timer = 7000 ; } else ShadowWordPain_Timer -= diff ; // ManaBurn _ Timer ENDCOM if ( ManaBurn_Timer <= diff ) { if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 100 , true ) ) DoCast ( target , SPELL_MANABURN ) ; ManaBurn_Timer = 10000 ; } else ManaBurn_Timer -= diff ; // PsychicScream _ Timer ENDCOM if ( PsychicScream_Timer <= diff ) { DoCastVictim ( SPELL_PSYCHICSCREAM ) ; PsychicScream_Timer = 30000 ; } else PsychicScream_Timer -= diff ; // ShadowShield _ Timer ENDCOM if ( ShadowShield_Timer <= diff ) { DoCast ( me , SPELL_SHADOWSHIELD ) ; ShadowShield_Timer = 25000 ; } else ShadowShield_Timer -= diff ; DoMeleeAttackIfReady ( ) ; } } ; } ; void AddSC_boss_high_interrogator_gerstahn ( ) { new boss_high_interrogator_gerstahn ( ) ; } </DOCUMENT>
<DOCUMENT_ID="xlmbn/trscoin/tree/master/src/test/multisig_tests.cpp"> # include < boost / assert . hpp > # include < boost / assign / list_of . hpp > # include < boost / assign / list_inserter . hpp > # include < boost / assign / std / vector . hpp > # include < boost / test / unit_test . hpp > # include < boost / foreach . hpp > # include < boost / tuple / tuple . hpp > # include < openssl / ec . h > # include < openssl / err . h > # include " keystore . h " # include " main . h " # include " script . h " # include " wallet . h " using namespace std ; using namespace boost :: assign ; typedef vector < unsigned char > valtype ; extern uint256 SignatureHash ( CScript scriptCode , const CTransaction & txTo , unsigned int nIn , int nHashType ) ; BOOST_AUTO_TEST_SUITE ( multisig_tests ) CScript sign_multisig ( CScript scriptPubKey , vector < CKey > keys , CTransaction transaction , int whichIn ) { uint256 hash = SignatureHash ( scriptPubKey , transaction , whichIn , SIGHASH_ALL ) ; CScript result ; result << OP_0 ; // ▁ CHECKMULTISIG ▁ bug ▁ workaround ENDCOM BOOST_FOREACH ( const CKey & key , keys ) { vector < unsigned char > vchSig ; BOOST_CHECK ( key . Sign ( hash , vchSig ) ) ; vchSig . push_back ( ( unsigned char ) SIGHASH_ALL ) ; result << vchSig ; } return result ; } BOOST_AUTO_TEST_CASE ( multisig_verify ) { unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) key [ i ] . MakeNewKey ( true ) ; CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; CTransaction txFrom ; // ▁ Funding ▁ transaction ENDCOM txFrom . vout . resize ( 3 ) ; txFrom . vout [ 0 ] . scriptPubKey = a_and_b ; txFrom . vout [ 1 ] . scriptPubKey = a_or_b ; txFrom . vout [ 2 ] . scriptPubKey = escrow ; CTransaction txTo [ 3 ] ; // ▁ Spending ▁ transaction ENDCOM for ( int i = 0 ; i < 3 ; i ++ ) { txTo [ i ] . vin . resize ( 1 ) ; txTo [ i ] . vout . resize ( 1 ) ; txTo [ i ] . vin [ 0 ] . prevout . n = i ; txTo [ i ] . vin [ 0 ] . prevout . hash = txFrom . GetHash ( ) ; txTo [ i ] . vout [ 0 ] . nValue = 1 ; } vector < CKey > keys ; CScript s ; // ▁ Test ▁ a ▁ AND ▁ b : ENDCOM keys . clear ( ) ; keys += key [ 0 ] , key [ 1 ] ; // ▁ magic ▁ operator + = ▁ from ▁ boost . assign ENDCOM s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK ( VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) { keys . clear ( ) ; keys += key [ i ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) , strprintf ( " a & b ▁ 1 : ▁ % d " , i ) ) ; keys . clear ( ) ; keys += key [ 1 ] , key [ i ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) , strprintf ( " a & b ▁ 2 : ▁ % d " , i ) ) ; } // ▁ Test ▁ a ▁ OR ▁ b : ENDCOM for ( int i = 0 ; i < 4 ; i ++ ) { keys . clear ( ) ; keys += key [ i ] ; s = sign_multisig ( a_or_b , keys , txTo [ 1 ] , 0 ) ; if ( i == 0 || i == 1 ) BOOST_CHECK_MESSAGE ( VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) , strprintf ( " a | b : ▁ % d " , i ) ) ; else BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) , strprintf ( " a | b : ▁ % d " , i ) ) ; } s . clear ( ) ; s << OP_0 << OP_0 ; BOOST_CHECK ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) ) ; s . clear ( ) ; s << OP_0 << OP_1 ; BOOST_CHECK ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) { keys . clear ( ) ; keys += key [ i ] , key [ j ] ; s = sign_multisig ( escrow , keys , txTo [ 2 ] , 0 ) ; if ( i < j && i < 3 && j < 3 ) BOOST_CHECK_MESSAGE ( VerifyScript ( s , escrow , txTo [ 2 ] , 0 , flags , 0 ) , strprintf ( " escrow ▁ 1 : ▁ % d ▁ % d " , i , j ) ) ; else BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , escrow , txTo [ 2 ] , 0 , flags , 0 ) , strprintf ( " escrow ▁ 2 : ▁ % d ▁ % d " , i , j ) ) ; } } BOOST_AUTO_TEST_CASE ( multisig_IsStandard ) { CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) key [ i ] . MakeNewKey ( true ) ; CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( a_and_b ) ) ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( a_or_b ) ) ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( escrow ) ) ; CScript one_of_four ; one_of_four << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << key [ 3 ] . GetPubKey ( ) << OP_4 << OP_CHECKMULTISIG ; BOOST_CHECK ( ! :: IsStandard ( one_of_four ) ) ; CScript malformed [ 6 ] ; malformed [ 0 ] << OP_3 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; malformed [ 1 ] << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; malformed [ 2 ] << OP_0 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; malformed [ 3 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_0 << OP_CHECKMULTISIG ; malformed [ 4 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_CHECKMULTISIG ; malformed [ 5 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) ; for ( int i = 0 ; i < 6 ; i ++ ) BOOST_CHECK ( ! :: IsStandard ( malformed [ i ] ) ) ; } BOOST_AUTO_TEST_CASE ( multisig_Solver1 ) { // ▁ Tests ▁ Solver ( ) ▁ that ▁ returns ▁ lists ▁ of ▁ keys ▁ that ▁ are ENDCOM // ▁ required ▁ to ▁ satisfy ▁ a ▁ ScriptPubKey ENDCOM // ▁ Also ▁ tests ▁ IsMine ( ) ▁ and ▁ ExtractAddress ( ) ENDCOM // ▁ Note : ▁ ExtractAddress ▁ for ▁ the ▁ multisignature ▁ transactions ENDCOM // ▁ always ▁ returns ▁ false ▁ for ▁ this ▁ release , ▁ even ▁ if ▁ you ▁ have ENDCOM // ▁ one ▁ key ▁ that ▁ would ▁ satisfy ▁ an ▁ ( a | b ) ▁ or ▁ 2 - of - 3 ▁ keys ▁ needed ENDCOM // ▁ to ▁ spend ▁ an ▁ escrow ▁ transaction . ENDCOM CBasicKeyStore keystore , emptykeystore , partialkeystore ; CKey key [ 3 ] ; CTxDestination keyaddr [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { key [ i ] . MakeNewKey ( true ) ; keystore . AddKey ( key [ i ] ) ; keyaddr [ i ] = key [ i ] . GetPubKey ( ) . GetID ( ) ; } partialkeystore . AddKey ( key [ 0 ] ) ; { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << key [ 0 ] . GetPubKey ( ) << OP_CHECKSIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 1 ) ; CTxDestination addr ; BOOST_CHECK ( ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( addr == keyaddr [ 0 ] ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_DUP << OP_HASH160 << key [ 0 ] . GetPubKey ( ) . GetID ( ) << OP_EQUALVERIFY << OP_CHECKSIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 1 ) ; CTxDestination addr ; BOOST_CHECK ( ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( addr == keyaddr [ 0 ] ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK_EQUAL ( solutions . size ( ) , 4U ) ; CTxDestination addr ; BOOST_CHECK ( ! ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; BOOST_CHECK ( ! IsMine ( partialkeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK_EQUAL ( solutions . size ( ) , 4U ) ; vector < CTxDestination > addrs ; int nRequired ; BOOST_CHECK ( ExtractDestinations ( s , whichType , addrs , nRequired ) ) ; BOOST_CHECK ( addrs [ 0 ] == keyaddr [ 0 ] ) ; BOOST_CHECK ( addrs [ 1 ] == keyaddr [ 1 ] ) ; BOOST_CHECK ( nRequired == 1 ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; BOOST_CHECK ( ! IsMine ( partialkeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 5 ) ; } } BOOST_AUTO_TEST_CASE ( multisig_Sign ) { // ▁ Test ▁ SignSignature ( ) ▁ ( and ▁ therefore ▁ the ▁ version ▁ of ▁ Solver ( ) ▁ that ▁ signs ▁ transactions ) ENDCOM CBasicKeyStore keystore ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { key [ i ] . MakeNewKey ( true ) ; keystore . AddKey ( key [ i ] ) ; } CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; CTransaction txFrom ; // ▁ Funding ▁ transaction ENDCOM txFrom . vout . resize ( 3 ) ; txFrom . vout [ 0 ] . scriptPubKey = a_and_b ; txFrom . vout [ 1 ] . scriptPubKey = a_or_b ; txFrom . vout [ 2 ] . scriptPubKey = escrow ; CTransaction txTo [ 3 ] ; // ▁ Spending ▁ transaction ENDCOM for ( int i = 0 ; i < 3 ; i ++ ) { txTo [ i ] . vin . resize ( 1 ) ; txTo [ i ] . vout . resize ( 1 ) ; txTo [ i ] . vin [ 0 ] . prevout . n = i ; txTo [ i ] . vin [ 0 ] . prevout . hash = txFrom . GetHash ( ) ; txTo [ i ] . vout [ 0 ] . nValue = 1 ; } for ( int i = 0 ; i < 3 ; i ++ ) { BOOST_CHECK_MESSAGE ( SignSignature ( keystore , txFrom , txTo [ i ] , 0 ) , strprintf ( " SignSignature ▁ % d " , i ) ) ; } } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="kstripp/LittleBudget/tree/master/src/core/main.cpp"> /* * * * * STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * ▁ LB ▁ - ▁ The ▁ Little ▁ Budget ▁ Utility ▁ for ▁ GnuCash ▁ * STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2004,2005 ▁ by ▁ Gabriel ▁ M . ▁ Beddingfield ▁ * STRNEWLINE ▁ * ▁ gabriel @ teuton . org ▁ * STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ * STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ * STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ * STRNEWLINE ▁ * ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ▁ * STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ * STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ * STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ * STRNEWLINE ▁ * ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ▁ * STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ * STRNEWLINE ▁ * ▁ along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ * STRNEWLINE ▁ * ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ▁ * STRNEWLINE ▁ * ▁ 59 ▁ Temple ▁ Place ▁ - ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 , ▁ USA . ▁ * STRNEWLINE ▁ * * * * */ /* ▁ main . cpp STRNEWLINE ▁ Gabriel ▁ M . ▁ Beddingfield STRNEWLINE ▁ 02OCT2004 STRNEWLINE STRNEWLINE ▁ For ▁ merging ▁ a ▁ gnucash ▁ report STRNEWLINE ▁ with ▁ a ▁ published ▁ budget . STRNEWLINE */ # include < iostream > # include " lb . h " using std :: cout ; using std :: endl ; using std :: cerr ; # ifndef VERSION # define VERSION "1.0.1" # endif int main ( int argc , const char * argv [ ] ) { try { lb app ( argc , argv ) ; return app . run ( ) ; } catch ( lb_error e ) { cerr << e . what ( ) << endl ; return EXIT_FAILURE ; } catch ( runtime_error e ) { cerr << e . what ( ) << endl ; return EXIT_FAILURE ; } catch ( ... ) { cerr << " Unhandled ▁ exception ▁ in ▁ lb . " << endl ; return EXIT_FAILURE ; } } </DOCUMENT>
<DOCUMENT_ID="twalpole/selenium/tree/master/cpp/iedriver/CommandHandlers/MaximizeWindowCommandHandler.cpp"> // ▁ Licensed ▁ to ▁ the ▁ Software ▁ Freedom ▁ Conservancy ▁ ( SFC ) ▁ under ▁ one ENDCOM // ▁ or ▁ more ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file ENDCOM // ▁ distributed ▁ with ▁ this ▁ work ▁ for ▁ additional ▁ information ENDCOM // ▁ regarding ▁ copyright ▁ ownership . ▁ The ▁ SFC ▁ licenses ▁ this ▁ file ENDCOM // ▁ to ▁ you ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ENDCOM // ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . ENDCOM // ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at ENDCOM // ▁ http : // www . apache . org / licenses / LICENSE - 2.0 ENDCOM // ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ENDCOM // ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ENDCOM // ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ENDCOM // ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ENDCOM // ▁ limitations ▁ under ▁ the ▁ License . ENDCOM # include " MaximizeWindowCommandHandler . h " # include " errorcodes . h " # include " . . / Browser . h " # include " . . / IECommandExecutor . h " namespace webdriver { MaximizeWindowCommandHandler :: MaximizeWindowCommandHandler ( void ) { } MaximizeWindowCommandHandler :: ~ MaximizeWindowCommandHandler ( void ) { } void MaximizeWindowCommandHandler :: ExecuteInternal ( const IECommandExecutor & executor , const ParametersMap & command_parameters , Response * response ) { int status_code = WD_SUCCESS ; BrowserHandle browser_wrapper ; status_code = executor . GetCurrentBrowser ( & browser_wrapper ) ; if ( status_code != WD_SUCCESS ) { response -> SetErrorResponse ( ERROR_NO_SUCH_WINDOW , " Error ▁ retrieving ▁ window " ) ; return ; } HWND window_handle = browser_wrapper -> GetTopLevelWindowHandle ( ) ; if ( ! :: IsZoomed ( window_handle ) ) { browser_wrapper -> Restore ( ) ; :: ShowWindow ( window_handle , SW_MAXIMIZE ) ; } RECT window_rect ; :: GetWindowRect ( window_handle , & window_rect ) ; Json :: Value response_value ; response_value [ " width " ] = window_rect . right - window_rect . left ; response_value [ " height " ] = window_rect . bottom - window_rect . top ; response_value [ " x " ] = window_rect . left ; response_value [ " y " ] = window_rect . top ; response -> SetSuccessResponse ( response_value ) ; } } // ▁ namespace ▁ webdriver ENDCOM </DOCUMENT>
<DOCUMENT_ID="dklann/rivendell/tree/master/lib/rdlist_logs.cpp"> // ▁ rdlist _ logs . cpp ENDCOM // ▁ Select ▁ a ▁ Rivendell ▁ Log ENDCOM // ▁ ( C ) ▁ Copyright ▁ 2002-2019 ▁ Fred ▁ Gleason ▁ < fredg @ paravelsystems . com > ENDCOM // ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM // ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ version ▁ 2 ▁ as ENDCOM // ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation . ENDCOM // ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM // ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM // ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM // ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM // ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ENDCOM // ▁ License ▁ along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ENDCOM // ▁ Foundation , ▁ Inc . , ▁ 675 ▁ Mass ▁ Ave , ▁ Cambridge , ▁ MA ▁ 02139 , ▁ USA . ENDCOM # include " rdapplication . h " # include " rddb . h " # include " rdescape _ string . h " # include " rdlist _ logs . h " RDListLogs :: RDListLogs ( QString * logname , RDLogFilter :: FilterMode mode , QWidget * parent ) : RDDialog ( parent ) { list_logname = logname ; // ▁ Fix ▁ the ▁ Window ▁ Size ENDCOM setMinimumSize ( sizeHint ( ) ) ; setWindowTitle ( tr ( " Select ▁ Log " ) ) ; // ▁ Log ▁ Filter ENDCOM list_filter_widget = new RDLogFilter ( mode , this ) ; connect ( list_filter_widget , SIGNAL ( filterChanged ( const QString & ) ) , this , SLOT ( filterChangedData ( const QString & ) ) ) ; // ▁ Log ▁ List ENDCOM list_log_list = new Q3ListView ( this ) ; list_log_list -> setAllColumnsShowFocus ( true ) ; list_log_list -> setItemMargin ( 5 ) ; list_log_list -> setSelectionMode ( Q3ListView :: Single ) ; connect ( list_log_list , SIGNAL ( doubleClicked ( Q3ListViewItem * , const QPoint & , int ) ) , this , SLOT ( doubleClickedData ( Q3ListViewItem * , const QPoint & , int ) ) ) ; list_log_list -> addColumn ( tr ( " Name " ) ) ; list_log_list -> setColumnAlignment ( 0 , Qt :: AlignLeft ) ; list_log_list -> addColumn ( tr ( " Description " ) ) ; list_log_list -> setColumnAlignment ( 1 , Qt :: AlignLeft ) ; list_log_list -> addColumn ( tr ( " Service " ) ) ; list_log_list -> setColumnAlignment ( 2 , Qt :: AlignLeft ) ; // ▁ OK ▁ Button ENDCOM list_ok_button = new QPushButton ( this ) ; list_ok_button -> setFont ( buttonFont ( ) ) ; list_ok_button -> setText ( tr ( " OK " ) ) ; connect ( list_ok_button , SIGNAL ( clicked ( ) ) , this , SLOT ( okButtonData ( ) ) ) ; // ▁ Cancel ▁ Button ENDCOM list_cancel_button = new QPushButton ( this ) ; list_cancel_button -> setFont ( buttonFont ( ) ) ; list_cancel_button -> setText ( tr ( " Cancel " ) ) ; list_cancel_button -> setDefault ( true ) ; connect ( list_cancel_button , SIGNAL ( clicked ( ) ) , this , SLOT ( cancelButtonData ( ) ) ) ; RefreshList ( ) ; } QSize RDListLogs :: sizeHint ( ) const { return QSize ( 500 , 300 ) ; } QSizePolicy RDListLogs :: sizePolicy ( ) const { return QSizePolicy ( QSizePolicy :: Fixed , QSizePolicy :: Fixed ) ; } void RDListLogs :: closeEvent ( QCloseEvent * e ) { done ( 1 ) ; } void RDListLogs :: filterChangedData ( const QString & where_sql ) { RefreshList ( ) ; } void RDListLogs :: doubleClickedData ( Q3ListViewItem * , const QPoint & , int ) { okButtonData ( ) ; } void RDListLogs :: okButtonData ( ) { Q3ListViewItem * item = list_log_list -> selectedItem ( ) ; if ( item == NULL ) { return ; } * list_logname = item -> text ( 0 ) ; done ( 0 ) ; } void RDListLogs :: cancelButtonData ( ) { done ( 1 ) ; } void RDListLogs :: resizeEvent ( QResizeEvent * e ) { list_filter_widget -> setGeometry ( 10 , 10 , size ( ) . width ( ) - 10 , list_filter_widget -> sizeHint ( ) . height ( ) ) ; list_log_list -> setGeometry ( 10 , list_filter_widget -> sizeHint ( ) . height ( ) , size ( ) . width ( ) - 20 , size ( ) . height ( ) - list_filter_widget -> sizeHint ( ) . height ( ) - 70 ) ; list_ok_button -> setGeometry ( size ( ) . width ( ) - 190 , size ( ) . height ( ) - 60 , 80 , 50 ) ; list_cancel_button -> setGeometry ( size ( ) . width ( ) - 90 , size ( ) . height ( ) - 60 , 80 , 50 ) ; } void RDListLogs :: RefreshList ( ) { RDSqlQuery * q ; QString sql ; Q3ListViewItem * l ; Q3ListViewItem * view_item = NULL ; QDate current_date = QDate :: currentDate ( ) ; list_log_list -> clear ( ) ; sql = QString ( " select ▁ NAME , DESCRIPTION , SERVICE ▁ from ▁ LOGS ▁ " ) + " where ▁ ( TYPE = 0 ) & & ( LOG _ EXISTS = \ " Y\ " ) & & " + " ( ( START _ DATE < = \ " " + current_date . toString ( " yyyy - MM - dd " ) + " \ " ) | | " + " ( START _ DATE = \ " 0000-00-00\ " ) | | " + " ( START _ DATE ▁ is ▁ null ) ) & & " + " ( ( END _ DATE > = \ " " + current_date . toString ( " yyyy - MM - dd " ) + " \ " ) | | " + " ( END _ DATE = \ " 0000-00-00\ " ) | | " + " ( END _ DATE ▁ is ▁ null ) ) " + list_filter_widget -> whereSql ( ) ; q = new RDSqlQuery ( sql ) ; while ( q -> next ( ) ) { l = new Q3ListViewItem ( list_log_list ) ; l -> setText ( 0 , q -> value ( 0 ) . toString ( ) ) ; l -> setText ( 1 , q -> value ( 1 ) . toString ( ) ) ; l -> setText ( 2 , q -> value ( 2 ) . toString ( ) ) ; if ( l -> text ( 0 ) == * list_logname ) { view_item = l ; } } delete q ; if ( view_item != NULL ) { list_log_list -> setCurrentItem ( view_item ) ; list_log_list -> ensureItemVisible ( view_item ) ; } } </DOCUMENT>
<DOCUMENT_ID="Maximus-/WinObjC/tree/master/deps/3rdparty/iculegacy/source/test/intltest/testidna.cpp"> /* STRNEWLINE ▁ * * * * * STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2003-2010 , ▁ International ▁ Business ▁ Machines STRNEWLINE ▁ * ▁ Corporation ▁ and ▁ others . ▁ All ▁ Rights ▁ Reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * * * * * STRNEWLINE ▁ * ▁ file ▁ name : ▁ testidna . cpp STRNEWLINE ▁ * ▁ encoding : ▁ US - ASCII STRNEWLINE ▁ * ▁ tab ▁ size : ▁ 8 ▁ ( not ▁ used ) STRNEWLINE ▁ * ▁ indentation : 4 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ created ▁ on : ▁ 2003feb1 STRNEWLINE ▁ * ▁ created ▁ by : ▁ Ram ▁ Viswanadha STRNEWLINE ▁ */ # include " unicode / utypes . h " # if ! UCONFIG_NO_IDNA && ! UCONFIG_NO_TRANSLITERATION # include < time . h > # include < limits . h > # include < stdlib . h > # include < string . h > # include " unicode / localpointer . h " # include " unicode / ustring . h " # include " unicode / usprep . h " # include " unicode / uniset . h " # include " testidna . h " # include " idnaref . h " # include " nptrans . h " # include " unicode / putil . h " # include " idnaconf . h " static const UChar unicodeIn [ ] [ 41 ] = { { 0x0644 , 0x064A , 0x0647 , 0x0645 , 0x0627 , 0x0628 , 0x062A , 0x0643 , 0x0644 , 0x0645 , 0x0648 , 0x0634 , 0x0639 , 0x0631 , 0x0628 , 0x064A , 0x061F , 0x0000 } , { 0x4ED6 , 0x4EEC , 0x4E3A , 0x4EC0 , 0x4E48 , 0x4E0D , 0x8BF4 , 0x4E2D , 0x6587 , 0x0000 } , { 0x0050 , 0x0072 , 0x006F , 0x010D , 0x0070 , 0x0072 , 0x006F , 0x0073 , 0x0074 , 0x011B , 0x006E , 0x0065 , 0x006D , 0x006C , 0x0075 , 0x0076 , 0x00ED , 0x010D , 0x0065 , 0x0073 , 0x006B , 0x0079 , 0x0000 } , { 0x05DC , 0x05DE , 0x05D4 , 0x05D4 , 0x05DD , 0x05E4 , 0x05E9 , 0x05D5 , 0x05D8 , 0x05DC , 0x05D0 , 0x05DE , 0x05D3 , 0x05D1 , 0x05E8 , 0x05D9 , 0x05DD , 0x05E2 , 0x05D1 , 0x05E8 , 0x05D9 , 0x05EA , 0x0000 } , { 0x092F , 0x0939 , 0x0932 , 0x094B , 0x0917 , 0x0939 , 0x093F , 0x0928 , 0x094D , 0x0926 , 0x0940 , 0x0915 , 0x094D , 0x092F , 0x094B , 0x0902 , 0x0928 , 0x0939 , 0x0940 , 0x0902 , 0x092C , 0x094B , 0x0932 , 0x0938 , 0x0915 , 0x0924 , 0x0947 , 0x0939 , 0x0948 , 0x0902 , 0x0000 } , { 0x306A , 0x305C , 0x307F , 0x3093 , 0x306A , 0x65E5 , 0x672C , 0x8A9E , 0x3092 , 0x8A71 , 0x3057 , 0x3066 , 0x304F , 0x308C , 0x306A , 0x3044 , 0x306E , 0x304B , 0x0000 } , /* ▁ STRNEWLINE ▁ { STRNEWLINE ▁ 0xC138 , ▁ 0xACC4 , ▁ 0xC758 , ▁ 0xBAA8 , ▁ 0xB4E0 , ▁ 0xC0AC , ▁ 0xB78C , ▁ 0xB4E4 , ▁ 0xC774 , STRNEWLINE ▁ 0xD55C , ▁ 0xAD6D , ▁ 0xC5B4 , ▁ 0xB97C , ▁ 0xC774 , ▁ 0xD574 , ▁ 0xD55C , ▁ 0xB2E4 , ▁ 0xBA74 , STRNEWLINE ▁ 0xC5BC , ▁ 0xB9C8 , ▁ 0xB098 , ▁ 0xC88B , ▁ 0xC744 , ▁ 0xAE4C , ▁ 0x0000 STRNEWLINE ▁ } , STRNEWLINE */ { 0x043F , 0x043E , 0x0447 , 0x0435 , 0x043C , 0x0443 , 0x0436 , 0x0435 , 0x043E , 0x043D , 0x0438 , 0x043D , 0x0435 , 0x0433 , 0x043E , 0x0432 , 0x043E , 0x0440 , 0x044F , 0x0442 , 0x043F , 0x043E , 0x0440 , 0x0443 , 0x0441 , 0x0441 , 0x043A , 0x0438 , 0x0000 } , { 0x0050 , 0x006F , 0x0072 , 0x0071 , 0x0075 , 0x00E9 , 0x006E , 0x006F , 0x0070 , 0x0075 , 0x0065 , 0x0064 , 0x0065 , 0x006E , 0x0073 , 0x0069 , 0x006D , 0x0070 , 0x006C , 0x0065 , 0x006D , 0x0065 , 0x006E , 0x0074 , 0x0065 , 0x0068 , 0x0061 , 0x0062 , 0x006C , 0x0061 , 0x0072 , 0x0065 , 0x006E , 0x0045 , 0x0073 , 0x0070 , 0x0061 , 0x00F1 , 0x006F , 0x006C , 0x0000 } , { 0x4ED6 , 0x5011 , 0x7232 , 0x4EC0 , 0x9EBD , 0x4E0D , 0x8AAA , 0x4E2D , 0x6587 , 0x0000 } , { 0x0054 , 0x1EA1 , 0x0069 , 0x0073 , 0x0061 , 0x006F , 0x0068 , 0x1ECD , 0x006B , 0x0068 , 0x00F4 , 0x006E , 0x0067 , 0x0074 , 0x0068 , 0x1EC3 , 0x0063 , 0x0068 , 0x1EC9 , 0x006E , 0x00F3 , 0x0069 , 0x0074 , 0x0069 , 0x1EBF , 0x006E , 0x0067 , 0x0056 , 0x0069 , 0x1EC7 , 0x0074 , 0x0000 } , { 0x0033 , 0x5E74 , 0x0042 , 0x7D44 , 0x91D1 , 0x516B , 0x5148 , 0x751F , 0x0000 } , { 0x5B89 , 0x5BA4 , 0x5948 , 0x7F8E , 0x6075 , 0x002D , 0x0077 , 0x0069 , 0x0074 , 0x0068 , 0x002D , 0x0053 , 0x0055 , 0x0050 , 0x0045 , 0x0052 , 0x002D , 0x004D , 0x004F , 0x004E , 0x004B , 0x0045 , 0x0059 , 0x0053 , 0x0000 } , { 0x0048 , 0x0065 , 0x006C , 0x006C , 0x006F , 0x002D , 0x0041 , 0x006E , 0x006F , 0x0074 , 0x0068 , 0x0065 , 0x0072 , 0x002D , 0x0057 , 0x0061 , 0x0079 , 0x002D , 0x305D , 0x308C , 0x305E , 0x308C , 0x306E , 0x5834 , 0x6240 , 0x0000 } , { 0x3072 , 0x3068 , 0x3064 , 0x5C4B , 0x6839 , 0x306E , 0x4E0B , 0x0032 , 0x0000 } , { 0x004D , 0x0061 , 0x006A , 0x0069 , 0x3067 , 0x004B , 0x006F , 0x0069 , 0x3059 , 0x308B , 0x0035 , 0x79D2 , 0x524D , 0x0000 } , { 0x30D1 , 0x30D5 , 0x30A3 , 0x30FC , 0x0064 , 0x0065 , 0x30EB , 0x30F3 , 0x30D0 , 0x0000 } , { 0x305D , 0x306E , 0x30B9 , 0x30D4 , 0x30FC , 0x30C9 , 0x3067 , 0x0000 } , // ▁ test ▁ non - BMP ▁ code ▁ points ENDCOM { 0xD800 , 0xDF00 , 0xD800 , 0xDF01 , 0xD800 , 0xDF02 , 0xD800 , 0xDF03 , 0xD800 , 0xDF05 , 0xD800 , 0xDF06 , 0xD800 , 0xDF07 , 0xD800 , 0xDF09 , 0xD800 , 0xDF0A , 0xD800 , 0xDF0B , 0x0000 } , { 0xD800 , 0xDF0D , 0xD800 , 0xDF0C , 0xD800 , 0xDF1E , 0xD800 , 0xDF0F , 0xD800 , 0xDF16 , 0xD800 , 0xDF15 , 0xD800 , 0xDF14 , 0xD800 , 0xDF12 , 0xD800 , 0xDF10 , 0xD800 , 0xDF20 , 0xD800 , 0xDF21 , 0x0000 } , // ▁ Greek ENDCOM { 0x03b5 , 0x03bb , 0x03bb , 0x03b7 , 0x03bd , 0x03b9 , 0x03ba , 0x03ac } , // ▁ Maltese ENDCOM { 0x0062 , 0x006f , 0x006e , 0x0121 , 0x0075 , 0x0073 , 0x0061 , 0x0127 , 0x0127 , 0x0061 } , // ▁ Russian ENDCOM { 0x043f , 0x043e , 0x0447 , 0x0435 , 0x043c , 0x0443 , 0x0436 , 0x0435 , 0x043e , 0x043d , 0x0438 , 0x043d , 0x0435 , 0x0433 , 0x043e , 0x0432 , 0x043e , 0x0440 , 0x044f , 0x0442 , 0x043f , 0x043e , 0x0440 , 0x0443 , 0x0441 , 0x0441 , 0x043a , 0x0438 } , { 0xFB00 , 0xFB01 } } ; static const char * asciiIn [ ] = { " xn - - egbpdaj6bu4bxfgehfvwxn " , " xn - - ihqwcrb4cv8a8dqg056pqjye " , " xn - - Proprostnemluvesky - uyb24dma41a " , " xn - -4dbcagdahymbxekheh6e0a7fei0b " , " xn - - i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd " , " xn - - n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa " , /* ▁ " xn - -989aomsvi5e83db1d2a355cv1e0vak1dwrv93d5xbh15a0dt30a5jpsd879ccm6fea98c " , */ " xn - - b1abfaaepdrnnbgefbaDotcwatmq2g4l " , " xn - - PorqunopuedensimplementehablarenEspaol - fmd56a " , " xn - - ihqwctvzc91f659drss3x8bo0yb " , " xn - - TisaohkhngthchnitingVit - kjcr8268qyxafd2f1b9g " , " xn - -3B - ww4c5e180e575a65lsy2b " , " xn - - - with - SUPER - MONKEYS - pc58ag80a8qai00g7n9n " , " xn - - Hello - Another - Way - - fc4qua05auwb3674vfr0b " , " xn - -2 - u9tlzr9756bt3uc0v " , " xn - - MajiKoi5-783gue6qz075azm5e " , " xn - - de - jg4avhby1noc0d " , " xn - - d9juau41awczczp " , " XN - -097CCDEKGHQJK " , " XN - - db8CBHEJLGH4E0AL " , " xn - - hxargifdar " , // ▁ Greek ENDCOM " xn - - bonusaa - 5bb1da " , // ▁ Maltese ENDCOM " xn - - b1abfaaepdrnnbgefbadotcwatmq2g4l " , // ▁ Russian ▁ ( Cyrillic ) ENDCOM " fffi " } ; static const char * domainNames [ ] = { " slip129-37-118-146 . nc . us . ibm . net " , " saratoga . pe . utexas . edu " , " dial - 120-45 . ots . utexas . edu " , " woo - 085 . dorms . waller . net " , " hd30-049 . hil . compuserve . com " , " pem203-31 . pe . ttu . edu " , "56K - 227 . MaxTNT3 . pdq . net " , " dial - 36-2 . ots . utexas . edu " , " slip129-37-23-152 . ga . us . ibm . net " , " ts45ip119 . cadvision . com " , " sdn - ts - 004txaustP05 . dialsprint . net " , " bar - tnt1s66 . erols . com " , "101 . st - louis - 15 . mo . dial - access . att . net " , " h92-245 . Arco . COM " , " dial - 13-2 . ots . utexas . edu " , " net - redynet29 . datamarkets . com . ar " , " ccs - shiva28 . reacciun . net . ve " , "7 . houston - 11 . tx . dial - access . att . net " , " ingw129-37-120-26 . mo . us . ibm . net " , " dialup6 . austintx . com " , " dns2 . tpao . gov . tr " , " slip129-37-119-194 . nc . us . ibm . net " , " cs7 . dillons . co . uk . 203.119.193 . in - addr . arpa " , " swprd1 . innovplace . saskatoon . sk . ca " , " bikini . bologna . maraut . it " , " node91 . subnet159-198-79 . baxter . com " , " cust19 . max5 . new - york . ny . ms . uu . net " , " balexander . slip . andrew . cmu . edu " , " pool029 . max2 . denver . co . dynip . alter . net " , " cust49 . max9 . new - york . ny . ms . uu . net " , " s61 . abq - dialin2 . hollyberry . com " , " \\u0917\\u0928\\u0947\\u0936 . sanjose . ibm . com " , // ' : ' (0x003a ) ▁ produces ▁ U _ IDNA _ STD3 _ ASCII _ RULES _ ERROR ENDCOM " www . xn - - vea . com " , // ▁ " www . \\u00E0\\u00B3\\u00AF . com " , // ' ▁ ' ▁ ( 0x0020 ) ▁ produces ▁ U _ IDNA _ STD3 _ ASCII _ RULES _ ERROR ENDCOM " www . \\u00C2\\u00A4 . com " , " www . \\u00C2\\u00A3 . com " , // ▁ " \\u0025 " , ▁ // ' % ' ▁ ( 0x0025 ) ▁ produces ▁ U _ IDNA _ STD3 _ ASCII _ RULES _ ERROR ENDCOM // ▁ " \\u005C\\u005C " , ▁ // ' \ ' ▁ ( 0x005C ) ▁ produces ▁ U _ IDNA _ STD3 _ ASCII _ RULES _ ERROR ENDCOM // " \\u002F " , ENDCOM // " www . \\u0021 . com " , ENDCOM // " www . \\u0024 . com " , ENDCOM // " \\u003f " , ENDCOM // ▁ These ▁ yeild ▁ U _ IDNA _ PROHIBITED _ ERROR ENDCOM // " \\u00CF\\u0082 . com " , ENDCOM // " \\u00CE\\u00B2\\u00C3\\u009Fss . com " , ENDCOM // " \\u00E2\\u0098\\u00BA . com " , ENDCOM " \\u00C3\\u00BC . com " , } ; typedef struct ErrorCases ErrorCases ; static const struct ErrorCases { UChar unicode [ 100 ] ; const char * ascii ; UErrorCode expected ; UBool useSTD3ASCIIRules ; UBool testToUnicode ; UBool testLabel ; } errorCases [ ] = { { { 0x0077 , 0x0077 , 0x0077 , 0x002e , /* ▁ www . ▁ */ 0xC138 , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x070F , /* prohibited */ 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0x002e , 0x0063 , 0x006f , 0x006d , /* ▁ com . ▁ */ 0x0000 } , " www . XN - -8mb5595fsoa28orucya378bqre2tcwop06c5qbw82a1rffmae0361dea96b . com " , U_IDNA_PROHIBITED_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , /* ▁ www . ▁ */ 0xC138 , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x0221 , 0x0234 /* Unassigned ▁ code ▁ points */ , 0x002e , 0x0063 , 0x006f , 0x006d , /* ▁ com . ▁ */ 0x0000 } , " www . XN - -6lA2Bz548Fj1GuA391Bf1Gb1N59Ab29A7iA . com " , U_IDNA_UNASSIGNED_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , /* ▁ www . ▁ */ 0xC138 , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x0644 , 0x064A , 0x0647 , /* Arabic ▁ code ▁ points . ▁ Cannot ▁ mix ▁ RTL ▁ with ▁ LTR */ 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0x002e , 0x0063 , 0x006f , 0x006d , /* ▁ com . ▁ */ 0x0000 } , " www . xn - - ghBGI4851OiyA33VqrD6Az86C4qF83CtRv93D5xBk15AzfG0nAgA0578DeA71C . com " , U_IDNA_CHECK_BIDI_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , /* ▁ www . ▁ */ /* ▁ labels ▁ cannot ▁ begin ▁ with ▁ an ▁ HYPHEN ▁ */ 0x002D , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x002E , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0x002e , 0x0063 , 0x006f , 0x006d , /* ▁ com . ▁ */ 0x0000 } , " www . xn - - - - b95Ew8SqA315Ao5FbuMlnNmhA . com " , U_IDNA_STD3_ASCII_RULES_ERROR , TRUE , FALSE , FALSE } , { { /* ▁ correct ▁ ACE - prefix ▁ followed ▁ by ▁ unicode ▁ */ 0x0077 , 0x0077 , 0x0077 , 0x002e , /* ▁ www . ▁ */ 0x0078 , 0x006e , 0x002d , 0x002d , /* ▁ ACE ▁ Prefix ▁ */ 0x002D , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x002D , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0x002e , 0x0063 , 0x006f , 0x006d , /* ▁ com . ▁ */ 0x0000 } , /* ▁ wrong ▁ ACE - prefix ▁ followed ▁ by ▁ valid ▁ ACE - encoded ▁ ASCII ▁ */ " www . XY - - - - - b91I0V65S96C2A355Cw1E5yCeQr19CsnP1mFfmAE0361DeA96B . com " , U_IDNA_ACE_PREFIX_ERROR , FALSE , FALSE , FALSE } , /* ▁ cannot ▁ verify ▁ U _ IDNA _ VERIFICATION _ ERROR ▁ */ { { 0x0077 , 0x0077 , 0x0077 , 0x002e , /* ▁ www . ▁ */ 0xC138 , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0xC5BC , 0xB9C8 , 0xB098 , 0xC88B , 0xC744 , 0xAE4C , 0x002e , 0x0063 , 0x006f , 0x006d , /* ▁ com . ▁ */ 0x0000 } , " www . xn - -989AoMsVi5E83Db1D2A355Cv1E0vAk1DwRv93D5xBh15A0Dt30A5JpSD879Ccm6FeA98C . com " , U_IDNA_LABEL_TOO_LONG_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , /* ▁ www . ▁ */ 0x0030 , 0x0644 , 0x064A , 0x0647 , 0x0031 , /* ▁ Arabic ▁ code ▁ points ▁ squashed ▁ between ▁ EN ▁ codepoints ▁ */ 0x002e , 0x0063 , 0x006f , 0x006d , /* ▁ com . ▁ */ 0x0000 } , " www . xn - -01 - tvdmo . com " , U_IDNA_CHECK_BIDI_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , // ▁ www . ▁ ENDCOM 0x206C , 0x0644 , 0x064A , 0x0647 , 0x206D , // ▁ Arabic ▁ code ▁ points ▁ squashed ▁ between ▁ BN ▁ codepoints ▁ ENDCOM 0x002e , 0x0063 , 0x006f , 0x006d , // ▁ com . ▁ ENDCOM 0x0000 } , " www . XN - - ghbgi278xia . com " , U_IDNA_PROHIBITED_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , // ▁ www . ▁ ENDCOM 0x002D , 0x0041 , 0x0042 , 0x0043 , 0x0044 , 0x0045 , // ▁ HYPHEN ▁ at ▁ the ▁ start ▁ of ▁ label ▁ ENDCOM 0x002e , 0x0063 , 0x006f , 0x006d , // ▁ com . ▁ ENDCOM 0x0000 } , " www . - abcde . com " , U_IDNA_STD3_ASCII_RULES_ERROR , TRUE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , // ▁ www . ▁ ENDCOM 0x0041 , 0x0042 , 0x0043 , 0x0044 , 0x0045 , 0x002D , // ▁ HYPHEN ▁ at ▁ the ▁ end ▁ of ▁ the ▁ label ENDCOM 0x002e , 0x0063 , 0x006f , 0x006d , // ▁ com . ▁ ENDCOM 0x0000 } , " www . abcde - . com " , U_IDNA_STD3_ASCII_RULES_ERROR , TRUE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , // ▁ www . ▁ ENDCOM 0x0041 , 0x0042 , 0x0043 , 0x0044 , 0x0045 , 0x0040 , // ▁ Containing ▁ non ▁ LDH ▁ code ▁ point ENDCOM 0x002e , 0x0063 , 0x006f , 0x006d , // ▁ com . ▁ ENDCOM 0x0000 } , " www . abcde @ . com " , U_IDNA_STD3_ASCII_RULES_ERROR , TRUE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , // ▁ www . ▁ ENDCOM // ▁ zero ▁ length ▁ label ENDCOM 0x002e , 0x0063 , 0x006f , 0x006d , // ▁ com . ▁ ENDCOM 0x0000 } , " www . . com " , U_IDNA_ZERO_LENGTH_LABEL_ERROR , TRUE , FALSE , FALSE } , { { 0 } , NULL , U_ILLEGAL_ARGUMENT_ERROR , TRUE , TRUE , FALSE } } ; # define MAX_DEST_SIZE 300 void TestIDNA :: debug ( const UChar * src , int32_t srcLength , int32_t options ) { UParseError parseError ; UErrorCode transStatus = U_ZERO_ERROR ; UErrorCode prepStatus = U_ZERO_ERROR ; NamePrepTransform * trans = NamePrepTransform :: createInstance ( parseError , transStatus ) ; int32_t prepOptions = ( ( ( options & UIDNA_ALLOW_UNASSIGNED ) != 0 ) ? USPREP_ALLOW_UNASSIGNED : 0 ) ; LocalUStringPrepProfilePointer prep ( usprep_openByType ( USPREP_RFC3491_NAMEPREP , & prepStatus ) ) ; UChar * transOut = NULL , * prepOut = NULL ; int32_t transOutLength = 0 , prepOutLength = 0 ; transOutLength = trans -> process ( src , srcLength , transOut , 0 , prepOptions > 0 , & parseError , transStatus ) ; if ( transStatus == U_BUFFER_OVERFLOW_ERROR ) { transStatus = U_ZERO_ERROR ; transOut = ( UChar * ) malloc ( U_SIZEOF_UCHAR * transOutLength ) ; transOutLength = trans -> process ( src , srcLength , transOut , transOutLength , prepOptions > 0 , & parseError , transStatus ) ; } prepOutLength = usprep_prepare ( prep . getAlias ( ) , src , srcLength , prepOut , 0 , prepOptions , & parseError , & prepStatus ) ; if ( prepStatus == U_BUFFER_OVERFLOW_ERROR ) { prepStatus = U_ZERO_ERROR ; prepOut = ( UChar * ) malloc ( U_SIZEOF_UCHAR * prepOutLength ) ; prepOutLength = usprep_prepare ( prep . getAlias ( ) , src , srcLength , prepOut , prepOutLength , prepOptions , & parseError , & prepStatus ) ; } if ( UnicodeString ( transOut , transOutLength ) != UnicodeString ( prepOut , prepOutLength ) ) { errln ( " Failed . ▁ Expected : ▁ " + prettify ( UnicodeString ( transOut , transOutLength ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( prepOut , prepOutLength ) ) ) ; } free ( transOut ) ; free ( prepOut ) ; delete trans ; } void TestIDNA :: testAPI ( const UChar * src , const UChar * expected , const char * testName , UBool useSTD3ASCIIRules , UErrorCode expectedStatus , UBool doCompare , UBool testUnassigned , TestFunc func , UBool testSTD3ASCIIRules ) { UErrorCode status = U_ZERO_ERROR ; UChar destStack [ MAX_DEST_SIZE ] ; int32_t destLen = 0 ; UChar * dest = NULL ; int32_t expectedLen = ( expected != NULL ) ? u_strlen ( expected ) : 0 ; int32_t options = ( useSTD3ASCIIRules == TRUE ) ? UIDNA_USE_STD3_RULES : UIDNA_DEFAULT ; UParseError parseError ; int32_t tSrcLen = 0 ; UChar * tSrc = NULL ; if ( src != NULL ) { tSrcLen = u_strlen ( src ) ; tSrc = ( UChar * ) malloc ( U_SIZEOF_UCHAR * tSrcLen ) ; memcpy ( tSrc , src , tSrcLen * U_SIZEOF_UCHAR ) ; } // ▁ test ▁ null - terminated ▁ source ▁ and ▁ return ▁ value ▁ of ▁ number ▁ of ▁ UChars ▁ required ENDCOM destLen = func ( src , - 1 , NULL , 0 , options , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; // ▁ reset ▁ error ▁ code ENDCOM if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options , & parseError , & status ) ; // ▁ TODO ▁ : ▁ compare ▁ output ▁ with ▁ expected ENDCOM if ( U_SUCCESS ( status ) && expectedStatus != U_IDNA_STD3_ASCII_RULES_ERROR && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source . ▁ Expected ▁ : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( dest , destLen ) ) ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errcheckln ( status , " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; free ( tSrc ) ; return ; } if ( testUnassigned ) { status = U_ZERO_ERROR ; destLen = func ( src , - 1 , NULL , 0 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; // ▁ reset ▁ error ▁ code ENDCOM if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; // ▁ TODO ▁ : ▁ compare ▁ output ▁ with ▁ expected ENDCOM if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { // errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ with ▁ both ▁ options ▁ set . \n " , testName ) ; ENDCOM errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ " + prettify ( src ) + " ▁ with ▁ both ▁ options ▁ set . ▁ Expected : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) + " Got : ▁ " + prettify ( UnicodeString ( dest , destLen ) ) ) ; debug ( src , - 1 , options | UIDNA_ALLOW_UNASSIGNED ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } // testing ▁ query ▁ string ENDCOM if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } status = U_ZERO_ERROR ; // ▁ test ▁ source ▁ with ▁ lengthand ▁ return ▁ value ▁ of ▁ number ▁ of ▁ UChars ▁ required ENDCOM destLen = func ( tSrc , tSrcLen , NULL , 0 , options , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; // ▁ reset ▁ error ▁ code ENDCOM if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options , & parseError , & status ) ; // ▁ TODO ▁ : ▁ compare ▁ output ▁ with ▁ expected ENDCOM if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } if ( testUnassigned ) { status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; // ▁ reset ▁ error ▁ code ENDCOM if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; // ▁ TODO ▁ : ▁ compare ▁ output ▁ with ▁ expected ENDCOM if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length ▁ and ▁ both ▁ options ▁ set . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } // testing ▁ query ▁ string ENDCOM if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } status = U_ZERO_ERROR ; if ( testSTD3ASCIIRules == TRUE ) { destLen = func ( src , - 1 , NULL , 0 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; // ▁ reset ▁ error ▁ code ENDCOM if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; // ▁ TODO ▁ : ▁ compare ▁ output ▁ with ▁ expected ENDCOM if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { // errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ with ▁ both ▁ options ▁ set . \n " , testName ) ; ENDCOM errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ both ▁ options ▁ set . ▁ Expected : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } // testing ▁ query ▁ string ENDCOM if ( status != expectedStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; // ▁ reset ▁ error ▁ code ENDCOM if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; // ▁ TODO ▁ : ▁ compare ▁ output ▁ with ▁ expected ENDCOM if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length ▁ and ▁ both ▁ options ▁ set . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } // testing ▁ query ▁ string ENDCOM if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } free ( tSrc ) ; } void TestIDNA :: testCompare ( const UChar * s1 , int32_t s1Len , const UChar * s2 , int32_t s2Len , const char * testName , CompareFunc func , UBool isEqual ) { UErrorCode status = U_ZERO_ERROR ; int32_t retVal = func ( s1 , - 1 , s2 , - 1 , UIDNA_DEFAULT , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ null ▁ termniated ▁ strings . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , - 1 , s2 , - 1 , UIDNA_ALLOW_UNASSIGNED , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ null ▁ termniated ▁ strings ▁ with ▁ options ▁ set . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ and ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , s1Len , s2 , s2Len , UIDNA_DEFAULT , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ string ▁ length . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ with ▁ string ▁ length . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , s1Len , s2 , s2Len , UIDNA_ALLOW_UNASSIGNED , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ string ▁ length ▁ and ▁ options ▁ set . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ with ▁ string ▁ length ▁ and ▁ options ▁ set . ▁ Error : ▁ % s " , u_errorName ( status ) , testName ) ; } } void TestIDNA :: testToASCII ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testAPI ( unicodeIn [ i ] , buf , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; } } void TestIDNA :: testToUnicode ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( asciiIn ) / sizeof ( asciiIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testAPI ( buf , unicodeIn [ i ] , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; } } void TestIDNA :: testIDNToUnicode ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; UErrorCode status = U_ZERO_ERROR ; int32_t bufLen = 0 ; UParseError parseError ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( domainNames ) / sizeof ( domainNames [ 0 ] ) ) ; i ++ ) { bufLen = ( int32_t ) strlen ( domainNames [ i ] ) ; bufLen = u_unescape ( domainNames [ i ] , buf , bufLen + 1 ) ; func ( buf , bufLen , expected , MAX_DEST_SIZE , UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s " , testName , i , u_errorName ( status ) ) ; break ; } testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; // test ▁ toUnicode ▁ with ▁ all ▁ labels ▁ in ▁ the ▁ string ENDCOM testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s ▁ \n " , testName , i , u_errorName ( status ) ) ; break ; } } } void TestIDNA :: testIDNToASCII ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; UErrorCode status = U_ZERO_ERROR ; int32_t bufLen = 0 ; UParseError parseError ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( domainNames ) / sizeof ( domainNames [ 0 ] ) ) ; i ++ ) { bufLen = ( int32_t ) strlen ( domainNames [ i ] ) ; bufLen = u_unescape ( domainNames [ i ] , buf , bufLen + 1 ) ; func ( buf , bufLen , expected , MAX_DEST_SIZE , UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s " , testName , i , u_errorName ( status ) ) ; break ; } testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; // test ▁ toASCII ▁ with ▁ all ▁ labels ▁ in ▁ the ▁ string ENDCOM testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , FALSE , TRUE , func ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s ▁ \n " , testName , i , u_errorName ( status ) ) ; break ; } } } void TestIDNA :: testCompare ( const char * testName , CompareFunc func ) { int32_t i ; UChar www [ ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UChar com [ ] = { 0x002E , 0x0043 , 0x004F , 0x004D , 0x0000 } ; UChar buf [ MAX_DEST_SIZE ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UnicodeString source ( www ) , uni0 ( www ) , uni1 ( www ) , ascii0 ( www ) , ascii1 ( www ) ; uni0 . append ( unicodeIn [ 0 ] ) ; uni0 . append ( com ) ; uni0 . append ( ( UChar ) 0x0000 ) ; uni1 . append ( unicodeIn [ 1 ] ) ; uni1 . append ( com ) ; uni1 . append ( ( UChar ) 0x0000 ) ; ascii0 . append ( asciiIn [ 0 ] ) ; ascii0 . append ( com ) ; ascii0 . append ( ( UChar ) 0x0000 ) ; ascii1 . append ( asciiIn [ 1 ] ) ; ascii1 . append ( com ) ; ascii1 . append ( ( UChar ) 0x0000 ) ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf + 4 , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; u_strcat ( buf , com ) ; // ▁ for ▁ every ▁ entry ▁ in ▁ unicodeIn ▁ array ENDCOM // ▁ prepend ▁ www . ▁ and ▁ append ▁ . com ENDCOM source . truncate ( 4 ) ; source . append ( unicodeIn [ i ] ) ; source . append ( com ) ; source . append ( ( UChar ) 0x0000 ) ; // ▁ a ) ▁ compare ▁ it ▁ with ▁ itself ENDCOM const UChar * src = source . getBuffer ( ) ; int32_t srcLen = u_strlen ( src ) ; // subtract ▁ null ENDCOM testCompare ( src , srcLen , src , srcLen , testName , func , TRUE ) ; // ▁ b ) ▁ compare ▁ it ▁ with ▁ asciiIn ▁ equivalent ENDCOM testCompare ( src , srcLen , buf , u_strlen ( buf ) , testName , func , TRUE ) ; // ▁ c ) ▁ compare ▁ it ▁ with ▁ unicodeIn ▁ not ▁ equivalent ENDCOM if ( i == 0 ) { testCompare ( src , srcLen , uni1 . getBuffer ( ) , uni1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , uni0 . getBuffer ( ) , uni0 . length ( ) - 1 , testName , func , FALSE ) ; } // ▁ d ) ▁ compare ▁ it ▁ with ▁ asciiIn ▁ not ▁ equivalent ENDCOM if ( i == 0 ) { testCompare ( src , srcLen , ascii1 . getBuffer ( ) , ascii1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , ascii0 . getBuffer ( ) , ascii0 . length ( ) - 1 , testName , func , FALSE ) ; } } } # if 0 static int32_t getNextSeperator ( UChar * src , int32_t srcLength , UChar * * limit ) { if ( srcLength == - 1 ) { int32_t i ; for ( i = 0 ; ; i ++ ) { if ( src [ i ] == 0 ) { * limit = src + i ; // ▁ point ▁ to ▁ null ENDCOM return i ; } if ( src [ i ] == 0x002e ) { * limit = src + ( i + 1 ) ; // ▁ go ▁ past ▁ the ▁ delimiter ENDCOM return i ; } } // ▁ we ▁ have ▁ not ▁ found ▁ the ▁ delimiter ENDCOM if ( i == srcLength ) { * limit = src + srcLength ; } return i ; } else { int32_t i ; for ( i = 0 ; i < srcLength ; i ++ ) { if ( src [ i ] == 0x002e ) { * limit = src + ( i + 1 ) ; // ▁ go ▁ past ▁ the ▁ delimiter ENDCOM return i ; } } // ▁ we ▁ have ▁ not ▁ found ▁ the ▁ delimiter ENDCOM if ( i == srcLength ) { * limit = src + srcLength ; } return i ; } } void printPunycodeOutput ( ) { UChar dest [ MAX_DEST_SIZE ] ; int32_t destCapacity = MAX_DEST_SIZE ; UChar * start ; UChar * limit ; int32_t labelLen = 0 ; UBool caseFlags [ MAX_DEST_SIZE ] ; for ( int32_t i = 0 ; i < sizeof ( errorCases ) / sizeof ( errorCases [ 0 ] ) ; i ++ ) { ErrorCases errorCase = errorCases [ i ] ; UErrorCode status = U_ZERO_ERROR ; start = errorCase . unicode ; int32_t srcLen = u_strlen ( start ) ; labelLen = getNextSeperator ( start , srcLen , & limit ) ; start = limit ; labelLen = getNextSeperator ( start , srcLen - labelLen , & limit ) ; int32_t destLen = u_strToPunycode ( dest , destCapacity , start , labelLen , caseFlags , & status ) ; if ( U_FAILURE ( status ) ) { printf ( " u _ strToPunycode ▁ failed ▁ for ▁ index ▁ % i \n " , i ) ; continue ; } for ( int32_t j = 0 ; j < destLen ; j ++ ) { printf ( " % c " , ( char ) dest [ j ] ) ; } printf ( " \n " ) ; } } # endif void TestIDNA :: testErrorCases ( const char * IDNToASCIIName , TestFunc IDNToASCII , const char * IDNToUnicodeName , TestFunc IDNToUnicode ) { UChar buf [ MAX_DEST_SIZE ] ; int32_t bufLen = 0 ; for ( int32_t i = 0 ; i < ( int32_t ) ( sizeof ( errorCases ) / sizeof ( errorCases [ 0 ] ) ) ; i ++ ) { ErrorCases errorCase = errorCases [ i ] ; UChar * src = NULL ; if ( errorCase . ascii != NULL ) { bufLen = ( int32_t ) strlen ( errorCase . ascii ) ; u_charsToUChars ( errorCase . ascii , buf , bufLen + 1 ) ; } else { bufLen = 1 ; memset ( buf , 0 , U_SIZEOF_UCHAR * MAX_DEST_SIZE ) ; } if ( errorCase . unicode [ 0 ] != 0 ) { src = errorCase . unicode ; } // ▁ test ▁ toASCII ENDCOM testAPI ( src , buf , IDNToASCIIName , errorCase . useSTD3ASCIIRules , errorCase . expected , TRUE , TRUE , IDNToASCII ) ; if ( errorCase . testLabel == TRUE ) { testAPI ( src , buf , IDNToASCIIName , errorCase . useSTD3ASCIIRules , errorCase . expected , FALSE , TRUE , IDNToASCII ) ; } if ( errorCase . testToUnicode == TRUE ) { testAPI ( ( src == NULL ) ? NULL : buf , src , IDNToUnicodeName , errorCase . useSTD3ASCIIRules , errorCase . expected , TRUE , TRUE , IDNToUnicode ) ; } } } /* STRNEWLINE void ▁ TestIDNA : : testConformance ( const ▁ char * ▁ toASCIIName , ▁ TestFunc ▁ toASCII , STRNEWLINE ▁ const ▁ char * ▁ IDNToASCIIName , ▁ TestFunc ▁ IDNToASCII , STRNEWLINE ▁ const ▁ char * ▁ IDNToUnicodeName , ▁ TestFunc ▁ IDNToUnicode , STRNEWLINE ▁ const ▁ char * ▁ toUnicodeName , ▁ TestFunc ▁ toUnicode ) { STRNEWLINE ▁ UChar ▁ src [ MAX _ DEST _ SIZE ] ; STRNEWLINE ▁ int32 _ t ▁ srcLen = 0 ; STRNEWLINE ▁ UChar ▁ expected [ MAX _ DEST _ SIZE ] ; STRNEWLINE ▁ int32 _ t ▁ expectedLen ▁ = ▁ 0 ; STRNEWLINE ▁ for ( int32 _ t ▁ i = 0 ; i < ▁ ( int32 _ t ) ( sizeof ( conformanceTestCases ) / sizeof ( conformanceTestCases [ 0 ] ) ) ; i + + ) { STRNEWLINE ▁ const ▁ char * ▁ utf8Chars1 ▁ = ▁ conformanceTestCases [ i ] . in ; STRNEWLINE ▁ int32 _ t ▁ utf8Chars1Len ▁ = ▁ ( int32 _ t ) strlen ( utf8Chars1 ) ; STRNEWLINE ▁ const ▁ char * ▁ utf8Chars2 ▁ = ▁ conformanceTestCases [ i ] . out ; STRNEWLINE ▁ int32 _ t ▁ utf8Chars2Len ▁ = ▁ ( utf8Chars2 ▁ = = ▁ NULL ) ▁ ? ▁ 0 ▁ : ▁ ( int32 _ t ) strlen ( utf8Chars2 ) ; STRNEWLINE STRNEWLINE ▁ UErrorCode ▁ status ▁ = ▁ U _ ZERO _ ERROR ; STRNEWLINE ▁ u _ strFromUTF8 ( src , MAX _ DEST _ SIZE , & srcLen , utf8Chars1 , utf8Chars1Len , & status ) ; STRNEWLINE ▁ if ( U _ FAILURE ( status ) ) { STRNEWLINE ▁ errln ( UnicodeString ( " Conversion ▁ of ▁ UTF8 ▁ source ▁ in ▁ conformanceTestCases [ " ) ▁ + ▁ i ▁ + UnicodeString ( ▁ " ] . in ▁ ( ▁ " ) + prettify ( utf8Chars1 ) ▁ + UnicodeString ( " ▁ ) ▁ failed . ▁ Error : ▁ " ) + ▁ UnicodeString ( u _ errorName ( status ) ) ) ; STRNEWLINE ▁ continue ; STRNEWLINE ▁ } STRNEWLINE ▁ if ( utf8Chars2 ▁ ! = ▁ NULL ) { STRNEWLINE ▁ u _ strFromUTF8 ( expected , MAX _ DEST _ SIZE , & expectedLen , utf8Chars2 , utf8Chars2Len , ▁ & status ) ; STRNEWLINE ▁ if ( U _ FAILURE ( status ) ) { STRNEWLINE ▁ errln ( UnicodeString ( " Conversion ▁ of ▁ UTF8 ▁ source ▁ in ▁ conformanceTestCases [ " ) ▁ + ▁ i ▁ + UnicodeString ( ▁ " ] . in ▁ ( ▁ " ) + prettify ( utf8Chars1 ) ▁ + UnicodeString ( " ▁ ) ▁ failed . ▁ Error : ▁ " ) + ▁ UnicodeString ( u _ errorName ( status ) ) ) ; STRNEWLINE ▁ continue ; STRNEWLINE ▁ } STRNEWLINE ▁ } STRNEWLINE ▁ STRNEWLINE ▁ if ( conformanceTestCases [ i ] . expectedStatus ▁ ! = ▁ U _ ZERO _ ERROR ) { STRNEWLINE ▁ // ▁ test ▁ toASCII STRNEWLINE ▁ testAPI ( src , expected , STRNEWLINE ▁ IDNToASCIIName , ▁ FALSE , STRNEWLINE ▁ conformanceTestCases [ i ] . expectedStatus , ▁ STRNEWLINE ▁ TRUE , ▁ STRNEWLINE ▁ ( conformanceTestCases [ i ] . expectedStatus ▁ ! = ▁ U _ IDNA _ UNASSIGNED _ ERROR ) , STRNEWLINE ▁ IDNToASCII ) ; STRNEWLINE STRNEWLINE ▁ testAPI ( src , expected , STRNEWLINE ▁ toASCIIName , ▁ FALSE , STRNEWLINE ▁ conformanceTestCases [ i ] . expectedStatus , ▁ TRUE , ▁ STRNEWLINE ▁ ( conformanceTestCases [ i ] . expectedStatus ▁ ! = ▁ U _ IDNA _ UNASSIGNED _ ERROR ) , STRNEWLINE ▁ toASCII ) ; STRNEWLINE ▁ } STRNEWLINE STRNEWLINE ▁ testAPI ( src , src , STRNEWLINE ▁ IDNToUnicodeName , ▁ FALSE , STRNEWLINE ▁ conformanceTestCases [ i ] . expectedStatus , ▁ TRUE , ▁ TRUE , ▁ IDNToUnicode ) ; STRNEWLINE ▁ testAPI ( src , src , STRNEWLINE ▁ toUnicodeName , ▁ FALSE , STRNEWLINE ▁ conformanceTestCases [ i ] . expectedStatus , ▁ TRUE , ▁ TRUE , ▁ toUnicode ) ; STRNEWLINE STRNEWLINE ▁ } STRNEWLINE ▁ STRNEWLINE } STRNEWLINE */ // ▁ test ▁ and ▁ ascertain ENDCOM // ▁ func ( func ( func ( src ) ) ) ▁ = = ▁ func ( src ) ENDCOM void TestIDNA :: testChaining ( const UChar * src , int32_t numIterations , const char * testName , UBool useSTD3ASCIIRules , UBool caseInsensitive , TestFunc func ) { UChar even [ MAX_DEST_SIZE ] ; UChar odd [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; int32_t i = 0 , evenLen = 0 , oddLen = 0 , expectedLen = 0 ; UErrorCode status = U_ZERO_ERROR ; int32_t srcLen = u_strlen ( src ) ; int32_t options = ( useSTD3ASCIIRules == TRUE ) ? UIDNA_USE_STD3_RULES : UIDNA_DEFAULT ; UParseError parseError ; // ▁ test ▁ null - terminated ▁ source ▁ ENDCOM expectedLen = func ( src , - 1 , expected , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , - 1 , even , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , - 1 , odd , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; } } // ▁ test ▁ null - terminated ▁ source ▁ ENDCOM status = U_ZERO_ERROR ; expectedLen = func ( src , - 1 , expected , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , - 1 , even , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , - 1 , odd , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; } } // ▁ test ▁ source ▁ with ▁ length ▁ ENDCOM status = U_ZERO_ERROR ; expectedLen = func ( src , srcLen , expected , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , oddLen , even , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , evenLen , odd , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ source ▁ with ▁ source ▁ length ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ source ▁ with ▁ source ▁ length ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , srcLen , expected , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , oddLen , even , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , evenLen , odd , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed \n " , testName ) ; } } } void TestIDNA :: testChaining ( const char * toASCIIName , TestFunc toASCII , const char * toUnicodeName , TestFunc toUnicode ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( asciiIn ) / sizeof ( asciiIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testChaining ( buf , 5 , toUnicodeName , FALSE , FALSE , toUnicode ) ; } for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { testChaining ( unicodeIn [ i ] , 5 , toASCIIName , FALSE , TRUE , toASCII ) ; } } void TestIDNA :: testRootLabelSeparator ( const char * testName , CompareFunc func , const char * IDNToASCIIName , TestFunc IDNToASCII , const char * IDNToUnicodeName , TestFunc IDNToUnicode ) { int32_t i ; UChar www [ ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UChar com [ ] = { 0x002E , 0x0043 , 0x004F , 0x004D , 0x002E , /* ▁ root ▁ label ▁ separator ▁ */ 0x0000 } ; UChar buf [ MAX_DEST_SIZE ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UnicodeString source ( www ) , uni0 ( www ) , uni1 ( www ) , ascii0 ( www ) , ascii1 ( www ) ; uni0 . append ( unicodeIn [ 0 ] ) ; uni0 . append ( com ) ; uni0 . append ( ( UChar ) 0x0000 ) ; uni1 . append ( unicodeIn [ 1 ] ) ; uni1 . append ( com ) ; uni1 . append ( ( UChar ) 0x0000 ) ; ascii0 . append ( asciiIn [ 0 ] ) ; ascii0 . append ( com ) ; ascii0 . append ( ( UChar ) 0x0000 ) ; ascii1 . append ( asciiIn [ 1 ] ) ; ascii1 . append ( com ) ; ascii1 . append ( ( UChar ) 0x0000 ) ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf + 4 , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; u_strcat ( buf , com ) ; // ▁ for ▁ every ▁ entry ▁ in ▁ unicodeIn ▁ array ENDCOM // ▁ prepend ▁ www . ▁ and ▁ append ▁ . com ENDCOM source . truncate ( 4 ) ; source . append ( unicodeIn [ i ] ) ; source . append ( com ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; int32_t srcLen = u_strlen ( src ) ; // subtract ▁ null ENDCOM // ▁ b ) ▁ compare ▁ it ▁ with ▁ asciiIn ▁ equivalent ENDCOM testCompare ( src , srcLen , buf , u_strlen ( buf ) , testName , func , TRUE ) ; // ▁ a ) ▁ compare ▁ it ▁ with ▁ itself ENDCOM testCompare ( src , srcLen , src , srcLen , testName , func , TRUE ) ; // ▁ IDNToASCII ▁ comparison ENDCOM testAPI ( src , buf , IDNToASCIIName , FALSE , U_ZERO_ERROR , TRUE , TRUE , IDNToASCII ) ; // ▁ IDNToUnicode ▁ comparison ENDCOM testAPI ( buf , src , IDNToUnicodeName , FALSE , U_ZERO_ERROR , TRUE , TRUE , IDNToUnicode ) ; // ▁ c ) ▁ compare ▁ it ▁ with ▁ unicodeIn ▁ not ▁ equivalent ENDCOM if ( i == 0 ) { testCompare ( src , srcLen , uni1 . getBuffer ( ) , uni1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , uni0 . getBuffer ( ) , uni0 . length ( ) - 1 , testName , func , FALSE ) ; } // ▁ d ) ▁ compare ▁ it ▁ with ▁ asciiIn ▁ not ▁ equivalent ENDCOM if ( i == 0 ) { testCompare ( src , srcLen , ascii1 . getBuffer ( ) , ascii1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , ascii0 . getBuffer ( ) , ascii0 . length ( ) - 1 , testName , func , FALSE ) ; } } } // ▁ runIndexedTest ENDCOM extern IntlTest * createUTS46Test ( ) ; void TestIDNA :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * par ) { if ( exec ) logln ( ( UnicodeString ) " TestSuite ▁ IDNA ▁ API ▁ " ) ; switch ( index ) { case 0 : name = " TestToASCII " ; if ( exec ) TestToASCII ( ) ; break ; case 1 : name = " TestToUnicode " ; if ( exec ) TestToUnicode ( ) ; break ; case 2 : name = " TestIDNToASCII " ; if ( exec ) TestIDNToASCII ( ) ; break ; case 3 : name = " TestIDNToUnicode " ; if ( exec ) TestIDNToUnicode ( ) ; break ; case 4 : name = " TestCompare " ; if ( exec ) TestCompare ( ) ; break ; case 5 : name = " TestErrorCases " ; if ( exec ) TestErrorCases ( ) ; break ; case 6 : name = " TestChaining " ; if ( exec ) TestChaining ( ) ; break ; case 7 : name = " TestRootLabelSeparator " ; if ( exec ) TestRootLabelSeparator ( ) ; break ; case 8 : name = " TestCompareReferenceImpl " ; if ( exec ) TestCompareReferenceImpl ( ) ; break ; case 9 : name = " TestDataFile " ; if ( exec ) TestDataFile ( ) ; break ; # if ! UCONFIG_NO_FILE_IO && ! UCONFIG_NO_LEGACY_CONVERSION case 10 : name = " TestRefIDNA " ; if ( exec ) TestRefIDNA ( ) ; break ; case 11 : name = " TestIDNAMonkeyTest " ; if ( exec ) TestIDNAMonkeyTest ( ) ; break ; # else case 10 : case 11 : name = " skip " ; break ; # endif case 12 : { name = " TestConformanceTestVectors " ; if ( exec ) { logln ( " TestSuite ▁ IDNA ▁ conf - - - - " ) ; logln ( ) ; IdnaConfTest test ; callTest ( test , par ) ; } break ; } case 13 : name = " UTS46Test " ; if ( exec ) { logln ( " TestSuite ▁ UTS46Test - - - " ) ; logln ( ) ; LocalPointer < IntlTest > test ( createUTS46Test ( ) ) ; callTest ( * test , par ) ; } break ; default : name = " " ; break ; /* needed ▁ to ▁ end ▁ loop */ } } void TestIDNA :: TestToASCII ( ) { testToASCII ( " uidna _ toASCII " , uidna_toASCII ) ; } void TestIDNA :: TestToUnicode ( ) { testToUnicode ( " uidna _ toUnicode " , uidna_toUnicode ) ; } void TestIDNA :: TestIDNToASCII ( ) { testIDNToASCII ( " uidna _ IDNToASCII " , uidna_IDNToASCII ) ; } void TestIDNA :: TestIDNToUnicode ( ) { testIDNToUnicode ( " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; } void TestIDNA :: TestCompare ( ) { testCompare ( " uidna _ compare " , uidna_compare ) ; } void TestIDNA :: TestErrorCases ( ) { testErrorCases ( " uidna _ IDNToASCII " , uidna_IDNToASCII , " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; } void TestIDNA :: TestRootLabelSeparator ( ) { testRootLabelSeparator ( " uidna _ compare " , uidna_compare , " uidna _ IDNToASCII " , uidna_IDNToASCII , " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; } void TestIDNA :: TestChaining ( ) { testChaining ( " uidna _ toASCII " , uidna_toASCII , " uidna _ toUnicode " , uidna_toUnicode ) ; } static const int loopCount = 100 ; static const int maxCharCount = 20 ; static const int maxCodePoint = 0x10ffff ; static uint32_t randul ( ) { static UBool initialized = FALSE ; if ( ! initialized ) { srand ( ( unsigned ) time ( NULL ) ) ; initialized = TRUE ; } // ▁ Assume ▁ rand ▁ has ▁ at ▁ least ▁ 12 ▁ bits ▁ of ▁ precision ENDCOM uint32_t l = 0 ; for ( uint32_t i = 0 ; i < sizeof ( l ) ; ++ i ) ( ( char * ) & l ) [ i ] = ( char ) ( ( rand ( ) & 0x0FF0 ) >> 4 ) ; return l ; } /* * STRNEWLINE ▁ * ▁ Return ▁ a ▁ random ▁ integer ▁ i ▁ where ▁ 0 ▁ < = ▁ i ▁ < ▁ n . STRNEWLINE ▁ * ▁ A ▁ special ▁ function ▁ that ▁ gets ▁ random ▁ codepoints ▁ from ▁ planes ▁ 0,1,2 ▁ and ▁ 14 STRNEWLINE ▁ */ static int32_t rand_uni ( ) { int32_t retVal = ( int32_t ) ( randul ( ) & 0x3FFFF ) ; if ( retVal >= 0x30000 ) { retVal += 0xB0000 ; } return retVal ; } static int32_t randi ( int32_t n ) { return ( int32_t ) ( randul ( ) % ( n + 1 ) ) ; } void getTestSource ( UnicodeString & fillIn ) { int32_t i = 0 ; int32_t charCount = ( randi ( maxCharCount ) + 1 ) ; while ( i < charCount ) { int32_t codepoint = rand_uni ( ) ; if ( codepoint == 0x0000 ) { continue ; } fillIn . append ( ( UChar32 ) codepoint ) ; i ++ ; } } UnicodeString TestIDNA :: testCompareReferenceImpl ( UnicodeString & src , TestFunc refIDNA , const char * refIDNAName , TestFunc uIDNA , const char * uIDNAName , int32_t options ) { const UChar * srcUChars = src . getBuffer ( ) ; UChar exp [ MAX_DEST_SIZE ] = { 0 } ; int32_t expCap = MAX_DEST_SIZE , expLen = 0 ; UErrorCode expStatus = U_ZERO_ERROR ; UParseError parseError ; logln ( " Comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ for ▁ input : ▁ " + prettify ( srcUChars ) ) ; expLen = refIDNA ( srcUChars , src . length ( ) - 1 , exp , expCap , options , & parseError , & expStatus ) ; UChar got [ MAX_DEST_SIZE ] = { 0 } ; int32_t gotCap = MAX_DEST_SIZE , gotLen = 0 ; UErrorCode gotStatus = U_ZERO_ERROR ; gotLen = uIDNA ( srcUChars , src . length ( ) - 1 , got , gotCap , options , & parseError , & gotStatus ) ; if ( expStatus != gotStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ status ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( gotStatus ) ) + " ▁ for ▁ Source : ▁ " + prettify ( srcUChars ) + " ▁ Options : ▁ " + options ) ; return UnicodeString ( " " ) ; } // ▁ now ▁ we ▁ know ▁ that ▁ both ▁ implementations ▁ yielded ▁ same ▁ error ENDCOM if ( U_SUCCESS ( expStatus ) ) { // ▁ compare ▁ the ▁ outputs ▁ if ▁ status ▁ = = ▁ U _ ZERO _ ERROR ENDCOM if ( u_strCompare ( exp , expLen , got , gotLen , TRUE ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ output ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ Expected : ▁ " + prettify ( UnicodeString ( exp , expLen ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( got , gotLen ) ) + " ▁ for ▁ Source : ▁ " + prettify ( srcUChars ) + " ▁ Options : ▁ " + options ) ; } return UnicodeString ( exp , expLen ) ; } else { logln ( " Got ▁ the ▁ same ▁ error ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ for ▁ input : ▁ " + prettify ( srcUChars ) ) ; } return UnicodeString ( " " ) ; } void TestIDNA :: testCompareReferenceImpl ( const UChar * src , int32_t srcLen ) { UnicodeString label ( src , srcLen ) ; label . append ( ( UChar ) 0x0000 ) ; // test ▁ idnaref _ toASCII ▁ and ▁ idnare ENDCOM UnicodeString asciiLabel = testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_ALLOW_UNASSIGNED ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_DEFAULT ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_USE_STD3_RULES ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_USE_STD3_RULES | UIDNA_ALLOW_UNASSIGNED ) ; if ( asciiLabel . length ( ) != 0 ) { asciiLabel . append ( ( UChar ) 0x0000 ) ; // ▁ test ▁ toUnciode ENDCOM testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_ALLOW_UNASSIGNED ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_DEFAULT ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_USE_STD3_RULES ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_USE_STD3_RULES | UIDNA_ALLOW_UNASSIGNED ) ; } } const char * failures [ ] = { " \\uAA42\\U0001F8DD\\U00019D01\\U000149A3\\uD385\\U000EE0F5\\U00018B92\\U000179D1\\U00018624\\U0002227F\\U000E83C0\\U000E8DCD\\u5460\\U00017F34\\U0001570B\\u43D1\\U0002C9C9\\U000281EC\\u2105\\U000180AE\\uC5D4" , " \\U0002F5A6\\uD638\\u0D0A\\u9E9C\\uFE5B\\U0001FCCB\\u66C4" , } ; void TestIDNA :: TestIDNAMonkeyTest ( ) { UnicodeString source ; UErrorCode status = U_ZERO_ERROR ; int i ; getInstance ( status ) ; // ▁ Init ▁ prep ENDCOM if ( U_FAILURE ( status ) ) { dataerrln ( " Test ▁ could ▁ not ▁ initialize . ▁ Got ▁ % s " , u_errorName ( status ) ) ; return ; } for ( i = 0 ; i < loopCount ; i ++ ) { source . truncate ( 0 ) ; getTestSource ( source ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; } /* ▁ for ▁ debugging ▁ */ for ( i = 0 ; i < ( int ) ( sizeof ( failures ) / sizeof ( failures [ 0 ] ) ) ; i ++ ) { source . truncate ( 0 ) ; source . append ( UnicodeString ( failures [ i ] , - 1 , US_INV ) ) ; source = source . unescape ( ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; // debug ( source . getBuffer ( ) , source . length ( ) , UIDNA _ ALLOW _ UNASSIGNED ) ; ENDCOM } source . truncate ( 0 ) ; source . append ( UNICODE_STRING_SIMPLE ( " \\uCF18\\U00021161\\U000EEF11\\U0002BB82\\U0001D63C " ) ) ; debug ( source . getBuffer ( ) , source . length ( ) , UIDNA_ALLOW_UNASSIGNED ) ; { // ▁ test ▁ deletion ▁ of ▁ code ▁ points ENDCOM UnicodeString source ( " \\u043f\\u00AD\\u034f\\u043e\\u0447\\u0435\\u043c\\u0443\\u0436\\u0435\\u043e\\u043d\\u0438\\u043d\\u0435\\u0433\\u043e\\u0432\\u043e\\u0440\\u044f\\u0442\\u043f\\u043e\\u0440\\u0443\\u0441\\u0441\\u043a\\u0438\\u0000" , - 1 , US_INV ) ; source = source . unescape ( ) ; UnicodeString expected ( " \\u043f\\u043e\\u0447\\u0435\\u043c\\u0443\\u0436\\u0435\\u043e\\u043d\\u0438\\u043d\\u0435\\u0433\\u043e\\u0432\\u043e\\u0440\\u044f\\u0442\\u043f\\u043e\\u0440\\u0443\\u0441\\u0441\\u043a\\u0438\\u0000" , - 1 , US_INV ) ; expected = expected . unescape ( ) ; UnicodeString ascii ( " xn - - b1abfaaepdrnnbgefbadotcwatmq2g4l " ) ; ascii . append ( ( UChar ) 0x0000 ) ; testAPI ( source . getBuffer ( ) , ascii . getBuffer ( ) , " uidna _ toASCII " , FALSE , U_ZERO_ERROR , TRUE , TRUE , uidna_toASCII ) ; testAPI ( source . getBuffer ( ) , ascii . getBuffer ( ) , " idnaref _ toASCII " , FALSE , U_ZERO_ERROR , TRUE , TRUE , idnaref_toASCII ) ; testCompareReferenceImpl ( source . getBuffer ( ) , source . length ( ) - 1 ) ; } } void TestIDNA :: TestCompareReferenceImpl ( ) { UChar src [ 2 ] = { 0 , 0 } ; int32_t srcLen = 0 ; for ( int32_t i = 0x40000 ; i < 0x10ffff ; i ++ ) { if ( quick == TRUE && i > 0x1FFFF ) { return ; } if ( i >= 0x30000 && i <= 0xF0000 ) { i += 0xB0000 ; } if ( i > 0xFFFF ) { src [ 0 ] = U16_LEAD ( i ) ; src [ 1 ] = U16_TRAIL ( i ) ; srcLen = 2 ; } else { src [ 0 ] = ( UChar ) i ; src [ 1 ] = 0 ; srcLen = 1 ; } testCompareReferenceImpl ( src , srcLen ) ; } } void TestIDNA :: TestRefIDNA ( ) { UErrorCode status = U_ZERO_ERROR ; getInstance ( status ) ; // ▁ Init ▁ prep ENDCOM if ( U_FAILURE ( status ) ) { if ( status == U_FILE_ACCESS_ERROR ) { dataerrln ( " Test ▁ could ▁ not ▁ initialize . ▁ Got ▁ % s " , u_errorName ( status ) ) ; } return ; } testToASCII ( " idnaref _ toASCII " , idnaref_toASCII ) ; testToUnicode ( " idnaref _ toUnicode " , idnaref_toUnicode ) ; testIDNToASCII ( " idnaref _ IDNToASCII " , idnaref_IDNToASCII ) ; testIDNToUnicode ( " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testCompare ( " idnaref _ compare " , idnaref_compare ) ; testErrorCases ( " idnaref _ IDNToASCII " , idnaref_IDNToASCII , " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testChaining ( " idnaref _ toASCII " , idnaref_toASCII , " idnaref _ toUnicode " , idnaref_toUnicode ) ; testRootLabelSeparator ( " idnaref _ compare " , idnaref_compare , " idnaref _ IDNToASCII " , idnaref_IDNToASCII , " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testChaining ( " idnaref _ toASCII " , idnaref_toASCII , " idnaref _ toUnicode " , idnaref_toUnicode ) ; } void TestIDNA :: TestDataFile ( ) { testData ( * this ) ; } TestIDNA :: ~ TestIDNA ( ) { if ( gPrep != NULL ) { delete gPrep ; gPrep = NULL ; } } NamePrepTransform * TestIDNA :: gPrep = NULL ; NamePrepTransform * TestIDNA :: getInstance ( UErrorCode & status ) { if ( TestIDNA :: gPrep == NULL ) { UParseError parseError ; TestIDNA :: gPrep = NamePrepTransform :: createInstance ( parseError , status ) ; if ( TestIDNA :: gPrep == NULL ) { // status ▁ = ▁ U _ MEMORY _ ALLOCATION _ ERROR ; ENDCOM return NULL ; } } return TestIDNA :: gPrep ; } # endif /* ▁ # if ▁ ! UCONFIG _ NO _ IDNA ▁ */ </DOCUMENT>
<DOCUMENT_ID="sofa-framework/sofa/tree/master/applications/plugins/SofaPython/PythonScriptController.cpp"> /* * * * * STRNEWLINE * ▁ SOFA , ▁ Simulation ▁ Open - Framework ▁ Architecture , ▁ development ▁ version ▁ * STRNEWLINE * ▁ ( c ) ▁ 2006-2019 ▁ INRIA , ▁ USTL , ▁ UJF , ▁ CNRS , ▁ MGH ▁ * STRNEWLINE * ▁ * STRNEWLINE * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it ▁ * STRNEWLINE * ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ * STRNEWLINE * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2.1 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ * STRNEWLINE * ▁ your ▁ option ) ▁ any ▁ later ▁ version . ▁ * STRNEWLINE * ▁ * STRNEWLINE * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT ▁ * STRNEWLINE * ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or ▁ * STRNEWLINE * ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ * STRNEWLINE * ▁ for ▁ more ▁ details . ▁ * STRNEWLINE * ▁ * STRNEWLINE * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ * STRNEWLINE * ▁ along ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . ▁ * STRNEWLINE * * * * * STRNEWLINE * ▁ Authors : ▁ The ▁ SOFA ▁ Team ▁ and ▁ external ▁ contributors ▁ ( see ▁ Authors . txt ) ▁ * STRNEWLINE * ▁ * STRNEWLINE * ▁ Contact ▁ information : ▁ contact @ sofa - framework . org ▁ * STRNEWLINE * * * * */ # include " PythonMacros . h " # include " PythonScriptController . h " # include < sofa / core / ObjectFactory . h > # include < sofa / helper / AdvancedTimer . h > using sofa :: helper :: AdvancedTimer ; using sofa :: core :: objectmodel :: Base ; using sofa :: simulation :: Node ; # include " Binding _ PythonScriptController . h " using sofa :: simulation :: PythonEnvironment ; # include " PythonScriptEvent . h " using sofa :: core :: objectmodel :: PythonScriptEvent ; # include < sofa / helper / system / FileMonitor . h > using sofa :: helper :: system :: FileMonitor ; using sofa :: helper :: system :: FileEventListener ; # include < sofa / core / objectmodel / IdleEvent . h > using sofa :: core :: objectmodel :: IdleEvent ; # include " PythonFactory . h " // TODO ( dmarchal ) : ▁ This ▁ have ▁ to ▁ be ▁ merged ▁ with ▁ the ▁ ScopedAdvancedTimer ENDCOM struct ActivableScopedAdvancedTimer { const char * message ; bool m_active ; Base * m_base ; ActivableScopedAdvancedTimer ( bool active , const char * message , Base * base ) : message ( message ) , m_active ( active ) , m_base ( base ) { if ( m_active ) AdvancedTimer :: stepBegin ( message , m_base ) ; } ~ ActivableScopedAdvancedTimer ( ) { if ( m_active ) AdvancedTimer :: stepEnd ( message , m_base ) ; } } ; namespace sofa { namespace component { namespace controller { class MyFileEventListener : public FileEventListener { PythonScriptController * m_controller ; public : MyFileEventListener ( PythonScriptController * psc ) { m_controller = psc ; } ~ MyFileEventListener ( ) override { } virtual void fileHasChanged ( const std :: string & filepath ) override { PythonEnvironment :: gil lock { __func__ } ; // / ▁ This ▁ function ▁ is ▁ called ▁ when ▁ the ▁ file ▁ has ▁ changed . ▁ Two ▁ cases ▁ have ENDCOM // / ▁ to ▁ be ▁ considered ▁ if ▁ the ▁ script ▁ was ▁ already ▁ loaded ▁ once ▁ or ▁ not . ENDCOM if ( ! m_controller -> scriptControllerInstance ( ) ) { m_controller -> doLoadScript ( ) ; } else { PythonEnvironment :: gil state { __func__ } ; std :: string file = filepath ; SP_CALL_FILEFUNC ( const_cast < char * > ( " onReimpAFile " ) , const_cast < char * > ( " s " ) , const_cast < char * > ( file . data ( ) ) ) ; m_controller -> refreshBinding ( ) ; } } } ; int PythonScriptControllerClass = core :: RegisterObject ( " A ▁ Sofa ▁ controller ▁ scripted ▁ in ▁ python " ) . add < PythonScriptController > ( ) ; PythonScriptController :: PythonScriptController ( ) : ScriptController ( ) , m_filename ( initData ( & m_filename , " filename " , " Python ▁ script ▁ filename " ) ) , m_classname ( initData ( & m_classname , " classname " , " Python ▁ class ▁ implemented ▁ in ▁ the ▁ script ▁ to ▁ instanciate ▁ for ▁ the ▁ controller " ) ) , m_variables ( initData ( & m_variables , " variables " , " Array ▁ of ▁ string ▁ variables ▁ ( equivalent ▁ to ▁ a ▁ c - like ▁ argv ) " ) ) , m_timingEnabled ( initData ( & m_timingEnabled , true , " timingEnabled " , " Set ▁ this ▁ attribute ▁ to ▁ true ▁ or ▁ false ▁ to ▁ activate / deactivate ▁ the ▁ gathering " " ▁ of ▁ timing ▁ statistics ▁ on ▁ the ▁ python ▁ execution ▁ time . ▁ Default ▁ value ▁ is ▁ set " " to ▁ true . " ) ) , m_doAutoReload ( initData ( & m_doAutoReload , false , " autoreload " , " Automatically ▁ reload ▁ the ▁ file ▁ when ▁ the ▁ source ▁ code ▁ is ▁ changed . ▁ " " Default ▁ value ▁ is ▁ set ▁ to ▁ false " ) ) , m_ScriptControllerClass ( nullptr ) , m_ScriptControllerInstance ( nullptr ) { m_filelistener = new MyFileEventListener ( this ) ; } PythonScriptController :: ~ PythonScriptController ( ) { if ( m_filelistener ) { FileMonitor :: removeListener ( m_filelistener ) ; delete m_filelistener ; } } void PythonScriptController :: setInstance ( PyObject * instance ) { PythonEnvironment :: gil lock ( __func__ ) ; // ▁ " trust ▁ me ▁ i ' m ▁ an ▁ engineer " ENDCOM if ( m_ScriptControllerInstance ) { Py_DECREF ( m_ScriptControllerInstance ) ; } m_ScriptControllerInstance = instance ; // ▁ note : ▁ we ▁ don ' t ▁ use ▁ PyObject _ Type ▁ as ▁ it ▁ returns ▁ a ▁ new ▁ reference ▁ which ▁ is ENDCOM // ▁ not ▁ handled ▁ correctly ▁ in ▁ loadScript ENDCOM m_ScriptControllerClass = ( PyObject * ) instance -> ob_type ; Py_INCREF ( instance ) ; refreshBinding ( ) ; } void PythonScriptController :: refreshBinding ( ) { BIND_OBJECT_METHOD ( onLoaded ) BIND_OBJECT_METHOD ( createGraph ) BIND_OBJECT_METHOD ( initGraph ) BIND_OBJECT_METHOD ( bwdInitGraph ) BIND_OBJECT_METHOD ( onKeyPressed ) BIND_OBJECT_METHOD ( onKeyReleased ) BIND_OBJECT_METHOD ( onMouseMove ) BIND_OBJECT_METHOD ( onMouseButtonLeft ) BIND_OBJECT_METHOD ( onMouseButtonRight ) BIND_OBJECT_METHOD ( onMouseButtonMiddle ) BIND_OBJECT_METHOD ( onMouseWheel ) BIND_OBJECT_METHOD ( onBeginAnimationStep ) BIND_OBJECT_METHOD ( onEndAnimationStep ) BIND_OBJECT_METHOD ( storeResetState ) BIND_OBJECT_METHOD ( reset ) BIND_OBJECT_METHOD ( cleanup ) BIND_OBJECT_METHOD ( onGUIEvent ) BIND_OBJECT_METHOD ( onScriptEvent ) BIND_OBJECT_METHOD ( draw ) BIND_OBJECT_METHOD ( onIdle ) } bool PythonScriptController :: isDerivedFrom ( const std :: string & name , const std :: string & module ) { PythonEnvironment :: gil lock ( __func__ ) ; PyObject * moduleDict = PyModule_GetDict ( PyImport_AddModule ( module . c_str ( ) ) ) ; PyObject * controllerClass = PyDict_GetItemString ( moduleDict , name . c_str ( ) ) ; return 1 == PyObject_IsInstance ( m_ScriptControllerInstance , controllerClass ) ; } void PythonScriptController :: loadScript ( ) { PythonEnvironment :: gil lock ( __func__ ) ; if ( m_doAutoReload . getValue ( ) ) { FileMonitor :: addFile ( m_filename . getFullPath ( ) , m_filelistener ) ; } // ▁ if ▁ the ▁ filename ▁ is ▁ empty , ▁ the ▁ controller ▁ is ▁ supposed ▁ to ▁ be ▁ in ▁ an ▁ already ▁ loaded ▁ file ENDCOM // ▁ otherwise ▁ load ▁ the ▁ controller ' s ▁ file ENDCOM if ( m_filename . isSet ( ) && ! m_filename . getRelativePath ( ) . empty ( ) && ! PythonEnvironment :: runFile ( m_filename . getFullPath ( ) . c_str ( ) ) ) { msg_error ( ) << " ▁ load ▁ error ▁ ( file ▁ ' " << m_filename . getFullPath ( ) . c_str ( ) << " ' ▁ not ▁ parsable ) " ; return ; } // ▁ classe ENDCOM PyObject * pDict = PyModule_GetDict ( PyImport_AddModule ( " _ _ main _ _ " ) ) ; m_ScriptControllerClass = PyDict_GetItemString ( pDict , m_classname . getValueString ( ) . c_str ( ) ) ; if ( ! m_ScriptControllerClass ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ not ▁ found ) . " ; return ; } // ▁ verify ▁ that ▁ the ▁ class ▁ is ▁ a ▁ subclass ▁ of ▁ PythonScriptController ENDCOM if ( 1 != PyObject_IsSubclass ( m_ScriptControllerClass , ( PyObject * ) & SP_SOFAPYTYPEOBJECT ( PythonScriptController ) ) ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ does ▁ not ▁ inherit ▁ from ▁ ' Sofa . PythonScriptController ' ) . " ; return ; } // ▁ créer ▁ l ' instance ▁ de ▁ la ▁ classe ENDCOM m_ScriptControllerInstance = BuildPySPtr < Base > ( this , ( PyTypeObject * ) m_ScriptControllerClass ) ; if ( ! m_ScriptControllerInstance ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ instanciation ▁ error ) . " ; return ; } refreshBinding ( ) ; } void PythonScriptController :: doLoadScript ( ) { loadScript ( ) ; } void PythonScriptController :: script_onIdleEvent ( const IdleEvent * /* event */ ) { FileMonitor :: updates ( 0 ) ; { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_onIdle ) ; } // / ▁ Flush ▁ the ▁ console ▁ to ▁ avoid ▁ the ▁ sys . stdout . flush ( ) ▁ in ▁ each ▁ script ▁ function . ENDCOM std :: cout . flush ( ) ; std :: cerr . flush ( ) ; } void PythonScriptController :: script_onLoaded ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onLoaded , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } void PythonScriptController :: script_createGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_createGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } void PythonScriptController :: script_initGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_initGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } void PythonScriptController :: script_bwdInitGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_bwdInitGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } bool PythonScriptController :: script_onKeyPressed ( const char c ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onKeyPressed " , this ) ; bool b = false ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEBOOLFUNC ( m_Func_onKeyPressed , " ( c ) " , c ) ; return b ; } bool PythonScriptController :: script_onKeyReleased ( const char c ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onKeyReleased " , this ) ; bool b = false ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEBOOLFUNC ( m_Func_onKeyReleased , " ( c ) " , c ) ; return b ; } void PythonScriptController :: script_onMouseMove ( const int posX , const int posY ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseMove " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onMouseMove , " ( ii ) " , posX , posY ) ; } void PythonScriptController :: script_onMouseButtonLeft ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonLeft " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonLeft , " ( iiO ) " , posX , posY , pyPressed ) } void PythonScriptController :: script_onMouseButtonRight ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonRight " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonRight , " ( iiO ) " , posX , posY , pyPressed ) } void PythonScriptController :: script_onMouseButtonMiddle ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonMiddle " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonMiddle , " ( iiO ) " , posX , posY , pyPressed ) } void PythonScriptController :: script_onMouseWheel ( const int posX , const int posY , const int delta ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseWheel " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onMouseWheel , " ( iii ) " , posX , posY , delta ) } void PythonScriptController :: script_onBeginAnimationStep ( const double dt ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onBeginAnimationStep " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onBeginAnimationStep , " ( d ) " , dt ) } void PythonScriptController :: script_onEndAnimationStep ( const double dt ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onEndAnimationStep " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onEndAnimationStep , " ( d ) " , dt ) } void PythonScriptController :: script_storeResetState ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_storeResetState ) } void PythonScriptController :: script_reset ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_reset ) } void PythonScriptController :: script_cleanup ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_cleanup ) } void PythonScriptController :: script_onGUIEvent ( const char * controlID , const char * valueName , const char * value ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onGUIEvent " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onGUIEvent , " ( sss ) " , controlID , valueName , value ) ; } void PythonScriptController :: script_onScriptEvent ( core :: objectmodel :: ScriptEvent * event ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onScriptEvent " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PythonScriptEvent * pyEvent = static_cast < PythonScriptEvent * > ( event ) ; SP_CALL_MODULEFUNC ( m_Func_onScriptEvent , " ( OsO ) " , sofa :: PythonFactory :: toPython ( pyEvent -> getSender ( ) . get ( ) ) , pyEvent -> getEventName ( ) . c_str ( ) , pyEvent -> getUserData ( ) ) ; } void PythonScriptController :: script_draw ( const core :: visual :: VisualParams * ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ draw " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_draw ) ; } void PythonScriptController :: handleEvent ( core :: objectmodel :: Event * event ) { if ( PythonScriptEvent :: checkEventType ( event ) ) { script_onScriptEvent ( static_cast < PythonScriptEvent * > ( event ) ) ; } else { ScriptController :: handleEvent ( event ) ; } } } // ▁ namespace ▁ controller ENDCOM } // ▁ namespace ▁ component ENDCOM } // ▁ namespace ▁ sofa ENDCOM </DOCUMENT>
<DOCUMENT_ID="eugene1g/phantomjs/tree/master/src/qt/qtbase/src/corelib/doc/snippets/code/src_corelib_io_qfile.cpp"> /* * * * * STRNEWLINE * * STRNEWLINE * * ▁ Copyright ▁ ( C ) ▁ 2013 ▁ Digia ▁ Plc ▁ and / or ▁ its ▁ subsidiary ( - ies ) . STRNEWLINE * * ▁ Contact : ▁ http : // www . qt - project . org / legal STRNEWLINE * * STRNEWLINE * * ▁ This ▁ file ▁ is ▁ part ▁ of ▁ the ▁ documentation ▁ of ▁ the ▁ Qt ▁ Toolkit . STRNEWLINE * * STRNEWLINE * * ▁ $ QT _ BEGIN _ LICENSE : BSD $ STRNEWLINE * * ▁ You ▁ may ▁ use ▁ this ▁ file ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ BSD ▁ license ▁ as ▁ follows : STRNEWLINE * * STRNEWLINE * * ▁ " Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without STRNEWLINE * * ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions ▁ are STRNEWLINE * * ▁ met : STRNEWLINE * * ▁ * ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright STRNEWLINE * * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . STRNEWLINE * * ▁ * ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright STRNEWLINE * * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in STRNEWLINE * * ▁ the ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the STRNEWLINE * * ▁ distribution . STRNEWLINE * * ▁ * ▁ Neither ▁ the ▁ name ▁ of ▁ Digia ▁ Plc ▁ and ▁ its ▁ Subsidiary ( - ies ) ▁ nor ▁ the ▁ names STRNEWLINE * * ▁ of ▁ its ▁ contributors ▁ may ▁ be ▁ used ▁ to ▁ endorse ▁ or ▁ promote ▁ products ▁ derived STRNEWLINE * * ▁ from ▁ this ▁ software ▁ without ▁ specific ▁ prior ▁ written ▁ permission . STRNEWLINE * * STRNEWLINE * * STRNEWLINE * * ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ THE ▁ COPYRIGHT ▁ HOLDERS ▁ AND ▁ CONTRIBUTORS STRNEWLINE * * ▁ " AS ▁ IS " ▁ AND ▁ ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT STRNEWLINE * * ▁ LIMITED ▁ TO , ▁ THE ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR STRNEWLINE * * ▁ A ▁ PARTICULAR ▁ PURPOSE ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ▁ COPYRIGHT STRNEWLINE * * ▁ OWNER ▁ OR ▁ CONTRIBUTORS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , STRNEWLINE * * ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ ( INCLUDING , ▁ BUT ▁ NOT STRNEWLINE * * ▁ LIMITED ▁ TO , ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES ; ▁ LOSS ▁ OF ▁ USE , STRNEWLINE * * ▁ DATA , ▁ OR ▁ PROFITS ; ▁ OR ▁ BUSINESS ▁ INTERRUPTION ) ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY STRNEWLINE * * ▁ THEORY ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ CONTRACT , ▁ STRICT ▁ LIABILITY , ▁ OR ▁ TORT STRNEWLINE * * ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE STRNEWLINE * * ▁ OF ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . " STRNEWLINE * * STRNEWLINE * * ▁ $ QT _ END _ LICENSE $ STRNEWLINE * * STRNEWLINE * * * * */ QFile file ; QDir :: setCurrent ( " / tmp " ) ; file . setFileName ( " readme . txt " ) ; QDir :: setCurrent ( " / home " ) ; file . open ( QIODevice :: ReadOnly ) ; // ▁ opens ▁ " / home / readme . txt " ▁ under ▁ Unix ENDCOM QByteArray myEncoderFunc ( const QString & fileName ) ; QString myDecoderFunc ( const QByteArray & localFileName ) ; # include < stdio . h > void printError ( const char * msg ) { QFile file ; file . open ( stderr , QIODevice :: WriteOnly ) ; file . write ( msg , qstrlen ( msg ) ) ; // ▁ write ▁ to ▁ stderr ENDCOM file . close ( ) ; } CONFIG += console </DOCUMENT>
<DOCUMENT_ID="sneiiler/ardupilot/tree/master/libraries/AP_HAL/utility/getopt_cpp.cpp"> /* STRNEWLINE ▁ * ▁ getopt _ long ( ) ▁ - - ▁ long ▁ options ▁ parser STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Portions ▁ Copyright ▁ ( c ) ▁ 1987 , ▁ 1993 , ▁ 1994 STRNEWLINE ▁ * ▁ The ▁ Regents ▁ of ▁ the ▁ University ▁ of ▁ California . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Portions ▁ Copyright ▁ ( c ) ▁ 2003 STRNEWLINE ▁ * ▁ PostgreSQL ▁ Global ▁ Development ▁ Group STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Simple ▁ conversion ▁ to ▁ C + + ▁ by ▁ Andrew ▁ Tridgell ▁ for ▁ ArduPilot . ▁ Based ▁ on STRNEWLINE ▁ * ▁ getopt _ long . cpp ▁ from ▁ ccache STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without STRNEWLINE ▁ * ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions STRNEWLINE ▁ * ▁ are ▁ met : STRNEWLINE ▁ * ▁ 1 . ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . STRNEWLINE ▁ * ▁ 2 . ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in ▁ the STRNEWLINE ▁ * ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the ▁ distribution . STRNEWLINE ▁ * ▁ 3 . ▁ Neither ▁ the ▁ name ▁ of ▁ the ▁ University ▁ nor ▁ the ▁ names ▁ of ▁ its ▁ contributors STRNEWLINE ▁ * ▁ may ▁ be ▁ used ▁ to ▁ endorse ▁ or ▁ promote ▁ products ▁ derived ▁ from ▁ this ▁ software STRNEWLINE ▁ * ▁ without ▁ specific ▁ prior ▁ written ▁ permission . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ THE ▁ REGENTS ▁ AND ▁ CONTRIBUTORS ▁ ` ` AS ▁ IS ' ' ▁ AND STRNEWLINE ▁ * ▁ ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ THE STRNEWLINE ▁ * ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE STRNEWLINE ▁ * ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ▁ REGENTS ▁ OR ▁ CONTRIBUTORS ▁ BE ▁ LIABLE STRNEWLINE ▁ * ▁ FOR ▁ ANY ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR ▁ CONSEQUENTIAL STRNEWLINE ▁ * ▁ DAMAGES ▁ ( INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS STRNEWLINE ▁ * ▁ OR ▁ SERVICES ; ▁ LOSS ▁ OF ▁ USE , ▁ DATA , ▁ OR ▁ PROFITS ; ▁ OR ▁ BUSINESS ▁ INTERRUPTION ) STRNEWLINE ▁ * ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY ▁ THEORY ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ CONTRACT , ▁ STRICT STRNEWLINE ▁ * ▁ LIABILITY , ▁ OR ▁ TORT ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) ▁ ARISING ▁ IN ▁ ANY ▁ WAY STRNEWLINE ▁ * ▁ OUT ▁ OF ▁ THE ▁ USE ▁ OF ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ OF STRNEWLINE ▁ * ▁ SUCH ▁ DAMAGE . STRNEWLINE ▁ */ # include " getopt _ cpp . h " # include < stdio . h > # include < string . h > /* STRNEWLINE ▁ constructor STRNEWLINE ▁ */ GetOptLong :: GetOptLong ( int _argc , char * const _argv [ ] , const char * _optstring , const GetOptLong :: option * _longopts ) : opterr ( 0 ) , optind ( 1 ) , optopt ( 0 ) , longindex ( - 1 ) , optarg ( NULL ) , argc ( _argc ) , argv ( _argv ) , optstring ( _optstring ) , longopts ( _longopts ) , place ( " " ) { } /* STRNEWLINE ▁ main ▁ parse ▁ code STRNEWLINE ▁ */ int GetOptLong :: getoption ( void ) { const char * oli ; /* ▁ option ▁ letter ▁ list ▁ index ▁ */ if ( ! * place ) { /* ▁ update ▁ scanning ▁ pointer ▁ */ if ( optind >= argc ) { place = " " ; return - 1 ; } place = argv [ optind ] ; if ( place [ 0 ] != ' - ' ) { place = " " ; return - 1 ; } place ++ ; if ( place [ 0 ] && place [ 0 ] == ' - ' && place [ 1 ] == ' \0' ) { /* ▁ found ▁ " - - " ▁ */ ++ optind ; place = " " ; return - 1 ; } if ( place [ 0 ] && place [ 0 ] == ' - ' && place [ 1 ] ) { /* ▁ long ▁ option ▁ */ size_t namelen ; int i ; place ++ ; namelen = strcspn ( place , " = " ) ; for ( i = 0 ; longopts [ i ] . name != NULL ; i ++ ) { if ( strlen ( longopts [ i ] . name ) == namelen && strncmp ( place , longopts [ i ] . name , namelen ) == 0 ) { if ( longopts [ i ] . has_arg ) { if ( place [ namelen ] == ' = ' ) optarg = place + namelen + 1 ; else if ( optind < argc - 1 ) { optind ++ ; optarg = argv [ optind ] ; } else { if ( optstring [ 0 ] == ' : ' ) return BADARG ; if ( opterr ) fprintf ( stderr , " % s : ▁ option ▁ requires ▁ an ▁ argument ▁ - - ▁ % s \n " , argv [ 0 ] , place ) ; place = " " ; optind ++ ; return BADCH ; } } else { optarg = NULL ; if ( place [ namelen ] != 0 ) { /* ▁ XXX ▁ error ? ▁ */ } } optind ++ ; longindex = i ; place = " " ; if ( longopts [ i ] . flag == NULL ) return longopts [ i ] . val ; else { * longopts [ i ] . flag = longopts [ i ] . val ; return 0 ; } } } if ( opterr && optstring [ 0 ] != ' : ' ) fprintf ( stderr , " % s : ▁ illegal ▁ option ▁ - - ▁ % s \n " , argv [ 0 ] , place ) ; place = " " ; optind ++ ; return BADCH ; } } /* ▁ short ▁ option ▁ */ optopt = ( int ) * place ++ ; oli = strchr ( optstring , optopt ) ; if ( ! oli ) { if ( ! * place ) ++ optind ; if ( opterr && * optstring != ' : ' ) fprintf ( stderr , " % s : ▁ illegal ▁ option ▁ - - ▁ % c \n " , argv [ 0 ] , optopt ) ; return BADCH ; } if ( oli [ 1 ] != ' : ' ) { /* ▁ don ' t ▁ need ▁ argument ▁ */ optarg = NULL ; if ( ! * place ) ++ optind ; } else { /* ▁ need ▁ an ▁ argument ▁ */ if ( * place ) /* ▁ no ▁ white ▁ space ▁ */ optarg = place ; else if ( argc <= ++ optind ) { /* ▁ no ▁ arg ▁ */ place = " " ; if ( * optstring == ' : ' ) return BADARG ; if ( opterr ) fprintf ( stderr , " % s : ▁ option ▁ requires ▁ an ▁ argument ▁ - - ▁ % c \n " , argv [ 0 ] , optopt ) ; return BADCH ; } else /* ▁ white ▁ space ▁ */ optarg = argv [ optind ] ; place = " " ; ++ optind ; } return optopt ; } </DOCUMENT>
<DOCUMENT_ID="didoutheone/MangosOneDidou/tree/master/dep/recastnavigation/RecastDemo/Source/CrowdManager.cpp"> // ▁ Copyright ▁ ( c ) ▁ 2009-2010 ▁ Mikko ▁ Mononen ▁ memon @ inside . org ENDCOM // ▁ This ▁ software ▁ is ▁ provided ▁ ' as - is ' , ▁ without ▁ any ▁ express ▁ or ▁ implied ENDCOM // ▁ warranty . ▁ In ▁ no ▁ event ▁ will ▁ the ▁ authors ▁ be ▁ held ▁ liable ▁ for ▁ any ▁ damages ENDCOM // ▁ arising ▁ from ▁ the ▁ use ▁ of ▁ this ▁ software . ENDCOM // ▁ Permission ▁ is ▁ granted ▁ to ▁ anyone ▁ to ▁ use ▁ this ▁ software ▁ for ▁ any ▁ purpose , ENDCOM // ▁ including ▁ commercial ▁ applications , ▁ and ▁ to ▁ alter ▁ it ▁ and ▁ redistribute ▁ it ENDCOM // ▁ freely , ▁ subject ▁ to ▁ the ▁ following ▁ restrictions : ENDCOM // ▁ 1 . ▁ The ▁ origin ▁ of ▁ this ▁ software ▁ must ▁ not ▁ be ▁ misrepresented ; ▁ you ▁ must ▁ not ENDCOM // ▁ claim ▁ that ▁ you ▁ wrote ▁ the ▁ original ▁ software . ▁ If ▁ you ▁ use ▁ this ▁ software ENDCOM // ▁ in ▁ a ▁ product , ▁ an ▁ acknowledgment ▁ in ▁ the ▁ product ▁ documentation ▁ would ▁ be ENDCOM // ▁ appreciated ▁ but ▁ is ▁ not ▁ required . ENDCOM // ▁ 2 . ▁ Altered ▁ source ▁ versions ▁ must ▁ be ▁ plainly ▁ marked ▁ as ▁ such , ▁ and ▁ must ▁ not ▁ be ENDCOM // ▁ misrepresented ▁ as ▁ being ▁ the ▁ original ▁ software . ENDCOM // ▁ 3 . ▁ This ▁ notice ▁ may ▁ not ▁ be ▁ removed ▁ or ▁ altered ▁ from ▁ any ▁ source ▁ distribution . ENDCOM # define _USE_MATH_DEFINES # include < math . h > # include < stdio . h > # include < stdlib . h > # include < string . h > # include < float . h > # include " DetourNavMesh . h " # include " DetourNavMeshQuery . h " # include " DetourObstacleAvoidance . h " # include " DetourCommon . h " # include " CrowdManager . h " # include " SampleInterfaces . h " // ▁ For ▁ timer ENDCOM # include " DetourAssert . h " # include " DetourAlloc . h " static const int VO_ADAPTIVE_DIVS = 7 ; static const int VO_ADAPTIVE_RINGS = 2 ; static const int VO_ADAPTIVE_DEPTH = 5 ; static const int VO_GRID_SIZE = 33 ; inline int hashPos2 ( int x , int y , int n ) { return ( ( x * 73856093 ) ^ ( y * 19349663 ) ) & ( n - 1 ) ; } ProximityGrid :: ProximityGrid ( ) : m_maxItems ( 0 ) , m_cellSize ( 0 ) , m_pool ( 0 ) , m_poolHead ( 0 ) , m_poolSize ( 0 ) , m_buckets ( 0 ) , m_bucketsSize ( 0 ) { } ProximityGrid :: ~ ProximityGrid ( ) { dtFree ( m_buckets ) ; dtFree ( m_pool ) ; } bool ProximityGrid :: init ( const int maxItems , const float cellSize ) { dtAssert ( maxItems > 0 ) ; dtAssert ( cellSize > 0.0f ) ; m_cellSize = cellSize ; m_invCellSize = 1.0f / m_cellSize ; // ▁ Allocate ▁ hashs ▁ buckets ENDCOM m_bucketsSize = dtNextPow2 ( maxItems ) ; m_buckets = ( unsigned short * ) dtAlloc ( sizeof ( unsigned short ) * m_bucketsSize , DT_ALLOC_PERM ) ; if ( ! m_buckets ) return false ; // ▁ Allocate ▁ pool ▁ of ▁ items . ENDCOM m_poolSize = maxItems * 4 ; m_poolHead = 0 ; m_pool = ( Item * ) dtAlloc ( sizeof ( Item ) * m_poolSize , DT_ALLOC_PERM ) ; if ( ! m_pool ) return false ; clear ( ) ; return true ; } void ProximityGrid :: clear ( ) { memset ( m_buckets , 0xff , sizeof ( unsigned short ) * m_bucketsSize ) ; m_poolHead = 0 ; m_bounds [ 0 ] = 0xffff ; m_bounds [ 1 ] = 0xffff ; m_bounds [ 2 ] = - 0xffff ; m_bounds [ 3 ] = - 0xffff ; } void ProximityGrid :: addItem ( const unsigned short id , const float minx , const float miny , const float maxx , const float maxy ) { const int iminx = ( int ) floorf ( minx * m_invCellSize ) ; const int iminy = ( int ) floorf ( miny * m_invCellSize ) ; const int imaxx = ( int ) floorf ( maxx * m_invCellSize ) ; const int imaxy = ( int ) floorf ( maxy * m_invCellSize ) ; m_bounds [ 0 ] = dtMin ( m_bounds [ 0 ] , iminx ) ; m_bounds [ 1 ] = dtMin ( m_bounds [ 1 ] , iminy ) ; m_bounds [ 2 ] = dtMax ( m_bounds [ 2 ] , imaxx ) ; m_bounds [ 3 ] = dtMax ( m_bounds [ 3 ] , imaxy ) ; for ( int y = iminy ; y <= imaxy ; ++ y ) { for ( int x = iminx ; x <= imaxx ; ++ x ) { if ( m_poolHead < m_poolSize ) { const int h = hashPos2 ( x , y , m_bucketsSize ) ; const unsigned short idx = ( unsigned short ) m_poolHead ; m_poolHead ++ ; Item & item = m_pool [ idx ] ; item . x = ( short ) x ; item . y = ( short ) y ; item . id = id ; item . next = m_buckets [ h ] ; m_buckets [ h ] = idx ; } } } } int ProximityGrid :: queryItems ( const float minx , const float miny , const float maxx , const float maxy , unsigned short * ids , const int maxIds ) const { const int iminx = ( int ) floorf ( minx * m_invCellSize ) ; const int iminy = ( int ) floorf ( miny * m_invCellSize ) ; const int imaxx = ( int ) floorf ( maxx * m_invCellSize ) ; const int imaxy = ( int ) floorf ( maxy * m_invCellSize ) ; int n = 0 ; for ( int y = iminy ; y <= imaxy ; ++ y ) { for ( int x = iminx ; x <= imaxx ; ++ x ) { const int h = hashPos2 ( x , y , m_bucketsSize ) ; unsigned short idx = m_buckets [ h ] ; while ( idx != 0xffff ) { Item & item = m_pool [ idx ] ; if ( ( int ) item . x == x && ( int ) item . y == y ) { // ▁ Check ▁ if ▁ the ▁ id ▁ exists ▁ already . ENDCOM const unsigned short * end = ids + n ; unsigned short * i = ids ; while ( i != end && * i != item . id ) ++ i ; // ▁ Item ▁ not ▁ found , ▁ add ▁ it . ENDCOM if ( i == end ) { if ( n >= maxIds ) return n ; ids [ n ++ ] = item . id ; } } idx = item . next ; } } } return n ; } int ProximityGrid :: getItemCountAt ( const int x , const int y ) const { int n = 0 ; const int h = hashPos2 ( x , y , m_bucketsSize ) ; unsigned short idx = m_buckets [ h ] ; while ( idx != 0xffff ) { Item & item = m_pool [ idx ] ; if ( ( int ) item . x == x && ( int ) item . y == y ) n ++ ; idx = item . next ; } return n ; } PathQueue :: PathQueue ( ) : m_nextHandle ( 1 ) , m_delay ( 0 ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) m_queue [ i ] . ref = PATHQ_INVALID ; } PathQueue :: ~ PathQueue ( ) { } void PathQueue :: update ( dtNavMeshQuery * navquery ) { // ▁ Artificial ▁ delay ▁ to ▁ test ▁ the ▁ code ▁ better , ENDCOM // ▁ update ▁ only ▁ one ▁ request ▁ too . ENDCOM // ▁ TODO : ▁ Use ▁ sliced ▁ pathfinder . ENDCOM m_delay ++ ; if ( ( m_delay % 4 ) == 0 ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { PathQuery & q = m_queue [ i ] ; if ( q . ref == PATHQ_INVALID ) continue ; navquery -> findPath ( q . startRef , q . endRef , q . startPos , q . endPos , q . filter , q . path , & q . npath , PQ_MAX_PATH ) ; q . ready = true ; break ; } } // ▁ Kill ▁ forgotten ▁ request . ENDCOM for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { PathQuery & q = m_queue [ i ] ; if ( q . ref != PATHQ_INVALID && q . ready ) { q . keepalive ++ ; if ( q . keepalive > 2 ) q . ref = PATHQ_INVALID ; } } } PathQueueRef PathQueue :: request ( dtPolyRef startRef , dtPolyRef endRef , const float * startPos , const float * endPos , const dtQueryFilter * filter ) { // ▁ Find ▁ empty ▁ slot ENDCOM int slot = - 1 ; for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { if ( m_queue [ i ] . ref == PATHQ_INVALID ) { slot = i ; break ; } } // ▁ Could ▁ not ▁ find ▁ slot . ENDCOM if ( slot == - 1 ) return PATHQ_INVALID ; PathQueueRef ref = m_nextHandle ++ ; if ( m_nextHandle == PATHQ_INVALID ) m_nextHandle ++ ; PathQuery & q = m_queue [ slot ] ; q . ref = ref ; dtVcopy ( q . startPos , startPos ) ; q . startRef = startRef ; dtVcopy ( q . endPos , endPos ) ; q . endRef = endRef ; q . ready = false ; q . npath = 0 ; q . filter = filter ; // ▁ TODO : ▁ This ▁ is ▁ potentially ▁ dangerous ! ENDCOM q . keepalive = 0 ; return ref ; } int PathQueue :: getRequestState ( PathQueueRef ref ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { if ( m_queue [ i ] . ref == ref ) return m_queue [ i ] . ready ? PATHQ_STATE_READY : PATHQ_STATE_WORKING ; } return PATHQ_STATE_INVALID ; } int PathQueue :: getPathResult ( PathQueueRef ref , dtPolyRef * path , const int maxPath ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { if ( m_queue [ i ] . ref == ref ) { PathQuery & q = m_queue [ i ] ; // ▁ Allow ▁ to ▁ reuse ▁ the ▁ request . ENDCOM q . ref = PATHQ_INVALID ; int n = 0 ; for ( int j = 0 ; j < q . npath && j < maxPath ; ++ j ) path [ n ++ ] = q . path [ j ] ; return n ; } } return 0 ; } static int fixupCorridor ( dtPolyRef * path , const int npath , const int maxPath , const dtPolyRef * visited , const int nvisited ) { int furthestPath = - 1 ; int furthestVisited = - 1 ; // ▁ Find ▁ furthest ▁ common ▁ polygon . ENDCOM for ( int i = npath - 1 ; i >= 0 ; -- i ) { bool found = false ; for ( int j = nvisited - 1 ; j >= 0 ; -- j ) { if ( path [ i ] == visited [ j ] ) { furthestPath = i ; furthestVisited = j ; found = true ; } } if ( found ) break ; } // ▁ If ▁ no ▁ intersection ▁ found ▁ just ▁ return ▁ current ▁ path . ▁ ENDCOM if ( furthestPath == - 1 || furthestVisited == - 1 ) return npath ; // ▁ Concatenate ▁ paths . TABSYMBOL ENDCOM // ▁ Adjust ▁ beginning ▁ of ▁ the ▁ buffer ▁ to ▁ include ▁ the ▁ visited . ENDCOM const int req = nvisited - furthestVisited ; const int orig = dtMin ( furthestPath + 1 , npath ) ; int size = dtMax ( 0 , npath - orig ) ; if ( req + size > maxPath ) size = maxPath - req ; if ( size ) memmove ( path + req , path + orig , size * sizeof ( dtPolyRef ) ) ; // ▁ Store ▁ visited ENDCOM for ( int i = 0 ; i < req ; ++ i ) path [ i ] = visited [ ( nvisited - 1 ) - i ] ; return req + size ; } static int fixupCorridorEnd ( dtPolyRef * path , const int npath , const int maxPath , const dtPolyRef * visited , const int nvisited ) { int furthestPath = - 1 ; int furthestVisited = - 1 ; // ▁ Find ▁ furthest ▁ common ▁ polygon . ENDCOM for ( int i = 0 ; i < npath ; ++ i ) { bool found = false ; for ( int j = nvisited - 1 ; j >= 0 ; -- j ) { if ( path [ i ] == visited [ j ] ) { furthestPath = i ; furthestVisited = j ; found = true ; } } if ( found ) break ; } // ▁ If ▁ no ▁ intersection ▁ found ▁ just ▁ return ▁ current ▁ path . ▁ ENDCOM if ( furthestPath == - 1 || furthestVisited == - 1 ) return npath ; // ▁ Concatenate ▁ paths . ENDCOM const int ppos = furthestPath + 1 ; const int vpos = furthestVisited + 1 ; const int count = dtMin ( nvisited - vpos , maxPath - ppos ) ; dtAssert ( ppos + count <= maxPath ) ; if ( count ) memcpy ( path + ppos , visited + vpos , sizeof ( dtPolyRef ) * count ) ; return ppos + count ; } static int mergeCorridor ( dtPolyRef * path , const int npath , const int maxPath , const dtPolyRef * visited , const int nvisited ) { int furthestPath = - 1 ; int furthestVisited = - 1 ; // ▁ Find ▁ furthest ▁ common ▁ polygon . ENDCOM for ( int i = npath - 1 ; i >= 0 ; -- i ) { bool found = false ; for ( int j = nvisited - 1 ; j >= 0 ; -- j ) { if ( path [ i ] == visited [ j ] ) { furthestPath = i ; furthestVisited = j ; found = true ; } } if ( found ) break ; } // ▁ If ▁ no ▁ intersection ▁ found ▁ just ▁ return ▁ current ▁ path . ▁ ENDCOM if ( furthestPath == - 1 || furthestVisited == - 1 ) return npath ; // ▁ Concatenate ▁ paths . TABSYMBOL ENDCOM // ▁ Adjust ▁ beginning ▁ of ▁ the ▁ buffer ▁ to ▁ include ▁ the ▁ visited . ENDCOM const int req = furthestVisited ; if ( req <= 0 ) return npath ; const int orig = furthestPath ; int size = dtMax ( 0 , npath - orig ) ; if ( req + size > maxPath ) size = maxPath - req ; if ( size ) memmove ( path + req , path + orig , size * sizeof ( dtPolyRef ) ) ; // ▁ Store ▁ visited ENDCOM for ( int i = 0 ; i < req ; ++ i ) path [ i ] = visited [ i ] ; return req + size ; } PathCorridor :: PathCorridor ( ) : m_path ( 0 ) , m_npath ( 0 ) , m_maxPath ( 0 ) { } PathCorridor :: ~ PathCorridor ( ) { dtFree ( m_path ) ; } bool PathCorridor :: init ( const int maxPath ) { dtAssert ( ! m_path ) ; m_path = ( dtPolyRef * ) dtAlloc ( sizeof ( dtPolyRef ) * maxPath , DT_ALLOC_PERM ) ; if ( ! m_path ) return false ; m_npath = 0 ; m_maxPath = maxPath ; return true ; } void PathCorridor :: reset ( dtPolyRef ref , const float * pos ) { dtAssert ( m_path ) ; dtVcopy ( m_pos , pos ) ; dtVcopy ( m_target , pos ) ; m_path [ 0 ] = ref ; m_npath = 1 ; } int PathCorridor :: findCorners ( float * cornerVerts , unsigned char * cornerFlags , dtPolyRef * cornerPolys , const int maxCorners , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; dtAssert ( m_npath ) ; static const float MIN_TARGET_DIST = 0.01f ; int ncorners = 0 ; navquery -> findStraightPath ( m_pos , m_target , m_path , m_npath , cornerVerts , cornerFlags , cornerPolys , & ncorners , maxCorners ) ; // ▁ Prune ▁ points ▁ in ▁ the ▁ beginning ▁ of ▁ the ▁ path ▁ which ▁ are ▁ too ▁ close . ENDCOM while ( ncorners ) { if ( ( cornerFlags [ 0 ] & DT_STRAIGHTPATH_OFFMESH_CONNECTION ) || dtVdist2DSqr ( & cornerVerts [ 0 ] , m_pos ) > dtSqr ( MIN_TARGET_DIST ) ) break ; ncorners -- ; if ( ncorners ) { memmove ( cornerFlags , cornerFlags + 1 , sizeof ( unsigned char ) * ncorners ) ; memmove ( cornerPolys , cornerPolys + 1 , sizeof ( dtPolyRef ) * ncorners ) ; memmove ( cornerVerts , cornerVerts + 3 , sizeof ( float ) * 3 * ncorners ) ; } } // ▁ Prune ▁ points ▁ after ▁ an ▁ off - mesh ▁ connection . ENDCOM for ( int i = 0 ; i < ncorners ; ++ i ) { if ( cornerFlags [ i ] & DT_STRAIGHTPATH_OFFMESH_CONNECTION ) { ncorners = i + 1 ; break ; } } return ncorners ; } void PathCorridor :: optimizePathVisibility ( const float * next , const float pathOptimizationRange , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; // ▁ Clamp ▁ the ▁ ray ▁ to ▁ max ▁ distance . ENDCOM float goal [ 3 ] ; dtVcopy ( goal , next ) ; float dist = dtVdist2D ( m_pos , goal ) ; // ▁ If ▁ too ▁ close ▁ to ▁ the ▁ goal , ▁ do ▁ not ▁ try ▁ to ▁ optimize . ENDCOM if ( dist < 0.01f ) return ; // ▁ Overshoot ▁ a ▁ little . ▁ This ▁ helps ▁ to ▁ optimize ▁ open ▁ fields ▁ in ▁ tiled ▁ meshes . ENDCOM dist = dtMin ( dist + 0.01f , pathOptimizationRange ) ; // ▁ Adjust ▁ ray ▁ length . ENDCOM float delta [ 3 ] ; dtVsub ( delta , goal , m_pos ) ; dtVmad ( goal , m_pos , delta , pathOptimizationRange / dist ) ; static const int MAX_RES = 32 ; dtPolyRef res [ MAX_RES ] ; float t , norm [ 3 ] ; int nres = 0 ; navquery -> raycast ( m_path [ 0 ] , m_pos , goal , filter , & t , norm , res , & nres , MAX_RES ) ; if ( nres > 1 && t > 0.99f ) { m_npath = mergeCorridor ( m_path , m_npath , m_maxPath , res , nres ) ; } } bool PathCorridor :: optimizePathTopology ( dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; if ( m_npath < 3 ) return false ; static const int MAX_ITER = 32 ; static const int MAX_RES = 32 ; dtPolyRef res [ MAX_RES ] ; int nres = 0 ; navquery -> initSlicedFindPath ( m_path [ 0 ] , m_path [ m_npath - 1 ] , m_pos , m_target , filter ) ; navquery -> updateSlicedFindPath ( MAX_ITER ) ; dtStatus status = navquery -> finalizeSlicedFindPathPartial ( m_path , m_npath , res , & nres , MAX_RES ) ; if ( status == DT_SUCCESS && nres > 0 ) { m_npath = mergeCorridor ( m_path , m_npath , m_maxPath , res , nres ) ; return true ; } return false ; } void PathCorridor :: movePosition ( const float * npos , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; dtAssert ( m_npath ) ; // ▁ Move ▁ along ▁ navmesh ▁ and ▁ update ▁ new ▁ position . ENDCOM float result [ 3 ] ; static const int MAX_VISITED = 16 ; dtPolyRef visited [ MAX_VISITED ] ; int nvisited = 0 ; navquery -> moveAlongSurface ( m_path [ 0 ] , m_pos , npos , filter , result , visited , & nvisited , MAX_VISITED ) ; m_npath = fixupCorridor ( m_path , m_npath , m_maxPath , visited , nvisited ) ; // ▁ Adjust ▁ the ▁ position ▁ to ▁ stay ▁ on ▁ top ▁ of ▁ the ▁ navmesh . ENDCOM float h = m_pos [ 1 ] ; navquery -> getPolyHeight ( m_path [ 0 ] , result , & h ) ; result [ 1 ] = h ; dtVcopy ( m_pos , result ) ; } void PathCorridor :: moveTargetPosition ( const float * npos , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; dtAssert ( m_npath ) ; // ▁ Move ▁ along ▁ navmesh ▁ and ▁ update ▁ new ▁ position . ENDCOM float result [ 3 ] ; static const int MAX_VISITED = 16 ; dtPolyRef visited [ MAX_VISITED ] ; int nvisited = 0 ; navquery -> moveAlongSurface ( m_path [ m_npath - 1 ] , m_target , npos , filter , result , visited , & nvisited , MAX_VISITED ) ; m_npath = fixupCorridorEnd ( m_path , m_npath , m_maxPath , visited , nvisited ) ; // ▁ TODO : ▁ should ▁ we ▁ do ▁ that ? ENDCOM // ▁ Adjust ▁ the ▁ position ▁ to ▁ stay ▁ on ▁ top ▁ of ▁ the ▁ navmesh . ENDCOM /* TABSYMBOL float ▁ h ▁ = ▁ m _ target [ 1 ] ; STRNEWLINE TABSYMBOL navquery - > getPolyHeight ( m _ path [ m _ npath - 1 ] , ▁ result , ▁ & h ) ; STRNEWLINE TABSYMBOL result [ 1 ] ▁ = ▁ h ; */ dtVcopy ( m_target , result ) ; } void PathCorridor :: setCorridor ( const float * target , const dtPolyRef * path , const int npath ) { dtAssert ( m_path ) ; dtAssert ( npath > 0 ) ; dtAssert ( npath < m_maxPath ) ; dtVcopy ( m_target , target ) ; memcpy ( m_path , path , sizeof ( dtPolyRef ) * npath ) ; m_npath = npath ; } void Agent :: integrate ( const float maxAcc , const float dt ) { // ▁ Fake ▁ dynamic ▁ constraint . ENDCOM const float maxDelta = maxAcc * dt ; float dv [ 3 ] ; dtVsub ( dv , nvel , vel ) ; float ds = dtVlen ( dv ) ; if ( ds > maxDelta ) dtVscale ( dv , dv , maxDelta / ds ) ; dtVadd ( vel , vel , dv ) ; // ▁ Integrate ENDCOM if ( dtVlen ( vel ) > 0.0001f ) dtVmad ( npos , npos , vel , dt ) ; else dtVset ( vel , 0 , 0 , 0 ) ; } float Agent :: getDistanceToGoal ( const float range ) const { if ( ! ncorners ) return range ; const bool endOfPath = ( cornerFlags [ ncorners - 1 ] & DT_STRAIGHTPATH_END ) ? true : false ; const bool offMeshConnection = ( cornerFlags [ ncorners - 1 ] & DT_STRAIGHTPATH_OFFMESH_CONNECTION ) ? true : false ; if ( endOfPath || offMeshConnection ) return dtMin ( dtVdist2D ( npos , & cornerVerts [ ( ncorners - 1 ) * 3 ] ) , range ) ; return range ; } void Agent :: calcSmoothSteerDirection ( float * dir ) { if ( ! ncorners ) { dtVset ( dir , 0 , 0 , 0 ) ; return ; } const int ip0 = 0 ; const int ip1 = dtMin ( 1 , ncorners - 1 ) ; const float * p0 = & cornerVerts [ ip0 * 3 ] ; const float * p1 = & cornerVerts [ ip1 * 3 ] ; float dir0 [ 3 ] , dir1 [ 3 ] ; dtVsub ( dir0 , p0 , npos ) ; dtVsub ( dir1 , p1 , npos ) ; dir0 [ 1 ] = 0 ; dir1 [ 1 ] = 0 ; float len0 = dtVlen ( dir0 ) ; float len1 = dtVlen ( dir1 ) ; if ( len1 > 0.001f ) dtVscale ( dir1 , dir1 , 1.0f / len1 ) ; dir [ 0 ] = dir0 [ 0 ] - dir1 [ 0 ] * len0 * 0.5f ; dir [ 1 ] = 0 ; dir [ 2 ] = dir0 [ 2 ] - dir1 [ 2 ] * len0 * 0.5f ; dtVnormalize ( dir ) ; } void Agent :: calcStraightSteerDirection ( float * dir ) { if ( ! ncorners ) { dtVset ( dir , 0 , 0 , 0 ) ; return ; } dtVsub ( dir , & cornerVerts [ 0 ] , npos ) ; dir [ 1 ] = 0 ; dtVnormalize ( dir ) ; } LocalBoundary :: LocalBoundary ( ) : m_nsegs ( 0 ) { dtVset ( m_center , FLT_MAX , FLT_MAX , FLT_MAX ) ; } LocalBoundary :: ~ LocalBoundary ( ) { } void LocalBoundary :: reset ( ) { dtVset ( m_center , FLT_MAX , FLT_MAX , FLT_MAX ) ; m_nsegs = 0 ; } void LocalBoundary :: addSegment ( const float dist , const float * s ) { // ▁ Insert ▁ neighbour ▁ based ▁ on ▁ the ▁ distance . ENDCOM Segment * seg = 0 ; if ( ! m_nsegs ) { // ▁ First , ▁ trivial ▁ accept . ENDCOM seg = & m_segs [ 0 ] ; } else if ( dist >= m_segs [ m_nsegs - 1 ] . d ) { // ▁ Further ▁ than ▁ the ▁ last ▁ segment , ▁ skip . ENDCOM if ( m_nsegs >= MAX_SEGS ) return ; // ▁ Last , ▁ trivial ▁ accept . ENDCOM seg = & m_segs [ m_nsegs ] ; } else { // ▁ Insert ▁ inbetween . ENDCOM int i ; for ( i = 0 ; i < m_nsegs ; ++ i ) if ( dist <= m_segs [ i ] . d ) break ; const int tgt = i + 1 ; const int n = dtMin ( m_nsegs - i , MAX_SEGS - tgt ) ; dtAssert ( tgt + n <= MAX_SEGS ) ; if ( n > 0 ) memmove ( & m_segs [ tgt ] , & m_segs [ i ] , sizeof ( Segment ) * n ) ; seg = & m_segs [ i ] ; } seg -> d = dist ; memcpy ( seg -> s , s , sizeof ( float ) * 6 ) ; if ( m_nsegs < MAX_SEGS ) m_nsegs ++ ; } void LocalBoundary :: update ( dtPolyRef ref , const float * pos , const float collisionQueryRange , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { static const int MAX_LOCAL_POLYS = 16 ; static const int MAX_SEGS_PER_POLY = DT_VERTS_PER_POLYGON * 2 ; if ( ! ref ) { dtVset ( m_center , FLT_MAX , FLT_MAX , FLT_MAX ) ; m_nsegs = 0 ; return ; } dtVcopy ( m_center , pos ) ; // ▁ First ▁ query ▁ non - overlapping ▁ polygons . ENDCOM dtPolyRef locals [ MAX_LOCAL_POLYS ] ; int nlocals = 0 ; navquery -> findLocalNeighbourhood ( ref , pos , collisionQueryRange , filter , locals , 0 , & nlocals , MAX_LOCAL_POLYS ) ; // ▁ Secondly , ▁ store ▁ all ▁ polygon ▁ edges . ENDCOM m_nsegs = 0 ; float segs [ MAX_SEGS_PER_POLY * 6 ] ; int nsegs = 0 ; for ( int j = 0 ; j < nlocals ; ++ j ) { navquery -> getPolyWallSegments ( locals [ j ] , filter , segs , & nsegs , MAX_SEGS_PER_POLY ) ; for ( int k = 0 ; k < nsegs ; ++ k ) { const float * s = & segs [ k * 6 ] ; // ▁ Skip ▁ too ▁ distant ▁ segments . ENDCOM float tseg ; const float distSqr = dtDistancePtSegSqr2D ( pos , s , s + 3 , tseg ) ; if ( distSqr > dtSqr ( collisionQueryRange ) ) continue ; addSegment ( distSqr , s ) ; } } } CrowdManager :: CrowdManager ( ) : m_obstacleQuery ( 0 ) , m_pathResult ( 0 ) , m_maxPathResult ( 0 ) , m_totalTime ( 0 ) , m_rvoTime ( 0 ) , m_sampleCount ( 0 ) , m_moveRequestCount ( 0 ) { dtVset ( m_ext , 2 , 4 , 2 ) ; m_obstacleQuery = dtAllocObstacleAvoidanceQuery ( ) ; m_obstacleQuery -> init ( 6 , 8 ) ; m_obstacleQuery -> setDesiredVelocityWeight ( 2.0f ) ; m_obstacleQuery -> setCurrentVelocityWeight ( 0.75f ) ; m_obstacleQuery -> setPreferredSideWeight ( 0.75f ) ; m_obstacleQuery -> setCollisionTimeWeight ( 2.5f ) ; m_obstacleQuery -> setTimeHorizon ( 2.5f ) ; m_obstacleQuery -> setVelocitySelectionBias ( 0.4f ) ; memset ( m_vodebug , 0 , sizeof ( m_vodebug ) ) ; const int maxAdaptiveSamples = ( VO_ADAPTIVE_DIVS * VO_ADAPTIVE_RINGS + 1 ) * VO_ADAPTIVE_DEPTH ; const int maxGridSamples = VO_GRID_SIZE * VO_GRID_SIZE ; const int sampleCount = dtMax ( maxAdaptiveSamples , maxGridSamples ) ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { m_vodebug [ i ] = dtAllocObstacleAvoidanceDebugData ( ) ; m_vodebug [ i ] -> init ( sampleCount ) ; } // ▁ Allocate ▁ temp ▁ buffer ▁ for ▁ merging ▁ paths . ENDCOM m_maxPathResult = 256 ; m_pathResult = ( dtPolyRef * ) dtAlloc ( sizeof ( dtPolyRef ) * m_maxPathResult , DT_ALLOC_PERM ) ; // ▁ Alloca ▁ corridors . ENDCOM for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { m_agents [ i ] . corridor . init ( m_maxPathResult ) ; } // ▁ TODO : ▁ the ▁ radius ▁ should ▁ be ▁ related ▁ to ▁ the ▁ agent ▁ radius ▁ used ▁ to ▁ create ▁ the ▁ navmesh ! ENDCOM m_grid . init ( 100 , 1.0f ) ; reset ( ) ; } CrowdManager :: ~ CrowdManager ( ) { delete [ ] m_pathResult ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) dtFreeObstacleAvoidanceDebugData ( m_vodebug [ i ] ) ; dtFreeObstacleAvoidanceQuery ( m_obstacleQuery ) ; } void CrowdManager :: reset ( ) { for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) m_agents [ i ] . active = 0 ; } const int CrowdManager :: getAgentCount ( ) const { return MAX_AGENTS ; } const Agent * CrowdManager :: getAgent ( const int idx ) { return & m_agents [ idx ] ; } int CrowdManager :: addAgent ( const float * pos , const float radius , const float height , dtNavMeshQuery * navquery ) { // ▁ Find ▁ empty ▁ slot . ENDCOM int idx = - 1 ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { if ( ! m_agents [ i ] . active ) { idx = i ; break ; } } if ( idx == - 1 ) return - 1 ; Agent * ag = & m_agents [ idx ] ; // ▁ Find ▁ nearest ▁ position ▁ on ▁ navmesh ▁ and ▁ place ▁ the ▁ agent ▁ there . ENDCOM float nearest [ 3 ] ; dtPolyRef ref ; navquery -> findNearestPoly ( pos , m_ext , & m_filter , & ref , nearest ) ; if ( ! ref ) { // ▁ Could ▁ not ▁ find ▁ a ▁ location ▁ on ▁ navmesh . ENDCOM return - 1 ; } ag -> corridor . reset ( ref , nearest ) ; ag -> boundary . reset ( ) ; ag -> radius = radius ; ag -> height = height ; ag -> collisionQueryRange = radius * 8 ; ag -> pathOptimizationRange = radius * 30 ; ag -> topologyOptTime = 0 ; ag -> nneis = 0 ; dtVset ( ag -> dvel , 0 , 0 , 0 ) ; dtVset ( ag -> nvel , 0 , 0 , 0 ) ; dtVset ( ag -> vel , 0 , 0 , 0 ) ; dtVcopy ( ag -> npos , nearest ) ; ag -> maxspeed = 0 ; ag -> t = 0 ; dtVset ( ag -> opts , 0 , 0 , 0 ) ; dtVset ( ag -> opte , 0 , 0 , 0 ) ; ag -> active = 1 ; ag -> var = ( rand ( ) % 10 ) / 9.0f ; // ▁ Init ▁ trail ENDCOM for ( int i = 0 ; i < AGENT_MAX_TRAIL ; ++ i ) dtVcopy ( & ag -> trail [ i * 3 ] , ag -> corridor . getPos ( ) ) ; ag -> htrail = 0 ; return idx ; } void CrowdManager :: removeAgent ( const int idx ) { if ( idx >= 0 && idx < MAX_AGENTS ) { m_agents [ idx ] . active = 0 ; } } bool CrowdManager :: requestMoveTarget ( const int idx , dtPolyRef ref , const float * pos ) { if ( idx < 0 || idx > MAX_AGENTS ) return false ; if ( ! ref ) return false ; MoveRequest * req = 0 ; // ▁ Check ▁ if ▁ there ▁ is ▁ existing ▁ request ▁ and ▁ update ▁ that ▁ instead . ENDCOM for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { if ( m_moveRequests [ i ] . idx == idx ) { req = & m_moveRequests [ i ] ; break ; } } if ( ! req ) { if ( m_moveRequestCount >= MAX_AGENTS ) return false ; req = & m_moveRequests [ m_moveRequestCount ++ ] ; memset ( req , 0 , sizeof ( MoveRequest ) ) ; } // ▁ Initialize ▁ request . ENDCOM req -> idx = idx ; req -> ref = ref ; dtVcopy ( req -> pos , pos ) ; req -> pathqRef = PATHQ_INVALID ; req -> state = MR_TARGET_REQUESTING ; req -> temp [ 0 ] = ref ; req -> ntemp = 1 ; return true ; } bool CrowdManager :: adjustMoveTarget ( const int idx , dtPolyRef ref , const float * pos ) { if ( idx < 0 || idx > MAX_AGENTS ) return false ; if ( ! ref ) return false ; MoveRequest * req = 0 ; // ▁ Check ▁ if ▁ there ▁ is ▁ existing ▁ request ▁ and ▁ update ▁ that ▁ instead . ENDCOM for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { if ( m_moveRequests [ i ] . idx == idx ) { req = & m_moveRequests [ i ] ; break ; } } if ( ! req ) { if ( m_moveRequestCount >= MAX_AGENTS ) return false ; req = & m_moveRequests [ m_moveRequestCount ++ ] ; memset ( req , 0 , sizeof ( MoveRequest ) ) ; // ▁ New ▁ adjust ▁ request ENDCOM req -> state = MR_TARGET_ADJUST ; req -> idx = idx ; } // ▁ Set ▁ adjustment ▁ request . ENDCOM req -> aref = ref ; dtVcopy ( req -> apos , pos ) ; return true ; } int CrowdManager :: getActiveAgents ( Agent * * agents , const int maxAgents ) { int n = 0 ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { if ( ! m_agents [ i ] . active ) continue ; if ( n < maxAgents ) agents [ n ++ ] = & m_agents [ i ] ; } return n ; } static int addNeighbour ( const int idx , const float dist , Neighbour * neis , const int nneis , const int maxNeis ) { // ▁ Insert ▁ neighbour ▁ based ▁ on ▁ the ▁ distance . ENDCOM Neighbour * nei = 0 ; if ( ! nneis ) { nei = & neis [ nneis ] ; } else if ( dist >= neis [ nneis - 1 ] . dist ) { if ( nneis >= maxNeis ) return nneis ; nei = & neis [ nneis ] ; } else { int i ; for ( i = 0 ; i < nneis ; ++ i ) if ( dist <= neis [ i ] . dist ) break ; const int tgt = i + 1 ; const int n = dtMin ( nneis - i , maxNeis - tgt ) ; dtAssert ( tgt + n <= maxNeis ) ; if ( n > 0 ) memmove ( & neis [ tgt ] , & neis [ i ] , sizeof ( Neighbour ) * n ) ; nei = & neis [ i ] ; } memset ( nei , 0 , sizeof ( Neighbour ) ) ; nei -> idx = idx ; nei -> dist = dist ; return dtMin ( nneis + 1 , maxNeis ) ; } int CrowdManager :: getNeighbours ( const float * pos , const float height , const float range , const Agent * skip , Neighbour * result , const int maxResult ) { int n = 0 ; unsigned short ids [ MAX_AGENTS ] ; int nids = m_grid . queryItems ( pos [ 0 ] - range , pos [ 2 ] - range , pos [ 0 ] + range , pos [ 2 ] + range , ids , MAX_AGENTS ) ; for ( int i = 0 ; i < nids ; ++ i ) { Agent * ag = & m_agents [ ids [ i ] ] ; if ( ag == skip ) continue ; // ▁ Check ▁ for ▁ overlap . ENDCOM float diff [ 3 ] ; dtVsub ( diff , pos , ag -> npos ) ; if ( fabsf ( diff [ 1 ] ) >= ( height + ag -> height ) / 2.0f ) continue ; diff [ 1 ] = 0 ; const float distSqr = dtVlenSqr ( diff ) ; if ( distSqr > dtSqr ( range ) ) continue ; n = addNeighbour ( ids [ i ] , distSqr , result , n , maxResult ) ; } return n ; } void CrowdManager :: updateMoveRequest ( const float dt , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { // ▁ Fire ▁ off ▁ new ▁ requests . ENDCOM for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { MoveRequest * req = & m_moveRequests [ i ] ; Agent * ag = & m_agents [ req -> idx ] ; // ▁ Agent ▁ not ▁ active ▁ anymore , ▁ kill ▁ request . ENDCOM if ( ! ag -> active ) req -> state = MR_TARGET_FAILED ; // ▁ Adjust ▁ target ENDCOM if ( req -> aref ) { if ( req -> state == MR_TARGET_ADJUST ) { // ▁ Adjust ▁ existing ▁ path . ENDCOM ag -> corridor . moveTargetPosition ( req -> apos , navquery , filter ) ; req -> state = MR_TARGET_VALID ; } else { // ▁ Adjust ▁ on ▁ the ▁ flight ▁ request . ENDCOM float result [ 3 ] ; static const int MAX_VISITED = 16 ; dtPolyRef visited [ MAX_VISITED ] ; int nvisited = 0 ; navquery -> moveAlongSurface ( req -> temp [ req -> ntemp - 1 ] , req -> pos , req -> apos , filter , result , visited , & nvisited , MAX_VISITED ) ; req -> ntemp = fixupCorridorEnd ( req -> temp , req -> ntemp , MAX_TEMP_PATH , visited , nvisited ) ; dtVcopy ( req -> pos , result ) ; // ▁ Reset ▁ adjustment . ENDCOM dtVset ( req -> apos , 0 , 0 , 0 ) ; req -> aref = 0 ; } } if ( req -> state == MR_TARGET_REQUESTING ) { // ▁ Calculate ▁ request ▁ position . ENDCOM // ▁ If ▁ there ▁ is ▁ a ▁ lot ▁ of ▁ latency ▁ between ▁ requests , ▁ it ▁ is ▁ possible ▁ to ENDCOM // ▁ project ▁ the ▁ current ▁ position ▁ ahead ▁ and ▁ use ▁ raycast ▁ to ▁ find ▁ the ▁ actual ENDCOM // ▁ location ▁ and ▁ path . ENDCOM const dtPolyRef * path = ag -> corridor . getPath ( ) ; const int npath = ag -> corridor . getPathCount ( ) ; dtAssert ( npath ) ; // ▁ Here ▁ we ▁ take ▁ the ▁ simple ▁ approach ▁ and ▁ set ▁ the ▁ path ▁ to ▁ be ▁ just ▁ the ▁ current ▁ location . ENDCOM float reqPos [ 3 ] ; dtVcopy ( reqPos , ag -> corridor . getPos ( ) ) ; // ▁ The ▁ location ▁ of ▁ the ▁ request ENDCOM dtPolyRef reqPath [ 8 ] ; // ▁ The ▁ path ▁ to ▁ the ▁ request ▁ location ENDCOM reqPath [ 0 ] = path [ 0 ] ; int reqPathCount = 1 ; req -> pathqRef = m_pathq . request ( reqPath [ reqPathCount - 1 ] , req -> ref , reqPos , req -> pos , & m_filter ) ; if ( req -> pathqRef != PATHQ_INVALID ) { ag -> corridor . setCorridor ( reqPos , reqPath , reqPathCount ) ; req -> state = MR_TARGET_WAITING_FOR_PATH ; } } } // ▁ Update ▁ requests . ENDCOM m_pathq . update ( navquery ) ; // ▁ Process ▁ path ▁ results . ENDCOM for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { MoveRequest * req = & m_moveRequests [ i ] ; Agent * ag = & m_agents [ req -> idx ] ; if ( req -> state == MR_TARGET_WAITING_FOR_PATH ) { // ▁ Poll ▁ path ▁ queue . ENDCOM int state = m_pathq . getRequestState ( req -> pathqRef ) ; if ( state == PATHQ_STATE_INVALID ) { req -> pathqRef = PATHQ_INVALID ; req -> state = MR_TARGET_FAILED ; } else if ( state == PATHQ_STATE_READY ) { const dtPolyRef * path = ag -> corridor . getPath ( ) ; const int npath = ag -> corridor . getPathCount ( ) ; dtAssert ( npath ) ; // ▁ Apply ▁ results . ENDCOM float targetPos [ 3 ] ; dtVcopy ( targetPos , req -> pos ) ; dtPolyRef * res = m_pathResult ; bool valid = true ; int nres = m_pathq . getPathResult ( req -> pathqRef , res , m_maxPathResult ) ; if ( ! nres ) valid = false ; // ▁ Merge ▁ with ▁ any ▁ target ▁ adjustment ▁ that ▁ happened ▁ during ▁ the ▁ search . ENDCOM if ( req -> ntemp > 1 ) { nres = fixupCorridorEnd ( res , nres , m_maxPathResult , req -> temp , req -> ntemp ) ; } // ▁ Merge ▁ result ▁ and ▁ existing ▁ path . ENDCOM // ▁ The ▁ agent ▁ might ▁ have ▁ moved ▁ whilst ▁ the ▁ request ▁ is ENDCOM // ▁ being ▁ processed , ▁ so ▁ the ▁ path ▁ may ▁ have ▁ changed . ENDCOM // ▁ We ▁ assume ▁ that ▁ the ▁ end ▁ of ▁ the ▁ path ▁ is ▁ at ▁ the ▁ same ▁ location ENDCOM // ▁ where ▁ the ▁ request ▁ was ▁ issued . ENDCOM // ▁ The ▁ last ▁ ref ▁ in ▁ the ▁ old ▁ path ▁ should ▁ be ▁ the ▁ same ▁ as ENDCOM // ▁ the ▁ location ▁ where ▁ the ▁ request ▁ was ▁ issued . . ENDCOM if ( valid && path [ npath - 1 ] != res [ 0 ] ) valid = false ; if ( valid ) { // ▁ Put ▁ the ▁ old ▁ path ▁ infront ▁ of ▁ the ▁ old ▁ path . ENDCOM if ( npath > 1 ) { // ▁ Make ▁ space ▁ for ▁ the ▁ old ▁ path . ENDCOM if ( ( npath - 1 ) + nres > m_maxPathResult ) nres = m_maxPathResult - ( npath - 1 ) ; memmove ( res + npath - 1 , res , sizeof ( dtPolyRef ) * nres ) ; // ▁ Copy ▁ old ▁ path ▁ in ▁ the ▁ beginning . ENDCOM memcpy ( res , path , sizeof ( dtPolyRef ) * ( npath - 1 ) ) ; nres += npath - 1 ; } // ▁ Check ▁ for ▁ partial ▁ path . ENDCOM if ( res [ nres - 1 ] != req -> ref ) { // ▁ Partial ▁ path , ▁ constrain ▁ target ▁ position ▁ inside ▁ the ▁ last ▁ polygon . ENDCOM float nearest [ 3 ] ; if ( navquery -> closestPointOnPoly ( res [ nres - 1 ] , targetPos , nearest ) == DT_SUCCESS ) dtVcopy ( targetPos , nearest ) ; else valid = false ; } } if ( valid ) { ag -> corridor . setCorridor ( targetPos , res , nres ) ; req -> state = MR_TARGET_VALID ; } else { // ▁ Something ▁ went ▁ wrong . ENDCOM req -> state = MR_TARGET_FAILED ; } } } // ▁ Remove ▁ request ▁ when ▁ done ▁ with ▁ it . ENDCOM if ( req -> state == MR_TARGET_VALID || req -> state == MR_TARGET_FAILED ) { m_moveRequestCount -- ; if ( i != m_moveRequestCount ) memcpy ( & m_moveRequests [ i ] , & m_moveRequests [ m_moveRequestCount ] , sizeof ( MoveRequest ) ) ; -- i ; } } } static int addToOptQueue ( Agent * newag , Agent * * agents , const int nagents , const int maxAgents ) { // ▁ Insert ▁ neighbour ▁ based ▁ on ▁ greatest ▁ time . ENDCOM int slot = 0 ; if ( ! nagents ) { slot = nagents ; } else if ( newag -> topologyOptTime <= agents [ nagents - 1 ] -> topologyOptTime ) { if ( nagents >= maxAgents ) return nagents ; slot = nagents ; } else { int i ; for ( i = 0 ; i < nagents ; ++ i ) if ( newag -> topologyOptTime >= agents [ i ] -> topologyOptTime ) break ; const int tgt = i + 1 ; const int n = dtMin ( nagents - i , maxAgents - tgt ) ; dtAssert ( tgt + n <= maxAgents ) ; if ( n > 0 ) memmove ( & agents [ tgt ] , & agents [ i ] , sizeof ( Agent * ) * n ) ; slot = i ; } agents [ slot ] = newag ; return dtMin ( nagents + 1 , maxAgents ) ; } void CrowdManager :: updateTopologyOptimization ( const float dt , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { Agent * agents [ MAX_AGENTS ] ; int nagents = getActiveAgents ( agents , MAX_AGENTS ) ; if ( ! nagents ) return ; const float OPT_TIME_THR = 0.5f ; // ▁ seconds ENDCOM const int OPT_MAX_AGENTS = 1 ; Agent * queue [ OPT_MAX_AGENTS ] ; int nqueue = 0 ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> topologyOptTime += dt ; if ( ag -> topologyOptTime >= OPT_TIME_THR ) { nqueue = addToOptQueue ( ag , queue , nqueue , OPT_MAX_AGENTS ) ; } } for ( int i = 0 ; i < nqueue ; ++ i ) { Agent * ag = queue [ i ] ; ag -> corridor . optimizePathTopology ( navquery , filter ) ; ag -> topologyOptTime = 0 ; } } void CrowdManager :: update ( const float dt , unsigned int flags , dtNavMeshQuery * navquery ) { m_sampleCount = 0 ; m_totalTime = 0 ; m_rvoTime = 0 ; if ( ! navquery ) return ; TimeVal startTime = getPerfTime ( ) ; Agent * agents [ MAX_AGENTS ] ; int nagents = getActiveAgents ( agents , MAX_AGENTS ) ; static const float MAX_ACC = 8.0f ; static const float MAX_SPEED = 3.5f ; // ▁ Update ▁ async ▁ move ▁ request ▁ and ▁ path ▁ finder . ENDCOM updateMoveRequest ( dt , navquery , & m_filter ) ; // ▁ Optimize ▁ path ▁ topology . ENDCOM if ( flags & CROWDMAN_OPTIMIZE_TOPO ) updateTopologyOptimization ( dt , navquery , & m_filter ) ; // ▁ Register ▁ agents ▁ to ▁ proximity ▁ grid . ENDCOM m_grid . clear ( ) ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; const float * p = ag -> npos ; const float r = ag -> radius ; m_grid . addItem ( ( unsigned short ) i , p [ 0 ] - r , p [ 2 ] - r , p [ 0 ] + r , p [ 2 ] + r ) ; } // ▁ Get ▁ nearby ▁ navmesh ▁ segments ▁ and ▁ agents ▁ to ▁ collide ▁ with . ENDCOM for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; // ▁ Only ▁ update ▁ the ▁ collision ▁ boundary ▁ after ▁ certain ▁ distance ▁ has ▁ been ▁ passed . ENDCOM if ( dtVdist2DSqr ( ag -> npos , ag -> boundary . getCenter ( ) ) > dtSqr ( ag -> collisionQueryRange * 0.25f ) ) ag -> boundary . update ( ag -> corridor . getFirstPoly ( ) , ag -> npos , ag -> collisionQueryRange , navquery , & m_filter ) ; // ▁ Query ▁ neighbour ▁ agents ENDCOM ag -> nneis = getNeighbours ( ag -> npos , ag -> height , ag -> collisionQueryRange , ag , ag -> neis , AGENT_MAX_NEIGHBOURS ) ; } // ▁ Find ▁ next ▁ corner ▁ to ▁ steer ▁ to . ENDCOM for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; // ▁ Find ▁ corners ▁ for ▁ steering ENDCOM ag -> ncorners = ag -> corridor . findCorners ( ag -> cornerVerts , ag -> cornerFlags , ag -> cornerPolys , AGENT_MAX_CORNERS , navquery , & m_filter ) ; // ▁ Check ▁ to ▁ see ▁ if ▁ the ▁ corner ▁ after ▁ the ▁ next ▁ corner ▁ is ▁ directly ▁ visible , ENDCOM // ▁ and ▁ short ▁ cut ▁ to ▁ there . ENDCOM if ( ( flags & CROWDMAN_OPTIMIZE_VIS ) && ag -> ncorners > 0 ) { const float * target = & ag -> cornerVerts [ dtMin ( 1 , ag -> ncorners - 1 ) * 3 ] ; dtVcopy ( ag -> opts , ag -> corridor . getPos ( ) ) ; dtVcopy ( ag -> opte , target ) ; ag -> corridor . optimizePathVisibility ( target , ag -> pathOptimizationRange , navquery , & m_filter ) ; } else { dtVset ( ag -> opts , 0 , 0 , 0 ) ; dtVset ( ag -> opte , 0 , 0 , 0 ) ; } // ▁ Copy ▁ data ▁ for ▁ debug ▁ purposes . ENDCOM } // ▁ Calculate ▁ steering . ENDCOM for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; float dvel [ 3 ] = { 0 , 0 , 0 } ; // ▁ Calculate ▁ steering ▁ direction . ENDCOM if ( flags & CROWDMAN_ANTICIPATE_TURNS ) ag -> calcSmoothSteerDirection ( dvel ) ; else ag -> calcStraightSteerDirection ( dvel ) ; // ▁ Calculate ▁ speed ▁ scale , ▁ which ▁ tells ▁ the ▁ agent ▁ to ▁ slowdown ▁ at ▁ the ▁ end ▁ of ▁ the ▁ path . ENDCOM const float slowDownRadius = ag -> radius * 2 ; // ▁ TODO : ▁ make ▁ less ▁ hacky . ENDCOM const float speedScale = ag -> getDistanceToGoal ( slowDownRadius ) / slowDownRadius ; // ▁ Apply ▁ style . ENDCOM if ( flags & CROWDMAN_DRUNK ) { // ▁ Drunken ▁ steering ENDCOM // ▁ Pulsating ▁ speed . ENDCOM ag -> t += dt * ( 1.0f - ag -> var * 0.25f ) ; ag -> maxspeed = MAX_SPEED * ( 1 + dtSqr ( cosf ( ag -> t * 2.0f ) ) * 0.3f ) ; dtVscale ( dvel , dvel , ag -> maxspeed * speedScale ) ; // ▁ Slightly ▁ wandering ▁ steering . ENDCOM const float amp = cosf ( ag -> var * 13.69f + ag -> t * 3.123f ) * 0.2f ; const float nx = - dvel [ 2 ] ; const float nz = dvel [ 0 ] ; dvel [ 0 ] += nx * amp ; dvel [ 2 ] += nz * amp ; } else { // ▁ Normal ▁ steering . ENDCOM ag -> maxspeed = MAX_SPEED ; dtVscale ( dvel , dvel , ag -> maxspeed * speedScale ) ; } // ▁ Set ▁ the ▁ desired ▁ velocity . ENDCOM dtVcopy ( ag -> dvel , dvel ) ; } // ▁ Velocity ▁ planning . ENDCOM TimeVal rvoStartTime = getPerfTime ( ) ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; if ( flags & CROWDMAN_USE_VO ) { m_obstacleQuery -> reset ( ) ; // ▁ Add ▁ neighbours ▁ as ▁ obstacles . ENDCOM for ( int j = 0 ; j < ag -> nneis ; ++ j ) { const Agent * nei = & m_agents [ ag -> neis [ j ] . idx ] ; m_obstacleQuery -> addCircle ( nei -> npos , nei -> radius , nei -> vel , nei -> dvel ) ; } // ▁ Append ▁ neighbour ▁ segments ▁ as ▁ obstacles . ENDCOM for ( int j = 0 ; j < ag -> boundary . getSegmentCount ( ) ; ++ j ) { const float * s = ag -> boundary . getSegment ( j ) ; if ( dtTriArea2D ( ag -> npos , s , s + 3 ) < 0.0f ) continue ; m_obstacleQuery -> addSegment ( s , s + 3 ) ; } // ▁ Sample ▁ new ▁ safe ▁ velocity . ENDCOM bool adaptive = true ; if ( adaptive ) { m_obstacleQuery -> sampleVelocityAdaptive ( ag -> npos , ag -> radius , ag -> maxspeed , ag -> vel , ag -> dvel , ag -> nvel , VO_ADAPTIVE_DIVS , VO_ADAPTIVE_RINGS , VO_ADAPTIVE_DEPTH , m_vodebug [ i ] ) ; } else { m_obstacleQuery -> sampleVelocityGrid ( ag -> npos , ag -> radius , ag -> maxspeed , ag -> vel , ag -> dvel , ag -> nvel , VO_GRID_SIZE , m_vodebug [ i ] ) ; } } else { // ▁ If ▁ not ▁ using ▁ velocity ▁ planning , ▁ new ▁ velocity ▁ is ▁ directly ▁ the ▁ desired ▁ velocity . ENDCOM dtVcopy ( ag -> nvel , ag -> dvel ) ; } } TimeVal rvoEndTime = getPerfTime ( ) ; // ▁ Integrate . ENDCOM for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> integrate ( MAX_ACC , dt ) ; } // ▁ Handle ▁ collisions . ENDCOM for ( int iter = 0 ; iter < 4 ; ++ iter ) { for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; dtVset ( ag -> disp , 0 , 0 , 0 ) ; float w = 0 ; for ( int j = 0 ; j < ag -> nneis ; ++ j ) { const Agent * nei = & m_agents [ ag -> neis [ j ] . idx ] ; float diff [ 3 ] ; dtVsub ( diff , ag -> npos , nei -> npos ) ; if ( fabsf ( diff [ 1 ] ) >= ( ag -> height + nei -> height ) / 2.0f ) continue ; diff [ 1 ] = 0 ; float dist = dtVlenSqr ( diff ) ; if ( dist > dtSqr ( ag -> radius + nei -> radius ) ) continue ; dist = sqrtf ( dist ) ; float pen = ( ag -> radius + nei -> radius ) - dist ; if ( dist > 0.0001f ) pen = ( 1.0f / dist ) * ( pen * 0.5f ) * 0.7f ; dtVmad ( ag -> disp , ag -> disp , diff , pen ) ; w += 1.0f ; } if ( w > 0.0001f ) { const float iw = 1.0f / w ; dtVscale ( ag -> disp , ag -> disp , iw ) ; } } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; dtVadd ( ag -> npos , ag -> npos , ag -> disp ) ; } } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; // ▁ Move ▁ along ▁ navmesh . ENDCOM ag -> corridor . movePosition ( ag -> npos , navquery , & m_filter ) ; // ▁ Get ▁ valid ▁ constrained ▁ position ▁ back . ENDCOM dtVcopy ( ag -> npos , ag -> corridor . getPos ( ) ) ; } TimeVal endTime = getPerfTime ( ) ; // ▁ Debug / demo ▁ book ▁ keeping ENDCOM int ns = 0 ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; if ( flags & CROWDMAN_USE_VO ) { // ▁ Normalize ▁ samples ▁ for ▁ debug ▁ draw ENDCOM m_vodebug [ i ] -> normalizeSamples ( ) ; ns += m_vodebug [ i ] -> getSampleCount ( ) ; } // ▁ Update ▁ agent ▁ movement ▁ trail . ENDCOM ag -> htrail = ( ag -> htrail + 1 ) % AGENT_MAX_TRAIL ; dtVcopy ( & ag -> trail [ ag -> htrail * 3 ] , ag -> npos ) ; } m_sampleCount = ns ; m_rvoTime = getPerfDeltaTimeUsec ( rvoStartTime , rvoEndTime ) ; m_totalTime = getPerfDeltaTimeUsec ( startTime , endTime ) ; } </DOCUMENT>
<DOCUMENT_ID="Soverance/EtherealLegends/tree/master/Ethereal/Private/Gear/Weapons/Ranged/Annihilator.cpp"> // ▁ © ▁ 2014 ▁ - ▁ 2017 ▁ Soverance ▁ Studios ENDCOM // ▁ http : // www . soverance . com ENDCOM // ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ENDCOM // ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . ENDCOM // ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at ENDCOM // ▁ http : // www . apache . org / licenses / LICENSE - 2.0 ENDCOM // ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ENDCOM // ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ENDCOM // ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ENDCOM // ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ENDCOM // ▁ limitations ▁ under ▁ the ▁ License . ENDCOM # include " Ethereal . h " # include " Annihilator . h " # define LOCTEXT_NAMESPACE " EtherealText " // ▁ Sets ▁ default ▁ values ENDCOM AAnnihilator :: AAnnihilator ( const FObjectInitializer & ObjectInitializer ) : Super ( ObjectInitializer ) { // ▁ Get ▁ Assets , ▁ References ▁ Obtained ▁ Via ▁ Right ▁ Click ▁ in ▁ Editor ENDCOM static ConstructorHelpers :: FObjectFinder < USkeletalMesh > SkeletalMeshObject ( TEXT ( " SkeletalMesh ' / Game / VFX / sphere _ skeletal . sphere _ skeletal ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UStaticMesh > StaticMeshObject ( TEXT ( " StaticMesh ' / Game / Weapons / Ranged / Anni . Anni ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UStaticMesh > OffhandMeshObject ( TEXT ( " StaticMesh ' / Game / VFX / sphere . sphere ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UTexture2D > LargeIconObject ( TEXT ( " Texture2D ' / Game / Blueprints / Widgets / UI - Images / Icons _ Gear / WeaponIcon _ Annihilator . WeaponIcon _ Annihilator ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UTexture2D > SmallIconObject ( TEXT ( " Texture2D ' / Game / Blueprints / Widgets / UI - Images / Icons _ Gear / WeaponIcon _ Annihilator - small . WeaponIcon _ Annihilator - small ' " ) ) ; Name = EMasterGearList :: GL_Annihilator ; NameText = LOCTEXT ( " AnnihilatorName " , " Annihilator " ) ; Type = EMasterGearTypes :: GT_Ranged ; TypeText = LOCTEXT ( " AnnihilatorType " , " Ranged " ) ; Description = " An ▁ embodiment ▁ of ▁ the ▁ Ethereal ▁ Virtue : ▁ Wrath . " ; Price = 40000 ; MPCost = 0.0f ; ATK = 50.0f ; DEF = 40.0f ; SPD = 20.0f ; HP = 500.0f ; MP = 250.0f ; LargeIcon = LargeIconObject . Object ; SmallIcon = SmallIconObject . Object ; SK_WeaponSkeletalMesh = SkeletalMeshObject . Object ; SM_WeaponStaticMesh = StaticMeshObject . Object ; SM_WeaponOffhandMesh = StaticMeshObject . Object ; // ▁ Set ▁ Mesh ENDCOM WeaponSkeletalMesh -> SetSkeletalMesh ( SK_WeaponSkeletalMesh ) ; WeaponSkeletalMesh -> SetHiddenInGame ( true ) ; WeaponStaticMesh -> SetStaticMesh ( SM_WeaponStaticMesh ) ; WeaponStaticMesh -> SetWorldScale3D ( FVector ( 0.15f , 0.15f , 0.15f ) ) ; // ▁ scale ▁ correction ENDCOM WeaponStaticMesh -> SetRelativeLocation ( FVector ( 20 , - 2 , - 2 ) ) ; // ▁ location ▁ correction ENDCOM WeaponStaticMesh -> SetRelativeRotation ( FRotator ( - 12 , - 90 , - 75 ) ) ; // ▁ location ▁ correction ENDCOM WeaponOffhandMesh -> SetStaticMesh ( SM_WeaponOffhandMesh ) ; WeaponOffhandMesh -> SetHiddenInGame ( true ) ; } // ▁ Called ▁ when ▁ the ▁ game ▁ starts ▁ or ▁ when ▁ spawned ENDCOM void AAnnihilator :: BeginPlay ( ) { Super :: BeginPlay ( ) ; // ▁ Bind ▁ this ▁ function ▁ to ▁ the ▁ event ▁ dispatcher ▁ for ▁ Bind ▁ Gear ENDCOM OnBindGear . AddDynamic ( this , & AAnnihilator :: BindWeapon ) ; } // ▁ Custom ▁ code ▁ when ▁ binding ENDCOM void AAnnihilator :: BindWeapon ( ) { // ▁ If ▁ this ▁ weapon ▁ was ▁ bound ▁ while ▁ IsShown ▁ is ▁ true , ▁ set ▁ the ▁ weapon ▁ visible ENDCOM if ( IsShown ) { ShowWeapon ( false , true , false ) ; } } # undef LOCTEXT_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="mur47x111/JDK8-concurrent-tagging/tree/master/src/share/vm/gc_implementation/concurrentMarkSweep/vmCMSOperations.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( c ) ▁ 2005 , ▁ 2013 , ▁ Oracle ▁ and / or ▁ its ▁ affiliates . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * ▁ DO ▁ NOT ▁ ALTER ▁ OR ▁ REMOVE ▁ COPYRIGHT ▁ NOTICES ▁ OR ▁ THIS ▁ FILE ▁ HEADER . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ code ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it STRNEWLINE ▁ * ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ version ▁ 2 ▁ only , ▁ as STRNEWLINE ▁ * ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ code ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT STRNEWLINE ▁ * ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or STRNEWLINE ▁ * ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ version ▁ 2 ▁ for ▁ more ▁ details ▁ ( a ▁ copy ▁ is ▁ included ▁ in ▁ the ▁ LICENSE ▁ file ▁ that STRNEWLINE ▁ * ▁ accompanied ▁ this ▁ code ) . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ version STRNEWLINE ▁ * ▁ 2 ▁ along ▁ with ▁ this ▁ work ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ▁ Foundation , STRNEWLINE ▁ * ▁ Inc . , ▁ 51 ▁ Franklin ▁ St , ▁ Fifth ▁ Floor , ▁ Boston , ▁ MA ▁ 02110-1301 ▁ USA . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Please ▁ contact ▁ Oracle , ▁ 500 ▁ Oracle ▁ Parkway , ▁ Redwood ▁ Shores , ▁ CA ▁ 94065 ▁ USA STRNEWLINE ▁ * ▁ or ▁ visit ▁ www . oracle . com ▁ if ▁ you ▁ need ▁ additional ▁ information ▁ or ▁ have ▁ any STRNEWLINE ▁ * ▁ questions . STRNEWLINE ▁ * STRNEWLINE ▁ */ # include " precompiled . hpp " # include " gc _ implementation / concurrentMarkSweep / concurrentMarkSweepGeneration . inline . hpp " # include " gc _ implementation / concurrentMarkSweep / concurrentMarkSweepThread . hpp " # include " gc _ implementation / concurrentMarkSweep / vmCMSOperations . hpp " # include " gc _ implementation / shared / gcTimer . hpp " # include " gc _ implementation / shared / gcTraceTime . hpp " # include " gc _ implementation / shared / isGCActiveMark . hpp " # include " memory / gcLocker . inline . hpp " # include " runtime / interfaceSupport . hpp " # include " runtime / os . hpp " # include " utilities / dtrace . hpp " # ifndef USDT2 HS_DTRACE_PROBE_DECL ( hs_private , cms__initmark__begin ) ; HS_DTRACE_PROBE_DECL ( hs_private , cms__initmark__end ) ; HS_DTRACE_PROBE_DECL ( hs_private , cms__remark__begin ) ; HS_DTRACE_PROBE_DECL ( hs_private , cms__remark__end ) ; # endif /* ▁ ! USDT2 ▁ */ // ▁ Methods ▁ in ▁ abstract ▁ class ▁ VM _ CMS _ Operation ENDCOM void VM_CMS_Operation :: acquire_pending_list_lock ( ) { // ▁ The ▁ caller ▁ may ▁ block ▁ while ▁ communicating ENDCOM // ▁ with ▁ the ▁ SLT ▁ thread ▁ in ▁ order ▁ to ▁ acquire / release ▁ the ▁ PLL . ENDCOM ConcurrentMarkSweepThread :: slt ( ) -> manipulatePLL ( SurrogateLockerThread :: acquirePLL ) ; } void VM_CMS_Operation :: release_and_notify_pending_list_lock ( ) { // ▁ The ▁ caller ▁ may ▁ block ▁ while ▁ communicating ENDCOM // ▁ with ▁ the ▁ SLT ▁ thread ▁ in ▁ order ▁ to ▁ acquire / release ▁ the ▁ PLL . ENDCOM ConcurrentMarkSweepThread :: slt ( ) -> manipulatePLL ( SurrogateLockerThread :: releaseAndNotifyPLL ) ; } void VM_CMS_Operation :: verify_before_gc ( ) { if ( VerifyBeforeGC && GenCollectedHeap :: heap ( ) -> total_collections ( ) >= VerifyGCStartAt ) { GCTraceTime tm ( " Verify ▁ Before " , false , false , _collector -> _gc_timer_cm ) ; HandleMark hm ; FreelistLocker x ( _collector ) ; MutexLockerEx y ( _collector -> bitMapLock ( ) , Mutex :: _no_safepoint_check_flag ) ; Universe :: heap ( ) -> prepare_for_verify ( ) ; Universe :: verify ( ) ; } } void VM_CMS_Operation :: verify_after_gc ( ) { if ( VerifyAfterGC && GenCollectedHeap :: heap ( ) -> total_collections ( ) >= VerifyGCStartAt ) { GCTraceTime tm ( " Verify ▁ After " , false , false , _collector -> _gc_timer_cm ) ; HandleMark hm ; FreelistLocker x ( _collector ) ; MutexLockerEx y ( _collector -> bitMapLock ( ) , Mutex :: _no_safepoint_check_flag ) ; Universe :: verify ( ) ; } } bool VM_CMS_Operation :: lost_race ( ) const { if ( CMSCollector :: abstract_state ( ) == CMSCollector :: Idling ) { // ▁ We ▁ lost ▁ a ▁ race ▁ to ▁ a ▁ foreground ▁ collection ENDCOM // ▁ - - ▁ there ' s ▁ nothing ▁ to ▁ do ENDCOM return true ; } assert ( CMSCollector :: abstract_state ( ) == legal_state ( ) , " Inconsistent ▁ collector ▁ state ? " ) ; return false ; } bool VM_CMS_Operation :: doit_prologue ( ) { assert ( Thread :: current ( ) -> is_ConcurrentGC_thread ( ) , " just ▁ checking " ) ; assert ( ! CMSCollector :: foregroundGCShouldWait ( ) , " Possible ▁ deadlock " ) ; assert ( ! ConcurrentMarkSweepThread :: cms_thread_has_cms_token ( ) , " Possible ▁ deadlock " ) ; if ( needs_pll ( ) ) { acquire_pending_list_lock ( ) ; } // ▁ Get ▁ the ▁ Heap _ lock ▁ after ▁ the ▁ pending _ list _ lock . ENDCOM Heap_lock -> lock ( ) ; if ( lost_race ( ) ) { assert ( _prologue_succeeded == false , " Initialized ▁ in ▁ c ' tor " ) ; Heap_lock -> unlock ( ) ; if ( needs_pll ( ) ) { release_and_notify_pending_list_lock ( ) ; } } else { _prologue_succeeded = true ; } return _prologue_succeeded ; } void VM_CMS_Operation :: doit_epilogue ( ) { assert ( Thread :: current ( ) -> is_ConcurrentGC_thread ( ) , " just ▁ checking " ) ; assert ( ! CMSCollector :: foregroundGCShouldWait ( ) , " Possible ▁ deadlock " ) ; assert ( ! ConcurrentMarkSweepThread :: cms_thread_has_cms_token ( ) , " Possible ▁ deadlock " ) ; // ▁ Release ▁ the ▁ Heap _ lock ▁ first . ENDCOM Heap_lock -> unlock ( ) ; if ( needs_pll ( ) ) { release_and_notify_pending_list_lock ( ) ; } } // ▁ Methods ▁ in ▁ class ▁ VM _ CMS _ Initial _ Mark ENDCOM void VM_CMS_Initial_Mark :: doit ( ) { if ( lost_race ( ) ) { // ▁ Nothing ▁ to ▁ do . ENDCOM return ; } # ifndef USDT2 HS_DTRACE_PROBE ( hs_private , cms__initmark__begin ) ; # else /* ▁ USDT2 ▁ */ HS_PRIVATE_CMS_INITMARK_BEGIN ( ) ; # endif /* ▁ USDT2 ▁ */ _collector -> _gc_timer_cm -> register_gc_pause_start ( " Initial ▁ Mark " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; GCCauseSetter gccs ( gch , GCCause :: _cms_initial_mark ) ; VM_CMS_Operation :: verify_before_gc ( ) ; IsGCActiveMark x ; // ▁ stop - world ▁ GC ▁ active ENDCOM _collector -> do_CMS_operation ( CMSCollector :: CMS_op_checkpointRootsInitial , gch -> gc_cause ( ) ) ; VM_CMS_Operation :: verify_after_gc ( ) ; _collector -> _gc_timer_cm -> register_gc_pause_end ( ) ; # ifndef USDT2 HS_DTRACE_PROBE ( hs_private , cms__initmark__end ) ; # else /* ▁ USDT2 ▁ */ HS_PRIVATE_CMS_INITMARK_END ( ) ; # endif /* ▁ USDT2 ▁ */ } // ▁ Methods ▁ in ▁ class ▁ VM _ CMS _ Final _ Remark _ Operation ENDCOM void VM_CMS_Final_Remark :: doit ( ) { if ( lost_race ( ) ) { // ▁ Nothing ▁ to ▁ do . ENDCOM return ; } # ifndef USDT2 HS_DTRACE_PROBE ( hs_private , cms__remark__begin ) ; # else /* ▁ USDT2 ▁ */ HS_PRIVATE_CMS_REMARK_BEGIN ( ) ; # endif /* ▁ USDT2 ▁ */ _collector -> _gc_timer_cm -> register_gc_pause_start ( " Final ▁ Mark " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; GCCauseSetter gccs ( gch , GCCause :: _cms_final_remark ) ; VM_CMS_Operation :: verify_before_gc ( ) ; IsGCActiveMark x ; // ▁ stop - world ▁ GC ▁ active ENDCOM _collector -> do_CMS_operation ( CMSCollector :: CMS_op_checkpointRootsFinal , gch -> gc_cause ( ) ) ; VM_CMS_Operation :: verify_after_gc ( ) ; _collector -> save_heap_summary ( ) ; _collector -> _gc_timer_cm -> register_gc_pause_end ( ) ; # ifndef USDT2 HS_DTRACE_PROBE ( hs_private , cms__remark__end ) ; # else /* ▁ USDT2 ▁ */ HS_PRIVATE_CMS_REMARK_END ( ) ; # endif /* ▁ USDT2 ▁ */ } // ▁ VM ▁ operation ▁ to ▁ invoke ▁ a ▁ concurrent ▁ collection ▁ of ▁ a ENDCOM // ▁ GenCollectedHeap ▁ heap . ENDCOM void VM_GenCollectFullConcurrent :: doit ( ) { assert ( Thread :: current ( ) -> is_VM_thread ( ) , " Should ▁ be ▁ VM ▁ thread " ) ; assert ( GCLockerInvokesConcurrent || ExplicitGCInvokesConcurrent , " Unexpected " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; if ( _gc_count_before == gch -> total_collections ( ) ) { // ▁ The ▁ " full " ▁ of ▁ do _ full _ collection ▁ call ▁ below ▁ " forces " ENDCOM // ▁ a ▁ collection ; ▁ the ▁ second ▁ arg , ▁ 0 , ▁ below ▁ ensures ▁ that ENDCOM // ▁ only ▁ the ▁ young ▁ gen ▁ is ▁ collected . ▁ XXX ▁ In ▁ the ▁ future , ENDCOM // ▁ we ' ll ▁ probably ▁ need ▁ to ▁ have ▁ something ▁ in ▁ this ▁ interface ENDCOM // ▁ to ▁ say ▁ do ▁ this ▁ only ▁ if ▁ we ▁ are ▁ sure ▁ we ▁ will ▁ not ▁ bail ENDCOM // ▁ out ▁ to ▁ a ▁ full ▁ collection ▁ in ▁ this ▁ attempt , ▁ but ▁ that ' s ENDCOM // ▁ for ▁ the ▁ future . ENDCOM assert ( SafepointSynchronize :: is_at_safepoint ( ) , " We ▁ can ▁ only ▁ be ▁ executing ▁ this ▁ arm ▁ of ▁ if ▁ at ▁ a ▁ safepoint " ) ; GCCauseSetter gccs ( gch , _gc_cause ) ; gch -> do_full_collection ( gch -> must_clear_all_soft_refs ( ) , 0 /* ▁ collect ▁ only ▁ youngest ▁ gen ▁ */ ) ; } // ▁ Else ▁ no ▁ need ▁ for ▁ a ▁ foreground ▁ young ▁ gc ENDCOM assert ( ( _gc_count_before < gch -> total_collections ( ) ) || ( GC_locker :: is_active ( ) /* ▁ gc ▁ may ▁ have ▁ been ▁ skipped ▁ */ && ( _gc_count_before == gch -> total_collections ( ) ) ) , " total _ collections ( ) ▁ should ▁ be ▁ monotonically ▁ increasing " ) ; MutexLockerEx x ( FullGCCount_lock , Mutex :: _no_safepoint_check_flag ) ; assert ( _full_gc_count_before <= gch -> total_full_collections ( ) , " Error " ) ; if ( gch -> total_full_collections ( ) == _full_gc_count_before ) { // ▁ Disable ▁ iCMS ▁ until ▁ the ▁ full ▁ collection ▁ is ▁ done , ▁ and ENDCOM // ▁ remember ▁ that ▁ we ▁ did ▁ so . ENDCOM CMSCollector :: disable_icms ( ) ; _disabled_icms = true ; // ▁ In ▁ case ▁ CMS ▁ thread ▁ was ▁ in ▁ icms _ wait ( ) , ▁ wake ▁ it ▁ up . ENDCOM CMSCollector :: start_icms ( ) ; // ▁ Nudge ▁ the ▁ CMS ▁ thread ▁ to ▁ start ▁ a ▁ concurrent ▁ collection . ENDCOM CMSCollector :: request_full_gc ( _full_gc_count_before , _gc_cause ) ; } else { assert ( _full_gc_count_before < gch -> total_full_collections ( ) , " Error " ) ; FullGCCount_lock -> notify_all ( ) ; // ▁ Inform ▁ the ▁ Java ▁ thread ▁ its ▁ work ▁ is ▁ done ENDCOM } } bool VM_GenCollectFullConcurrent :: evaluate_at_safepoint ( ) const { Thread * thr = Thread :: current ( ) ; assert ( thr != NULL , " Unexpected ▁ tid " ) ; if ( ! thr -> is_Java_thread ( ) ) { assert ( thr -> is_VM_thread ( ) , " Expected ▁ to ▁ be ▁ evaluated ▁ by ▁ VM ▁ thread " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; if ( _gc_count_before != gch -> total_collections ( ) ) { // ▁ No ▁ need ▁ to ▁ do ▁ a ▁ young ▁ gc , ▁ we ' ll ▁ just ▁ nudge ▁ the ▁ CMS ▁ thread ENDCOM // ▁ in ▁ the ▁ doit ( ) ▁ method ▁ above , ▁ to ▁ be ▁ executed ▁ soon . ENDCOM assert ( _gc_count_before < gch -> total_collections ( ) , " total _ collections ( ) ▁ should ▁ be ▁ monotnically ▁ increasing " ) ; return false ; // ▁ no ▁ need ▁ for ▁ foreground ▁ young ▁ gc ENDCOM } } return true ; // ▁ may ▁ still ▁ need ▁ foreground ▁ young ▁ gc ENDCOM } void VM_GenCollectFullConcurrent :: doit_epilogue ( ) { Thread * thr = Thread :: current ( ) ; assert ( thr -> is_Java_thread ( ) , " just ▁ checking " ) ; JavaThread * jt = ( JavaThread * ) thr ; // ▁ Release ▁ the ▁ Heap _ lock ▁ first . ENDCOM Heap_lock -> unlock ( ) ; release_and_notify_pending_list_lock ( ) ; // ▁ It ▁ is ▁ fine ▁ to ▁ test ▁ whether ▁ completed ▁ collections ▁ has ENDCOM // ▁ exceeded ▁ our ▁ request ▁ count ▁ without ▁ locking ▁ because ENDCOM // ▁ the ▁ completion ▁ count ▁ is ▁ monotonically ▁ increasing ; ENDCOM // ▁ this ▁ will ▁ break ▁ for ▁ very ▁ long - running ▁ apps ▁ when ▁ the ENDCOM // ▁ count ▁ overflows ▁ and ▁ wraps ▁ around . ▁ XXX ▁ fix ▁ me ▁ ! ! ! ENDCOM // ▁ e . g . ▁ at ▁ the ▁ rate ▁ of ▁ 1 ▁ full ▁ gc ▁ per ▁ ms , ▁ this ▁ could ENDCOM // ▁ overflow ▁ in ▁ about ▁ 1000 ▁ years . ENDCOM GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; if ( _gc_cause != GCCause :: _gc_locker && gch -> total_full_collections_completed ( ) <= _full_gc_count_before ) { // ▁ maybe ▁ we ▁ should ▁ change ▁ the ▁ condition ▁ to ▁ test ▁ _ gc _ cause ▁ = = ENDCOM // ▁ GCCause : : _ java _ lang _ system _ gc , ▁ instead ▁ of ENDCOM // ▁ _ gc _ cause ▁ ! = ▁ GCCause : : _ gc _ locker ENDCOM assert ( _gc_cause == GCCause :: _java_lang_system_gc , " the ▁ only ▁ way ▁ to ▁ get ▁ here ▁ if ▁ this ▁ was ▁ a ▁ System . gc ( ) - induced ▁ GC " ) ; assert ( ExplicitGCInvokesConcurrent , " Error " ) ; // ▁ Now , ▁ wait ▁ for ▁ witnessing ▁ concurrent ▁ gc ▁ cycle ▁ to ▁ complete , ENDCOM // ▁ but ▁ do ▁ so ▁ in ▁ native ▁ mode , ▁ because ▁ we ▁ want ▁ to ▁ lock ▁ the ENDCOM // ▁ FullGCEvent _ lock , ▁ which ▁ may ▁ be ▁ needed ▁ by ▁ the ▁ VM ▁ thread ENDCOM // ▁ or ▁ by ▁ the ▁ CMS ▁ thread , ▁ so ▁ we ▁ do ▁ not ▁ want ▁ to ▁ be ▁ suspended ENDCOM // ▁ while ▁ holding ▁ that ▁ lock . ENDCOM ThreadToNativeFromVM native ( jt ) ; MutexLockerEx ml ( FullGCCount_lock , Mutex :: _no_safepoint_check_flag ) ; // ▁ Either ▁ a ▁ concurrent ▁ or ▁ a ▁ stop - world ▁ full ▁ gc ▁ is ▁ sufficient ENDCOM // ▁ witness ▁ to ▁ our ▁ request . ENDCOM while ( gch -> total_full_collections_completed ( ) <= _full_gc_count_before ) { FullGCCount_lock -> wait ( Mutex :: _no_safepoint_check_flag ) ; } } // ▁ Enable ▁ iCMS ▁ back ▁ if ▁ we ▁ disabled ▁ it ▁ earlier . ENDCOM if ( _disabled_icms ) { CMSCollector :: enable_icms ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="shadowofreality/ShadowCore/tree/master/src/server/game/Handlers/MiscHandler.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2008-2017 ▁ TrinityCore ▁ < http : // www . trinitycore . org / > STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2005-2009 ▁ MaNGOS ▁ < http : // getmangos . com / > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it STRNEWLINE ▁ * ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the STRNEWLINE ▁ * ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your STRNEWLINE ▁ * ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT STRNEWLINE ▁ * ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or STRNEWLINE ▁ * ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for STRNEWLINE ▁ * ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along STRNEWLINE ▁ * ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ */ # include " Common . h " # include " Language . h " # include " DatabaseEnv . h " # include " WorldPacket . h " # include " Opcodes . h " # include " Log . h " # include " Player . h " # include " GameTime . h " # include " GossipDef . h " # include " World . h " # include " ObjectMgr . h " # include " GuildMgr . h " # include " WorldSession . h " # include " Chat . h " # include " zlib . h " # include " ObjectAccessor . h " # include " Object . h " # include " Battleground . h " # include " OutdoorPvP . h " # include " AccountMgr . h " # include " DBCEnums . h " # include " ScriptMgr . h " # include " MapManager . h " # include " GameObjectAI . h " # include " Group . h " # include " Spell . h " # include " BattlegroundMgr . h " # include " Battlefield . h " # include " BattlefieldMgr . h " # include " WhoListStorage . h " void WorldSession :: HandleRepopRequestOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ REPOP _ REQUEST ▁ Message " ) ; recvData . read_skip < uint8 > ( ) ; if ( GetPlayer ( ) -> IsAlive ( ) || GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_GHOST ) ) return ; if ( GetPlayer ( ) -> HasAuraType ( SPELL_AURA_PREVENT_RESURRECTION ) ) return ; // ▁ silently ▁ return , ▁ client ▁ should ▁ display ▁ the ▁ error ▁ by ▁ itself ENDCOM // ▁ the ▁ world ▁ update ▁ order ▁ is ▁ sessions , ▁ players , ▁ creatures ENDCOM // ▁ the ▁ netcode ▁ runs ▁ in ▁ parallel ▁ with ▁ all ▁ of ▁ these ENDCOM // ▁ creatures ▁ can ▁ kill ▁ players ENDCOM // ▁ so ▁ if ▁ the ▁ server ▁ is ▁ lagging ▁ enough ▁ the ▁ player ▁ can ENDCOM // ▁ release ▁ spirit ▁ after ▁ he ' s ▁ killed ▁ but ▁ before ▁ he ▁ is ▁ updated ENDCOM if ( GetPlayer ( ) -> getDeathState ( ) == JUST_DIED ) { TC_LOG_DEBUG ( " network " , " HandleRepopRequestOpcode : ▁ got ▁ request ▁ after ▁ player ▁ % s ( % d ) ▁ was ▁ killed ▁ and ▁ before ▁ he ▁ was ▁ updated " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , GetPlayer ( ) -> GetGUID ( ) . GetCounter ( ) ) ; GetPlayer ( ) -> KillPlayer ( ) ; } // this ▁ is ▁ spirit ▁ release ▁ confirm ? ENDCOM GetPlayer ( ) -> RemoveGhoul ( ) ; GetPlayer ( ) -> RemovePet ( NULL , PET_SAVE_NOT_IN_SLOT , true ) ; GetPlayer ( ) -> BuildPlayerRepop ( ) ; GetPlayer ( ) -> RepopAtGraveyard ( ) ; } void WorldSession :: HandleGossipSelectOptionOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ GOSSIP _ SELECT _ OPTION " ) ; uint32 gossipListId ; uint32 menuId ; ObjectGuid guid ; std :: string code = " " ; recvData >> guid >> menuId >> gossipListId ; if ( ! _player -> PlayerTalkClass -> GetGossipMenu ( ) . GetItem ( gossipListId ) ) { recvData . rfinish ( ) ; return ; } if ( _player -> PlayerTalkClass -> IsGossipOptionCoded ( gossipListId ) ) recvData >> code ; // ▁ Prevent ▁ cheating ▁ on ▁ C + + ▁ scripted ▁ menus ENDCOM if ( _player -> PlayerTalkClass -> GetGossipMenu ( ) . GetSenderGUID ( ) != guid ) return ; Creature * unit = NULL ; GameObject * go = NULL ; if ( guid . IsCreatureOrVehicle ( ) ) { unit = GetPlayer ( ) -> GetNPCIfCanInteractWith ( guid , UNIT_NPC_FLAG_GOSSIP ) ; if ( ! unit ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ % s ▁ not ▁ found ▁ or ▁ you ▁ can ' t ▁ interact ▁ with ▁ him . " , guid . ToString ( ) . c_str ( ) ) ; return ; } } else if ( guid . IsGameObject ( ) ) { go = _player -> GetGameObjectIfCanInteractWith ( guid ) ; if ( ! go ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ % s ▁ not ▁ found ▁ or ▁ you ▁ can ' t ▁ interact ▁ with ▁ it . " , guid . ToString ( ) . c_str ( ) ) ; return ; } } else { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ unsupported ▁ % s . " , guid . ToString ( ) . c_str ( ) ) ; return ; } // ▁ remove ▁ fake ▁ death ENDCOM if ( GetPlayer ( ) -> HasUnitState ( UNIT_STATE_DIED ) ) GetPlayer ( ) -> RemoveAurasByType ( SPELL_AURA_FEIGN_DEATH ) ; if ( ( unit && unit -> GetScriptId ( ) != unit -> LastUsedScriptID ) || ( go && go -> GetScriptId ( ) != go -> LastUsedScriptID ) ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ Script ▁ reloaded ▁ while ▁ in ▁ use , ▁ ignoring ▁ and ▁ set ▁ new ▁ scipt ▁ id " ) ; if ( unit ) unit -> LastUsedScriptID = unit -> GetScriptId ( ) ; if ( go ) go -> LastUsedScriptID = go -> GetScriptId ( ) ; _player -> PlayerTalkClass -> SendCloseGossip ( ) ; return ; } if ( ! code . empty ( ) ) { if ( unit ) { unit -> AI ( ) -> sGossipSelectCode ( _player , menuId , gossipListId , code . c_str ( ) ) ; if ( ! sScriptMgr -> OnGossipSelectCode ( _player , unit , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) , code . c_str ( ) ) ) _player -> OnGossipSelect ( unit , gossipListId , menuId ) ; } else { go -> AI ( ) -> GossipSelectCode ( _player , menuId , gossipListId , code . c_str ( ) ) ; if ( ! sScriptMgr -> OnGossipSelectCode ( _player , go , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) , code . c_str ( ) ) ) _player -> OnGossipSelect ( go , gossipListId , menuId ) ; } } else { if ( unit ) { unit -> AI ( ) -> sGossipSelect ( _player , menuId , gossipListId ) ; if ( ! sScriptMgr -> OnGossipSelect ( _player , unit , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) ) ) _player -> OnGossipSelect ( unit , gossipListId , menuId ) ; } else { go -> AI ( ) -> GossipSelect ( _player , menuId , gossipListId ) ; if ( ! sScriptMgr -> OnGossipSelect ( _player , go , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) ) ) _player -> OnGossipSelect ( go , gossipListId , menuId ) ; } } } void WorldSession :: HandleWhoOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ WHO ▁ Message " ) ; uint32 matchCount = 0 ; uint32 levelMin , levelMax , racemask , classmask , zonesCount , strCount ; uint32 zoneids [ 10 ] ; // ▁ 10 ▁ is ▁ client ▁ limit ENDCOM std :: string packetPlayerName , packetGuildName ; recvData >> levelMin ; // ▁ maximal ▁ player ▁ level , ▁ default ▁ 0 ENDCOM recvData >> levelMax ; // ▁ minimal ▁ player ▁ level , ▁ default ▁ 100 ▁ ( MAX _ LEVEL ) ENDCOM recvData >> packetPlayerName ; // ▁ player ▁ name , ▁ case ▁ sensitive . . . ENDCOM recvData >> packetGuildName ; // ▁ guild ▁ name , ▁ case ▁ sensitive . . . ENDCOM recvData >> racemask ; // ▁ race ▁ mask ENDCOM recvData >> classmask ; // ▁ class ▁ mask ENDCOM recvData >> zonesCount ; // ▁ zones ▁ count , ▁ client ▁ limit ▁ = ▁ 10 ▁ ( 2.0.10 ) ENDCOM if ( zonesCount > 10 ) return ; // ▁ can ' t ▁ be ▁ received ▁ from ▁ real ▁ client ▁ or ▁ broken ▁ packet ENDCOM for ( uint32 i = 0 ; i < zonesCount ; ++ i ) { uint32 temp ; recvData >> temp ; // ▁ zone ▁ id , ▁ 0 ▁ if ▁ zone ▁ is ▁ unknown . . . ENDCOM zoneids [ i ] = temp ; TC_LOG_DEBUG ( " network " , " Zone ▁ % u : ▁ % u " , i , zoneids [ i ] ) ; } recvData >> strCount ; // ▁ user ▁ entered ▁ strings ▁ count , ▁ client ▁ limit = 4 ▁ ( checked ▁ on ▁ 2.0.10 ) ENDCOM if ( strCount > 4 ) return ; // ▁ can ' t ▁ be ▁ received ▁ from ▁ real ▁ client ▁ or ▁ broken ▁ packet ENDCOM TC_LOG_DEBUG ( " network " , " Minlvl ▁ % u , ▁ maxlvl ▁ % u , ▁ name ▁ % s , ▁ guild ▁ % s , ▁ racemask ▁ % u , ▁ classmask ▁ % u , ▁ zones ▁ % u , ▁ strings ▁ % u " , levelMin , levelMax , packetPlayerName . c_str ( ) , packetGuildName . c_str ( ) , racemask , classmask , zonesCount , strCount ) ; std :: wstring str [ 4 ] ; // ▁ 4 ▁ is ▁ client ▁ limit ENDCOM for ( uint32 i = 0 ; i < strCount ; ++ i ) { std :: string temp ; recvData >> temp ; // ▁ user ▁ entered ▁ string , ▁ it ▁ used ▁ as ▁ universal ▁ search ▁ pattern ( guild + player ▁ name ) ? ENDCOM if ( ! Utf8toWStr ( temp , str [ i ] ) ) continue ; wstrToLower ( str [ i ] ) ; TC_LOG_DEBUG ( " network " , " String ▁ % u : ▁ % s " , i , temp . c_str ( ) ) ; } std :: wstring wpacketPlayerName ; std :: wstring wpacketGuildName ; if ( ! ( Utf8toWStr ( packetPlayerName , wpacketPlayerName ) && Utf8toWStr ( packetGuildName , wpacketGuildName ) ) ) return ; wstrToLower ( wpacketPlayerName ) ; wstrToLower ( wpacketGuildName ) ; // ▁ client ▁ send ▁ in ▁ case ▁ not ▁ set ▁ max ▁ level ▁ value ▁ 100 ▁ but ▁ Trinity ▁ supports ▁ 255 ▁ max ▁ level , ENDCOM // ▁ update ▁ it ▁ to ▁ show ▁ GMs ▁ with ▁ characters ▁ after ▁ 100 ▁ level ENDCOM if ( levelMax >= MAX_LEVEL ) levelMax = STRONG_MAX_LEVEL ; uint32 team = _player -> GetTeam ( ) ; uint32 gmLevelInWhoList = sWorld -> getIntConfig ( CONFIG_GM_LEVEL_IN_WHO_LIST ) ; uint32 displayCount = 0 ; WorldPacket data ( SMSG_WHO , 500 ) ; // ▁ guess ▁ size ENDCOM data << uint32 ( matchCount ) ; // ▁ placeholder , ▁ count ▁ of ▁ players ▁ matching ▁ criteria ENDCOM data << uint32 ( displayCount ) ; // ▁ placeholder , ▁ count ▁ of ▁ players ▁ displayed ENDCOM WhoListInfoVector const & whoList = sWhoListStorageMgr -> GetWhoList ( ) ; for ( WhoListPlayerInfo const & target : whoList ) { // ▁ player ▁ can ▁ see ▁ member ▁ of ▁ other ▁ team ▁ only ▁ if ▁ CONFIG _ ALLOW _ TWO _ SIDE _ WHO _ LIST ENDCOM if ( target . GetTeam ( ) != team && ! HasPermission ( rbac :: RBAC_PERM_TWO_SIDE_WHO_LIST ) ) continue ; // ▁ player ▁ can ▁ see ▁ MODERATOR , ▁ GAME ▁ MASTER , ▁ ADMINISTRATOR ▁ only ▁ if ▁ CONFIG _ GM _ IN _ WHO _ LIST ENDCOM if ( ! HasPermission ( rbac :: RBAC_PERM_WHO_SEE_ALL_SEC_LEVELS ) && target . GetSecurity ( ) > AccountTypes ( gmLevelInWhoList ) ) continue ; // ▁ check ▁ if ▁ target ▁ is ▁ globally ▁ visible ▁ for ▁ player ENDCOM if ( _player -> GetGUID ( ) != target . GetGuid ( ) && ! target . IsVisible ( ) ) if ( AccountMgr :: IsPlayerAccount ( _player -> GetSession ( ) -> GetSecurity ( ) ) || target . GetSecurity ( ) > _player -> GetSession ( ) -> GetSecurity ( ) ) continue ; // ▁ check ▁ if ▁ target ' s ▁ level ▁ is ▁ in ▁ level ▁ range ENDCOM uint8 lvl = target . GetLevel ( ) ; if ( lvl < levelMin || lvl > levelMax ) continue ; // ▁ check ▁ if ▁ class ▁ matches ▁ classmask ENDCOM uint8 class_ = target . GetClass ( ) ; if ( ! ( classmask & ( 1 << class_ ) ) ) continue ; // ▁ check ▁ if ▁ race ▁ matches ▁ racemask ENDCOM uint32 race = target . GetRace ( ) ; if ( ! ( racemask & ( 1 << race ) ) ) continue ; uint32 playerZoneId = target . GetZoneId ( ) ; uint8 gender = target . GetGender ( ) ; bool showZones = true ; for ( uint32 i = 0 ; i < zonesCount ; ++ i ) { if ( zoneids [ i ] == playerZoneId ) { showZones = true ; break ; } showZones = false ; } if ( ! showZones ) continue ; std :: wstring const & wideplayername = target . GetWidePlayerName ( ) ; if ( ! ( wpacketPlayerName . empty ( ) || wideplayername . find ( wpacketPlayerName ) != std :: wstring :: npos ) ) continue ; std :: wstring const & wideguildname = target . GetWideGuildName ( ) ; if ( ! ( wpacketGuildName . empty ( ) || wideguildname . find ( wpacketGuildName ) != std :: wstring :: npos ) ) continue ; std :: string aname ; if ( AreaTableEntry const * areaEntry = sAreaTableStore . LookupEntry ( playerZoneId ) ) aname = areaEntry -> area_name [ GetSessionDbcLocale ( ) ] ; bool s_show = true ; for ( uint32 i = 0 ; i < strCount ; ++ i ) { if ( ! str [ i ] . empty ( ) ) { if ( wideguildname . find ( str [ i ] ) != std :: wstring :: npos || wideplayername . find ( str [ i ] ) != std :: wstring :: npos || Utf8FitTo ( aname , str [ i ] ) ) { s_show = true ; break ; } s_show = false ; } } if ( ! s_show ) continue ; // ▁ 49 ▁ is ▁ maximum ▁ player ▁ count ▁ sent ▁ to ▁ client ▁ - ▁ can ▁ be ▁ overridden ENDCOM // ▁ through ▁ config , ▁ but ▁ is ▁ unstable ENDCOM if ( ( matchCount ++ ) >= sWorld -> getIntConfig ( CONFIG_MAX_WHO ) ) continue ; data << target . GetPlayerName ( ) ; // ▁ player ▁ name ENDCOM data << target . GetGuildName ( ) ; // ▁ guild ▁ name ENDCOM data << uint32 ( lvl ) ; // ▁ player ▁ level ENDCOM data << uint32 ( class_ ) ; // ▁ player ▁ class ENDCOM data << uint32 ( race ) ; // ▁ player ▁ race ENDCOM data << uint8 ( gender ) ; // ▁ player ▁ gender ENDCOM data << uint32 ( playerZoneId ) ; // ▁ player ▁ zone ▁ id ENDCOM ++ displayCount ; } data . put ( 0 , displayCount ) ; // ▁ insert ▁ right ▁ count , ▁ count ▁ displayed ENDCOM data . put ( 4 , matchCount ) ; // ▁ insert ▁ right ▁ count , ▁ count ▁ of ▁ matches ENDCOM SendPacket ( & data ) ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Send ▁ SMSG _ WHO ▁ Message " ) ; } void WorldSession :: HandleLogoutRequestOpcode ( WorldPacket & /* recvData */ ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ LOGOUT _ REQUEST ▁ Message , ▁ security ▁ - ▁ % u " , GetSecurity ( ) ) ; if ( ObjectGuid lguid = GetPlayer ( ) -> GetLootGUID ( ) ) DoLootRelease ( lguid ) ; bool instantLogout = ( GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_RESTING ) && ! GetPlayer ( ) -> IsInCombat ( ) ) || GetPlayer ( ) -> IsInFlight ( ) || HasPermission ( rbac :: RBAC_PERM_INSTANT_LOGOUT ) ; // / ▁ TODO : ▁ Possibly ▁ add ▁ RBAC ▁ permission ▁ to ▁ log ▁ out ▁ in ▁ combat ENDCOM bool canLogoutInCombat = GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_RESTING ) ; uint32 reason = 0 ; if ( GetPlayer ( ) -> IsInCombat ( ) && ! canLogoutInCombat ) reason = 1 ; else if ( GetPlayer ( ) -> m_movementInfo . HasMovementFlag ( MOVEMENTFLAG_FALLING | MOVEMENTFLAG_FALLING_FAR ) ) reason = 3 ; // ▁ is ▁ jumping ▁ or ▁ falling ENDCOM else if ( GetPlayer ( ) -> duel || GetPlayer ( ) -> HasAura ( 9454 ) ) // ▁ is ▁ dueling ▁ or ▁ frozen ▁ by ▁ GM ▁ via ▁ freeze ▁ command ENDCOM reason = 2 ; // ▁ FIXME ▁ - ▁ Need ▁ the ▁ correct ▁ value ENDCOM WorldPacket data ( SMSG_LOGOUT_RESPONSE , 1 + 4 ) ; data << uint32 ( reason ) ; data << uint8 ( instantLogout ) ; SendPacket ( & data ) ; if ( reason ) { LogoutRequest ( 0 ) ; return ; } // instant ▁ logout ▁ in ▁ taverns / cities ▁ or ▁ on ▁ taxi ▁ or ▁ for ▁ admins , ▁ gm ' s , ▁ mod ' s ▁ if ▁ its ▁ enabled ▁ in ▁ worldserver . conf ENDCOM if ( instantLogout ) { LogoutPlayer ( true ) ; return ; } // ▁ not ▁ set ▁ flags ▁ if ▁ player ▁ can ' t ▁ free ▁ move ▁ to ▁ prevent ▁ lost ▁ state ▁ at ▁ logout ▁ cancel ENDCOM if ( GetPlayer ( ) -> CanFreeMove ( ) ) { if ( GetPlayer ( ) -> GetStandState ( ) == UNIT_STAND_STATE_STAND ) GetPlayer ( ) -> SetStandState ( UNIT_STAND_STATE_SIT ) ; WorldPacket data ( SMSG_FORCE_MOVE_ROOT , ( 8 + 4 ) ) ; // ▁ guess ▁ size ENDCOM data << GetPlayer ( ) -> GetPackGUID ( ) ; data << ( uint32 ) 2 ; SendPacket ( & data ) ; GetPlayer ( ) -> SetFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_STUNNED ) ; } LogoutRequest ( time ( NULL ) ) ; } void WorldSession :: HandlePlayerLogoutOpcode ( WorldPacket & /* recvData */ ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ PLAYER _ LOGOUT ▁ Message " ) ; } void WorldSession :: HandleLogoutCancelOpcode ( WorldPacket & /* recvData */ ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ LOGOUT _ CANCEL ▁ Message " ) ; // ▁ Player ▁ have ▁ already ▁ logged ▁ out ▁ serverside , ▁ too ▁ late ▁ to ▁ cancel ENDCOM if ( ! GetPlayer ( ) ) return ; LogoutRequest ( 0 ) ; WorldPacket data ( SMSG_LOGOUT_CANCEL_ACK , 0 ) ; SendPacket ( & data ) ; // ▁ not ▁ remove ▁ flags ▁ if ▁ can ' t ▁ free ▁ move ▁ - ▁ its ▁ not ▁ set ▁ in ▁ Logout ▁ request ▁ code . ENDCOM if ( GetPlayer ( ) -> CanFreeMove ( ) ) { // ! we ▁ can ▁ move ▁ again ENDCOM data . Initialize ( SMSG_FORCE_MOVE_UNROOT , 8 ) ; // ▁ guess ▁ size ENDCOM data << GetPlayer ( ) -> GetPackGUID ( ) ; data << uint32 ( 0 ) ; SendPacket ( & data ) ; // ! ▁ Stand ▁ Up ENDCOM GetPlayer ( ) -> SetStandState ( UNIT_STAND_STATE_STAND ) ; // ! ▁ DISABLE _ ROTATE ENDCOM GetPlayer ( ) -> RemoveFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_STUNNED ) ; } } void WorldSession :: HandleTogglePvP ( WorldPacket & recvData ) { // ▁ this ▁ opcode ▁ can ▁ be ▁ used ▁ in ▁ two ▁ ways : ▁ Either ▁ set ▁ explicit ▁ new ▁ status ▁ or ▁ toggle ▁ old ▁ status ENDCOM if ( recvData . size ( ) == 1 ) { bool newPvPStatus ; recvData >> newPvPStatus ; GetPlayer ( ) -> ApplyModFlag ( PLAYER_FLAGS , PLAYER_FLAGS_IN_PVP , newPvPStatus ) ; GetPlayer ( ) -> ApplyModFlag ( PLAYER_FLAGS , PLAYER_FLAGS_PVP_TIMER , ! newPvPStatus ) ; } else { GetPlayer ( ) -> ToggleFlag ( PLAYER_FLAGS , PLAYER_FLAGS_IN_PVP ) ; GetPlayer ( ) -> ToggleFlag ( PLAYER_FLAGS , PLAYER_FLAGS_PVP_TIMER ) ; } if ( GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_IN_PVP ) ) { if ( ! GetPlayer ( ) -> IsPvP ( ) || GetPlayer ( ) -> pvpInfo . EndTimer ) GetPlayer ( ) -> UpdatePvP ( true , true ) ; } else { if ( ! GetPlayer ( ) -> pvpInfo . IsHostile && GetPlayer ( ) -> IsPvP ( ) ) GetPlayer ( ) -> pvpInfo . EndTimer = time ( NULL ) ; // ▁ start ▁ toggle - off ENDCOM } // if ▁ ( OutdoorPvP * ▁ pvp ▁ = ▁ _ player - > GetOutdoorPvP ( ) ) ENDCOM // ▁ pvp - > HandlePlayerActivityChanged ( _ player ) ; ENDCOM } void WorldSession :: HandleZoneUpdateOpcode ( WorldPacket & recvData ) { uint32 newZone ; recvData >> newZone ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ ZONE _ UPDATE : ▁ % u " , newZone ) ; // ▁ use ▁ server ▁ side ▁ data , ▁ but ▁ only ▁ after ▁ update ▁ the ▁ player ▁ position . ▁ See ▁ Player : : UpdatePosition ( ) . ENDCOM GetPlayer ( ) -> SetNeedsZoneUpdate ( true ) ; // GetPlayer ( ) - > SendInitWorldStates ( true , ▁ newZone ) ; ENDCOM } void WorldSession :: HandleSetSelectionOpcode ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid ; _player -> SetSelection ( guid ) ; } void WorldSession :: HandleStandStateChangeOpcode ( WorldPacket & recvData ) { // ▁ TC _ LOG _ DEBUG ( " network " , ▁ " WORLD : ▁ Received ▁ CMSG _ STANDSTATECHANGE " ) ; ▁ - - ▁ too ▁ many ▁ spam ▁ in ▁ log ▁ at ▁ lags / debug ▁ stop ENDCOM uint32 animstate ; recvData >> animstate ; _player -> SetStandState ( animstate ) ; } void WorldSession :: HandleBugOpcode ( WorldPacket & recvData ) { uint32 suggestion , contentlen , typelen ; std :: string content , type ; recvData >> suggestion >> contentlen >> content ; recvData >> typelen >> type ; if ( suggestion == 0 ) TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ BUG ▁ [ Bug ▁ Report ] " ) ; else TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ BUG ▁ [ Suggestion ] " ) ; TC_LOG_DEBUG ( " network " , " % s " , type . c_str ( ) ) ; TC_LOG_DEBUG ( " network " , " % s " , content . c_str ( ) ) ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_BUG_REPORT ) ; stmt -> setString ( 0 , type ) ; stmt -> setString ( 1 , content ) ; CharacterDatabase . Execute ( stmt ) ; } void WorldSession :: HandleReclaimCorpseOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ RECLAIM _ CORPSE " ) ; ObjectGuid guid ; recvData >> guid ; if ( _player -> IsAlive ( ) ) return ; // ▁ do ▁ not ▁ allow ▁ corpse ▁ reclaim ▁ in ▁ arena ENDCOM if ( _player -> InArena ( ) ) return ; // ▁ body ▁ not ▁ released ▁ yet ENDCOM if ( ! _player -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_GHOST ) ) return ; Corpse * corpse = _player -> GetCorpse ( ) ; if ( ! corpse ) return ; // ▁ prevent ▁ resurrect ▁ before ▁ 30 - sec ▁ delay ▁ after ▁ body ▁ release ▁ not ▁ finished ENDCOM if ( time_t ( corpse -> GetGhostTime ( ) + _player -> GetCorpseReclaimDelay ( corpse -> GetType ( ) == CORPSE_RESURRECTABLE_PVP ) ) > time_t ( time ( NULL ) ) ) return ; if ( ! corpse -> IsWithinDistInMap ( _player , CORPSE_RECLAIM_RADIUS , true ) ) return ; // ▁ resurrect ENDCOM _player -> ResurrectPlayer ( _player -> InBattleground ( ) ? 1.0f : 0.5f ) ; // ▁ spawn ▁ bones ENDCOM _player -> SpawnCorpseBones ( ) ; } void WorldSession :: HandleResurrectResponseOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ RESURRECT _ RESPONSE " ) ; ObjectGuid guid ; uint8 status ; recvData >> guid ; recvData >> status ; if ( GetPlayer ( ) -> IsAlive ( ) ) return ; if ( status == 0 ) { GetPlayer ( ) -> ClearResurrectRequestData ( ) ; // ▁ reject ENDCOM return ; } if ( ! GetPlayer ( ) -> IsResurrectRequestedBy ( guid ) ) return ; GetPlayer ( ) -> ResurrectUsingRequestData ( ) ; } void WorldSession :: SendAreaTriggerMessage ( const char * Text , ... ) { va_list ap ; char szStr [ 1024 ] ; szStr [ 0 ] = ' \0' ; va_start ( ap , Text ) ; vsnprintf ( szStr , 1024 , Text , ap ) ; va_end ( ap ) ; uint32 length = strlen ( szStr ) + 1 ; WorldPacket data ( SMSG_AREA_TRIGGER_MESSAGE , 4 + length ) ; data << length ; data << szStr ; SendPacket ( & data ) ; } void WorldSession :: HandleAreaTriggerOpcode ( WorldPacket & recvData ) { uint32 triggerId ; recvData >> triggerId ; TC_LOG_DEBUG ( " network " , " CMSG _ AREATRIGGER . ▁ Trigger ▁ ID : ▁ % u " , triggerId ) ; Player * player = GetPlayer ( ) ; if ( player -> IsInFlight ( ) ) { TC_LOG_DEBUG ( " network " , " HandleAreaTriggerOpcode : ▁ Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ in ▁ flight , ▁ ignore ▁ Area ▁ Trigger ▁ ID : % u " , player -> GetName ( ) . c_str ( ) , player -> GetGUID ( ) . GetCounter ( ) , triggerId ) ; return ; } AreaTriggerEntry const * atEntry = sAreaTriggerStore . LookupEntry ( triggerId ) ; if ( ! atEntry ) { TC_LOG_DEBUG ( " network " , " HandleAreaTriggerOpcode : ▁ Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ send ▁ unknown ▁ ( by ▁ DBC ) ▁ Area ▁ Trigger ▁ ID : % u " , player -> GetName ( ) . c_str ( ) , player -> GetGUID ( ) . GetCounter ( ) , triggerId ) ; return ; } if ( ! player -> IsInAreaTriggerRadius ( atEntry ) ) { TC_LOG_DEBUG ( " network " , " HandleAreaTriggerOpcode : ▁ Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ too ▁ far , ▁ ignore ▁ Area ▁ Trigger ▁ ID : ▁ % u " , player -> GetName ( ) . c_str ( ) , player -> GetGUID ( ) . GetCounter ( ) , triggerId ) ; return ; } if ( player -> isDebugAreaTriggers ) ChatHandler ( player -> GetSession ( ) ) . PSendSysMessage ( LANG_DEBUG_AREATRIGGER_REACHED , triggerId ) ; if ( sScriptMgr -> OnAreaTrigger ( player , atEntry ) ) return ; if ( player -> IsAlive ( ) ) if ( uint32 questId = sObjectMgr -> GetQuestForAreaTrigger ( triggerId ) ) if ( player -> GetQuestStatus ( questId ) == QUEST_STATUS_INCOMPLETE ) player -> AreaExploredOrEventHappens ( questId ) ; if ( sObjectMgr -> IsTavernAreaTrigger ( triggerId ) ) { // ▁ set ▁ resting ▁ flag ▁ we ▁ are ▁ in ▁ the ▁ inn ENDCOM player -> SetRestFlag ( REST_FLAG_IN_TAVERN , atEntry -> id ) ; if ( sWorld -> IsFFAPvPRealm ( ) ) player -> RemoveByteFlag ( UNIT_FIELD_BYTES_2 , UNIT_BYTES_2_OFFSET_PVP_FLAG , UNIT_BYTE2_FLAG_FFA_PVP ) ; return ; } if ( Battleground * bg = player -> GetBattleground ( ) ) if ( bg -> GetStatus ( ) == STATUS_IN_PROGRESS ) bg -> HandleAreaTrigger ( player , triggerId ) ; if ( OutdoorPvP * pvp = player -> GetOutdoorPvP ( ) ) if ( pvp -> HandleAreaTrigger ( _player , triggerId ) ) return ; AreaTrigger const * at = sObjectMgr -> GetAreaTrigger ( triggerId ) ; if ( ! at ) return ; bool teleported = false ; if ( player -> GetMapId ( ) != at -> target_mapId ) { if ( Map :: EnterState denyReason = sMapMgr -> PlayerCannotEnter ( at -> target_mapId , player , false ) ) { bool reviveAtTrigger = false ; // ▁ should ▁ we ▁ revive ▁ the ▁ player ▁ if ▁ he ▁ is ▁ trying ▁ to ▁ enter ▁ the ▁ correct ▁ instance ? ENDCOM switch ( denyReason ) { case Map :: CANNOT_ENTER_NO_ENTRY : TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ attempted ▁ to ▁ enter ▁ map ▁ with ▁ id ▁ % d ▁ which ▁ has ▁ no ▁ entry " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; break ; case Map :: CANNOT_ENTER_UNINSTANCED_DUNGEON : TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ attempted ▁ to ▁ enter ▁ dungeon ▁ map ▁ % d ▁ but ▁ no ▁ instance ▁ template ▁ was ▁ found " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; break ; case Map :: CANNOT_ENTER_DIFFICULTY_UNAVAILABLE : TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ attempted ▁ to ▁ enter ▁ instance ▁ map ▁ % d ▁ but ▁ the ▁ requested ▁ difficulty ▁ was ▁ not ▁ found " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; if ( MapEntry const * entry = sMapStore . LookupEntry ( at -> target_mapId ) ) player -> SendTransferAborted ( entry -> MapID , TRANSFER_ABORT_DIFFICULTY , player -> GetDifficulty ( entry -> IsRaid ( ) ) ) ; break ; case Map :: CANNOT_ENTER_NOT_IN_RAID : { WorldPacket data ( SMSG_RAID_GROUP_ONLY , 4 + 4 ) ; data << uint32 ( 0 ) ; data << uint32 ( 2 ) ; // ▁ You ▁ must ▁ be ▁ in ▁ a ▁ raid ▁ group ▁ to ▁ enter ▁ this ▁ instance . ENDCOM player -> GetSession ( ) -> SendPacket ( & data ) ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ must ▁ be ▁ in ▁ a ▁ raid ▁ group ▁ to ▁ enter ▁ instance ▁ map ▁ % d " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; reviveAtTrigger = true ; break ; } case Map :: CANNOT_ENTER_CORPSE_IN_DIFFERENT_INSTANCE : { WorldPacket data ( SMSG_CORPSE_NOT_IN_INSTANCE ) ; player -> GetSession ( ) -> SendPacket ( & data ) ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ does ▁ not ▁ have ▁ a ▁ corpse ▁ in ▁ instance ▁ map ▁ % d ▁ and ▁ cannot ▁ enter " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; break ; } case Map :: CANNOT_ENTER_INSTANCE_BIND_MISMATCH : if ( MapEntry const * entry = sMapStore . LookupEntry ( at -> target_mapId ) ) { char const * mapName = entry -> name [ player -> GetSession ( ) -> GetSessionDbcLocale ( ) ] ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ cannot ▁ enter ▁ instance ▁ map ▁ ' % s ' ▁ because ▁ their ▁ permanent ▁ bind ▁ is ▁ incompatible ▁ with ▁ their ▁ group ' s " , player -> GetName ( ) . c_str ( ) , mapName ) ; // ▁ is ▁ there ▁ a ▁ special ▁ opcode ▁ for ▁ this ? ENDCOM // ▁ @ todo ▁ figure ▁ out ▁ how ▁ to ▁ get ▁ player ▁ localized ▁ difficulty ▁ string ▁ ( e . g . ▁ " 10 ▁ player " , ▁ " Heroic " ▁ etc ) ENDCOM ChatHandler ( player -> GetSession ( ) ) . PSendSysMessage ( player -> GetSession ( ) -> GetTrinityString ( LANG_INSTANCE_BIND_MISMATCH ) , mapName ) ; } reviveAtTrigger = true ; break ; case Map :: CANNOT_ENTER_TOO_MANY_INSTANCES : player -> SendTransferAborted ( at -> target_mapId , TRANSFER_ABORT_TOO_MANY_INSTANCES ) ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ cannot ▁ enter ▁ instance ▁ map ▁ % d ▁ because ▁ he ▁ has ▁ exceeded ▁ the ▁ maximum ▁ number ▁ of ▁ instances ▁ per ▁ hour . " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; reviveAtTrigger = true ; break ; case Map :: CANNOT_ENTER_MAX_PLAYERS : player -> SendTransferAborted ( at -> target_mapId , TRANSFER_ABORT_MAX_PLAYERS ) ; reviveAtTrigger = true ; break ; case Map :: CANNOT_ENTER_ZONE_IN_COMBAT : player -> SendTransferAborted ( at -> target_mapId , TRANSFER_ABORT_ZONE_IN_COMBAT ) ; reviveAtTrigger = true ; break ; default : break ; } if ( reviveAtTrigger ) // ▁ check ▁ if ▁ the ▁ player ▁ is ▁ touching ▁ the ▁ areatrigger ▁ leading ▁ to ▁ the ▁ map ▁ his ▁ corpse ▁ is ▁ on ENDCOM if ( ! player -> IsAlive ( ) && player -> HasCorpse ( ) ) if ( player -> GetCorpseLocation ( ) . GetMapId ( ) == at -> target_mapId ) { player -> ResurrectPlayer ( 0.5f ) ; player -> SpawnCorpseBones ( ) ; } return ; } if ( Group * group = player -> GetGroup ( ) ) if ( group -> isLFGGroup ( ) && player -> GetMap ( ) -> IsDungeon ( ) ) teleported = player -> TeleportToBGEntryPoint ( ) ; } if ( ! teleported ) player -> TeleportTo ( at -> target_mapId , at -> target_X , at -> target_Y , at -> target_Z , at -> target_Orientation , TELE_TO_NOT_LEAVE_TRANSPORT ) ; } void WorldSession :: HandleUpdateAccountData ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ UPDATE _ ACCOUNT _ DATA " ) ; uint32 type , timestamp , decompressedSize ; recvData >> type >> timestamp >> decompressedSize ; TC_LOG_DEBUG ( " network " , " UAD : ▁ type ▁ % u , ▁ time ▁ % u , ▁ decompressedSize ▁ % u " , type , timestamp , decompressedSize ) ; if ( type > NUM_ACCOUNT_DATA_TYPES ) return ; if ( decompressedSize == 0 ) // ▁ erase ENDCOM { SetAccountData ( AccountDataType ( type ) , 0 , " " ) ; WorldPacket data ( SMSG_UPDATE_ACCOUNT_DATA_COMPLETE , 4 + 4 ) ; data << uint32 ( type ) ; data << uint32 ( 0 ) ; SendPacket ( & data ) ; return ; } if ( decompressedSize > 0xFFFF ) { recvData . rfinish ( ) ; // ▁ unnneded ▁ warning ▁ spam ▁ in ▁ this ▁ case ENDCOM TC_LOG_ERROR ( " network " , " UAD : ▁ Account ▁ data ▁ packet ▁ too ▁ big , ▁ size ▁ % u " , decompressedSize ) ; return ; } ByteBuffer dest ; dest . resize ( decompressedSize ) ; uLongf realSize = decompressedSize ; if ( uncompress ( dest . contents ( ) , & realSize , recvData . contents ( ) + recvData . rpos ( ) , recvData . size ( ) - recvData . rpos ( ) ) != Z_OK ) { recvData . rfinish ( ) ; // ▁ unnneded ▁ warning ▁ spam ▁ in ▁ this ▁ case ENDCOM TC_LOG_ERROR ( " network " , " UAD : ▁ Failed ▁ to ▁ decompress ▁ account ▁ data " ) ; return ; } recvData . rfinish ( ) ; // ▁ uncompress ▁ read ▁ ( recvData . size ( ) ▁ - ▁ recvData . rpos ( ) ) ENDCOM std :: string adata ; dest >> adata ; SetAccountData ( AccountDataType ( type ) , timestamp , adata ) ; WorldPacket data ( SMSG_UPDATE_ACCOUNT_DATA_COMPLETE , 4 + 4 ) ; data << uint32 ( type ) ; data << uint32 ( 0 ) ; SendPacket ( & data ) ; } void WorldSession :: HandleRequestAccountData ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ REQUEST _ ACCOUNT _ DATA " ) ; uint32 type ; recvData >> type ; TC_LOG_DEBUG ( " network " , " RAD : ▁ type ▁ % u " , type ) ; if ( type >= NUM_ACCOUNT_DATA_TYPES ) return ; AccountData * adata = GetAccountData ( AccountDataType ( type ) ) ; uint32 size = adata -> Data . size ( ) ; uLongf destSize = compressBound ( size ) ; ByteBuffer dest ; dest . resize ( destSize ) ; if ( size && compress ( dest . contents ( ) , & destSize , ( uint8 const * ) adata -> Data . c_str ( ) , size ) != Z_OK ) { TC_LOG_DEBUG ( " network " , " RAD : ▁ Failed ▁ to ▁ compress ▁ account ▁ data " ) ; return ; } dest . resize ( destSize ) ; WorldPacket data ( SMSG_UPDATE_ACCOUNT_DATA , 8 + 4 + 4 + 4 + destSize ) ; data << uint64 ( _player ? _player -> GetGUID ( ) : ObjectGuid :: Empty ) ; data << uint32 ( type ) ; // ▁ type ▁ ( 0-7 ) ENDCOM data << uint32 ( adata -> Time ) ; // ▁ unix ▁ time ENDCOM data << uint32 ( size ) ; // ▁ decompressed ▁ length ENDCOM data . append ( dest ) ; // ▁ compressed ▁ data ENDCOM SendPacket ( & data ) ; } void WorldSession :: HandleSetActionButtonOpcode ( WorldPacket & recvData ) { uint8 button ; uint32 packetData ; recvData >> button >> packetData ; TC_LOG_DEBUG ( " network " , " CMSG _ SET _ ACTION _ BUTTON ▁ Button : ▁ % u ▁ Data : ▁ % u " , button , packetData ) ; if ( ! packetData ) GetPlayer ( ) -> removeActionButton ( button ) ; else GetPlayer ( ) -> addActionButton ( button , ACTION_BUTTON_ACTION ( packetData ) , ACTION_BUTTON_TYPE ( packetData ) ) ; } void WorldSession :: HandleCompleteCinematic ( WorldPacket & /* recvData */ ) { // ▁ If ▁ player ▁ has ▁ sight ▁ bound ▁ to ▁ visual ▁ waypoint ▁ NPC ▁ we ▁ should ▁ remove ▁ it ENDCOM GetPlayer ( ) -> GetCinematicMgr ( ) -> EndCinematic ( ) ; } void WorldSession :: HandleNextCinematicCamera ( WorldPacket & /* recvData */ ) { // ▁ Sent ▁ by ▁ client ▁ when ▁ cinematic ▁ actually ▁ begun . ▁ So ▁ we ▁ begin ▁ the ▁ server ▁ side ▁ process ENDCOM GetPlayer ( ) -> GetCinematicMgr ( ) -> BeginCinematic ( ) ; } void WorldSession :: HandleMoveTimeSkippedOpcode ( WorldPacket & recvData ) { /* ▁ WorldSession : : Update ( getMSTime ( ) ) ; */ TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ MOVE _ TIME _ SKIPPED " ) ; ObjectGuid guid ; recvData >> guid . ReadAsPacked ( ) ; recvData . read_skip < uint32 > ( ) ; /* STRNEWLINE ▁ uint64 ▁ guid ; STRNEWLINE ▁ uint32 ▁ time _ skipped ; STRNEWLINE ▁ recvData ▁ > > ▁ guid ; STRNEWLINE ▁ recvData ▁ > > ▁ time _ skipped ; STRNEWLINE ▁ TC _ LOG _ DEBUG ( " network " , ▁ " WORLD : ▁ CMSG _ MOVE _ TIME _ SKIPPED " ) ; STRNEWLINE STRNEWLINE ▁ // // ▁ @ todo STRNEWLINE ▁ must ▁ be ▁ need ▁ use ▁ in ▁ Trinity STRNEWLINE ▁ We ▁ substract ▁ server ▁ Lags ▁ to ▁ move ▁ time ▁ ( AntiLags ) STRNEWLINE ▁ for ▁ exmaple STRNEWLINE ▁ GetPlayer ( ) - > ModifyLastMoveTime ( - int32 ( time _ skipped ) ) ; STRNEWLINE ▁ */ } void WorldSession :: HandleFeatherFallAck ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ MOVE _ FEATHER _ FALL _ ACK " ) ; // ▁ no ▁ used ENDCOM recvData . rfinish ( ) ; // ▁ prevent ▁ warnings ▁ spam ENDCOM } void WorldSession :: HandleMoveUnRootAck ( WorldPacket & recvData ) { // ▁ no ▁ used ENDCOM recvData . rfinish ( ) ; // ▁ prevent ▁ warnings ▁ spam ENDCOM /* STRNEWLINE ▁ uint64 ▁ guid ; STRNEWLINE ▁ recvData ▁ > > ▁ guid ; STRNEWLINE STRNEWLINE ▁ // ▁ now ▁ can ▁ skip ▁ not ▁ our ▁ packet STRNEWLINE ▁ if ▁ ( _ player - > GetGUID ( ) ▁ ! = ▁ guid ) STRNEWLINE ▁ { STRNEWLINE ▁ recvData . rfinish ( ) ; ▁ // ▁ prevent ▁ warnings ▁ spam STRNEWLINE ▁ return ; STRNEWLINE ▁ } STRNEWLINE STRNEWLINE ▁ TC _ LOG _ DEBUG ( " network " , ▁ " WORLD : ▁ CMSG _ FORCE _ MOVE _ UNROOT _ ACK " ) ; STRNEWLINE STRNEWLINE ▁ recvData . read _ skip < uint32 > ( ) ; ▁ // ▁ unk STRNEWLINE STRNEWLINE ▁ MovementInfo ▁ movementInfo ; STRNEWLINE ▁ movementInfo . guid ▁ = ▁ guid ; STRNEWLINE ▁ ReadMovementInfo ( recvData , ▁ & movementInfo ) ; STRNEWLINE ▁ recvData . read _ skip < float > ( ) ; ▁ // ▁ unk2 STRNEWLINE */ } void WorldSession :: HandleMoveRootAck ( WorldPacket & recvData ) { // ▁ no ▁ used ENDCOM recvData . rfinish ( ) ; // ▁ prevent ▁ warnings ▁ spam ENDCOM /* STRNEWLINE ▁ uint64 ▁ guid ; STRNEWLINE ▁ recvData ▁ > > ▁ guid ; STRNEWLINE STRNEWLINE ▁ // ▁ now ▁ can ▁ skip ▁ not ▁ our ▁ packet STRNEWLINE ▁ if ▁ ( _ player - > GetGUID ( ) ▁ ! = ▁ guid ) STRNEWLINE ▁ { STRNEWLINE ▁ recvData . rfinish ( ) ; ▁ // ▁ prevent ▁ warnings ▁ spam STRNEWLINE ▁ return ; STRNEWLINE ▁ } STRNEWLINE STRNEWLINE ▁ TC _ LOG _ DEBUG ( " network " , ▁ " WORLD : ▁ CMSG _ FORCE _ MOVE _ ROOT _ ACK " ) ; STRNEWLINE STRNEWLINE ▁ recvData . read _ skip < uint32 > ( ) ; ▁ // ▁ unk STRNEWLINE STRNEWLINE ▁ MovementInfo ▁ movementInfo ; STRNEWLINE ▁ ReadMovementInfo ( recvData , ▁ & movementInfo ) ; STRNEWLINE */ } void WorldSession :: HandleSetActionBarToggles ( WorldPacket & recvData ) { uint8 actionBar ; recvData >> actionBar ; if ( ! GetPlayer ( ) ) // ▁ ignore ▁ until ▁ not ▁ logged ▁ ( check ▁ needed ▁ because ▁ STATUS _ AUTHED ) ENDCOM { if ( actionBar != 0 ) TC_LOG_ERROR ( " network " , " WorldSession : : HandleSetActionBarToggles ▁ in ▁ not ▁ logged ▁ state ▁ with ▁ value : ▁ % u , ▁ ignored " , uint32 ( actionBar ) ) ; return ; } GetPlayer ( ) -> SetByteValue ( PLAYER_FIELD_BYTES , PLAYER_FIELD_BYTES_OFFSET_ACTION_BAR_TOGGLES , actionBar ) ; } void WorldSession :: HandlePlayedTime ( WorldPacket & recvData ) { uint8 unk1 ; recvData >> unk1 ; // ▁ 0 ▁ or ▁ 1 ▁ expected ENDCOM WorldPacket data ( SMSG_PLAYED_TIME , 4 + 4 + 1 ) ; data << uint32 ( _player -> GetTotalPlayedTime ( ) ) ; data << uint32 ( _player -> GetLevelPlayedTime ( ) ) ; data << uint8 ( unk1 ) ; // ▁ 0 ▁ - ▁ will ▁ not ▁ show ▁ in ▁ chat ▁ frame ENDCOM SendPacket ( & data ) ; } void WorldSession :: HandleInspectOpcode ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ INSPECT " ) ; Player * player = ObjectAccessor :: GetPlayer ( * _player , guid ) ; if ( ! player ) { TC_LOG_DEBUG ( " network " , " CMSG _ INSPECT : ▁ No ▁ player ▁ found ▁ from ▁ % s " , guid . ToString ( ) . c_str ( ) ) ; return ; } if ( ! GetPlayer ( ) -> IsWithinDistInMap ( player , INSPECT_DISTANCE , false ) ) return ; if ( GetPlayer ( ) -> IsValidAttackTarget ( player ) ) return ; uint32 talent_points = 0x47 ; uint32 guid_size = player -> GetPackGUID ( ) . size ( ) ; WorldPacket data ( SMSG_INSPECT_TALENT , guid_size + 4 + talent_points ) ; data << player -> GetPackGUID ( ) ; if ( GetPlayer ( ) -> CanBeGameMaster ( ) || sWorld -> getIntConfig ( CONFIG_TALENTS_INSPECTING ) + ( GetPlayer ( ) -> GetTeamId ( ) == player -> GetTeamId ( ) ) > 1 ) player -> BuildPlayerTalentsInfoData ( & data ) ; else { data << uint32 ( 0 ) ; // ▁ unspentTalentPoints ENDCOM data << uint8 ( 0 ) ; // ▁ talentGroupCount ENDCOM data << uint8 ( 0 ) ; // ▁ talentGroupIndex ENDCOM } player -> BuildEnchantmentsInfoData ( & data ) ; SendPacket ( & data ) ; } void WorldSession :: HandleInspectHonorStatsOpcode ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid ; Player * player = ObjectAccessor :: GetPlayer ( * _player , guid ) ; if ( ! player ) { TC_LOG_DEBUG ( " network " , " MSG _ INSPECT _ HONOR _ STATS : ▁ No ▁ player ▁ found ▁ from ▁ % s " , guid . ToString ( ) . c_str ( ) ) ; return ; } if ( ! GetPlayer ( ) -> IsWithinDistInMap ( player , INSPECT_DISTANCE , false ) ) return ; if ( GetPlayer ( ) -> IsValidAttackTarget ( player ) ) return ; WorldPacket data ( MSG_INSPECT_HONOR_STATS , 8 + 1 + 4 * 4 ) ; data << uint64 ( player -> GetGUID ( ) ) ; data << uint8 ( player -> GetHonorPoints ( ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_KILLS ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_TODAY_CONTRIBUTION ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_YESTERDAY_CONTRIBUTION ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_LIFETIME_HONORABLE_KILLS ) ) ; SendPacket ( & data ) ; } void WorldSession :: HandleWorldTeleportOpcode ( WorldPacket & recvData ) { uint32 time ; uint32 mapid ; float PositionX ; float PositionY ; float PositionZ ; float Orientation ; recvData >> time ; // ▁ time ▁ in ▁ m . sec . ENDCOM recvData >> mapid ; recvData >> PositionX ; recvData >> PositionY ; recvData >> PositionZ ; recvData >> Orientation ; // ▁ o ▁ ( 3.141593 ▁ = ▁ 180 ▁ degrees ) ENDCOM TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ WORLD _ TELEPORT " ) ; if ( GetPlayer ( ) -> IsInFlight ( ) ) { TC_LOG_DEBUG ( " network " , " Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ in ▁ flight , ▁ ignore ▁ worldport ▁ command . " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , GetPlayer ( ) -> GetGUID ( ) . GetCounter ( ) ) ; return ; } TC_LOG_DEBUG ( " network " , " CMSG _ WORLD _ TELEPORT : ▁ Player ▁ = ▁ % s , ▁ Time ▁ = ▁ % u , ▁ map ▁ = ▁ % u , ▁ x ▁ = ▁ % f , ▁ y ▁ = ▁ % f , ▁ z ▁ = ▁ % f , ▁ o ▁ = ▁ % f " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , time , mapid , PositionX , PositionY , PositionZ , Orientation ) ; if ( HasPermission ( rbac :: RBAC_PERM_OPCODE_WORLD_TELEPORT ) ) GetPlayer ( ) -> TeleportTo ( mapid , PositionX , PositionY , PositionZ , Orientation ) ; else SendNotification ( LANG_YOU_NOT_HAVE_PERMISSION ) ; } void WorldSession :: HandleWhoisOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " Received ▁ opcode ▁ CMSG _ WHOIS " ) ; std :: string charname ; recvData >> charname ; if ( ! HasPermission ( rbac :: RBAC_PERM_OPCODE_WHOIS ) ) { SendNotification ( LANG_YOU_NOT_HAVE_PERMISSION ) ; return ; } if ( charname . empty ( ) || ! normalizePlayerName ( charname ) ) { SendNotification ( LANG_NEED_CHARACTER_NAME ) ; return ; } Player * player = ObjectAccessor :: FindConnectedPlayerByName ( charname ) ; if ( ! player ) { SendNotification ( LANG_PLAYER_NOT_EXIST_OR_OFFLINE , charname . c_str ( ) ) ; return ; } uint32 accid = player -> GetSession ( ) -> GetAccountId ( ) ; PreparedStatement * stmt = LoginDatabase . GetPreparedStatement ( LOGIN_SEL_ACCOUNT_WHOIS ) ; stmt -> setUInt32 ( 0 , accid ) ; PreparedQueryResult result = LoginDatabase . Query ( stmt ) ; if ( ! result ) { SendNotification ( LANG_ACCOUNT_FOR_PLAYER_NOT_FOUND , charname . c_str ( ) ) ; return ; } Field * fields = result -> Fetch ( ) ; std :: string acc = fields [ 0 ] . GetString ( ) ; if ( acc . empty ( ) ) acc = " Unknown " ; std :: string email = fields [ 1 ] . GetString ( ) ; if ( email . empty ( ) ) email = " Unknown " ; std :: string lastip = fields [ 2 ] . GetString ( ) ; if ( lastip . empty ( ) ) lastip = " Unknown " ; std :: string msg = charname + " ' s ▁ " + " account ▁ is ▁ " + acc + " , ▁ e - mail : ▁ " + email + " , ▁ last ▁ ip : ▁ " + lastip ; WorldPacket data ( SMSG_WHOIS , msg . size ( ) + 1 ) ; data << msg ; SendPacket ( & data ) ; TC_LOG_DEBUG ( " network " , " Received ▁ whois ▁ command ▁ from ▁ player ▁ % s ▁ for ▁ character ▁ % s " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , charname . c_str ( ) ) ; } void WorldSession :: HandleComplainOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ COMPLAIN " ) ; uint8 spam_type ; // ▁ 0 ▁ - ▁ mail , ▁ 1 ▁ - ▁ chat ENDCOM ObjectGuid spammer_guid ; uint32 unk1 = 0 ; uint32 unk2 = 0 ; uint32 unk3 = 0 ; uint32 unk4 = 0 ; std :: string description = " " ; recvData >> spam_type ; // ▁ unk ▁ 0x01 ▁ const , ▁ may ▁ be ▁ spam ▁ type ▁ ( mail / chat ) ENDCOM recvData >> spammer_guid ; // ▁ player ▁ guid ENDCOM switch ( spam_type ) { case 0 : recvData >> unk1 ; // ▁ const ▁ 0 ENDCOM recvData >> unk2 ; // ▁ probably ▁ mail ▁ id ENDCOM recvData >> unk3 ; // ▁ const ▁ 0 ENDCOM break ; case 1 : recvData >> unk1 ; // ▁ probably ▁ language ENDCOM recvData >> unk2 ; // ▁ message ▁ type ? ENDCOM recvData >> unk3 ; // ▁ probably ▁ channel ▁ id ENDCOM recvData >> unk4 ; // ▁ time ENDCOM recvData >> description ; // ▁ spam ▁ description ▁ string ▁ ( messagetype , ▁ channel ▁ name , ▁ player ▁ name , ▁ message ) ENDCOM break ; } // ▁ NOTE : ▁ all ▁ chat ▁ messages ▁ from ▁ this ▁ spammer ▁ automatically ▁ ignored ▁ by ▁ spam ▁ reporter ▁ until ▁ logout ▁ in ▁ case ▁ chat ▁ spam . ENDCOM // ▁ if ▁ it ' s ▁ mail ▁ spam ▁ - ▁ ALL ▁ mails ▁ from ▁ this ▁ spammer ▁ automatically ▁ removed ▁ by ▁ client ENDCOM // ▁ Complaint ▁ Received ▁ message ENDCOM WorldPacket data ( SMSG_COMPLAIN_RESULT , 1 ) ; data << uint8 ( 0 ) ; SendPacket ( & data ) ; TC_LOG_DEBUG ( " network " , " REPORT ▁ SPAM : ▁ type ▁ % u , ▁ % s , ▁ unk1 ▁ % u , ▁ unk2 ▁ % u , ▁ unk3 ▁ % u , ▁ unk4 ▁ % u , ▁ message ▁ % s " , spam_type , spammer_guid . ToString ( ) . c_str ( ) , unk1 , unk2 , unk3 , unk4 , description . c_str ( ) ) ; } void WorldSession :: HandleRealmSplitOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " CMSG _ REALM _ SPLIT " ) ; uint32 unk ; std :: string split_date = "01/01/01" ; recvData >> unk ; WorldPacket data ( SMSG_REALM_SPLIT , 4 + 4 + split_date . size ( ) + 1 ) ; data << unk ; data << uint32 ( 0x00000000 ) ; // ▁ realm ▁ split ▁ state ENDCOM // ▁ split ▁ states : ENDCOM // ▁ 0x0 ▁ realm ▁ normal ENDCOM // ▁ 0x1 ▁ realm ▁ split ENDCOM // ▁ 0x2 ▁ realm ▁ split ▁ pending ENDCOM data << split_date ; SendPacket ( & data ) ; // TC _ LOG _ DEBUG ( " response ▁ sent ▁ % u " , ▁ unk ) ; ENDCOM } void WorldSession :: HandleFarSightOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ FAR _ SIGHT " ) ; bool apply ; recvData >> apply ; if ( apply ) { TC_LOG_DEBUG ( " network " , " Added ▁ FarSight ▁ % s ▁ to ▁ player ▁ % u " , _player -> GetGuidValue ( PLAYER_FARSIGHT ) . ToString ( ) . c_str ( ) , _player -> GetGUID ( ) . GetCounter ( ) ) ; if ( WorldObject * target = _player -> GetViewpoint ( ) ) _player -> SetSeer ( target ) ; else TC_LOG_DEBUG ( " network " , " Player ▁ % s ▁ ( % s ) ▁ requests ▁ non - existing ▁ seer ▁ % s " , _player -> GetName ( ) . c_str ( ) , _player -> GetGUID ( ) . ToString ( ) . c_str ( ) , _player -> GetGuidValue ( PLAYER_FARSIGHT ) . ToString ( ) . c_str ( ) ) ; } else { TC_LOG_DEBUG ( " network " , " Player ▁ % u ▁ set ▁ vision ▁ to ▁ self " , _player -> GetGUID ( ) . GetCounter ( ) ) ; _player -> SetSeer ( _player ) ; } GetPlayer ( ) -> UpdateVisibilityForPlayer ( ) ; } void WorldSession :: HandleSetTitleOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " CMSG _ SET _ TITLE " ) ; int32 title ; recvData >> title ; // ▁ - 1 ▁ at ▁ none ENDCOM if ( title > 0 && title < MAX_TITLE_INDEX ) { if ( ! GetPlayer ( ) -> HasTitle ( title ) ) return ; } else title = 0 ; GetPlayer ( ) -> SetUInt32Value ( PLAYER_CHOSEN_TITLE , title ) ; } void WorldSession :: HandleTimeSyncResp ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " CMSG _ TIME _ SYNC _ RESP " ) ; uint32 counter , clientTicks ; recvData >> counter >> clientTicks ; if ( counter != _player -> m_timeSyncCounter - 1 ) TC_LOG_DEBUG ( " network " , " Wrong ▁ time ▁ sync ▁ counter ▁ from ▁ player ▁ % s ▁ ( cheater ? ) " , _player -> GetName ( ) . c_str ( ) ) ; TC_LOG_DEBUG ( " network " , " Time ▁ sync ▁ received : ▁ counter ▁ % u , ▁ client ▁ ticks ▁ % u , ▁ time ▁ since ▁ last ▁ sync ▁ % u " , counter , clientTicks , clientTicks - _player -> m_timeSyncClient ) ; uint32 ourTicks = clientTicks + ( GameTime :: GetGameTimeMS ( ) - _player -> m_timeSyncServer ) ; // ▁ diff ▁ should ▁ be ▁ small ENDCOM TC_LOG_DEBUG ( " network " , " Our ▁ ticks : ▁ % u , ▁ diff ▁ % u , ▁ latency ▁ % u " , ourTicks , ourTicks - clientTicks , GetLatency ( ) ) ; _player -> m_timeSyncClient = clientTicks ; } void WorldSession :: HandleResetInstancesOpcode ( WorldPacket & /* recvData */ ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ RESET _ INSTANCES " ) ; if ( Group * group = _player -> GetGroup ( ) ) { if ( group -> IsLeader ( _player -> GetGUID ( ) ) ) group -> ResetInstances ( INSTANCE_RESET_ALL , false , _player ) ; } else _player -> ResetInstances ( INSTANCE_RESET_ALL , false ) ; } void WorldSession :: HandleSetDungeonDifficultyOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " MSG _ SET _ DUNGEON _ DIFFICULTY " ) ; uint32 mode ; recvData >> mode ; if ( mode >= MAX_DUNGEON_DIFFICULTY ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetDungeonDifficultyOpcode : ▁ player ▁ % d ▁ sent ▁ an ▁ invalid ▁ instance ▁ mode ▁ % d ! " , _player -> GetGUID ( ) . GetCounter ( ) , mode ) ; return ; } if ( Difficulty ( mode ) == _player -> GetDungeonDifficulty ( ) ) return ; // ▁ cannot ▁ reset ▁ while ▁ in ▁ an ▁ instance ENDCOM Map * map = _player -> FindMap ( ) ; if ( map && map -> IsDungeon ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetDungeonDifficultyOpcode : ▁ player ▁ ( Name : ▁ % s , ▁ GUID : ▁ % u ) ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ player ▁ is ▁ inside ! " , _player -> GetName ( ) . c_str ( ) , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } Group * group = _player -> GetGroup ( ) ; if ( group ) { if ( group -> IsLeader ( _player -> GetGUID ( ) ) ) { for ( GroupReference * itr = group -> GetFirstMember ( ) ; itr != NULL ; itr = itr -> next ( ) ) { Player * groupGuy = itr -> GetSource ( ) ; if ( ! groupGuy ) continue ; if ( ! groupGuy -> IsInMap ( groupGuy ) ) return ; if ( groupGuy -> GetMap ( ) -> IsNonRaidDungeon ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetDungeonDifficultyOpcode : ▁ player ▁ % d ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ group ▁ member ▁ ( Name : ▁ % s , ▁ GUID : ▁ % u ) ▁ is ▁ inside ! " , _player -> GetGUID ( ) . GetCounter ( ) , groupGuy -> GetName ( ) . c_str ( ) , groupGuy -> GetGUID ( ) . GetCounter ( ) ) ; return ; } } // ▁ the ▁ difficulty ▁ is ▁ set ▁ even ▁ if ▁ the ▁ instances ▁ can ' t ▁ be ▁ reset ENDCOM // _ player - > SendDungeonDifficulty ( true ) ; ENDCOM group -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , false , _player ) ; group -> SetDungeonDifficulty ( Difficulty ( mode ) ) ; } } else { _player -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , false ) ; _player -> SetDungeonDifficulty ( Difficulty ( mode ) ) ; } } void WorldSession :: HandleSetRaidDifficultyOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " MSG _ SET _ RAID _ DIFFICULTY " ) ; uint32 mode ; recvData >> mode ; if ( mode >= MAX_RAID_DIFFICULTY ) { TC_LOG_ERROR ( " network " , " WorldSession : : HandleSetRaidDifficultyOpcode : ▁ player ▁ % d ▁ sent ▁ an ▁ invalid ▁ instance ▁ mode ▁ % d ! " , _player -> GetGUID ( ) . GetCounter ( ) , mode ) ; return ; } // ▁ cannot ▁ reset ▁ while ▁ in ▁ an ▁ instance ENDCOM Map * map = _player -> FindMap ( ) ; if ( map && map -> IsDungeon ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetRaidDifficultyOpcode : ▁ player ▁ % d ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ inside ! " , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } if ( Difficulty ( mode ) == _player -> GetRaidDifficulty ( ) ) return ; Group * group = _player -> GetGroup ( ) ; if ( group ) { if ( group -> IsLeader ( _player -> GetGUID ( ) ) ) { for ( GroupReference * itr = group -> GetFirstMember ( ) ; itr != NULL ; itr = itr -> next ( ) ) { Player * groupGuy = itr -> GetSource ( ) ; if ( ! groupGuy ) continue ; if ( ! groupGuy -> IsInMap ( groupGuy ) ) return ; if ( groupGuy -> GetMap ( ) -> IsRaid ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetRaidDifficultyOpcode : ▁ player ▁ % d ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ inside ! " , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } } // ▁ the ▁ difficulty ▁ is ▁ set ▁ even ▁ if ▁ the ▁ instances ▁ can ' t ▁ be ▁ reset ENDCOM // _ player - > SendDungeonDifficulty ( true ) ; ENDCOM group -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , true , _player ) ; group -> SetRaidDifficulty ( Difficulty ( mode ) ) ; } } else { _player -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , true ) ; _player -> SetRaidDifficulty ( Difficulty ( mode ) ) ; } } void WorldSession :: HandleCancelMountAuraOpcode ( WorldPacket & /* recvData */ ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ CANCEL _ MOUNT _ AURA " ) ; // If ▁ player ▁ is ▁ not ▁ mounted , ▁ so ▁ go ▁ out ▁ : ) ENDCOM if ( ! _player -> IsMounted ( ) ) // ▁ not ▁ blizz ▁ like ; ▁ no ▁ any ▁ messages ▁ on ▁ blizz ENDCOM { ChatHandler ( this ) . SendSysMessage ( LANG_CHAR_NON_MOUNTED ) ; return ; } if ( _player -> IsInFlight ( ) ) // ▁ not ▁ blizz ▁ like ; ▁ no ▁ any ▁ messages ▁ on ▁ blizz ENDCOM { ChatHandler ( this ) . SendSysMessage ( LANG_YOU_IN_FLIGHT ) ; return ; } _player -> RemoveAurasByType ( SPELL_AURA_MOUNTED ) ; // ▁ Calls ▁ Dismount ( ) ENDCOM } void WorldSession :: HandleMoveSetCanFlyAckOpcode ( WorldPacket & recvData ) { // ▁ fly ▁ mode ▁ on / off ENDCOM TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ MOVE _ SET _ CAN _ FLY _ ACK " ) ; ObjectGuid guid ; // ▁ guid ▁ - ▁ unused ENDCOM recvData >> guid . ReadAsPacked ( ) ; recvData . read_skip < uint32 > ( ) ; // ▁ unk ENDCOM MovementInfo movementInfo ; movementInfo . guid = guid ; ReadMovementInfo ( recvData , & movementInfo ) ; recvData . read_skip < float > ( ) ; // ▁ unk2 ENDCOM _player -> m_unitMovedByMe -> m_movementInfo . flags = movementInfo . GetMovementFlags ( ) ; } void WorldSession :: HandleRequestPetInfoOpcode ( WorldPacket & /* recvData ▁ */ ) { /* STRNEWLINE ▁ TC _ LOG _ DEBUG ( " network " , ▁ " WORLD : ▁ CMSG _ REQUEST _ PET _ INFO " ) ; STRNEWLINE ▁ recvData . hexlike ( ) ; STRNEWLINE ▁ */ } void WorldSession :: HandleSetTaxiBenchmarkOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ SET _ TAXI _ BENCHMARK _ MODE " ) ; uint8 mode ; recvData >> mode ; mode ? _player -> SetFlag ( PLAYER_FLAGS , PLAYER_FLAGS_TAXI_BENCHMARK ) : _player -> RemoveFlag ( PLAYER_FLAGS , PLAYER_FLAGS_TAXI_BENCHMARK ) ; TC_LOG_DEBUG ( " network " , " Client ▁ used ▁ \ " / timetest ▁ % d\ " ▁ command " , mode ) ; } void WorldSession :: HandleQueryInspectAchievements ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid . ReadAsPacked ( ) ; TC_LOG_DEBUG ( " network " , " CMSG _ QUERY _ INSPECT _ ACHIEVEMENTS ▁ [ % s ] ▁ Inspected ▁ Player ▁ [ % s ] " , _player -> GetGUID ( ) . ToString ( ) . c_str ( ) , guid . ToString ( ) . c_str ( ) ) ; Player * player = ObjectAccessor :: GetPlayer ( * _player , guid ) ; if ( ! player ) return ; if ( ! GetPlayer ( ) -> IsWithinDistInMap ( player , INSPECT_DISTANCE , false ) ) return ; if ( GetPlayer ( ) -> IsValidAttackTarget ( player ) ) return ; player -> SendRespondInspectAchievements ( _player ) ; } void WorldSession :: HandleWorldStateUITimerUpdate ( WorldPacket & /* recvData */ ) { // ▁ empty ▁ opcode ENDCOM TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ WORLD _ STATE _ UI _ TIMER _ UPDATE " ) ; WorldPacket data ( SMSG_WORLD_STATE_UI_TIMER_UPDATE , 4 ) ; data << uint32 ( time ( NULL ) ) ; SendPacket ( & data ) ; } void WorldSession :: HandleReadyForAccountDataTimes ( WorldPacket & /* recvData */ ) { // ▁ empty ▁ opcode ENDCOM TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ READY _ FOR _ ACCOUNT _ DATA _ TIMES " ) ; SendAccountDataTimes ( GLOBAL_CACHE_MASK ) ; } void WorldSession :: SendSetPhaseShift ( uint32 PhaseShift ) { WorldPacket data ( SMSG_SET_PHASE_SHIFT , 4 ) ; data << uint32 ( PhaseShift ) ; SendPacket ( & data ) ; } // ▁ Battlefield ▁ and ▁ Battleground ENDCOM void WorldSession :: HandleAreaSpiritHealerQueryOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ AREA _ SPIRIT _ HEALER _ QUERY " ) ; Battleground * bg = _player -> GetBattleground ( ) ; ObjectGuid guid ; recvData >> guid ; Creature * unit = GetPlayer ( ) -> GetMap ( ) -> GetCreature ( guid ) ; if ( ! unit ) return ; if ( ! unit -> IsSpiritService ( ) ) // ▁ it ' s ▁ not ▁ spirit ▁ service ENDCOM return ; if ( bg ) sBattlegroundMgr -> SendAreaSpiritHealerQueryOpcode ( _player , bg , guid ) ; if ( Battlefield * bf = sBattlefieldMgr -> GetBattlefieldToZoneId ( _player -> GetZoneId ( ) ) ) bf -> SendAreaSpiritHealerQueryOpcode ( _player , guid ) ; } void WorldSession :: HandleAreaSpiritHealerQueueOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ AREA _ SPIRIT _ HEALER _ QUEUE " ) ; Battleground * bg = _player -> GetBattleground ( ) ; ObjectGuid guid ; recvData >> guid ; Creature * unit = GetPlayer ( ) -> GetMap ( ) -> GetCreature ( guid ) ; if ( ! unit ) return ; if ( ! unit -> IsSpiritService ( ) ) // ▁ it ' s ▁ not ▁ spirit ▁ service ENDCOM return ; if ( bg ) bg -> AddPlayerToResurrectQueue ( guid , _player -> GetGUID ( ) ) ; if ( Battlefield * bf = sBattlefieldMgr -> GetBattlefieldToZoneId ( _player -> GetZoneId ( ) ) ) bf -> AddPlayerToResurrectQueue ( guid , _player -> GetGUID ( ) ) ; } void WorldSession :: HandleHearthAndResurrect ( WorldPacket & /* recvData */ ) { if ( _player -> IsInFlight ( ) ) return ; if ( Battlefield * bf = sBattlefieldMgr -> GetBattlefieldToZoneId ( _player -> GetZoneId ( ) ) ) { bf -> PlayerAskToLeave ( _player ) ; return ; } AreaTableEntry const * atEntry = sAreaTableStore . LookupEntry ( _player -> GetAreaId ( ) ) ; if ( ! atEntry || ! ( atEntry -> flags & AREA_FLAG_WINTERGRASP_2 ) ) return ; _player -> BuildPlayerRepop ( ) ; _player -> ResurrectPlayer ( 1.0f ) ; _player -> TeleportTo ( _player -> m_homebindMapId , _player -> m_homebindX , _player -> m_homebindY , _player -> m_homebindZ , _player -> GetOrientation ( ) ) ; } void WorldSession :: HandleInstanceLockResponse ( WorldPacket & recvPacket ) { uint8 accept ; recvPacket >> accept ; if ( ! _player -> HasPendingBind ( ) ) { TC_LOG_INFO ( " network " , " InstanceLockResponse : ▁ Player ▁ % s ▁ ( guid ▁ % u ) ▁ tried ▁ to ▁ bind ▁ himself / teleport ▁ to ▁ graveyard ▁ without ▁ a ▁ pending ▁ bind ! " , _player -> GetName ( ) . c_str ( ) , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } if ( accept ) _player -> BindToInstance ( ) ; else _player -> RepopAtGraveyard ( ) ; _player -> SetPendingBind ( 0 , 0 ) ; } void WorldSession :: HandleUpdateMissileTrajectory ( WorldPacket & recvPacket ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ UPDATE _ MISSILE _ TRAJECTORY " ) ; ObjectGuid guid ; uint32 spellId ; float elevation , speed ; float curX , curY , curZ ; float targetX , targetY , targetZ ; uint8 moveStop ; recvPacket >> guid >> spellId >> elevation >> speed ; recvPacket >> curX >> curY >> curZ ; recvPacket >> targetX >> targetY >> targetZ ; recvPacket >> moveStop ; Unit * caster = ObjectAccessor :: GetUnit ( * _player , guid ) ; Spell * spell = caster ? caster -> GetCurrentSpell ( CURRENT_GENERIC_SPELL ) : NULL ; if ( ! spell || spell -> m_spellInfo -> Id != spellId || ! spell -> m_targets . HasDst ( ) || ! spell -> m_targets . HasSrc ( ) ) { recvPacket . rfinish ( ) ; return ; } Position pos = * spell -> m_targets . GetSrcPos ( ) ; pos . Relocate ( curX , curY , curZ ) ; spell -> m_targets . ModSrc ( pos ) ; pos = * spell -> m_targets . GetDstPos ( ) ; pos . Relocate ( targetX , targetY , targetZ ) ; spell -> m_targets . ModDst ( pos ) ; spell -> m_targets . SetElevation ( elevation ) ; spell -> m_targets . SetSpeed ( speed ) ; if ( moveStop ) { uint32 opcode ; recvPacket >> opcode ; recvPacket . SetOpcode ( opcode ) ; HandleMovementOpcodes ( recvPacket ) ; } } </DOCUMENT>
<DOCUMENT_ID="alejocb/rgbdtam/tree/master/ThirdParty/g2o/g2o/core/marginal_covariance_cholesky.cpp"> // ▁ g2o ▁ - ▁ General ▁ Graph ▁ Optimization ENDCOM // ▁ Copyright ▁ ( C ) ▁ 2011 ▁ R . ▁ Kuemmerle , ▁ G . ▁ Grisetti , ▁ W . ▁ Burgard ENDCOM // ▁ All ▁ rights ▁ reserved . ENDCOM // ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without ENDCOM // ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions ▁ are ENDCOM // ▁ met : ENDCOM // ▁ * ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright ▁ notice , ENDCOM // ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . ENDCOM // ▁ * ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright ENDCOM // ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in ▁ the ENDCOM // ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the ▁ distribution . ENDCOM // ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ THE ▁ COPYRIGHT ▁ HOLDERS ▁ AND ▁ CONTRIBUTORS ▁ " AS ENDCOM // ▁ IS " ▁ AND ▁ ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ENDCOM // ▁ TO , ▁ THE ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR ▁ A ENDCOM // ▁ PARTICULAR ▁ PURPOSE ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ▁ COPYRIGHT ENDCOM // ▁ HOLDER ▁ OR ▁ CONTRIBUTORS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , ENDCOM // ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ ( INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ENDCOM // ▁ TO , ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES ; ▁ LOSS ▁ OF ▁ USE , ▁ DATA , ▁ OR ENDCOM // ▁ PROFITS ; ▁ OR ▁ BUSINESS ▁ INTERRUPTION ) ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY ▁ THEORY ▁ OF ENDCOM // ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ CONTRACT , ▁ STRICT ▁ LIABILITY , ▁ OR ▁ TORT ▁ ( INCLUDING ENDCOM // ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE ▁ OF ▁ THIS ENDCOM // ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . ENDCOM # include " marginal _ covariance _ cholesky . h " # include < algorithm > # include < cassert > using namespace std ; namespace g2o { struct MatrixElem { int r , c ; MatrixElem ( int r_ , int c_ ) : r ( r_ ) , c ( c_ ) { } bool operator < ( const MatrixElem & other ) const { return c > other . c || ( c == other . c && r > other . r ) ; } } ; MarginalCovarianceCholesky :: MarginalCovarianceCholesky ( ) : _n ( 0 ) , _Ap ( 0 ) , _Ai ( 0 ) , _Ax ( 0 ) , _perm ( 0 ) { } MarginalCovarianceCholesky :: ~ MarginalCovarianceCholesky ( ) { } void MarginalCovarianceCholesky :: setCholeskyFactor ( int n , int * Lp , int * Li , double * Lx , int * permInv ) { _n = n ; _Ap = Lp ; _Ai = Li ; _Ax = Lx ; _perm = permInv ; // ▁ pre - compute ▁ reciprocal ▁ values ▁ of ▁ the ▁ diagonal ▁ of ▁ L ENDCOM _diag . resize ( n ) ; for ( int r = 0 ; r < n ; ++ r ) { const int & sc = _Ap [ r ] ; // ▁ L ▁ is ▁ lower ▁ triangular , ▁ thus ▁ the ▁ first ▁ elem ▁ in ▁ the ▁ column ▁ is ▁ the ▁ diagonal ▁ entry ENDCOM assert ( r == _Ai [ sc ] && " Error ▁ in ▁ CCS ▁ storage ▁ of ▁ L " ) ; _diag [ r ] = 1.0 / _Ax [ sc ] ; } } double MarginalCovarianceCholesky :: computeEntry ( int r , int c ) { assert ( r <= c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; if ( foundIt != _map . end ( ) ) { return foundIt -> second ; } // ▁ compute ▁ the ▁ summation ▁ over ▁ column ▁ r ENDCOM double s = 0. ; const int & sc = _Ap [ r ] ; const int & ec = _Ap [ r + 1 ] ; for ( int j = sc + 1 ; j < ec ; ++ j ) { // ▁ sum ▁ over ▁ row ▁ r ▁ while ▁ skipping ▁ the ▁ element ▁ on ▁ the ▁ diagonal ENDCOM const int & rr = _Ai [ j ] ; double val = rr < c ? computeEntry ( rr , c ) : computeEntry ( c , rr ) ; s += val * _Ax [ j ] ; } double result ; if ( r == c ) { const double & diagElem = _diag [ r ] ; result = diagElem * ( diagElem - s ) ; } else { result = - s * _diag [ r ] ; } _map [ idx ] = result ; return result ; } void MarginalCovarianceCholesky :: computeCovariance ( double * * covBlocks , const std :: vector < int > & blockIndices ) { _map . clear ( ) ; int base = 0 ; vector < MatrixElem > elemsToCompute ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int nbase = blockIndices [ i ] ; int vdim = nbase - base ; for ( int rr = 0 ; rr < vdim ; ++ rr ) for ( int cc = rr ; cc < vdim ; ++ cc ) { int r = _perm ? _perm [ rr + base ] : rr + base ; // ▁ apply ▁ permutation ENDCOM int c = _perm ? _perm [ cc + base ] : cc + base ; if ( r > c ) // ▁ make ▁ sure ▁ it ' s ▁ still ▁ upper ▁ triangular ▁ after ▁ applying ▁ the ▁ permutation ENDCOM swap ( r , c ) ; elemsToCompute . push_back ( MatrixElem ( r , c ) ) ; } base = nbase ; } // ▁ sort ▁ the ▁ elems ▁ to ▁ reduce ▁ the ▁ recursive ▁ calls ENDCOM sort ( elemsToCompute . begin ( ) , elemsToCompute . end ( ) ) ; // ▁ compute ▁ the ▁ inverse ▁ elements ▁ we ▁ need ENDCOM for ( size_t i = 0 ; i < elemsToCompute . size ( ) ; ++ i ) { const MatrixElem & me = elemsToCompute [ i ] ; computeEntry ( me . r , me . c ) ; } // ▁ set ▁ the ▁ marginal ▁ covariance ▁ for ▁ the ▁ vertices , ▁ by ▁ writing ▁ to ▁ the ▁ blocks ▁ memory ENDCOM base = 0 ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int nbase = blockIndices [ i ] ; int vdim = nbase - base ; double * cov = covBlocks [ i ] ; for ( int rr = 0 ; rr < vdim ; ++ rr ) for ( int cc = rr ; cc < vdim ; ++ cc ) { int r = _perm ? _perm [ rr + base ] : rr + base ; // ▁ apply ▁ permutation ENDCOM int c = _perm ? _perm [ cc + base ] : cc + base ; if ( r > c ) // ▁ upper ▁ triangle ENDCOM swap ( r , c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; assert ( foundIt != _map . end ( ) ) ; cov [ rr * vdim + cc ] = foundIt -> second ; if ( rr != cc ) cov [ cc * vdim + rr ] = foundIt -> second ; } base = nbase ; } } void MarginalCovarianceCholesky :: computeCovariance ( SparseBlockMatrix < MatrixXd > & spinv , const std :: vector < int > & rowBlockIndices , const std :: vector < std :: pair < int , int > > & blockIndices ) { // ▁ allocate ▁ the ▁ sparse ENDCOM spinv = SparseBlockMatrix < MatrixXd > ( & rowBlockIndices [ 0 ] , & rowBlockIndices [ 0 ] , rowBlockIndices . size ( ) , rowBlockIndices . size ( ) , true ) ; _map . clear ( ) ; vector < MatrixElem > elemsToCompute ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int blockRow = blockIndices [ i ] . first ; int blockCol = blockIndices [ i ] . second ; assert ( blockRow >= 0 ) ; assert ( blockRow < ( int ) rowBlockIndices . size ( ) ) ; assert ( blockCol >= 0 ) ; assert ( blockCol < ( int ) rowBlockIndices . size ( ) ) ; int rowBase = spinv . rowBaseOfBlock ( blockRow ) ; int colBase = spinv . colBaseOfBlock ( blockCol ) ; MatrixXd * block = spinv . block ( blockRow , blockCol , true ) ; assert ( block ) ; for ( int iRow = 0 ; iRow < block -> rows ( ) ; ++ iRow ) for ( int iCol = 0 ; iCol < block -> cols ( ) ; ++ iCol ) { int rr = rowBase + iRow ; int cc = colBase + iCol ; int r = _perm ? _perm [ rr ] : rr ; // ▁ apply ▁ permutation ENDCOM int c = _perm ? _perm [ cc ] : cc ; if ( r > c ) swap ( r , c ) ; elemsToCompute . push_back ( MatrixElem ( r , c ) ) ; } } // ▁ sort ▁ the ▁ elems ▁ to ▁ reduce ▁ the ▁ number ▁ of ▁ recursive ▁ calls ENDCOM sort ( elemsToCompute . begin ( ) , elemsToCompute . end ( ) ) ; // ▁ compute ▁ the ▁ inverse ▁ elements ▁ we ▁ need ENDCOM for ( size_t i = 0 ; i < elemsToCompute . size ( ) ; ++ i ) { const MatrixElem & me = elemsToCompute [ i ] ; computeEntry ( me . r , me . c ) ; } // ▁ set ▁ the ▁ marginal ▁ covariance ▁ ENDCOM for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int blockRow = blockIndices [ i ] . first ; int blockCol = blockIndices [ i ] . second ; int rowBase = spinv . rowBaseOfBlock ( blockRow ) ; int colBase = spinv . colBaseOfBlock ( blockCol ) ; MatrixXd * block = spinv . block ( blockRow , blockCol ) ; assert ( block ) ; for ( int iRow = 0 ; iRow < block -> rows ( ) ; ++ iRow ) for ( int iCol = 0 ; iCol < block -> cols ( ) ; ++ iCol ) { int rr = rowBase + iRow ; int cc = colBase + iCol ; int r = _perm ? _perm [ rr ] : rr ; // ▁ apply ▁ permutation ENDCOM int c = _perm ? _perm [ cc ] : cc ; if ( r > c ) swap ( r , c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; assert ( foundIt != _map . end ( ) ) ; ( * block ) ( iRow , iCol ) = foundIt -> second ; } } } } // ▁ end ▁ namespace ENDCOM </DOCUMENT>
<DOCUMENT_ID="Hankuo/color-emoji.skia/tree/master/src/gpu/gl/unix/GrGLCreateNativeInterface_unix.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ 2011 ▁ Google ▁ Inc . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Use ▁ of ▁ this ▁ source ▁ code ▁ is ▁ governed ▁ by ▁ a ▁ BSD - style ▁ license ▁ that ▁ can ▁ be STRNEWLINE ▁ * ▁ found ▁ in ▁ the ▁ LICENSE ▁ file . STRNEWLINE ▁ */ # include " gl / GrGLExtensions . h " # include " gl / GrGLInterface . h " # include " . . / GrGLUtil . h " # include < GL / glx . h > # include < GL / gl . h > # include < GL / glext . h > # include < GL / glu . h > # define GR_GL_GET_PROC ( F ) interface -> f ## F = ( GrGL ## F ## Proc ) glXGetProcAddress ( reinterpret_cast < const GLubyte * > ( " gl " # F ) ) ; # define GR_GL_GET_PROC_SUFFIX ( F , S ) interface -> f ## F = ( GrGL ## F ## Proc ) glXGetProcAddress ( reinterpret_cast < const GLubyte * > ( " gl " # F # S ) ) ; const GrGLInterface * GrGLCreateNativeInterface ( ) { if ( NULL != glXGetCurrentContext ( ) ) { const char * versionString = ( const char * ) glGetString ( GL_VERSION ) ; GrGLVersion glVer = GrGLGetVersionFromString ( versionString ) ; // ▁ This ▁ may ▁ or ▁ may ▁ not ▁ succeed ▁ depending ▁ on ▁ the ▁ gl ▁ version . ENDCOM GrGLGetStringiProc glGetStringi = ( GrGLGetStringiProc ) glXGetProcAddress ( reinterpret_cast < const GLubyte * > ( " glGetStringi " ) ) ; GrGLExtensions extensions ; if ( ! extensions . init ( kDesktop_GrGLBinding , glGetString , glGetStringi , glGetIntegerv ) ) { return NULL ; } if ( glVer < GR_GL_VER ( 1 , 5 ) ) { // ▁ We ▁ must ▁ have ▁ array ▁ and ▁ element _ array ▁ buffer ▁ objects . ENDCOM return NULL ; } GrGLInterface * interface = new GrGLInterface ( ) ; interface -> fActiveTexture = glActiveTexture ; GR_GL_GET_PROC ( AttachShader ) ; GR_GL_GET_PROC ( BindAttribLocation ) ; GR_GL_GET_PROC ( BindBuffer ) ; GR_GL_GET_PROC ( BindFragDataLocation ) ; GR_GL_GET_PROC ( BeginQuery ) ; interface -> fBindTexture = glBindTexture ; interface -> fBlendFunc = glBlendFunc ; if ( glVer >= GR_GL_VER ( 1 , 4 ) || extensions . has ( " GL _ ARB _ imaging " ) || extensions . has ( " GL _ EXT _ blend _ color " ) ) { GR_GL_GET_PROC ( BlendColor ) ; } GR_GL_GET_PROC ( BufferData ) ; GR_GL_GET_PROC ( BufferSubData ) ; interface -> fClear = glClear ; interface -> fClearColor = glClearColor ; interface -> fClearStencil = glClearStencil ; interface -> fColorMask = glColorMask ; GR_GL_GET_PROC ( CompileShader ) ; interface -> fCompressedTexImage2D = glCompressedTexImage2D ; interface -> fCopyTexSubImage2D = glCopyTexSubImage2D ; GR_GL_GET_PROC ( CreateProgram ) ; GR_GL_GET_PROC ( CreateShader ) ; interface -> fCullFace = glCullFace ; GR_GL_GET_PROC ( DeleteBuffers ) ; GR_GL_GET_PROC ( DeleteProgram ) ; GR_GL_GET_PROC ( DeleteQueries ) ; GR_GL_GET_PROC ( DeleteShader ) ; interface -> fDeleteTextures = glDeleteTextures ; interface -> fDepthMask = glDepthMask ; interface -> fDisable = glDisable ; GR_GL_GET_PROC ( DisableVertexAttribArray ) ; interface -> fDrawArrays = glDrawArrays ; interface -> fDrawBuffer = glDrawBuffer ; GR_GL_GET_PROC ( DrawBuffers ) ; interface -> fDrawElements = glDrawElements ; interface -> fEnable = glEnable ; GR_GL_GET_PROC ( EnableVertexAttribArray ) ; GR_GL_GET_PROC ( EndQuery ) ; interface -> fFinish = glFinish ; interface -> fFlush = glFlush ; interface -> fFrontFace = glFrontFace ; GR_GL_GET_PROC ( GenBuffers ) ; GR_GL_GET_PROC ( GetBufferParameteriv ) ; interface -> fGetError = glGetError ; interface -> fGetIntegerv = glGetIntegerv ; GR_GL_GET_PROC ( GetQueryObjectiv ) ; GR_GL_GET_PROC ( GetQueryObjectuiv ) ; if ( glVer >= GR_GL_VER ( 3 , 3 ) || extensions . has ( " GL _ ARB _ timer _ query " ) ) { GR_GL_GET_PROC ( GetQueryObjecti64v ) ; GR_GL_GET_PROC ( GetQueryObjectui64v ) ; GR_GL_GET_PROC ( QueryCounter ) ; } else if ( extensions . has ( " GL _ EXT _ timer _ query " ) ) { GR_GL_GET_PROC_SUFFIX ( GetQueryObjecti64v , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GetQueryObjectui64v , EXT ) ; } GR_GL_GET_PROC ( GetQueryiv ) ; GR_GL_GET_PROC ( GetProgramInfoLog ) ; GR_GL_GET_PROC ( GetProgramiv ) ; GR_GL_GET_PROC ( GetShaderInfoLog ) ; GR_GL_GET_PROC ( GetShaderiv ) ; interface -> fGetString = glGetString ; GR_GL_GET_PROC ( GetStringi ) ; interface -> fGetTexLevelParameteriv = glGetTexLevelParameteriv ; GR_GL_GET_PROC ( GenQueries ) ; interface -> fGenTextures = glGenTextures ; GR_GL_GET_PROC ( GetUniformLocation ) ; interface -> fLineWidth = glLineWidth ; GR_GL_GET_PROC ( LinkProgram ) ; GR_GL_GET_PROC ( MapBuffer ) ; interface -> fPixelStorei = glPixelStorei ; interface -> fReadBuffer = glReadBuffer ; interface -> fReadPixels = glReadPixels ; if ( extensions . has ( " GL _ NV _ framebuffer _ multisample _ coverage " ) ) { GR_GL_GET_PROC_SUFFIX ( RenderbufferStorageMultisampleCoverage , NV ) ; } interface -> fScissor = glScissor ; GR_GL_GET_PROC ( ShaderSource ) ; interface -> fStencilFunc = glStencilFunc ; GR_GL_GET_PROC ( StencilFuncSeparate ) ; interface -> fStencilMask = glStencilMask ; GR_GL_GET_PROC ( StencilMaskSeparate ) ; interface -> fStencilOp = glStencilOp ; GR_GL_GET_PROC ( StencilOpSeparate ) ; interface -> fTexImage2D = glTexImage2D ; interface -> fTexParameteri = glTexParameteri ; interface -> fTexParameteriv = glTexParameteriv ; if ( glVer >= GR_GL_VER ( 4 , 2 ) || extensions . has ( " GL _ ARB _ texture _ storage " ) ) { GR_GL_GET_PROC ( TexStorage2D ) ; } else if ( extensions . has ( " GL _ EXT _ texture _ storage " ) ) { GR_GL_GET_PROC_SUFFIX ( TexStorage2D , EXT ) ; } interface -> fTexSubImage2D = glTexSubImage2D ; GR_GL_GET_PROC ( Uniform1f ) ; GR_GL_GET_PROC ( Uniform1i ) ; GR_GL_GET_PROC ( Uniform1fv ) ; GR_GL_GET_PROC ( Uniform1iv ) ; GR_GL_GET_PROC ( Uniform2f ) ; GR_GL_GET_PROC ( Uniform2i ) ; GR_GL_GET_PROC ( Uniform2fv ) ; GR_GL_GET_PROC ( Uniform2iv ) ; GR_GL_GET_PROC ( Uniform3f ) ; GR_GL_GET_PROC ( Uniform3i ) ; GR_GL_GET_PROC ( Uniform3fv ) ; GR_GL_GET_PROC ( Uniform3iv ) ; GR_GL_GET_PROC ( Uniform4f ) ; GR_GL_GET_PROC ( Uniform4i ) ; GR_GL_GET_PROC ( Uniform4fv ) ; GR_GL_GET_PROC ( Uniform4iv ) ; GR_GL_GET_PROC ( UniformMatrix2fv ) ; GR_GL_GET_PROC ( UniformMatrix3fv ) ; GR_GL_GET_PROC ( UniformMatrix4fv ) ; GR_GL_GET_PROC ( UnmapBuffer ) ; GR_GL_GET_PROC ( UseProgram ) ; GR_GL_GET_PROC ( VertexAttrib4fv ) ; GR_GL_GET_PROC ( VertexAttribPointer ) ; interface -> fViewport = glViewport ; GR_GL_GET_PROC ( BindFragDataLocationIndexed ) ; if ( glVer >= GR_GL_VER ( 3 , 0 ) || extensions . has ( " GL _ ARB _ vertex _ array _ object " ) ) { // ▁ no ▁ ARB ▁ suffix ▁ for ▁ GL _ ARB _ vertex _ array _ object ENDCOM GR_GL_GET_PROC ( BindVertexArray ) ; GR_GL_GET_PROC ( GenVertexArrays ) ; GR_GL_GET_PROC ( DeleteVertexArrays ) ; } // ▁ First ▁ look ▁ for ▁ GL3.0 ▁ FBO ▁ or ▁ GL _ ARB _ framebuffer _ object ▁ ( same ▁ since ENDCOM // ▁ GL _ ARB _ framebuffer _ object ▁ doesn ' t ▁ use ▁ ARB ▁ suffix . ) ENDCOM if ( glVer >= GR_GL_VER ( 3 , 0 ) || extensions . has ( " GL _ ARB _ framebuffer _ object " ) ) { GR_GL_GET_PROC ( GenFramebuffers ) ; GR_GL_GET_PROC ( GetFramebufferAttachmentParameteriv ) ; GR_GL_GET_PROC ( GetRenderbufferParameteriv ) ; GR_GL_GET_PROC ( BindFramebuffer ) ; GR_GL_GET_PROC ( FramebufferTexture2D ) ; GR_GL_GET_PROC ( CheckFramebufferStatus ) ; GR_GL_GET_PROC ( DeleteFramebuffers ) ; GR_GL_GET_PROC ( RenderbufferStorage ) ; GR_GL_GET_PROC ( GenRenderbuffers ) ; GR_GL_GET_PROC ( DeleteRenderbuffers ) ; GR_GL_GET_PROC ( FramebufferRenderbuffer ) ; GR_GL_GET_PROC ( BindRenderbuffer ) ; GR_GL_GET_PROC ( RenderbufferStorageMultisample ) ; GR_GL_GET_PROC ( BlitFramebuffer ) ; } else if ( extensions . has ( " GL _ EXT _ framebuffer _ object " ) ) { GR_GL_GET_PROC_SUFFIX ( GenFramebuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GetFramebufferAttachmentParameteriv , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GetRenderbufferParameteriv , EXT ) ; GR_GL_GET_PROC_SUFFIX ( BindFramebuffer , EXT ) ; GR_GL_GET_PROC_SUFFIX ( FramebufferTexture2D , EXT ) ; GR_GL_GET_PROC_SUFFIX ( CheckFramebufferStatus , EXT ) ; GR_GL_GET_PROC_SUFFIX ( DeleteFramebuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( RenderbufferStorage , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GenRenderbuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( DeleteRenderbuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( FramebufferRenderbuffer , EXT ) ; GR_GL_GET_PROC_SUFFIX ( BindRenderbuffer , EXT ) ; if ( extensions . has ( " GL _ EXT _ framebuffer _ multisample " ) ) { GR_GL_GET_PROC_SUFFIX ( RenderbufferStorageMultisample , EXT ) ; } if ( extensions . has ( " GL _ EXT _ framebuffer _ blit " ) ) { GR_GL_GET_PROC_SUFFIX ( BlitFramebuffer , EXT ) ; } } else { // ▁ we ▁ must ▁ have ▁ FBOs ENDCOM delete interface ; return NULL ; } interface -> fBindingsExported = kDesktop_GrGLBinding ; return interface ; } else { return NULL ; } } </DOCUMENT>
<DOCUMENT_ID="Dako300/BasicTV/tree/master/src/math/numbers/math_numbers.cpp"> # include " . . / . . / main . h " # include " . . / . . / util . h " # include " math _ numbers . h " # include " . . / math . h " # include " . . / . . / id / id _ api . h " # define MINOR_SPECIES_MULTIPLIER ( pow ( 2 , 64 ) - 1 ) // ▁ proxy ▁ functions ENDCOM static void number_sanity_fetch ( void * ptr , uint64_t start , uint64_t size , std :: vector < uint8_t > * data ) { if ( data -> size ( ) < start + size ) { print ( " can ' t ▁ copy , ▁ not ▁ enough ▁ room " , P_ERR ) ; } memcpy ( ptr , data -> data ( ) + start , size ) ; convert :: nbo :: from ( ( uint8_t * ) ptr , size ) ; } static std :: vector < uint8_t > number_sanity_fetch ( std :: vector < uint8_t > * data ) { std :: vector < uint8_t > retval ; if ( data -> size ( ) < 4 ) { print ( " not ▁ enough ▁ room ▁ to ▁ possibly ▁ encode ▁ major / minor ▁ size " , P_ERR ) ; } uint32_t size ; memcpy ( & size , data -> data ( ) , 4 ) ; size = NBO_32 ( size ) ; if ( data -> size ( ) < 4 + size ) { P_V ( size , P_WARN ) ; P_V ( data -> size ( ) , P_WARN ) ; print ( " invalid ▁ size ▁ for ▁ current ▁ number ▁ chunk " , P_ERR ) ; } retval = convert :: nbo :: from ( std :: vector < uint8_t > ( data -> begin ( ) + 4 , data -> begin ( ) + 4 + size ) ) ; /* STRNEWLINE TABSYMBOL ▁ Read ▁ data ▁ needs ▁ to ▁ be ▁ truncated STRNEWLINE TABSYMBOL ▁ */ data -> erase ( data -> begin ( ) , data -> begin ( ) + 4 + size ) ; return retval ; } uint64_t math :: number :: get :: unit ( std :: vector < uint8_t > data ) { uint64_t retval ; number_sanity_fetch ( & retval , 0 , sizeof ( retval ) , & data ) ; return retval ; } std :: pair < std :: vector < uint8_t > , std :: vector < uint8_t > > math :: number :: get :: raw_species ( std :: vector < uint8_t > data ) { uint64_t start = sizeof ( math_number_unit_t ) ; if ( data . size ( ) < start ) { return std :: pair < std :: vector < uint8_t > , std :: vector < uint8_t > > ( { } , { } ) ; } data . erase ( data . begin ( ) , data . begin ( ) + start ) ; // ▁ truncate ▁ unit ENDCOM std :: pair < std :: vector < uint8_t > , std :: vector < uint8_t > > retval ; retval . first = number_sanity_fetch ( & data ) ; retval . second = number_sanity_fetch ( & data ) ; return retval ; } long double math :: number :: get :: number ( std :: vector < uint8_t > data ) { long double retval ; std :: pair < std :: vector < uint8_t > , std :: vector < uint8_t > > species = math :: number :: get :: raw_species ( data ) ; if ( species . first . size ( ) > 8 || species . second . size ( ) > 8 ) { print ( " I ▁ need ▁ to ▁ expand ▁ this ▁ beyond ▁ 64 - bits " , P_ERR ) ; } uint64_t major_int = 0 , minor_int = 0 ; memcpy ( & major_int , species . first . data ( ) , species . first . size ( ) ) ; memcpy ( & minor_int , species . second . data ( ) , species . second . size ( ) ) ; retval = ( long double ) ( major_int ) + ( long double ) ( ( long double ) ( minor_int / MINOR_SPECIES_MULTIPLIER ) ) ; return retval ; } # define NUMBER_CREATE_ADD ( x ) retval . insert ( retval . end ( ) , ( uint8_t * ) & x , ( uint8_t * ) & x + sizeof ( x ) ) /* STRNEWLINE ▁ TODO : ▁ In ▁ order ▁ to ▁ really ▁ optimize ▁ the ▁ numbers , ▁ we ▁ need ▁ to ▁ calculate ▁ the ▁ min STRNEWLINE ▁ number ▁ of ▁ bytes ▁ needed ▁ to ▁ represent ▁ this ▁ ( not ▁ even ▁ in ▁ powers ▁ of ▁ two , ▁ which STRNEWLINE ▁ is ▁ pretty ▁ nice ) . ▁ As ▁ of ▁ right ▁ now , ▁ it ▁ is ▁ stuck ▁ at ▁ the ▁ ( somewhat ▁ reasonable ) STRNEWLINE ▁ max ▁ of ▁ 8 - bytes ▁ ( 64 - bit ) , ▁ but ▁ slimming ▁ that ▁ down ▁ could ▁ help ▁ a ▁ lot ▁ if ▁ I ▁ choose STRNEWLINE ▁ to ▁ optimize ▁ math _ number _ set _ simple _ t ▁ internally ▁ ( specifically ▁ removing ▁ overheads STRNEWLINE ▁ with ▁ multiple ▁ vectors ) . STRNEWLINE ▁ */ std :: vector < uint8_t > math :: number :: create ( long double number , uint64_t unit ) { std :: vector < uint8_t > retval ; int64_t major_int = ( ( uint64_t ) ( long double ) ( number ) ) ; uint32_t major_size = ( 8 ) ; uint64_t minor_int = ( ( ( ( long double ) number - ( long double ) major_int ) * ( long double ) MINOR_SPECIES_MULTIPLIER ) ) ; uint32_t minor_size = ( 8 ) ; unit = NBO_64 ( unit ) ; major_int = NBO_64 ( major_int ) ; major_size = NBO_32 ( major_size ) ; minor_int = NBO_64 ( minor_int ) ; minor_size = NBO_32 ( minor_size ) ; // ▁ doesn ' t ▁ bother ▁ with ▁ endian ▁ stuff , ▁ assumed ▁ to ▁ have ▁ been ▁ done ENDCOM NUMBER_CREATE_ADD ( unit ) ; NUMBER_CREATE_ADD ( major_size ) ; NUMBER_CREATE_ADD ( major_int ) ; NUMBER_CREATE_ADD ( minor_size ) ; NUMBER_CREATE_ADD ( minor_int ) ; return retval ; } std :: vector < uint8_t > math :: number :: create ( uint64_t number , uint64_t unit ) { std :: vector < uint8_t > retval ; uint64_t major_int = number ; uint32_t major_size = 8 ; uint64_t minor_int = 0 ; uint32_t minor_size = 0 ; unit = NBO_64 ( unit ) ; major_int = NBO_64 ( major_int ) ; major_size = NBO_32 ( major_size ) ; minor_int = NBO_64 ( minor_int ) ; minor_size = NBO_32 ( minor_size ) ; // ▁ doesn ' t ▁ bother ▁ with ▁ endian ▁ stuff , ▁ assumed ▁ to ▁ have ▁ been ▁ done ENDCOM NUMBER_CREATE_ADD ( unit ) ; NUMBER_CREATE_ADD ( major_size ) ; NUMBER_CREATE_ADD ( major_int ) ; NUMBER_CREATE_ADD ( minor_size ) ; NUMBER_CREATE_ADD ( minor_int ) ; return retval ; } std :: vector < uint8_t > math :: number :: create ( int64_t number , uint64_t unit ) { std :: vector < uint8_t > retval ; int64_t major_int = number ; uint32_t major_size = 8 ; uint64_t minor_int = 0 ; uint32_t minor_size = 0 ; unit = NBO_64 ( unit ) ; major_int = NBO_64 ( major_int ) ; major_size = NBO_32 ( major_size ) ; minor_int = NBO_64 ( minor_int ) ; minor_size = NBO_32 ( minor_size ) ; // ▁ doesn ' t ▁ bother ▁ with ▁ endian ▁ stuff , ▁ assumed ▁ to ▁ have ▁ been ▁ done ENDCOM NUMBER_CREATE_ADD ( unit ) ; NUMBER_CREATE_ADD ( major_size ) ; NUMBER_CREATE_ADD ( major_int ) ; NUMBER_CREATE_ADD ( minor_size ) ; NUMBER_CREATE_ADD ( minor_int ) ; return retval ; } std :: vector < uint8_t > math :: number :: create ( std :: vector < uint8_t > raw_number_data_major , std :: vector < uint8_t > raw_number_data_minor , uint64_t unit ) { std :: vector < uint8_t > retval ; convert :: nbo :: to ( raw_number_data_major . data ( ) , raw_number_data_major . size ( ) ) ; convert :: nbo :: to ( raw_number_data_minor . data ( ) , raw_number_data_minor . size ( ) ) ; ASSERT ( raw_number_data_major . size ( ) <= UINT32_MAX , P_ERR ) ; ASSERT ( raw_number_data_minor . size ( ) <= UINT32_MAX , P_ERR ) ; uint32_t major_size = NBO_32 ( static_cast < uint32_t > ( raw_number_data_major . size ( ) ) ) ; uint32_t minor_size = NBO_32 ( static_cast < uint32_t > ( raw_number_data_minor . size ( ) ) ) ; NUMBER_CREATE_ADD ( unit ) ; NUMBER_CREATE_ADD ( major_size ) ; retval . insert ( retval . end ( ) , raw_number_data_major . begin ( ) , raw_number_data_major . end ( ) ) ; NUMBER_CREATE_ADD ( minor_size ) ; retval . insert ( retval . end ( ) , raw_number_data_minor . begin ( ) , raw_number_data_minor . end ( ) ) ; } // ▁ simple ▁ helper ▁ function ENDCOM void math :: number :: add_data_to_set ( std :: vector < std :: vector < uint8_t > > data , id_t_ math_number_set_id ) { math_number_set_t * math_number_set_ptr = PTR_DATA ( math_number_set_id , math_number_set_t ) ; if ( math_number_set_ptr == nullptr ) { print ( " math _ number _ set _ ptr ▁ is ▁ a ▁ nullptr " , P_ERR ) ; } math_number_set_ptr -> add_data ( data ) ; } </DOCUMENT>
<DOCUMENT_ID="dodamn/pkg-dosbox/tree/master/src/hardware/mixer.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2002-2009 ▁ The ▁ DOSBox ▁ Team STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or STRNEWLINE ▁ * ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ Library ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software STRNEWLINE ▁ * ▁ Foundation , ▁ Inc . , ▁ 59 ▁ Temple ▁ Place ▁ - ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 , ▁ USA . STRNEWLINE ▁ */ /* ▁ $ Id : ▁ mixer . cpp , v ▁ 1.53 ▁ 2009/04/28 ▁ 21:48:24 ▁ harekiet ▁ Exp ▁ $ ▁ */ /* ▁ STRNEWLINE TABSYMBOL Remove ▁ the ▁ sdl ▁ code ▁ from ▁ here ▁ and ▁ have ▁ it ▁ handeld ▁ in ▁ the ▁ sdlmain . STRNEWLINE TABSYMBOL That ▁ should ▁ call ▁ the ▁ mixer ▁ start ▁ from ▁ there ▁ or ▁ something . STRNEWLINE */ # include < string . h > # include < sys / types . h > # include < math . h > # if defined ( WIN32 ) // Midi ▁ listing ENDCOM # ifndef WIN32_LEAN_AND_MEAN # define WIN32_LEAN_AND_MEAN # endif # include < windows . h > # include < mmsystem . h > # endif # include " SDL . h " # include " mem . h " # include " pic . h " # include " dosbox . h " # include " mixer . h " # include " timer . h " # include " setup . h " # include " cross . h " # include " support . h " # include " mapper . h " # include " hardware . h " # include " programs . h " # define MIXER_SSIZE 4 # define MIXER_SHIFT 14 # define MIXER_REMAIN ( ( 1 << MIXER_SHIFT ) - 1 ) # define MIXER_VOLSHIFT 13 static INLINE Bit16s MIXER_CLIP ( Bits SAMP ) { if ( SAMP < MAX_AUDIO ) { if ( SAMP > MIN_AUDIO ) return SAMP ; else return MIN_AUDIO ; } else return MAX_AUDIO ; } static struct { Bit32s work [ MIXER_BUFSIZE ] [ 2 ] ; Bitu pos , done ; Bitu needed , min_needed , max_needed ; Bit32u tick_add , tick_remain ; float mastervol [ 2 ] ; MixerChannel * channels ; bool nosound ; Bit32u freq ; Bit32u blocksize ; } mixer ; Bit8u MixTemp [ MIXER_BUFSIZE ] ; MixerChannel * MIXER_AddChannel ( MIXER_Handler handler , Bitu freq , const char * name ) { MixerChannel * chan = new MixerChannel ( ) ; chan -> scale = 1.0 ; chan -> handler = handler ; chan -> name = name ; chan -> SetFreq ( freq ) ; chan -> next = mixer . channels ; chan -> SetVolume ( 1 , 1 ) ; chan -> enabled = false ; mixer . channels = chan ; return chan ; } MixerChannel * MIXER_FindChannel ( const char * name ) { MixerChannel * chan = mixer . channels ; while ( chan ) { if ( ! strcasecmp ( chan -> name , name ) ) break ; chan = chan -> next ; } return chan ; } void MIXER_DelChannel ( MixerChannel * delchan ) { MixerChannel * chan = mixer . channels ; MixerChannel * * where = & mixer . channels ; while ( chan ) { if ( chan == delchan ) { * where = chan -> next ; delete delchan ; return ; } where = & chan -> next ; chan = chan -> next ; } } void MixerChannel :: UpdateVolume ( void ) { volmul [ 0 ] = ( Bits ) ( ( 1 << MIXER_VOLSHIFT ) * scale * volmain [ 0 ] * mixer . mastervol [ 0 ] ) ; volmul [ 1 ] = ( Bits ) ( ( 1 << MIXER_VOLSHIFT ) * scale * volmain [ 1 ] * mixer . mastervol [ 1 ] ) ; } void MixerChannel :: SetVolume ( float _left , float _right ) { volmain [ 0 ] = _left ; volmain [ 1 ] = _right ; UpdateVolume ( ) ; } void MixerChannel :: SetScale ( float f ) { scale = f ; UpdateVolume ( ) ; } void MixerChannel :: Enable ( bool _yesno ) { if ( _yesno == enabled ) return ; enabled = _yesno ; if ( enabled ) { freq_index = MIXER_REMAIN ; SDL_LockAudio ( ) ; if ( done < mixer . done ) done = mixer . done ; SDL_UnlockAudio ( ) ; } } void MixerChannel :: SetFreq ( Bitu _freq ) { freq_add = ( _freq << MIXER_SHIFT ) / mixer . freq ; } void MixerChannel :: Mix ( Bitu _needed ) { needed = _needed ; while ( enabled && needed > done ) { Bitu todo = needed - done ; todo *= freq_add ; if ( todo & MIXER_REMAIN ) { todo = ( todo >> MIXER_SHIFT ) + 1 ; } else { todo = ( todo >> MIXER_SHIFT ) ; } handler ( todo ) ; } } void MixerChannel :: AddSilence ( void ) { if ( done < needed ) { done = needed ; last [ 0 ] = last [ 1 ] = 0 ; freq_index = MIXER_REMAIN ; } } template < class Type , bool stereo , bool signeddata , bool nativeorder > inline void MixerChannel :: AddSamples ( Bitu len , const Type * data ) { Bits diff [ 2 ] ; Bitu mixpos = mixer . pos + done ; freq_index &= MIXER_REMAIN ; Bitu pos = 0 ; Bitu new_pos ; goto thestart ; for ( ; ; ) { new_pos = freq_index >> MIXER_SHIFT ; if ( pos < new_pos ) { last [ 0 ] += diff [ 0 ] ; if ( stereo ) last [ 1 ] += diff [ 1 ] ; pos = new_pos ; thestart : if ( pos >= len ) return ; if ( sizeof ( Type ) == 1 ) { if ( ! signeddata ) { if ( stereo ) { diff [ 0 ] = ( ( ( Bit8s ) ( data [ pos * 2 + 0 ] ^ 0x80 ) ) << 8 ) - last [ 0 ] ; diff [ 1 ] = ( ( ( Bit8s ) ( data [ pos * 2 + 1 ] ^ 0x80 ) ) << 8 ) - last [ 1 ] ; } else { diff [ 0 ] = ( ( ( Bit8s ) ( data [ pos ] ^ 0x80 ) ) << 8 ) - last [ 0 ] ; } } else { if ( stereo ) { diff [ 0 ] = ( data [ pos * 2 + 0 ] << 8 ) - last [ 0 ] ; diff [ 1 ] = ( data [ pos * 2 + 1 ] << 8 ) - last [ 1 ] ; } else { diff [ 0 ] = ( data [ pos ] << 8 ) - last [ 0 ] ; } } // 16bit ▁ and ▁ 32bit ▁ both ▁ contain ▁ 16bit ▁ data ▁ internally ENDCOM } else { if ( signeddata ) { if ( stereo ) { if ( nativeorder ) { diff [ 0 ] = data [ pos * 2 + 0 ] - last [ 0 ] ; diff [ 1 ] = data [ pos * 2 + 1 ] - last [ 1 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bit16s ) host_readw ( ( HostPt ) & data [ pos * 2 + 0 ] ) - last [ 0 ] ; diff [ 1 ] = ( Bit16s ) host_readw ( ( HostPt ) & data [ pos * 2 + 1 ] ) - last [ 1 ] ; } else { diff [ 0 ] = ( Bit32s ) host_readd ( ( HostPt ) & data [ pos * 2 + 0 ] ) - last [ 0 ] ; diff [ 1 ] = ( Bit32s ) host_readd ( ( HostPt ) & data [ pos * 2 + 1 ] ) - last [ 1 ] ; } } } else { if ( nativeorder ) { diff [ 0 ] = data [ pos ] - last [ 0 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bit16s ) host_readw ( ( HostPt ) & data [ pos ] ) - last [ 0 ] ; } else { diff [ 0 ] = ( Bit32s ) host_readd ( ( HostPt ) & data [ pos ] ) - last [ 0 ] ; } } } } else { if ( stereo ) { if ( nativeorder ) { diff [ 0 ] = ( Bits ) data [ pos * 2 + 0 ] - 32768 - last [ 0 ] ; diff [ 1 ] = ( Bits ) data [ pos * 2 + 1 ] - 32768 - last [ 1 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bits ) host_readw ( ( HostPt ) & data [ pos * 2 + 0 ] ) - 32768 - last [ 0 ] ; diff [ 1 ] = ( Bits ) host_readw ( ( HostPt ) & data [ pos * 2 + 1 ] ) - 32768 - last [ 1 ] ; } else { diff [ 0 ] = ( Bits ) host_readd ( ( HostPt ) & data [ pos * 2 + 0 ] ) - 32768 - last [ 0 ] ; diff [ 1 ] = ( Bits ) host_readd ( ( HostPt ) & data [ pos * 2 + 1 ] ) - 32768 - last [ 1 ] ; } } } else { if ( nativeorder ) { diff [ 0 ] = ( Bits ) data [ pos ] - 32768 - last [ 0 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bits ) host_readw ( ( HostPt ) & data [ pos ] ) - 32768 - last [ 0 ] ; } else { diff [ 0 ] = ( Bits ) host_readd ( ( HostPt ) & data [ pos ] ) - 32768 - last [ 0 ] ; } } } } } } Bits diff_mul = freq_index & MIXER_REMAIN ; freq_index += freq_add ; mixpos &= MIXER_BUFMASK ; Bits sample = last [ 0 ] + ( ( diff [ 0 ] * diff_mul ) >> MIXER_SHIFT ) ; mixer . work [ mixpos ] [ 0 ] += sample * volmul [ 0 ] ; if ( stereo ) sample = last [ 1 ] + ( ( diff [ 1 ] * diff_mul ) >> MIXER_SHIFT ) ; mixer . work [ mixpos ] [ 1 ] += sample * volmul [ 1 ] ; mixpos ++ ; done ++ ; } } void MixerChannel :: AddStretched ( Bitu len , Bit16s * data ) { if ( done >= needed ) { LOG_MSG ( " Can ' t ▁ add , ▁ buffer ▁ full " ) ; return ; } Bitu outlen = needed - done ; Bits diff ; freq_index = 0 ; Bitu temp_add = ( len << MIXER_SHIFT ) / outlen ; Bitu mixpos = mixer . pos + done ; done = needed ; Bitu pos = 0 ; diff = data [ 0 ] - last [ 0 ] ; while ( outlen -- ) { Bitu new_pos = freq_index >> MIXER_SHIFT ; if ( pos < new_pos ) { pos = new_pos ; last [ 0 ] += diff ; diff = data [ pos ] - last [ 0 ] ; } Bits diff_mul = freq_index & MIXER_REMAIN ; freq_index += temp_add ; mixpos &= MIXER_BUFMASK ; Bits sample = last [ 0 ] + ( ( diff * diff_mul ) >> MIXER_SHIFT ) ; mixer . work [ mixpos ] [ 0 ] += sample * volmul [ 0 ] ; mixer . work [ mixpos ] [ 1 ] += sample * volmul [ 1 ] ; mixpos ++ ; } } void MixerChannel :: AddSamples_m8 ( Bitu len , const Bit8u * data ) { AddSamples < Bit8u , false , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_s8 ( Bitu len , const Bit8u * data ) { AddSamples < Bit8u , true , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_m8s ( Bitu len , const Bit8s * data ) { AddSamples < Bit8s , false , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_s8s ( Bitu len , const Bit8s * data ) { AddSamples < Bit8s , true , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_m16 ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , false , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_s16 ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , true , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_m16u ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , false , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_s16u ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , true , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_m32 ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , false , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_s32 ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , true , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_m16_nonnative ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , false , true , false > ( len , data ) ; } void MixerChannel :: AddSamples_s16_nonnative ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , true , true , false > ( len , data ) ; } void MixerChannel :: AddSamples_m16u_nonnative ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , false , false , false > ( len , data ) ; } void MixerChannel :: AddSamples_s16u_nonnative ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , true , false , false > ( len , data ) ; } void MixerChannel :: AddSamples_m32_nonnative ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , false , true , false > ( len , data ) ; } void MixerChannel :: AddSamples_s32_nonnative ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , true , true , false > ( len , data ) ; } void MixerChannel :: FillUp ( void ) { SDL_LockAudio ( ) ; if ( ! enabled || done < mixer . done ) { SDL_UnlockAudio ( ) ; return ; } float index = PIC_TickIndex ( ) ; Mix ( ( Bitu ) ( index * mixer . needed ) ) ; SDL_UnlockAudio ( ) ; } extern bool ticksLocked ; static inline bool Mixer_irq_important ( void ) { /* ▁ In ▁ some ▁ states ▁ correct ▁ timing ▁ of ▁ the ▁ irqs ▁ is ▁ more ▁ important ▁ then ▁ STRNEWLINE TABSYMBOL ▁ * ▁ non ▁ stuttering ▁ audo ▁ */ return ( ticksLocked || ( CaptureState & ( CAPTURE_WAVE | CAPTURE_VIDEO ) ) ) ; } /* ▁ Mix ▁ a ▁ certain ▁ amount ▁ of ▁ new ▁ samples ▁ */ static void MIXER_MixData ( Bitu needed ) { MixerChannel * chan = mixer . channels ; while ( chan ) { chan -> Mix ( needed ) ; chan = chan -> next ; } if ( CaptureState & ( CAPTURE_WAVE | CAPTURE_VIDEO ) ) { Bit16s convert [ 1024 ] [ 2 ] ; Bitu added = needed - mixer . done ; if ( added > 1024 ) added = 1024 ; Bitu readpos = ( mixer . pos + mixer . done ) & MIXER_BUFMASK ; for ( Bitu i = 0 ; i < added ; i ++ ) { Bits sample = mixer . work [ readpos ] [ 0 ] >> MIXER_VOLSHIFT ; convert [ i ] [ 0 ] = MIXER_CLIP ( sample ) ; sample = mixer . work [ readpos ] [ 1 ] >> MIXER_VOLSHIFT ; convert [ i ] [ 1 ] = MIXER_CLIP ( sample ) ; readpos = ( readpos + 1 ) & MIXER_BUFMASK ; } CAPTURE_AddWave ( mixer . freq , added , ( Bit16s * ) convert ) ; } // Reset ▁ the ▁ the ▁ tick _ add ▁ for ▁ constant ▁ speed ENDCOM if ( Mixer_irq_important ( ) ) mixer . tick_add = ( ( mixer . freq ) << MIXER_SHIFT ) / 1000 ; mixer . done = needed ; } static void MIXER_Mix ( void ) { SDL_LockAudio ( ) ; MIXER_MixData ( mixer . needed ) ; mixer . tick_remain += mixer . tick_add ; mixer . needed += ( mixer . tick_remain >> MIXER_SHIFT ) ; mixer . tick_remain &= MIXER_REMAIN ; SDL_UnlockAudio ( ) ; } static void MIXER_Mix_NoSound ( void ) { MIXER_MixData ( mixer . needed ) ; /* ▁ Clear ▁ piece ▁ we ' ve ▁ just ▁ generated ▁ */ for ( Bitu i = 0 ; i < mixer . needed ; i ++ ) { mixer . work [ mixer . pos ] [ 0 ] = 0 ; mixer . work [ mixer . pos ] [ 1 ] = 0 ; mixer . pos = ( mixer . pos + 1 ) & MIXER_BUFMASK ; } /* ▁ Reduce ▁ count ▁ in ▁ channels ▁ */ for ( MixerChannel * chan = mixer . channels ; chan ; chan = chan -> next ) { if ( chan -> done > mixer . needed ) chan -> done -= mixer . needed ; else chan -> done = 0 ; } /* ▁ Set ▁ values ▁ for ▁ next ▁ tick ▁ */ mixer . tick_remain += mixer . tick_add ; mixer . needed = mixer . tick_remain >> MIXER_SHIFT ; mixer . tick_remain &= MIXER_REMAIN ; mixer . done = 0 ; } static void MIXER_CallBack ( void * userdata , Uint8 * stream , int len ) { Bitu need = ( Bitu ) len / MIXER_SSIZE ; Bit16s * output = ( Bit16s * ) stream ; Bitu reduce ; Bitu pos , index , index_add ; Bits sample ; /* ▁ Enough ▁ room ▁ in ▁ the ▁ buffer ▁ ? ▁ */ if ( mixer . done < need ) { // TABSYMBOL TABSYMBOL LOG _ MSG ( " Full ▁ underrun ▁ need ▁ % d , ▁ have ▁ % d , ▁ min ▁ % d " , ▁ need , ▁ mixer . done , ▁ mixer . min _ needed ) ; ENDCOM if ( ( need - mixer . done ) > ( need >> 7 ) ) // Max ▁ 1 ▁ procent ▁ stretch . ENDCOM return ; reduce = mixer . done ; index_add = ( reduce << MIXER_SHIFT ) / need ; mixer . tick_add = ( ( mixer . freq + mixer . min_needed ) << MIXER_SHIFT ) / 1000 ; } else if ( mixer . done < mixer . max_needed ) { Bitu left = mixer . done - need ; if ( left < mixer . min_needed ) { if ( ! Mixer_irq_important ( ) ) { Bitu needed = mixer . needed - need ; Bitu diff = ( mixer . min_needed > needed ? mixer . min_needed : needed ) - left ; mixer . tick_add = ( ( mixer . freq + ( diff * 3 ) ) << MIXER_SHIFT ) / 1000 ; left = 0 ; // No ▁ stretching ▁ as ▁ we ▁ compensate ▁ with ▁ the ▁ tick _ add ▁ value ENDCOM } else { left = ( mixer . min_needed - left ) ; left = 1 + ( 2 * left ) / mixer . min_needed ; // left = 1,2,3 ENDCOM } // TABSYMBOL TABSYMBOL TABSYMBOL LOG _ MSG ( " needed ▁ underrun ▁ need ▁ % d , ▁ have ▁ % d , ▁ min ▁ % d , ▁ left ▁ % d " , ▁ need , ▁ mixer . done , ▁ mixer . min _ needed , ▁ left ) ; ENDCOM reduce = need - left ; index_add = ( reduce << MIXER_SHIFT ) / need ; } else { reduce = need ; index_add = ( 1 << MIXER_SHIFT ) ; // TABSYMBOL TABSYMBOL TABSYMBOL LOG _ MSG ( " regular ▁ run ▁ need ▁ % d , ▁ have ▁ % d , ▁ min ▁ % d , ▁ left ▁ % d " , ▁ need , ▁ mixer . done , ▁ mixer . min _ needed , ▁ left ) ; ENDCOM /* ▁ Mixer ▁ tick ▁ value ▁ being ▁ updated : STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL ▁ * ▁ 3 ▁ cases : STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL ▁ * ▁ 1 ) ▁ A ▁ lot ▁ too ▁ high . ▁ > division ▁ by ▁ 5 . ▁ but ▁ maxed ▁ by ▁ 2 * ▁ min ▁ to ▁ prevent ▁ too ▁ fast ▁ drops . STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL ▁ * ▁ 2 ) ▁ A ▁ little ▁ too ▁ high ▁ > ▁ division ▁ by ▁ 8 STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL ▁ * ▁ 3 ) ▁ A ▁ little ▁ to ▁ nothing ▁ above ▁ the ▁ min _ needed ▁ buffer ▁ > ▁ go ▁ to ▁ default ▁ value STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL ▁ */ Bitu diff = left - mixer . min_needed ; if ( diff > ( mixer . min_needed << 1 ) ) diff = mixer . min_needed << 1 ; if ( diff > ( mixer . min_needed >> 1 ) ) mixer . tick_add = ( ( mixer . freq - ( diff / 5 ) ) << MIXER_SHIFT ) / 1000 ; else if ( diff > ( mixer . min_needed >> 4 ) ) mixer . tick_add = ( ( mixer . freq - ( diff >> 3 ) ) << MIXER_SHIFT ) / 1000 ; else mixer . tick_add = ( mixer . freq << MIXER_SHIFT ) / 1000 ; } } else { /* ▁ There ▁ is ▁ way ▁ too ▁ much ▁ data ▁ in ▁ the ▁ buffer ▁ */ // TABSYMBOL TABSYMBOL LOG _ MSG ( " overflow ▁ run ▁ need ▁ % d , ▁ have ▁ % d , ▁ min ▁ % d " , ▁ need , ▁ mixer . done , ▁ mixer . min _ needed ) ; ENDCOM if ( mixer . done > MIXER_BUFSIZE ) index_add = MIXER_BUFSIZE - 2 * mixer . min_needed ; else index_add = mixer . done - 2 * mixer . min_needed ; index_add = ( index_add << MIXER_SHIFT ) / need ; reduce = mixer . done - 2 * mixer . min_needed ; mixer . tick_add = ( ( mixer . freq - ( mixer . min_needed / 5 ) ) << MIXER_SHIFT ) / 1000 ; } /* ▁ Reduce ▁ done ▁ count ▁ in ▁ all ▁ channels ▁ */ for ( MixerChannel * chan = mixer . channels ; chan ; chan = chan -> next ) { if ( chan -> done > reduce ) chan -> done -= reduce ; else chan -> done = 0 ; } // ▁ Reset ▁ mixer . tick _ add ▁ when ▁ irqs ▁ are ▁ important ENDCOM if ( Mixer_irq_important ( ) ) mixer . tick_add = ( mixer . freq << MIXER_SHIFT ) / 1000 ; mixer . done -= reduce ; mixer . needed -= reduce ; pos = mixer . pos ; mixer . pos = ( mixer . pos + reduce ) & MIXER_BUFMASK ; index = 0 ; if ( need != reduce ) { while ( need -- ) { Bitu i = ( pos + ( index >> MIXER_SHIFT ) ) & MIXER_BUFMASK ; index += index_add ; sample = mixer . work [ i ] [ 0 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; sample = mixer . work [ i ] [ 1 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; } /* ▁ Clean ▁ the ▁ used ▁ buffer ▁ */ while ( reduce -- ) { pos &= MIXER_BUFMASK ; mixer . work [ pos ] [ 0 ] = 0 ; mixer . work [ pos ] [ 1 ] = 0 ; pos ++ ; } } else { while ( reduce -- ) { pos &= MIXER_BUFMASK ; sample = mixer . work [ pos ] [ 0 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; sample = mixer . work [ pos ] [ 1 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; mixer . work [ pos ] [ 0 ] = 0 ; mixer . work [ pos ] [ 1 ] = 0 ; pos ++ ; } } } static void MIXER_Stop ( Section * sec ) { } class MIXER : public Program { public : void MakeVolume ( char * scan , float & vol0 , float & vol1 ) { Bitu w = 0 ; bool db = ( toupper ( * scan ) == ' D ' ) ; if ( db ) scan ++ ; while ( * scan ) { if ( * scan == ' : ' ) { ++ scan ; w = 1 ; } char * before = scan ; float val = ( float ) strtod ( scan , & scan ) ; if ( before == scan ) { ++ scan ; continue ; } if ( ! db ) val /= 100 ; else val = powf ( 10.0f , ( float ) val / 20.0f ) ; if ( val < 0 ) val = 1.0f ; if ( ! w ) { vol0 = val ; } else { vol1 = val ; } } if ( ! w ) vol1 = vol0 ; } void Run ( void ) { if ( cmd -> FindExist ( " / LISTMIDI " ) ) { ListMidi ( ) ; return ; } if ( cmd -> FindString ( " MASTER " , temp_line , false ) ) { MakeVolume ( ( char * ) temp_line . c_str ( ) , mixer . mastervol [ 0 ] , mixer . mastervol [ 1 ] ) ; } MixerChannel * chan = mixer . channels ; while ( chan ) { if ( cmd -> FindString ( chan -> name , temp_line , false ) ) { MakeVolume ( ( char * ) temp_line . c_str ( ) , chan -> volmain [ 0 ] , chan -> volmain [ 1 ] ) ; } chan -> UpdateVolume ( ) ; chan = chan -> next ; } if ( cmd -> FindExist ( " / NOSHOW " ) ) return ; chan = mixer . channels ; WriteOut ( " Channel ▁ ▁ Main ▁ ▁ ▁ ▁ Main ( dB ) \n " ) ; ShowVolume ( " MASTER " , mixer . mastervol [ 0 ] , mixer . mastervol [ 1 ] ) ; for ( chan = mixer . channels ; chan ; chan = chan -> next ) ShowVolume ( chan -> name , chan -> volmain [ 0 ] , chan -> volmain [ 1 ] ) ; } private : void ShowVolume ( const char * name , float vol0 , float vol1 ) { WriteOut ( " % -8s ▁ % 3.0f : % - 3.0f ▁ ▁ % + 3.2f : % - + 3.2f ▁ \n " , name , vol0 * 100 , vol1 * 100 , 20 * log ( vol0 ) / log ( 10.0f ) , 20 * log ( vol1 ) / log ( 10.0f ) ) ; } void ListMidi ( ) { # if defined ( WIN32 ) unsigned int total = midiOutGetNumDevs ( ) ; for ( unsigned int i = 0 ; i < total ; i ++ ) { MIDIOUTCAPS mididev ; midiOutGetDevCaps ( i , & mididev , sizeof ( MIDIOUTCAPS ) ) ; WriteOut ( " % 2d\t ▁ \ " % s\ " \n " , i , mididev . szPname ) ; } # endif return ; } ; } ; static void MIXER_ProgramStart ( Program * * make ) { * make = new MIXER ; } MixerChannel * MixerObject :: Install ( MIXER_Handler handler , Bitu freq , const char * name ) { if ( ! installed ) { if ( strlen ( name ) > 31 ) E_Exit ( " Too ▁ long ▁ mixer ▁ channel ▁ name " ) ; safe_strncpy ( m_name , name , 32 ) ; installed = true ; return MIXER_AddChannel ( handler , freq , name ) ; } else { E_Exit ( " allready ▁ added ▁ mixer ▁ channel . " ) ; return 0 ; // Compiler ▁ happy ENDCOM } } MixerObject :: ~ MixerObject ( ) { if ( ! installed ) return ; MIXER_DelChannel ( MIXER_FindChannel ( m_name ) ) ; } void MIXER_Init ( Section * sec ) { sec -> AddDestroyFunction ( & MIXER_Stop ) ; Section_prop * section = static_cast < Section_prop * > ( sec ) ; /* ▁ Read ▁ out ▁ config ▁ section ▁ */ mixer . freq = section -> Get_int ( " rate " ) ; mixer . nosound = section -> Get_bool ( " nosound " ) ; mixer . blocksize = section -> Get_int ( " blocksize " ) ; /* ▁ Initialize ▁ the ▁ internal ▁ stuff ▁ */ mixer . channels = 0 ; mixer . pos = 0 ; mixer . done = 0 ; memset ( mixer . work , 0 , sizeof ( mixer . work ) ) ; mixer . mastervol [ 0 ] = 1.0f ; mixer . mastervol [ 1 ] = 1.0f ; /* ▁ Start ▁ the ▁ Mixer ▁ using ▁ SDL ▁ Sound ▁ at ▁ 22 ▁ khz ▁ */ SDL_AudioSpec spec ; SDL_AudioSpec obtained ; spec . freq = mixer . freq ; spec . format = AUDIO_S16SYS ; spec . channels = 2 ; spec . callback = MIXER_CallBack ; spec . userdata = NULL ; spec . samples = ( Uint16 ) mixer . blocksize ; mixer . tick_remain = 0 ; if ( mixer . nosound ) { LOG_MSG ( " MIXER : No ▁ Sound ▁ Mode ▁ Selected . " ) ; mixer . tick_add = ( ( mixer . freq ) << MIXER_SHIFT ) / 1000 ; TIMER_AddTickHandler ( MIXER_Mix_NoSound ) ; } else if ( SDL_OpenAudio ( & spec , & obtained ) < 0 ) { mixer . nosound = true ; LOG_MSG ( " MIXER : Can ' t ▁ open ▁ audio : ▁ % s ▁ , ▁ running ▁ in ▁ nosound ▁ mode . " , SDL_GetError ( ) ) ; mixer . tick_add = ( ( mixer . freq ) << MIXER_SHIFT ) / 1000 ; TIMER_AddTickHandler ( MIXER_Mix_NoSound ) ; } else { mixer . freq = obtained . freq ; mixer . blocksize = obtained . samples ; mixer . tick_add = ( mixer . freq << MIXER_SHIFT ) / 1000 ; TIMER_AddTickHandler ( MIXER_Mix ) ; SDL_PauseAudio ( 0 ) ; } mixer . min_needed = section -> Get_int ( " prebuffer " ) ; if ( mixer . min_needed > 100 ) mixer . min_needed = 100 ; mixer . min_needed = ( mixer . freq * mixer . min_needed ) / 1000 ; mixer . max_needed = mixer . blocksize * 2 + 2 * mixer . min_needed ; mixer . needed = mixer . min_needed + 1 ; PROGRAMS_MakeFile ( " MIXER . COM " , MIXER_ProgramStart ) ; } </DOCUMENT>
<DOCUMENT_ID="aybassiouny/wincaffe-cmake/tree/master/src/caffe/test/test_power_layer.cpp"> // ▁ Copyright ▁ 2014 ▁ BVLC ▁ and ▁ contributors . ENDCOM # include < algorithm > # include < vector > # include " cuda _ runtime . h " # include " gtest / gtest . h " # include " caffe / blob . hpp " # include " caffe / common . hpp " # include " caffe / filler . hpp " # include " caffe / vision _ layers . hpp " # include " caffe / test / test _ gradient _ check _ util . hpp " # include " caffe / test / test _ caffe _ main . hpp " using std :: isnan ; namespace caffe { extern cudaDeviceProp CAFFE_TEST_CUDA_PROP ; template < typename Dtype > class PowerLayerTest : public :: testing :: Test { protected : PowerLayerTest ( ) : blob_bottom_ ( new Blob < Dtype > ( 2 , 3 , 4 , 5 ) ) , blob_top_ ( new Blob < Dtype > ( ) ) { Caffe :: set_random_seed ( 1701 ) ; // ▁ fill ▁ the ▁ values ENDCOM FillerParameter filler_param ; GaussianFiller < Dtype > filler ( filler_param ) ; filler . Fill ( this -> blob_bottom_ ) ; blob_bottom_vec_ . push_back ( blob_bottom_ ) ; blob_top_vec_ . push_back ( blob_top_ ) ; } virtual ~ PowerLayerTest ( ) { delete blob_bottom_ ; delete blob_top_ ; } void TestForward ( Dtype power , Dtype scale , Dtype shift ) { LayerParameter layer_param ; layer_param . mutable_power_param ( ) -> set_power ( power ) ; layer_param . mutable_power_param ( ) -> set_scale ( scale ) ; layer_param . mutable_power_param ( ) -> set_shift ( shift ) ; PowerLayer < Dtype > layer ( layer_param ) ; layer . SetUp ( this -> blob_bottom_vec_ , & ( this -> blob_top_vec_ ) ) ; layer . Forward ( this -> blob_bottom_vec_ , & ( this -> blob_top_vec_ ) ) ; // ▁ Now , ▁ check ▁ values ENDCOM const Dtype * bottom_data = this -> blob_bottom_ -> cpu_data ( ) ; const Dtype * top_data = this -> blob_top_ -> cpu_data ( ) ; const Dtype min_precision = 1e - 5 ; for ( int i = 0 ; i < this -> blob_bottom_ -> count ( ) ; ++ i ) { Dtype expected_value = pow ( shift + scale * bottom_data [ i ] , power ) ; if ( power == Dtype ( 0 ) || power == Dtype ( 1 ) || power == Dtype ( 2 ) ) { EXPECT_FALSE ( isnan ( top_data [ i ] ) ) ; } if ( isnan ( expected_value ) ) { EXPECT_TRUE ( isnan ( top_data [ i ] ) ) ; } else { Dtype precision = max ( Dtype ( abs ( expected_value * 0.0001 ) ) , min_precision ) ; EXPECT_NEAR ( expected_value , top_data [ i ] , precision ) ; } } } void TestBackward ( Dtype power , Dtype scale , Dtype shift ) { LayerParameter layer_param ; layer_param . mutable_power_param ( ) -> set_power ( power ) ; layer_param . mutable_power_param ( ) -> set_scale ( scale ) ; layer_param . mutable_power_param ( ) -> set_shift ( shift ) ; PowerLayer < Dtype > layer ( layer_param ) ; if ( power != Dtype ( 0 ) && power != Dtype ( 1 ) && power != Dtype ( 2 ) ) { // ▁ Avoid ▁ NaNs ▁ by ▁ forcing ▁ ( shift ▁ + ▁ scale ▁ * ▁ x ) ▁ > = ▁ 0 ENDCOM Dtype * bottom_data = this -> blob_bottom_ -> mutable_cpu_data ( ) ; Dtype min_value = - shift / scale ; for ( int i = 0 ; i < this -> blob_bottom_ -> count ( ) ; ++ i ) { if ( bottom_data [ i ] < min_value ) { bottom_data [ i ] = min_value + ( min_value - bottom_data [ i ] ) ; } } } GradientChecker < Dtype > checker ( 1e - 2 , 1e - 2 , 1701 , 0. , 0.01 ) ; checker . CheckGradientEltwise ( & layer , & ( this -> blob_bottom_vec_ ) , & ( this -> blob_top_vec_ ) ) ; } Blob < Dtype > * const blob_bottom_ ; Blob < Dtype > * const blob_top_ ; vector < Blob < Dtype > * > blob_bottom_vec_ ; vector < Blob < Dtype > * > blob_top_vec_ ; } ; typedef :: testing :: Types < float , double > Dtypes ; TYPED_TEST_CASE ( PowerLayerTest , Dtypes ) ; TYPED_TEST ( PowerLayerTest , TestPowerCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientShiftZeroCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = 0.0 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZeroCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZeroGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOneCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOneGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.34 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoScaleHalfGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.5 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientShiftZeroGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = 0.0 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZeroGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZeroGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOneGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOneGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.34 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoScaleHalfGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.5 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } } // ▁ namespace ▁ caffe ENDCOM </DOCUMENT>
<DOCUMENT_ID="sacarlson/MultiCoin-exp/tree/master/src/db.cpp"> // ▁ Copyright ▁ ( c ) ▁ 2009-2010 ▁ Satoshi ▁ Nakamoto ENDCOM // ▁ Distributed ▁ under ▁ the ▁ MIT / X11 ▁ software ▁ license , ▁ see ▁ the ▁ accompanying ENDCOM // ▁ file ▁ license . txt ▁ or ▁ http : // www . opensource . org / licenses / mit - license . php . ENDCOM # include " headers . h " # include " db . h " # include " net . h " # include " auxpow . h " # include < boost / filesystem . hpp > # include < boost / filesystem / fstream . hpp > using namespace std ; using namespace boost ; unsigned int nWalletDBUpdated ; uint64 nAccountingEntryNumber = 0 ; // ▁ CDB ENDCOM static CCriticalSection cs_db ; static bool fDbEnvInit = false ; DbEnv dbenv ( 0 ) ; static map < string , int > mapFileUseCount ; static map < string , Db * > mapDb ; class CDBInit { public : CDBInit ( ) { } ~ CDBInit ( ) { if ( fDbEnvInit ) { dbenv . close ( 0 ) ; fDbEnvInit = false ; } } } instance_of_cdbinit ; CDB :: CDB ( const char * pszFile , const char * pszMode ) : pdb ( NULL ) { int ret ; if ( pszFile == NULL ) return ; fReadOnly = ( ! strchr ( pszMode , ' + ' ) && ! strchr ( pszMode , ' w ' ) ) ; bool fCreate = strchr ( pszMode , ' c ' ) ; unsigned int nFlags = DB_THREAD ; if ( fCreate ) nFlags |= DB_CREATE ; CRITICAL_BLOCK ( cs_db ) { if ( ! fDbEnvInit ) { if ( fShutdown ) return ; string strDataDir = GetDataDir ( ) ; string strLogDir = strDataDir + " / database " ; filesystem :: create_directory ( strLogDir . c_str ( ) ) ; string strErrorFile = strDataDir + " / db . log " ; printf ( " dbenv . open ▁ strLogDir = % s ▁ strErrorFile = % s \n " , strLogDir . c_str ( ) , strErrorFile . c_str ( ) ) ; dbenv . set_lg_dir ( strLogDir . c_str ( ) ) ; dbenv . set_lg_max ( 10000000 ) ; dbenv . set_lk_max_locks ( 10000 ) ; dbenv . set_lk_max_objects ( 10000 ) ; dbenv . set_errfile ( fopen ( strErrorFile . c_str ( ) , " a " ) ) ; // / ▁ debug ENDCOM dbenv . set_flags ( DB_AUTO_COMMIT , 1 ) ; ret = dbenv . open ( strDataDir . c_str ( ) , DB_CREATE | DB_INIT_LOCK | DB_INIT_LOG | DB_INIT_MPOOL | DB_INIT_TXN | DB_THREAD | DB_RECOVER , S_IRUSR | S_IWUSR ) ; if ( ret > 0 ) throw runtime_error ( strprintf ( " CDB ( ) ▁ : ▁ error ▁ % d ▁ opening ▁ database ▁ environment " , ret ) ) ; fDbEnvInit = true ; } strFile = pszFile ; ++ mapFileUseCount [ strFile ] ; pdb = mapDb [ strFile ] ; if ( pdb == NULL ) { pdb = new Db ( & dbenv , 0 ) ; ret = pdb -> open ( NULL , // ▁ Txn ▁ pointer ENDCOM pszFile , // ▁ Filename ENDCOM " main " , // ▁ Logical ▁ db ▁ name ENDCOM DB_BTREE , // ▁ Database ▁ type ENDCOM nFlags , // ▁ Flags ENDCOM 0 ) ; if ( ret > 0 ) { delete pdb ; pdb = NULL ; CRITICAL_BLOCK ( cs_db ) -- mapFileUseCount [ strFile ] ; strFile = " " ; throw runtime_error ( strprintf ( " CDB ( ) ▁ : ▁ can ' t ▁ open ▁ database ▁ file ▁ % s , ▁ error ▁ % d " , pszFile , ret ) ) ; } if ( fCreate && ! Exists ( string ( " version " ) ) ) { bool fTmp = fReadOnly ; fReadOnly = false ; WriteVersion ( VERSION ) ; fReadOnly = fTmp ; } mapDb [ strFile ] = pdb ; } } } void CDB :: Close ( ) { if ( ! pdb ) return ; if ( ! vTxn . empty ( ) ) vTxn . front ( ) -> abort ( ) ; vTxn . clear ( ) ; pdb = NULL ; // ▁ Flush ▁ database ▁ activity ▁ from ▁ memory ▁ pool ▁ to ▁ disk ▁ log ENDCOM unsigned int nMinutes = 0 ; if ( fReadOnly ) nMinutes = 1 ; if ( strFile == " addr . dat " ) nMinutes = 2 ; if ( strFile == " blkindex . dat " && IsInitialBlockDownload ( ) && nBestHeight % 500 != 0 ) nMinutes = 1 ; dbenv . txn_checkpoint ( 0 , nMinutes , 0 ) ; CRITICAL_BLOCK ( cs_db ) -- mapFileUseCount [ strFile ] ; } void static CloseDb ( const string & strFile ) { CRITICAL_BLOCK ( cs_db ) { if ( mapDb [ strFile ] != NULL ) { // ▁ Close ▁ the ▁ database ▁ handle ENDCOM Db * pdb = mapDb [ strFile ] ; pdb -> close ( 0 ) ; delete pdb ; mapDb [ strFile ] = NULL ; } } } void DBFlush ( bool fShutdown ) { // ▁ Flush ▁ log ▁ data ▁ to ▁ the ▁ actual ▁ data ▁ file ENDCOM // ▁ on ▁ all ▁ files ▁ that ▁ are ▁ not ▁ in ▁ use ENDCOM printf ( " DBFlush ( % s ) % s \n " , fShutdown ? " true " : " false " , fDbEnvInit ? " " : " ▁ db ▁ not ▁ started " ) ; if ( ! fDbEnvInit ) return ; CRITICAL_BLOCK ( cs_db ) { map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { string strFile = ( * mi ) . first ; int nRefCount = ( * mi ) . second ; printf ( " % s ▁ refcount = % d \n " , strFile . c_str ( ) , nRefCount ) ; if ( nRefCount == 0 ) { // ▁ Move ▁ log ▁ data ▁ to ▁ the ▁ dat ▁ file ENDCOM CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; printf ( " % s ▁ flush \n " , strFile . c_str ( ) ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; } else mi ++ ; } if ( fShutdown ) { char * * listp ; if ( mapFileUseCount . empty ( ) ) dbenv . log_archive ( & listp , DB_ARCH_REMOVE ) ; dbenv . close ( 0 ) ; fDbEnvInit = false ; } } } // ▁ CTxDB ENDCOM bool CTxDB :: ReadTxIndex ( uint256 hash , CTxIndex & txindex ) { assert ( ! fClient ) ; txindex . SetNull ( ) ; return Read ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: UpdateTxIndex ( uint256 hash , const CTxIndex & txindex ) { assert ( ! fClient ) ; return Write ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: AddTxIndex ( const CTransaction & tx , const CDiskTxPos & pos , int nHeight ) { assert ( ! fClient ) ; // ▁ Add ▁ to ▁ tx ▁ index ENDCOM uint256 hash = tx . GetHash ( ) ; CTxIndex txindex ( pos , tx . vout . size ( ) ) ; return Write ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: EraseTxIndex ( const CTransaction & tx ) { assert ( ! fClient ) ; uint256 hash = tx . GetHash ( ) ; return Erase ( make_pair ( string ( " tx " ) , hash ) ) ; } bool CTxDB :: ContainsTx ( uint256 hash ) { assert ( ! fClient ) ; return Exists ( make_pair ( string ( " tx " ) , hash ) ) ; } bool CTxDB :: ReadOwnerTxes ( uint160 hash160 , int nMinHeight , vector < CTransaction > & vtx ) { assert ( ! fClient ) ; vtx . clear ( ) ; // ▁ Get ▁ cursor ENDCOM Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; unsigned int fFlags = DB_SET_RANGE ; loop { // ▁ Read ▁ next ▁ record ENDCOM CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << string ( " owner " ) << hash160 << CDiskTxPos ( 0 , 0 , 0 ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) { pcursor -> close ( ) ; return false ; } // ▁ Unserialize ENDCOM string strType ; uint160 hashItem ; CDiskTxPos pos ; ssKey >> strType >> hashItem >> pos ; int nItemHeight ; ssValue >> nItemHeight ; // ▁ Read ▁ transaction ENDCOM if ( strType != " owner " || hashItem != hash160 ) break ; if ( nItemHeight >= nMinHeight ) { vtx . resize ( vtx . size ( ) + 1 ) ; if ( ! vtx . back ( ) . ReadFromDisk ( pos ) ) { pcursor -> close ( ) ; return false ; } } } pcursor -> close ( ) ; return true ; } bool CTxDB :: ReadDiskTx ( uint256 hash , CTransaction & tx , CTxIndex & txindex ) { assert ( ! fClient ) ; tx . SetNull ( ) ; if ( ! ReadTxIndex ( hash , txindex ) ) return false ; return ( tx . ReadFromDisk ( txindex . pos ) ) ; } bool CTxDB :: ReadDiskTx ( uint256 hash , CTransaction & tx ) { CTxIndex txindex ; return ReadDiskTx ( hash , tx , txindex ) ; } bool CTxDB :: ReadDiskTx ( COutPoint outpoint , CTransaction & tx , CTxIndex & txindex ) { return ReadDiskTx ( outpoint . hash , tx , txindex ) ; } bool CTxDB :: ReadDiskTx ( COutPoint outpoint , CTransaction & tx ) { CTxIndex txindex ; return ReadDiskTx ( outpoint . hash , tx , txindex ) ; } bool CTxDB :: WriteBlockIndex ( const CDiskBlockIndex & blockindex ) { return Write ( make_pair ( string ( " blockindex " ) , blockindex . GetBlockHash ( ) ) , blockindex ) ; } bool CTxDB :: EraseBlockIndex ( uint256 hash ) { return Erase ( make_pair ( string ( " blockindex " ) , hash ) ) ; } bool CTxDB :: ReadHashBestChain ( uint256 & hashBestChain ) { return Read ( string ( " hashBestChain " ) , hashBestChain ) ; } bool CTxDB :: WriteHashBestChain ( uint256 hashBestChain ) { return Write ( string ( " hashBestChain " ) , hashBestChain ) ; } bool CTxDB :: ReadBestInvalidWork ( CBigNum & bnBestInvalidWork ) { return Read ( string ( " bnBestInvalidWork " ) , bnBestInvalidWork ) ; } bool CTxDB :: WriteBestInvalidWork ( CBigNum bnBestInvalidWork ) { return Write ( string ( " bnBestInvalidWork " ) , bnBestInvalidWork ) ; } CBlockIndex static * InsertBlockIndex ( uint256 hash ) { if ( hash == 0 ) return NULL ; // ▁ Return ▁ existing ENDCOM map < uint256 , CBlockIndex * > :: iterator mi = mapBlockIndex . find ( hash ) ; if ( mi != mapBlockIndex . end ( ) ) return ( * mi ) . second ; // ▁ Create ▁ new ENDCOM CBlockIndex * pindexNew = new CBlockIndex ( ) ; if ( ! pindexNew ) throw runtime_error ( " LoadBlockIndex ( ) ▁ : ▁ new ▁ CBlockIndex ▁ failed " ) ; mi = mapBlockIndex . insert ( make_pair ( hash , pindexNew ) ) . first ; pindexNew -> phashBlock = & ( ( * mi ) . first ) ; return pindexNew ; } bool CTxDB :: LoadBlockIndex ( ) { // ▁ Get ▁ database ▁ cursor ENDCOM Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; // ▁ Load ▁ mapBlockIndex ENDCOM unsigned int fFlags = DB_SET_RANGE ; loop { // ▁ Read ▁ next ▁ record ENDCOM CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << make_pair ( string ( " blockindex " ) , uint256 ( 0 ) ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; // ▁ Unserialize ENDCOM string strType ; ssKey >> strType ; if ( strType == " blockindex " ) { CDiskBlockIndex diskindex ; ssValue >> diskindex ; // ▁ Construct ▁ block ▁ index ▁ object ENDCOM CBlockIndex * pindexNew = InsertBlockIndex ( diskindex . GetBlockHash ( ) ) ; pindexNew -> pprev = InsertBlockIndex ( diskindex . hashPrev ) ; pindexNew -> pnext = InsertBlockIndex ( diskindex . hashNext ) ; pindexNew -> nFile = diskindex . nFile ; pindexNew -> nBlockPos = diskindex . nBlockPos ; pindexNew -> nHeight = diskindex . nHeight ; pindexNew -> nVersion = diskindex . nVersion ; pindexNew -> hashMerkleRoot = diskindex . hashMerkleRoot ; pindexNew -> nTime = diskindex . nTime ; pindexNew -> nBits = diskindex . nBits ; pindexNew -> nNonce = diskindex . nNonce ; pindexNew -> auxpow = diskindex . auxpow ; // ▁ Watch ▁ for ▁ genesis ▁ block ENDCOM if ( pindexGenesisBlock == NULL && diskindex . GetBlockHash ( ) == hashGenesisBlock ) pindexGenesisBlock = pindexNew ; if ( ! pindexNew -> CheckIndex ( ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ CheckIndex ▁ failed ▁ at ▁ % d " , pindexNew -> nHeight ) ; } else { break ; } } pcursor -> close ( ) ; // ▁ Calculate ▁ bnChainWork ENDCOM vector < pair < int , CBlockIndex * > > vSortedByHeight ; vSortedByHeight . reserve ( mapBlockIndex . size ( ) ) ; BOOST_FOREACH ( const PAIRTYPE ( uint256 , CBlockIndex * ) & item , mapBlockIndex ) { CBlockIndex * pindex = item . second ; vSortedByHeight . push_back ( make_pair ( pindex -> nHeight , pindex ) ) ; } sort ( vSortedByHeight . begin ( ) , vSortedByHeight . end ( ) ) ; BOOST_FOREACH ( const PAIRTYPE ( int , CBlockIndex * ) & item , vSortedByHeight ) { CBlockIndex * pindex = item . second ; pindex -> bnChainWork = ( pindex -> pprev ? pindex -> pprev -> bnChainWork : 0 ) + pindex -> GetBlockWork ( ) ; } // ▁ Load ▁ hashBestChain ▁ pointer ▁ to ▁ end ▁ of ▁ best ▁ chain ENDCOM if ( ! ReadHashBestChain ( hashBestChain ) ) { if ( pindexGenesisBlock == NULL ) return true ; return error ( " CTxDB : : LoadBlockIndex ( ) ▁ : ▁ hashBestChain ▁ not ▁ loaded " ) ; } if ( ! mapBlockIndex . count ( hashBestChain ) ) return error ( " CTxDB : : LoadBlockIndex ( ) ▁ : ▁ hashBestChain ▁ not ▁ found ▁ in ▁ the ▁ block ▁ index " ) ; pindexBest = mapBlockIndex [ hashBestChain ] ; nBestHeight = pindexBest -> nHeight ; bnBestChainWork = pindexBest -> bnChainWork ; printf ( " LoadBlockIndex ( ) : ▁ hashBestChain = % s ▁ ▁ height = % d \n " , hashBestChain . ToString ( ) . substr ( 0 , 20 ) . c_str ( ) , nBestHeight ) ; // ▁ Load ▁ bnBestInvalidWork , ▁ OK ▁ if ▁ it ▁ doesn ' t ▁ exist ENDCOM ReadBestInvalidWork ( bnBestInvalidWork ) ; // ▁ Verify ▁ blocks ▁ in ▁ the ▁ best ▁ chain ENDCOM CBlockIndex * pindexFork = NULL ; for ( CBlockIndex * pindex = pindexBest ; pindex && pindex -> pprev ; pindex = pindex -> pprev ) { if ( pindex -> nHeight < nBestHeight - 2500 && ! mapArgs . count ( " - checkblocks " ) ) break ; CBlock block ; if ( ! block . ReadFromDisk ( pindex ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ block . ReadFromDisk ▁ failed " ) ; if ( ! block . CheckBlock ( pindex -> nHeight ) ) { printf ( " LoadBlockIndex ( ) ▁ : ▁ * * * ▁ found ▁ bad ▁ block ▁ at ▁ % d , ▁ hash = % s \n " , pindex -> nHeight , pindex -> GetBlockHash ( ) . ToString ( ) . c_str ( ) ) ; pindexFork = pindex -> pprev ; } } if ( pindexFork ) { // ▁ Reorg ▁ back ▁ to ▁ the ▁ fork ENDCOM printf ( " LoadBlockIndex ( ) ▁ : ▁ * * * ▁ moving ▁ best ▁ chain ▁ pointer ▁ back ▁ to ▁ block ▁ % d \n " , pindexFork -> nHeight ) ; CBlock block ; if ( ! block . ReadFromDisk ( pindexFork ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ block . ReadFromDisk ▁ failed " ) ; CTxDB txdb ; block . SetBestChain ( txdb , pindexFork ) ; } return true ; } // ▁ CAddrDB ENDCOM bool CAddrDB :: WriteAddress ( const CAddress & addr ) { return Write ( make_pair ( string ( " addr " ) , addr . GetKey ( ) ) , addr ) ; } bool CAddrDB :: EraseAddress ( const CAddress & addr ) { return Erase ( make_pair ( string ( " addr " ) , addr . GetKey ( ) ) ) ; } bool CAddrDB :: LoadAddresses ( ) { CRITICAL_BLOCK ( cs_mapAddresses ) { // ▁ Load ▁ user ▁ provided ▁ addresses ENDCOM CAutoFile filein = fopen ( ( GetDataDir ( ) + " / addr . txt " ) . c_str ( ) , " rt " ) ; if ( filein ) { try { char psz [ 1000 ] ; while ( fgets ( psz , sizeof ( psz ) , filein ) ) { CAddress addr ( psz , NODE_NETWORK ) ; addr . nTime = 0 ; // ▁ so ▁ it ▁ won ' t ▁ relay ▁ unless ▁ successfully ▁ connected ENDCOM if ( addr . IsValid ( ) ) AddAddress ( addr ) ; } } catch ( ... ) { } } // ▁ Get ▁ cursor ENDCOM Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; loop { // ▁ Read ▁ next ▁ record ENDCOM CDataStream ssKey ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue ) ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; // ▁ Unserialize ENDCOM string strType ; ssKey >> strType ; if ( strType == " addr " ) { CAddress addr ; ssValue >> addr ; mapAddresses . insert ( make_pair ( addr . GetKey ( ) , addr ) ) ; } } pcursor -> close ( ) ; printf ( " Loaded ▁ % d ▁ addresses \n " , mapAddresses . size ( ) ) ; } return true ; } bool LoadAddresses ( ) { return CAddrDB ( " cr + " ) . LoadAddresses ( ) ; } // ▁ CWalletDB ENDCOM bool CWalletDB :: WriteName ( const string & strAddress , const string & strName ) { nWalletDBUpdated ++ ; return Write ( make_pair ( string ( " name " ) , strAddress ) , strName ) ; } bool CWalletDB :: EraseName ( const string & strAddress ) { // ▁ This ▁ should ▁ only ▁ be ▁ used ▁ for ▁ sending ▁ addresses , ▁ never ▁ for ▁ receiving ▁ addresses , ENDCOM // ▁ receiving ▁ addresses ▁ must ▁ always ▁ have ▁ an ▁ address ▁ book ▁ entry ▁ if ▁ they ' re ▁ not ▁ change ▁ return . ENDCOM nWalletDBUpdated ++ ; return Erase ( make_pair ( string ( " name " ) , strAddress ) ) ; } bool CWalletDB :: ReadAccount ( const string & strAccount , CAccount & account ) { account . SetNull ( ) ; return Read ( make_pair ( string ( " acc " ) , strAccount ) , account ) ; } bool CWalletDB :: WriteAccount ( const string & strAccount , const CAccount & account ) { return Write ( make_pair ( string ( " acc " ) , strAccount ) , account ) ; } bool CWalletDB :: WriteAccountingEntry ( const CAccountingEntry & acentry ) { return Write ( make_tuple ( string ( " acentry " ) , acentry . strAccount , ++ nAccountingEntryNumber ) , acentry ) ; } int64 CWalletDB :: GetAccountCreditDebit ( const string & strAccount ) { list < CAccountingEntry > entries ; ListAccountCreditDebit ( strAccount , entries ) ; int64 nCreditDebit = 0 ; BOOST_FOREACH ( const CAccountingEntry & entry , entries ) nCreditDebit += entry . nCreditDebit ; return nCreditDebit ; } void CWalletDB :: ListAccountCreditDebit ( const string & strAccount , list < CAccountingEntry > & entries ) { int64 nCreditDebit = 0 ; bool fAllAccounts = ( strAccount == " * " ) ; Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) throw runtime_error ( " CWalletDB : : ListAccountCreditDebit ( ) ▁ : ▁ cannot ▁ create ▁ DB ▁ cursor " ) ; unsigned int fFlags = DB_SET_RANGE ; loop { // ▁ Read ▁ next ▁ record ENDCOM CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << make_tuple ( string ( " acentry " ) , ( fAllAccounts ? string ( " " ) : strAccount ) , uint64 ( 0 ) ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) { pcursor -> close ( ) ; throw runtime_error ( " CWalletDB : : ListAccountCreditDebit ( ) ▁ : ▁ error ▁ scanning ▁ DB " ) ; } // ▁ Unserialize ENDCOM string strType ; ssKey >> strType ; if ( strType != " acentry " ) break ; CAccountingEntry acentry ; ssKey >> acentry . strAccount ; if ( ! fAllAccounts && acentry . strAccount != strAccount ) break ; ssValue >> acentry ; entries . push_back ( acentry ) ; } pcursor -> close ( ) ; } bool CWalletDB :: LoadWallet ( CWallet * pwallet ) { pwallet -> vchDefaultKey . clear ( ) ; int nFileVersion = 0 ; vector < uint256 > vWalletUpgrade ; // ▁ Modify ▁ defaults ENDCOM # ifndef __WXMSW__ // ▁ Tray ▁ icon ▁ sometimes ▁ disappears ▁ on ▁ 9.10 ▁ karmic ▁ koala ▁ 64 - bit , ▁ leaving ▁ no ▁ way ▁ to ▁ access ▁ the ▁ program ENDCOM fMinimizeToTray = false ; fMinimizeOnClose = false ; # endif // // ▁ todo : ▁ shouldn ' t ▁ we ▁ catch ▁ exceptions ▁ and ▁ try ▁ to ▁ recover ▁ and ▁ continue ? ENDCOM CRITICAL_BLOCK ( pwallet -> cs_mapWallet ) CRITICAL_BLOCK ( pwallet -> cs_mapKeys ) { // ▁ Get ▁ cursor ENDCOM Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; loop { // ▁ Read ▁ next ▁ record ENDCOM CDataStream ssKey ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue ) ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; // ▁ Unserialize ENDCOM // ▁ Taking ▁ advantage ▁ of ▁ the ▁ fact ▁ that ▁ pair ▁ serialization ENDCOM // ▁ is ▁ just ▁ the ▁ two ▁ items ▁ serialized ▁ one ▁ after ▁ the ▁ other ENDCOM string strType ; ssKey >> strType ; if ( strType == " name " ) { string strAddress ; ssKey >> strAddress ; ssValue >> pwallet -> mapAddressBook [ strAddress ] ; } else if ( strType == " tx " ) { uint256 hash ; ssKey >> hash ; CWalletTx & wtx = pwallet -> mapWallet [ hash ] ; ssValue >> wtx ; wtx . pwallet = pwallet ; if ( wtx . GetHash ( ) != hash ) printf ( " Error ▁ in ▁ wallet . dat , ▁ hash ▁ mismatch \n " ) ; // ▁ Undo ▁ serialize ▁ changes ▁ in ▁ 31600 ENDCOM if ( 31404 <= wtx . fTimeReceivedIsTxTime && wtx . fTimeReceivedIsTxTime <= 31703 ) { if ( ! ssValue . empty ( ) ) { char fTmp ; char fUnused ; ssValue >> fTmp >> fUnused >> wtx . strFromAccount ; printf ( " LoadWallet ( ) ▁ upgrading ▁ tx ▁ ver = % d ▁ % d ▁ ' % s ' ▁ % s \n " , wtx . fTimeReceivedIsTxTime , fTmp , wtx . strFromAccount . c_str ( ) , hash . ToString ( ) . c_str ( ) ) ; wtx . fTimeReceivedIsTxTime = fTmp ; } else { printf ( " LoadWallet ( ) ▁ repairing ▁ tx ▁ ver = % d ▁ % s \n " , wtx . fTimeReceivedIsTxTime , hash . ToString ( ) . c_str ( ) ) ; wtx . fTimeReceivedIsTxTime = 0 ; } vWalletUpgrade . push_back ( hash ) ; } // // ▁ debug ▁ print ENDCOM // printf ( " LoadWallet ▁ % s \n " , ▁ wtx . GetHash ( ) . ToString ( ) . c _ str ( ) ) ; ENDCOM // printf ( " ▁ % 12I64d ▁ % s ▁ % s ▁ % s \n " , ENDCOM // ▁ wtx . vout [ 0 ] . nValue , ENDCOM // ▁ DateTimeStrFormat ( " % x ▁ % H : % M : % S " , ▁ wtx . GetBlockTime ( ) ) . c _ str ( ) , ENDCOM // ▁ wtx . hashBlock . ToString ( ) . substr ( 0,20 ) . c _ str ( ) , ENDCOM // ▁ wtx . mapValue [ " message " ] . c _ str ( ) ) ; ENDCOM } else if ( strType == " acentry " ) { string strAccount ; ssKey >> strAccount ; uint64 nNumber ; ssKey >> nNumber ; if ( nNumber > nAccountingEntryNumber ) nAccountingEntryNumber = nNumber ; } else if ( strType == " key " || strType == " wkey " ) { vector < unsigned char > vchPubKey ; ssKey >> vchPubKey ; CWalletKey wkey ; if ( strType == " key " ) ssValue >> wkey . vchPrivKey ; else ssValue >> wkey ; pwallet -> mapKeys [ vchPubKey ] = wkey . vchPrivKey ; mapPubKeys [ Hash160 ( vchPubKey ) ] = vchPubKey ; } else if ( strType == " defaultkey " ) { ssValue >> pwallet -> vchDefaultKey ; } else if ( strType == " pool " ) { int64 nIndex ; ssKey >> nIndex ; pwallet -> setKeyPool . insert ( nIndex ) ; } else if ( strType == " version " ) { ssValue >> nFileVersion ; if ( nFileVersion == 10300 ) nFileVersion = 300 ; } else if ( strType == " setting " ) { string strKey ; ssKey >> strKey ; // ▁ Options ENDCOM # ifndef GUI if ( strKey == " fGenerateBitcoins " ) ssValue >> fGenerateBitcoins ; # endif if ( strKey == " nTransactionFee " ) ssValue >> nTransactionFee ; if ( strKey == " addrIncoming " ) ssValue >> addrIncoming ; if ( strKey == " fLimitProcessors " ) ssValue >> fLimitProcessors ; if ( strKey == " nLimitProcessors " ) ssValue >> nLimitProcessors ; if ( strKey == " fMinimizeToTray " ) ssValue >> fMinimizeToTray ; if ( strKey == " fMinimizeOnClose " ) ssValue >> fMinimizeOnClose ; if ( strKey == " fUseProxy " ) ssValue >> fUseProxy ; if ( strKey == " addrProxy " ) ssValue >> addrProxy ; if ( fHaveUPnP && strKey == " fUseUPnP " ) ssValue >> fUseUPnP ; } } pcursor -> close ( ) ; } BOOST_FOREACH ( uint256 hash , vWalletUpgrade ) WriteTx ( hash , pwallet -> mapWallet [ hash ] ) ; printf ( " nFileVersion ▁ = ▁ % d \n " , nFileVersion ) ; printf ( " fGenerateBitcoins ▁ = ▁ % d \n " , fGenerateBitcoins ) ; printf ( " nTransactionFee ▁ = ▁ % " PRI64d " \n " , nTransactionFee ) ; printf ( " addrIncoming ▁ = ▁ % s \n " , addrIncoming . ToString ( ) . c_str ( ) ) ; printf ( " fMinimizeToTray ▁ = ▁ % d \n " , fMinimizeToTray ) ; printf ( " fMinimizeOnClose ▁ = ▁ % d \n " , fMinimizeOnClose ) ; printf ( " fUseProxy ▁ = ▁ % d \n " , fUseProxy ) ; printf ( " addrProxy ▁ = ▁ % s \n " , addrProxy . ToString ( ) . c_str ( ) ) ; if ( fHaveUPnP ) printf ( " fUseUPnP ▁ = ▁ % d \n " , fUseUPnP ) ; // ▁ Upgrade ENDCOM if ( nFileVersion < VERSION ) { // ▁ Get ▁ rid ▁ of ▁ old ▁ debug . log ▁ file ▁ in ▁ current ▁ directory ENDCOM if ( nFileVersion <= 105 && ! pszSetDataDir [ 0 ] ) unlink ( " debug . log " ) ; WriteVersion ( VERSION ) ; } return true ; } void ThreadFlushWalletDB ( void * parg ) { const string & strFile = ( ( const string * ) parg ) [ 0 ] ; static bool fOneThread ; if ( fOneThread ) return ; fOneThread = true ; if ( mapArgs . count ( " - noflushwallet " ) ) return ; unsigned int nLastSeen = nWalletDBUpdated ; unsigned int nLastFlushed = nWalletDBUpdated ; int64 nLastWalletUpdate = GetTime ( ) ; while ( ! fShutdown ) { Sleep ( 500 ) ; if ( nLastSeen != nWalletDBUpdated ) { nLastSeen = nWalletDBUpdated ; nLastWalletUpdate = GetTime ( ) ; } if ( nLastFlushed != nWalletDBUpdated && GetTime ( ) - nLastWalletUpdate >= 2 ) { TRY_CRITICAL_BLOCK ( cs_db ) { // ▁ Don ' t ▁ do ▁ this ▁ if ▁ any ▁ databases ▁ are ▁ in ▁ use ENDCOM int nRefCount = 0 ; map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { nRefCount += ( * mi ) . second ; mi ++ ; } if ( nRefCount == 0 && ! fShutdown ) { map < string , int > :: iterator mi = mapFileUseCount . find ( strFile ) ; if ( mi != mapFileUseCount . end ( ) ) { printf ( " % s ▁ " , DateTimeStrFormat ( " % x ▁ % H : % M : % S " , GetTime ( ) ) . c_str ( ) ) ; printf ( " Flushing ▁ wallet . dat \n " ) ; nLastFlushed = nWalletDBUpdated ; int64 nStart = GetTimeMillis ( ) ; // ▁ Flush ▁ wallet . dat ▁ so ▁ it ' s ▁ self ▁ contained ENDCOM CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; printf ( " Flushed ▁ wallet . dat ▁ % " PRI64d " ms \n " , GetTimeMillis ( ) - nStart ) ; } } } } } } bool BackupWallet ( const CWallet & wallet , const string & strDest ) { if ( ! wallet . fFileBacked ) return false ; while ( ! fShutdown ) { CRITICAL_BLOCK ( cs_db ) { if ( ! mapFileUseCount . count ( wallet . strWalletFile ) || mapFileUseCount [ wallet . strWalletFile ] == 0 ) { // ▁ Flush ▁ log ▁ data ▁ to ▁ the ▁ dat ▁ file ENDCOM CloseDb ( wallet . strWalletFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( wallet . strWalletFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( wallet . strWalletFile ) ; // ▁ Copy ▁ wallet . dat ENDCOM filesystem :: path pathSrc ( GetDataDir ( ) + " / " + wallet . strWalletFile ) ; filesystem :: path pathDest ( strDest ) ; if ( filesystem :: is_directory ( pathDest ) ) pathDest = pathDest / wallet . strWalletFile ; # if BOOST_VERSION >= 104000 filesystem :: copy_file ( pathSrc , pathDest , filesystem :: copy_option :: overwrite_if_exists ) ; # else filesystem :: copy_file ( pathSrc , pathDest ) ; # endif printf ( " copied ▁ wallet . dat ▁ to ▁ % s \n " , pathDest . string ( ) . c_str ( ) ) ; return true ; } } Sleep ( 100 ) ; } return false ; } </DOCUMENT>
<DOCUMENT_ID="bredelings/BAli-Phy/tree/master/external/range-v3/0.4.0/test/algorithm/minmax.cpp"> // ▁ Range ▁ v3 ▁ library ENDCOM // ▁ Copyright ▁ Eric ▁ Niebler ▁ 2014 - present ENDCOM // ▁ Copyright ▁ Casey ▁ Carter ▁ 2015 ENDCOM // ▁ Use , ▁ modification ▁ and ▁ distribution ▁ is ▁ subject ▁ to ▁ the ENDCOM // ▁ Boost ▁ Software ▁ License , ▁ Version ▁ 1.0 . ▁ ( See ▁ accompanying ENDCOM // ▁ file ▁ LICENSE _ 1_0 . txt ▁ or ▁ copy ▁ at ENDCOM // ▁ http : // www . boost . org / LICENSE _ 1_0 . txt ) ENDCOM // ▁ Project ▁ home : ▁ https : // github . com / ericniebler / range - v3 ENDCOM // ▁ The ▁ LLVM ▁ Compiler ▁ Infrastructure ENDCOM // ▁ This ▁ file ▁ is ▁ dual ▁ licensed ▁ under ▁ the ▁ MIT ▁ and ▁ the ▁ University ▁ of ▁ Illinois ▁ Open ENDCOM // ▁ Source ▁ Licenses . ▁ See ▁ LICENSE . TXT ▁ for ▁ details . ENDCOM # include < range / v3 / algorithm / minmax . hpp > # include < memory > # include < numeric > # include < random > # include < algorithm > # include " . . / simple _ test . hpp " # include " . . / test _ utils . hpp " # include " . . / test _ iterators . hpp " RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS namespace { std :: mt19937 gen ; template < class Iter , class Sent = Iter > void test_iter ( Iter first , Sent last ) { RANGES_ENSURE ( first != last ) ; auto rng = ranges :: make_iterator_range ( first , last ) ; auto res = ranges :: minmax ( rng ) ; for ( Iter i = first ; i != last ; ++ i ) { CHECK ( ! ( * i < res . first ) ) ; CHECK ( ! ( res . second < * i ) ) ; } } template < class Iter , class Sent = Iter > void test_iter ( unsigned N ) { RANGES_ENSURE ( N > 0 ) ; std :: unique_ptr < int [ ] > a { new int [ N ] } ; std :: iota ( a . get ( ) , a . get ( ) + N , 0 ) ; std :: shuffle ( a . get ( ) , a . get ( ) + N , gen ) ; test_iter ( Iter ( a . get ( ) ) , Sent ( a . get ( ) + N ) ) ; } template < class Iter , class Sent = Iter > void test_iter ( ) { test_iter < Iter , Sent > ( 1 ) ; test_iter < Iter , Sent > ( 2 ) ; test_iter < Iter , Sent > ( 3 ) ; test_iter < Iter , Sent > ( 10 ) ; test_iter < Iter , Sent > ( 1000 ) ; } template < class Iter , class Sent = Iter > void test_iter_comp ( Iter first , Sent last ) { RANGES_ENSURE ( first != last ) ; typedef std :: greater < int > Compare ; Compare comp ; auto rng = ranges :: make_iterator_range ( first , last ) ; auto res = ranges :: minmax ( rng , comp ) ; for ( Iter i = first ; i != last ; ++ i ) { CHECK ( ! comp ( * i , res . first ) ) ; CHECK ( ! comp ( res . second , * i ) ) ; } } template < class Iter , class Sent = Iter > void test_iter_comp ( unsigned N ) { RANGES_ENSURE ( N > 0 ) ; std :: unique_ptr < int [ ] > a { new int [ N ] } ; std :: iota ( a . get ( ) , a . get ( ) + N , 0 ) ; std :: shuffle ( a . get ( ) , a . get ( ) + N , gen ) ; test_iter_comp ( Iter ( a . get ( ) ) , Sent ( a . get ( ) + N ) ) ; } template < class Iter , class Sent = Iter > void test_iter_comp ( ) { test_iter_comp < Iter , Sent > ( 1 ) ; test_iter_comp < Iter , Sent > ( 2 ) ; test_iter_comp < Iter , Sent > ( 3 ) ; test_iter_comp < Iter , Sent > ( 10 ) ; test_iter_comp < Iter , Sent > ( 1000 ) ; } struct S { int value ; int index ; } ; } int main ( ) { test_iter < input_iterator < const int * > > ( ) ; test_iter < forward_iterator < const int * > > ( ) ; test_iter < bidirectional_iterator < const int * > > ( ) ; test_iter < random_access_iterator < const int * > > ( ) ; test_iter < const int * > ( ) ; test_iter < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < input_iterator < const int * > > ( ) ; test_iter < forward_iterator < const int * > > ( ) ; test_iter < bidirectional_iterator < const int * > > ( ) ; test_iter < random_access_iterator < const int * > > ( ) ; test_iter < const int * > ( ) ; test_iter < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < input_iterator < const int * > > ( ) ; test_iter_comp < forward_iterator < const int * > > ( ) ; test_iter_comp < bidirectional_iterator < const int * > > ( ) ; test_iter_comp < random_access_iterator < const int * > > ( ) ; test_iter_comp < const int * > ( ) ; test_iter_comp < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < input_iterator < const int * > > ( ) ; test_iter_comp < forward_iterator < const int * > > ( ) ; test_iter_comp < bidirectional_iterator < const int * > > ( ) ; test_iter_comp < random_access_iterator < const int * > > ( ) ; test_iter_comp < const int * > ( ) ; test_iter_comp < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; // ▁ Works ▁ with ▁ projections ? ENDCOM S s [ ] = { S { 1 , 0 } , S { 2 , 1 } , S { 3 , 2 } , S { 4 , 3 } , S { - 4 , 4 } , S { 40 , 5 } , S { - 4 , 6 } , S { 40 , 7 } , S { 7 , 8 } , S { 8 , 9 } , S { 9 , 10 } } ; auto res = ranges :: minmax ( s , std :: less < int > { } , & S :: value ) ; CHECK ( res . first . value == - 4 ) ; CHECK ( res . first . index == 4 ) ; CHECK ( res . second . value == 40 ) ; CHECK ( res . second . index == 7 ) ; return test_result ( ) ; } </DOCUMENT>
<DOCUMENT_ID="Baha/z3/tree/master/src/qe/qe_arith_plugin.cpp"> /* + + STRNEWLINE Copyright ▁ ( c ) ▁ 2010 ▁ Microsoft ▁ Corporation STRNEWLINE STRNEWLINE Module ▁ Name : STRNEWLINE STRNEWLINE ▁ arith _ plugin . cpp STRNEWLINE STRNEWLINE Abstract : STRNEWLINE STRNEWLINE ▁ Eliminate ▁ Arithmetical ▁ variable ▁ from ▁ formula STRNEWLINE STRNEWLINE Author : STRNEWLINE STRNEWLINE ▁ Nikolaj ▁ Bjorner ▁ ( nbjorner ) ▁ 2010-02-19 STRNEWLINE STRNEWLINE Revision ▁ History : STRNEWLINE STRNEWLINE STRNEWLINE - - */ # include " qe . h " # include " ast _ pp . h " # include " expr _ safe _ replace . h " # include " bool _ rewriter . h " # include " bv _ decl _ plugin . h " # include " arith _ decl _ plugin . h " # include " arith _ eq _ solver . h " # include " arith _ rewriter . h " # include " th _ rewriter . h " # include " factor _ rewriter . h " # include " obj _ pair _ hashtable . h " # include " nlarith _ util . h " # include " model _ evaluator . h " # include " smt _ kernel . h " namespace qe { class bound { rational m_coeff ; expr_ref m_term ; bool m_is_strict ; public : bound ( ast_manager & m , rational const & n , expr * t , bool is_strict ) : m_coeff ( n ) , m_term ( t , m ) , m_is_strict ( is_strict ) { } bool is_strict ( ) const { return m_is_strict ; } expr * term ( ) const { return m_term . get ( ) ; } rational const & coeff ( ) const { return m_coeff ; } void update ( rational const & k , expr * t ) { m_coeff = k ; m_term = t ; } void pp ( std :: ostream & out , app * x ) { ast_manager & m = m_term . get_manager ( ) ; out << " ( < = ▁ ( + ▁ ( * ▁ " << coeff ( ) << " ▁ " << mk_pp ( x , m ) << " ) ▁ " << mk_pp ( term ( ) , m ) << " ) ▁ 0 ) " ; } } ; typedef rational numeral ; // ▁ m _ k ▁ | ▁ ( m _ a ▁ * ▁ x ▁ + ▁ m _ term ) ENDCOM class div_constraint { numeral m_k ; numeral m_a ; expr * m_term ; public : div_constraint ( numeral const & k , numeral const & a , expr * t ) : m_k ( k ) , m_a ( a ) , m_term ( t ) { } numeral const & a ( ) const { return m_a ; } numeral const & k ( ) const { return m_k ; } expr * t ( ) const { return m_term ; } numeral & a_ref ( ) { return m_a ; } numeral & k_ref ( ) { return m_k ; } expr * & t_ref ( ) { return m_term ; } } ; typedef vector < div_constraint > div_constraints ; class arith_qe_util { ast_manager & m ; i_solver_context & m_ctx ; public : arith_util m_arith ; // ▁ initialize ▁ before ▁ m _ zero _ i , ▁ etc . ENDCOM th_rewriter simplify ; private : arith_eq_solver m_arith_solver ; bv_util m_bv ; expr_ref m_zero_i ; expr_ref m_one_i ; expr_ref m_minus_one_i ; expr_ref m_zero_r ; expr_ref m_one_r ; expr_ref m_tmp ; public : expr_safe_replace m_replace ; bool_rewriter m_bool_rewriter ; arith_rewriter m_arith_rewriter ; arith_qe_util ( ast_manager & m , smt_params & p , i_solver_context & ctx ) : m ( m ) , m_ctx ( ctx ) , m_arith ( m ) , simplify ( m ) , m_arith_solver ( m ) , m_bv ( m ) , m_zero_i ( m_arith . mk_numeral ( numeral ( 0 ) , true ) , m ) , m_one_i ( m_arith . mk_numeral ( numeral ( 1 ) , true ) , m ) , m_minus_one_i ( m_arith . mk_numeral ( numeral ( - 1 ) , true ) , m ) , m_zero_r ( m_arith . mk_numeral ( numeral ( 0 ) , false ) , m ) , m_one_r ( m_arith . mk_numeral ( numeral ( 1 ) , false ) , m ) , m_tmp ( m ) , m_replace ( m ) , m_bool_rewriter ( m ) , m_arith_rewriter ( m ) { } ast_manager & get_manager ( ) { return m ; } // ▁ match ▁ e ▁ : = ▁ k * x ▁ + ▁ rest , ▁ where ▁ k ▁ ! = ▁ 0 . ENDCOM bool get_coeff ( contains_app & contains_x , expr * p , rational & k , expr_ref & rest ) { app * x = contains_x . x ( ) ; ptr_vector < expr > restl , todo ; todo . push_back ( p ) ; bool found = false ; expr * e1 , * e2 ; while ( ! todo . empty ( ) ) { expr * e = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( e ) ) { for ( unsigned i = 0 ; i < to_app ( e ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( e ) -> get_arg ( i ) ) ; } } else if ( e == x ) { k = numeral ( 1 ) ; found = true ; break ; } else if ( m_arith . is_mul ( e , e1 , e2 ) && e1 == x && m_arith . is_numeral ( e2 , k ) ) { found = true ; break ; } else if ( m_arith . is_mul ( e , e1 , e2 ) && e2 == x && m_arith . is_numeral ( e1 , k ) ) { found = true ; break ; } else { restl . push_back ( e ) ; } } if ( ! found ) { TRACE ( " qe _ verbose " , tout << " Did ▁ not ▁ find : ▁ " << mk_pp ( x , m ) << " ▁ in ▁ " << mk_pp ( p , m ) << " \n " ; ) ; return false ; } while ( ! todo . empty ( ) ) { restl . push_back ( todo . back ( ) ) ; todo . pop_back ( ) ; } if ( restl . empty ( ) ) { rest = mk_zero ( x ) ; } else { rest = m_arith . mk_add ( restl . size ( ) , restl . c_ptr ( ) ) ; } if ( contains_x ( rest ) ) { return false ; } TRACE ( " qe _ verbose " , tout << mk_pp ( p , m ) << " ▁ = ▁ " << " ( + ▁ ( * ▁ " << k << " ▁ " << mk_pp ( x , m ) << " ) ▁ " << mk_pp ( rest , m ) << " ) \n " ; ) ; return true ; } // ▁ match ▁ p ▁ : = ▁ k ▁ + ▁ rest ENDCOM // ▁ where ▁ k ▁ is ▁ a ▁ numeral ▁ and ▁ rest ▁ does ▁ not ▁ contain ▁ numerals . ENDCOM void get_const ( expr * p , rational & k , expr_ref & rest ) { ptr_vector < expr > todo , restl ; todo . push_back ( p ) ; k = numeral ( 0 ) ; while ( ! todo . empty ( ) ) { p = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( p ) ) { for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } } else if ( m_arith . is_numeral ( p , k ) ) { break ; } else { restl . push_back ( p ) ; } } while ( ! todo . empty ( ) ) { restl . push_back ( todo . back ( ) ) ; todo . pop_back ( ) ; } if ( restl . empty ( ) ) { rest = mk_zero ( p ) ; } else { rest = m_arith . mk_add ( restl . size ( ) , restl . c_ptr ( ) ) ; } } // ▁ match ▁ ( not ▁ ne ) ENDCOM bool is_neg ( app * e , expr_ref & ne ) { if ( m . is_not ( e ) ) { ne = to_app ( e ) -> get_arg ( 0 ) ; return true ; } return false ; } bool is_le ( app * e , expr_ref & p ) { return is_le_ge_core < 1 > ( e , p ) ; } bool is_ge ( app * e , expr_ref & p ) { return is_le_ge_core < 0 > ( e , p ) ; } // ▁ match ▁ e ▁ = ▁ p ▁ < ▁ 0 ▁ or ▁ p ▁ > ▁ 0 ENDCOM bool is_lt ( app * e , expr_ref & p ) { numeral k ; expr * a1 , * a2 ; if ( m_arith . is_lt ( e , a1 , a2 ) || m_arith . is_gt ( e , a2 , a1 ) ) { p = a1 ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else { return false ; } p = mk_sub ( p , a2 ) ; simplify ( p ) ; return true ; } // ▁ match ▁ 0 ▁ = = ▁ p ▁ mod ▁ k , ▁ p ▁ mod ▁ k ▁ = = ▁ 0 ENDCOM bool is_divides ( app * e , numeral & k , expr_ref & p ) { expr * e1 , * e2 ; if ( ! m . is_eq ( e , e1 , e2 ) ) { return false ; } return is_divides ( e1 , e2 , k , p ) || is_divides ( e2 , e1 , k , p ) ; } bool is_divides ( expr * e1 , expr * e2 , numeral & k , expr_ref & p ) { if ( m_arith . is_mod ( e2 ) && m_arith . is_numeral ( e1 , k ) && k . is_zero ( ) && m_arith . is_numeral ( to_app ( e2 ) -> get_arg ( 1 ) , k ) ) { p = to_app ( e2 ) -> get_arg ( 0 ) ; return true ; } return false ; } bool is_not_divides ( app * e , app_ref & n , numeral & k , expr_ref & p ) { if ( ! m . is_not ( e ) ) { return false ; } if ( ! is_app ( to_app ( e ) -> get_arg ( 0 ) ) ) { return false ; } n = to_app ( to_app ( e ) -> get_arg ( 0 ) ) ; return is_divides ( n , k , p ) ; } bool is_real ( app * x ) const { return m_arith . is_real ( x ) ; } // ▁ b * t ▁ < = ▁ a * s ▁ ENDCOM template < bool is_strict > void mk_bound_aux ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { SASSERT ( a . is_neg ( ) == b . is_neg ( ) ) ; expr_ref tt ( t , m ) , ss ( s , m ) , e ( m ) ; // ▁ hack ▁ to ▁ fix ▁ wierd ▁ gcc ▁ compilation ▁ error ENDCOM rational abs_a ( a ) ; rational abs_b ( b ) ; if ( abs_a . is_neg ( ) ) abs_a . neg ( ) ; if ( abs_b . is_neg ( ) ) abs_b . neg ( ) ; ss = mk_mul ( abs_a , ss ) ; tt = mk_mul ( abs_b , tt ) ; if ( a . is_neg ( ) ) { e = mk_sub ( tt , ss ) ; if ( is_strict ) { if ( m_arith . is_int ( e ) ) { e = mk_add ( e , m_one_i ) ; mk_le ( e , result ) ; } else { mk_lt ( e , result ) ; } } else { mk_le ( e , result ) ; } } else { e = mk_sub ( ss , tt ) ; if ( is_strict ) { if ( m_arith . is_int ( e ) ) { e = mk_add ( e , m_one_i ) ; mk_le ( e , result ) ; } else { mk_lt ( e , result ) ; } } else { mk_le ( e , result ) ; } } } void mk_bound ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { mk_bound_aux < false > ( a , t , b , s , result ) ; } void mk_strict_bound ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { mk_bound_aux < true > ( a , t , b , s , result ) ; } void mk_divides ( numeral n , expr * e , expr_ref & result ) { SASSERT ( n . is_int ( ) ) ; expr_ref tmp1 ( e , m ) , tmp2 ( m ) ; simplify ( tmp1 ) ; m_arith_rewriter . mk_mod ( tmp1 , mk_numeral ( n ) , tmp2 ) ; m_bool_rewriter . mk_eq ( m_zero_i , tmp2 , result ) ; } void mk_div ( expr * a , numeral const & k , expr_ref & result ) { result = m_arith . mk_div ( a , m_arith . mk_numeral ( k , false ) ) ; simplify ( result ) ; } expr * mk_numeral ( numeral const & k , bool is_int = true ) { return m_arith . mk_numeral ( k , is_int ) ; } expr * mk_numeral ( int k , bool is_int ) { return mk_numeral ( numeral ( k ) , is_int ) ; } expr * mk_uminus ( expr * e ) { return m_arith . mk_uminus ( e ) ; } expr * mk_abs ( expr * e ) { rational val ; if ( m_arith . is_numeral ( e , val ) ) { if ( val . is_neg ( ) ) { return m_arith . mk_uminus ( e ) ; } else { return e ; } } else { return m . mk_ite ( m_arith . mk_le ( mk_zero ( e ) , e ) , e , m_arith . mk_uminus ( e ) ) ; } } template < bool is_max > expr_ref mk_min_max ( unsigned num_args , expr * const * args ) { SASSERT ( num_args > 0 ) ; if ( num_args == 1 ) { return expr_ref ( args [ 0 ] , m ) ; } else { expr_ref e2 = mk_min_max < is_max > ( num_args - 1 , args + 1 ) ; expr * e1 = args [ 0 ] ; expr * cmp = is_max ? m_arith . mk_le ( e1 , e2 ) : m_arith . mk_le ( e2 , e1 ) ; return expr_ref ( m . mk_ite ( cmp , e2 , e1 ) , m ) ; } } expr_ref mk_max ( unsigned num_args , expr * const * args ) { return mk_min_max < true > ( num_args , args ) ; } expr_ref mk_min ( unsigned num_args , expr * const * args ) { return mk_min_max < false > ( num_args , args ) ; } expr * mk_mul ( expr * a , expr * b ) { return m_arith . mk_mul ( a , b ) ; } expr * mk_add ( expr * a , expr * b ) { return m_arith . mk_add ( a , b ) ; } expr * mk_sub ( expr * a , expr * b ) { return m_arith . mk_sub ( a , b ) ; } expr * mk_mul ( numeral const & a , expr * b ) { if ( a . is_one ( ) ) return b ; return m_arith . mk_mul ( mk_numeral ( a , m_arith . is_int ( b ) ) , b ) ; } expr * mk_zero ( sort * s ) { return m_arith . is_int ( s ) ? m_zero_i : m_zero_r ; } expr * mk_zero ( expr * e ) { return m_arith . is_int ( e ) ? m_zero_i : m_zero_r ; } expr * mk_one ( sort * s ) { return m_arith . is_int ( s ) ? m_one_i : m_one_r ; } expr * mk_one ( expr * e ) { return m_arith . is_int ( e ) ? m_one_i : m_one_r ; } void mk_le ( expr * e , expr_ref & result ) { expr_ref tmp ( e , m ) ; simplify ( tmp ) ; m_arith_rewriter . mk_le ( tmp , mk_zero ( e ) , result ) ; } void mk_lt ( expr * e , expr_ref & result ) { rational r ; if ( m_arith . is_numeral ( e , r ) ) { if ( r . is_neg ( ) ) { result = m . mk_true ( ) ; } else { result = m . mk_false ( ) ; } } else if ( m_arith . is_int ( e ) ) { result = m_arith . mk_le ( e , m_minus_one_i ) ; } else { result = m . mk_not ( m_arith . mk_le ( mk_zero ( e ) , e ) ) ; } simplify ( result ) ; TRACE ( " qe _ verbose " , tout << " mk _ lt ▁ " << mk_pp ( result , m ) << " \n " ; ) ; } // ▁ ax ▁ + ▁ t ▁ = ▁ 0 ENDCOM void mk_eq ( rational const & a , app * x , expr * t , expr_ref & result ) { result = m_arith . mk_eq ( mk_add ( mk_mul ( a , x ) , t ) , mk_zero ( x ) ) ; } void mk_and ( unsigned sz , expr * const * args , expr_ref & result ) { m_bool_rewriter . mk_and ( sz , args , result ) ; } void mk_and ( expr * e1 , expr * e2 , expr_ref & result ) { m_bool_rewriter . mk_and ( e1 , e2 , result ) ; } void add_and ( expr * e , ptr_vector < expr > & conjs ) { if ( m . is_and ( e ) ) { conjs . append ( to_app ( e ) -> get_num_args ( ) , to_app ( e ) -> get_args ( ) ) ; } else { conjs . push_back ( e ) ; } } void mk_flat_and ( expr * e1 , expr * e2 , expr_ref & result ) { ptr_vector < expr > conjs ; add_and ( e1 , conjs ) ; add_and ( e2 , conjs ) ; m_bool_rewriter . mk_and ( conjs . size ( ) , conjs . c_ptr ( ) , result ) ; } void mk_or ( unsigned sz , expr * const * args , expr_ref & result ) { m_bool_rewriter . mk_or ( sz , args , result ) ; } void mk_or ( expr * e1 , expr * e2 , expr_ref & result ) { m_bool_rewriter . mk_or ( e1 , e2 , result ) ; } // ▁ b * t ▁ < = ▁ a * s ENDCOM void mk_resolve ( app * x , bool is_strict , rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { rational abs_a ( abs ( a ) ) , abs_b ( abs ( b ) ) ; SASSERT ( a . is_neg ( ) == b . is_pos ( ) ) ; SASSERT ( ! is_strict || ( abs_a . is_one ( ) && abs_b . is_one ( ) ) ) ; expr_ref bt ( mk_mul ( abs_b , t ) , m ) ; expr_ref as ( mk_mul ( abs_a , s ) , m ) ; expr_ref as_bt ( mk_add ( as , bt ) , m ) ; if ( is_strict ) { mk_lt ( as_bt , result ) ; } else { mk_le ( as_bt , result ) ; } if ( ! abs_a . is_one ( ) && ! abs_b . is_one ( ) ) { // ▁ integer ▁ resolution ▁ case . ▁ ENDCOM SASSERT ( ! is_strict ) ; SASSERT ( abs_a > rational :: one ( ) && abs_b > rational :: one ( ) ) ; expr_ref slack ( mk_numeral ( ( abs_a - numeral ( 1 ) ) * ( abs_b - numeral ( 1 ) ) , true ) , m ) ; expr_ref result1 ( m ) , result2 ( m ) ; // ▁ a * s ▁ + ▁ b * t ▁ < = ▁ 0 ENDCOM expr_ref as_bt_le_0 ( result , m ) , tmp2 ( m ) , asz_bt_le_0 ( m ) , tmp3 ( m ) , tmp4 ( m ) ; expr_ref b_divides_sz ( m ) ; // ▁ a * s ▁ + ▁ b * t ▁ + ▁ ( a - 1 ) ( b - 1 ) ▁ < = ▁ 0 ENDCOM tmp2 = m_arith . mk_add ( as_bt , slack ) ; mk_le ( tmp2 , result1 ) ; rational a1 = a , b1 = b ; if ( abs_a < abs_b ) { std :: swap ( abs_a , abs_b ) ; std :: swap ( a1 , b1 ) ; std :: swap ( s , t ) ; std :: swap ( as , bt ) ; } SASSERT ( abs_a >= abs_b ) ; // ▁ create ▁ finite ▁ disjunction ▁ for ▁ | b | . ▁ ENDCOM // ▁ exists ▁ x , ▁ z ▁ in ▁ [ 0 ▁ . . ▁ | b | - 2 ] ▁ . ▁ b * x ▁ + ▁ s ▁ + ▁ z ▁ = ▁ 0 ▁ & & ▁ ax ▁ + ▁ t ▁ < = ▁ 0 ▁ & & ▁ bx ▁ + ▁ s ▁ < = ▁ 0 ENDCOM // ▁ exists ▁ x , ▁ z ▁ in ▁ [ 0 ▁ . . ▁ | b | - 2 ] ▁ . ▁ b * x ▁ = ▁ - z ▁ - ▁ s ▁ & & ▁ ax ▁ + ▁ t ▁ < = ▁ 0 ▁ & & ▁ bx ▁ + ▁ s ▁ < = ▁ 0 ENDCOM // ▁ exists ▁ x , ▁ z ▁ in ▁ [ 0 ▁ . . ▁ | b | - 2 ] ▁ . ▁ b * x ▁ = ▁ - z ▁ - ▁ s ▁ & & ▁ a | b | x ▁ + ▁ | b | t ▁ < = ▁ 0 ▁ & & ▁ bx ▁ + ▁ s ▁ < = ▁ 0 ENDCOM // ▁ exists ▁ x , ▁ z ▁ in ▁ [ 0 ▁ . . ▁ | b | - 2 ] ▁ . ▁ b * x ▁ = ▁ - z ▁ - ▁ s ▁ & & ▁ a | b | x ▁ + ▁ | b | t ▁ < = ▁ 0 ▁ & & ▁ - z ▁ - ▁ s ▁ + ▁ s ▁ < = ▁ 0 ENDCOM // ▁ exists ▁ x , ▁ z ▁ in ▁ [ 0 ▁ . . ▁ | b | - 2 ] ▁ . ▁ b * x ▁ = ▁ - z ▁ - ▁ s ▁ & & ▁ a | b | x ▁ + ▁ | b | t ▁ < = ▁ 0 ▁ & & ▁ - z ▁ < = ▁ 0 ENDCOM // ▁ exists ▁ x , ▁ z ▁ in ▁ [ 0 ▁ . . ▁ | b | - 2 ] ▁ . ▁ b * x ▁ = ▁ - z ▁ - ▁ s ▁ & & ▁ a | b | x ▁ + ▁ | b | t ▁ < = ▁ 0 ENDCOM // ▁ exists ▁ x , ▁ z ▁ in ▁ [ 0 ▁ . . ▁ | b | - 2 ] ▁ . ▁ b * x ▁ = ▁ - z ▁ - ▁ s ▁ & & ▁ a * n _ sign ( b ) ( s ▁ + ▁ z ) ▁ + ▁ | b | t ▁ < = ▁ 0 ENDCOM // ▁ exists ▁ z ▁ in ▁ [ 0 ▁ . . ▁ | b | - 2 ] ▁ . ▁ | b | ▁ | ▁ ( z ▁ + ▁ s ) ▁ & & ▁ a * n _ sign ( b ) ( s ▁ + ▁ z ) ▁ + ▁ | b | t ▁ < = ▁ 0 ENDCOM expr_ref sz ( mk_add ( s , x ) , m ) ; if ( b1 . is_pos ( ) ) { sz = m_arith . mk_uminus ( sz ) ; } tmp4 = mk_add ( mk_mul ( a1 , sz ) , bt ) ; mk_le ( tmp4 , asz_bt_le_0 ) ; if ( to_app ( asz_bt_le_0 ) -> get_arg ( 0 ) == x && m_arith . is_zero ( to_app ( asz_bt_le_0 ) -> get_arg ( 1 ) ) ) { // ▁ exists ▁ z ▁ in ▁ [ 0 ▁ . . ▁ | b | - 2 ] ▁ . ▁ | b | ▁ | ▁ ( z ▁ + ▁ s ) ▁ & & ▁ z ▁ < = ▁ 0 ENDCOM // ▁ | b | ▁ | ▁ s ▁ ENDCOM mk_divides ( abs_b , s , tmp2 ) ; } else { mk_divides ( abs_b , sz , b_divides_sz ) ; mk_and ( b_divides_sz , asz_bt_le_0 , tmp4 ) ; mk_big_or ( abs_b - numeral ( 2 ) , x , tmp4 , tmp2 ) ; TRACE ( " qe " , tout << " b ▁ | ▁ s ▁ + ▁ z : ▁ " << mk_pp ( b_divides_sz , m ) << " \n " ; tout << " a ( s + z ) ▁ + ▁ bt ▁ < = ▁ 0 : ▁ " << mk_pp ( asz_bt_le_0 , m ) << " \n " ; ) ; } mk_flat_and ( as_bt_le_0 , tmp2 , result2 ) ; mk_or ( result1 , result2 , result ) ; simplify ( result ) ; // ▁ a * s ▁ + ▁ b * t ▁ + ▁ ( a - 1 ) ( b - 1 ) ▁ < = ▁ 0 ▁ ENDCOM // ▁ or ▁ exists ▁ z ▁ in ▁ [ 0 ▁ . . ▁ | b | - 2 ] ▁ . ▁ | b | ▁ | ▁ ( z ▁ + ▁ s ) ▁ & & ▁ a * n _ sign ( b ) ( s ▁ + ▁ z ) ▁ + ▁ | b | t ▁ < = ▁ 0 ENDCOM } TRACE ( " qe " , { tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; bound ( m , a , t , false ) . pp ( tout , x ) ; tout << " \n " ; bound ( m , b , s , false ) . pp ( tout , x ) ; tout << " \n " ; tout << mk_pp ( result , m ) << " \n " ; } ) ; } struct mul_lt { arith_util & u ; mul_lt ( arith_qe_util & u ) : u ( u . m_arith ) { } bool operator ( ) ( expr * n1 , expr * n2 ) const { expr * x , * y ; if ( u . is_mul ( n1 , x , y ) && u . is_numeral ( x ) ) { n1 = y ; } if ( u . is_mul ( n2 , x , y ) && u . is_numeral ( x ) ) { n2 = y ; } return n1 -> get_id ( ) < n2 -> get_id ( ) ; } } ; void normalize_sum ( expr_ref & p ) { simplify ( p ) ; if ( ! m_arith . is_add ( p ) ) { return ; } unsigned sz = to_app ( p ) -> get_num_args ( ) ; ptr_buffer < expr > args ; for ( unsigned i = 0 ; i < sz ; ++ i ) { args . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } std :: sort ( args . begin ( ) , args . end ( ) , mul_lt ( * this ) ) ; p = m_arith . mk_add ( args . size ( ) , args . c_ptr ( ) ) ; } void pp_div ( std :: ostream & out , app * x , div_constraint const & div ) { out << div . k ( ) << " ▁ | ▁ ( " << div . a ( ) << " * " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( div . t ( ) , m ) << " ) ▁ " ; } void pp_divs ( std :: ostream & out , app * x , div_constraints const & divs ) { for ( unsigned i = 0 ; i < divs . size ( ) ; ++ i ) { pp_div ( out , x , divs [ i ] ) ; out << " ▁ " ; } } bool mk_atom ( expr * e , bool p , expr_ref & result ) { // ▁ retain ▁ equalities . ENDCOM if ( ! is_app ( e ) ) { return false ; } app * a = to_app ( e ) ; expr_ref t1 ( m ) , t2 ( m ) ; expr_ref tmp1 ( m ) , tmp2 ( m ) ; rational k ; expr * a0 , * a1 ; if ( p && is_divides ( a , k , tmp1 ) ) { result = e ; } else if ( ! p && is_divides ( a , k , tmp1 ) ) { m_bool_rewriter . mk_not ( e , result ) ; } else if ( p && m . is_eq ( e , a0 , a1 ) && is_arith ( a0 ) ) { t1 = mk_sub ( a0 , a1 ) ; simplify ( t1 ) ; t2 = mk_sub ( a1 , a0 ) ; simplify ( t2 ) ; mk_le ( t1 , tmp1 ) ; mk_le ( t2 , tmp2 ) ; mk_and ( tmp1 , tmp2 , result ) ; } else if ( ! p && m . is_eq ( e , a0 , a1 ) && m_arith . is_int ( a0 ) ) { tmp1 = mk_sub ( a0 , a1 ) ; t1 = mk_add ( mk_one ( a0 ) , tmp1 ) ; simplify ( t1 ) ; t2 = mk_sub ( mk_one ( a0 ) , tmp1 ) ; simplify ( t2 ) ; mk_le ( t1 , tmp1 ) ; // ▁ a0 ▁ < ▁ a1 ▁ < = > ▁ 1 ▁ + ▁ a0 ▁ - ▁ a1 ▁ < = ▁ 0 ENDCOM mk_le ( t2 , tmp2 ) ; // ▁ a0 ▁ > ▁ a1 ▁ < = > ▁ 1 ▁ - ▁ a0 ▁ + ▁ a1 ▁ < = ▁ 0 ▁ ENDCOM mk_or ( tmp1 , tmp2 , result ) ; } else if ( ! p && m . is_eq ( e , a0 , a1 ) && m_arith . is_real ( a0 ) ) { t1 = mk_sub ( a0 , a1 ) ; simplify ( t1 ) ; t2 = mk_sub ( a1 , a0 ) ; simplify ( t2 ) ; mk_lt ( t1 , tmp1 ) ; mk_lt ( t2 , tmp2 ) ; mk_or ( tmp1 , tmp2 , result ) ; } else if ( ! p && ( m_arith . is_le ( e , a0 , a1 ) || m_arith . is_ge ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a1 , a0 ) ; mk_lt ( tmp1 , result ) ; } else if ( p && ( m_arith . is_le ( e ) || m_arith . is_ge ( e ) ) ) { result = e ; } else if ( p && ( m_arith . is_lt ( e , a0 , a1 ) || m_arith . is_gt ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a0 , a1 ) ; mk_lt ( tmp1 , result ) ; } else if ( ! p && ( m_arith . is_lt ( e , a0 , a1 ) || m_arith . is_gt ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a1 , a0 ) ; mk_le ( tmp1 , result ) ; } else { return false ; } TRACE ( " qe _ verbose " , tout << " Atom : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; return true ; } void mk_bounded_var ( rational const & n , app_ref & z_bv , app_ref & z ) { rational two ( 2 ) , b ( n ) ; unsigned sz = 0 ; do { ++ sz ; b = div ( b , two ) ; } while ( b . is_pos ( ) ) ; sort * s = m_bv . mk_sort ( sz ) ; z_bv = m . mk_fresh_const ( " z " , s ) ; expr_ref tmp ( m ) ; z = m_bv . mk_bv2int ( z_bv ) ; } bool solve ( conj_enum & conjs , expr * fml ) { expr_ref_vector eqs ( m ) ; extract_equalities ( conjs , eqs ) ; return reduce_equations ( eqs . size ( ) , eqs . c_ptr ( ) , fml ) ; } // ▁ Equation ▁ solving ▁ features . ENDCOM // ▁ Extract ▁ equalities ▁ from ▁ current ▁ goal . ENDCOM void extract_equalities ( conj_enum & conjs , expr_ref_vector & eqs ) { obj_hashtable < expr > leqs ; expr_ref_vector trail ( m ) ; expr_ref tmp1 ( m ) , tmp2 ( m ) ; expr * a0 , * a1 ; eqs . reset ( ) ; conj_enum :: iterator it = conjs . begin ( ) , end = conjs . end ( ) ; for ( ; it != end ; ++ it ) { expr * e = * it ; bool is_leq = false ; if ( m . is_eq ( e , a0 , a1 ) && is_arith ( a0 ) ) { m_arith_rewriter . mk_sub ( a0 , a1 , tmp1 ) ; simplify ( tmp1 ) ; eqs . push_back ( tmp1 ) ; } else if ( m_arith . is_le ( e , a0 , a1 ) || m_arith . is_ge ( e , a1 , a0 ) ) { m_arith_rewriter . mk_sub ( a0 , a1 , tmp1 ) ; is_leq = true ; } else { // ▁ drop ▁ equality . ENDCOM } if ( is_leq ) { normalize_sum ( tmp1 ) ; tmp2 = m_arith . mk_uminus ( tmp1 ) ; normalize_sum ( tmp2 ) ; if ( leqs . contains ( tmp2 ) ) { eqs . push_back ( tmp1 ) ; TRACE ( " qe " , tout << " found : ▁ ▁ " << mk_pp ( tmp1 , m ) << " \n " ; ) ; } else { trail . push_back ( tmp1 ) ; leqs . insert ( tmp1 ) ; TRACE ( " qe _ verbose " , tout << " insert : ▁ " << mk_pp ( tmp1 , m ) << " \n " ; ) ; } } } } private : // ▁ match ▁ p ▁ < = ▁ 0 ▁ or ▁ p ▁ > = ▁ 0 ENDCOM template < unsigned IS_LE > bool is_le_ge_core ( app * e , expr_ref & p ) { numeral k ; expr_ref tmp ( m ) ; expr * a2 ; if ( m_arith . is_le ( e ) ) { p = e -> get_arg ( 1 - IS_LE ) ; a2 = e -> get_arg ( IS_LE ) ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else if ( m_arith . is_ge ( e ) ) { p = e -> get_arg ( IS_LE ) ; a2 = e -> get_arg ( 1 - IS_LE ) ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else { return false ; } p = mk_sub ( p , a2 ) ; simplify ( p ) ; return true ; } bool is_arith ( expr * e ) { return m_arith . is_int ( e ) || m_arith . is_real ( e ) ; } void mk_big_or ( numeral up , app * x , expr * body , expr_ref & result ) { TRACE ( " qe " , tout << mk_pp ( x , m ) << " ▁ " << mk_pp ( body , m ) << " \n " ; ) ; if ( numeral ( 1 ) >= up ) { mk_big_or_blast ( up , x , body , result ) ; } else { mk_big_or_symbolic_blast ( up , x , body , result ) ; } } void mk_big_or_blast ( numeral up , app * x , expr * body , expr_ref & result ) { expr_ref_vector ors ( m ) ; numeral index ( 0 ) ; while ( index <= up ) { expr * n = mk_numeral ( index ) ; result = body ; m_replace . apply_substitution ( x , n , result ) ; ors . push_back ( result ) ; ++ index ; } mk_or ( ors . size ( ) , ors . c_ptr ( ) , result ) ; TRACE ( " qe " , tout << " [ 0 ▁ " << up << " ] ▁ " << mk_pp ( x , m ) << " \n " << mk_pp ( body , m ) << " \n " << mk_pp ( result , m ) << " \n " ; ) ; } void mk_big_or_symbolic ( numeral up , app * x , expr * body , expr_ref & result ) { app_ref z_bv ( m ) ; mk_big_or_symbolic ( up , x , body , z_bv , result ) ; m_ctx . add_var ( z_bv ) ; } void mk_big_or_symbolic_blast ( numeral up , app * x , expr * body , expr_ref & result ) { app_ref z_bv ( m ) ; mk_big_or_symbolic ( up , x , body , z_bv , result ) ; m_ctx . blast_or ( z_bv , result ) ; } void mk_big_or_symbolic ( numeral up , app * x , expr * body , app_ref & z_bv , expr_ref & result ) { expr * e1 = m_arith . mk_le ( x , m_arith . mk_numeral ( up , true ) ) ; mk_flat_and ( e1 , body , result ) ; app_ref z ( m ) ; mk_bounded_var ( up , z_bv , z ) ; m_replace . apply_substitution ( x , z , result ) ; } // ▁ Determine ▁ if ▁ ' x ' ▁ can ▁ be ▁ isolated . ENDCOM // ▁ Return ▁ the ▁ coefficient ▁ if ▁ found . ENDCOM bool isolate_x ( expr * p , app * x , contains_app & contains_x , numeral & coeff ) { numeral k ; while ( m_arith . is_add ( p ) ) { bool found_x = false ; expr * next_p = 0 ; for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { expr * arg = to_app ( p ) -> get_arg ( i ) ; if ( contains_x ( arg ) ) { if ( found_x ) { return false ; } found_x = true ; next_p = arg ; } } if ( ! next_p ) { return false ; } p = next_p ; } expr * e1 , * e2 ; if ( p == x ) { coeff = numeral ( 1 ) ; return true ; } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e1 , k ) && e2 == x ) { coeff = k ; return true ; } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e2 , k ) && e1 == x ) { coeff = k ; return true ; } return false ; } // ▁ Reduce ▁ equations . ENDCOM // ▁ Singular ▁ equations ▁ eliminate ▁ variables ▁ directly . ENDCOM // ▁ Linear ▁ equations ▁ eliminate ▁ original ▁ variables ▁ and ▁ introduce ▁ auxiliary ▁ variables . ENDCOM bool reduce_equations ( unsigned num_eqs , expr * const * eqs , expr * fml ) { for ( unsigned i = 0 ; i < num_eqs ; ++ i ) { if ( reduce_equation ( eqs [ i ] , fml ) ) { return true ; } } return false ; } bool solve_singular ( unsigned var_idx , expr * p , expr * fml ) { rational k ; expr_ref e ( m ) , tmp ( m ) ; app * x = m_ctx . get_var ( var_idx ) ; if ( ! isolate_x ( p , x , m_ctx . contains ( var_idx ) , k ) ) { return false ; } if ( m_arith . is_int ( x ) && ! ( abs ( k ) . is_one ( ) ) ) { return false ; } if ( abs ( k ) . is_one ( ) ) { if ( k . is_neg ( ) ) { e = m_arith . mk_add ( p , x ) ; } else { e = m_arith . mk_sub ( x , p ) ; } } else { SASSERT ( ! m_arith . is_int ( x ) ) ; // ▁ p ▁ = ▁ p ' ▁ + ▁ k * x ▁ = ▁ 0 ENDCOM // ▁ - k * x ▁ = ▁ p ' ▁ = ▁ p ▁ - ▁ k * x ENDCOM // ▁ x ▁ = ▁ ( p ▁ - ▁ k * x ) / ▁ - k ENDCOM expr * ke = m_arith . mk_numeral ( - k , false ) ; tmp = m_arith . mk_mul ( ke , x ) ; tmp = m_arith . mk_add ( p , tmp ) ; e = m_arith . mk_div ( tmp , ke ) ; } TRACE ( " qe " , tout << " is ▁ singular : \n " << mk_pp ( p , m ) << " \n " << mk_pp ( fml , m ) << " \n " << mk_pp ( x , m ) << " ▁ = ▁ " << mk_pp ( e , m ) << " \n " ; ) ; expr_ref result ( fml , m ) ; m_replace . apply_substitution ( x , e , result ) ; simplify ( result ) ; TRACE ( " qe " , tout << " singular ▁ solved : \n " << mk_pp ( result , m ) << " \n " ; ) ; m_ctx . elim_var ( var_idx , result , e ) ; return true ; } bool solve_singular ( expr * p , expr * fml ) { unsigned num_vars = m_ctx . get_num_vars ( ) ; for ( unsigned i = 0 ; i < num_vars ; ++ i ) { if ( solve_singular ( i , p , fml ) ) { return true ; } } return false ; } bool solve_linear ( expr * p , expr * fml ) { vector < numeral > values ; unsigned num_vars = m_ctx . get_num_vars ( ) ; app * const * vars_ptr = m_ctx . get_vars ( ) ; if ( ! is_linear ( p , num_vars , vars_ptr , values ) ) { return false ; } TRACE ( " qe " , tout << " is ▁ linear : ▁ " << mk_pp ( p , m ) << " \n " ; ) ; SASSERT ( values . size ( ) == num_vars + 1 ) ; SASSERT ( num_vars > 0 ) ; unsigned index ; bool is_aux ; // ▁ The ▁ first ▁ entry ▁ in ▁ values ▁ is ▁ the ▁ constant . ENDCOM VERIFY ( m_arith_solver . solve_integer_equation ( values , index , is_aux ) ) ; SASSERT ( 1 <= index && index <= num_vars ) ; app_ref x ( m_ctx . get_var ( index - 1 ) , m ) ; app_ref z ( m ) ; expr_ref p1 ( m ) ; if ( is_aux ) { // ▁ An ▁ auxiliary ▁ variable ▁ was ▁ introduced ▁ in ▁ lieu ▁ of ▁ ' x ' . ENDCOM // ▁ it ▁ has ▁ coefficient ▁ ' m ' ▁ = ▁ values [ index ] . ENDCOM SASSERT ( values [ index ] >= rational ( 3 ) ) ; z = m . mk_fresh_const ( " x " , m_arith . mk_int ( ) ) ; m_ctx . add_var ( z ) ; p1 = m_arith . mk_mul ( m_arith . mk_numeral ( values [ index ] , true ) , z ) ; } else { // ▁ the ▁ coefficient ▁ to ▁ ' x ' ▁ is ▁ - 1 . ENDCOM p1 = m_arith . mk_numeral ( numeral ( 0 ) , true ) ; } for ( unsigned i = 1 ; i <= num_vars ; ++ i ) { numeral k = values [ i ] ; if ( ! k . is_zero ( ) && i != index ) { p1 = m_arith . mk_add ( p1 , m_arith . mk_mul ( m_arith . mk_numeral ( k , true ) , m_ctx . get_var ( i - 1 ) ) ) ; } } p1 = m_arith . mk_add ( p1 , m_arith . mk_numeral ( values [ 0 ] , true ) ) ; TRACE ( " qe " , tout << " is ▁ linear : \n " << mk_pp ( fml , m ) << " \n " << mk_pp ( p , m ) << " \n " << mk_pp ( x , m ) << " ▁ = ▁ " << mk_pp ( p1 , m ) << " \n " ; tout << values [ 0 ] << " ▁ + ▁ " ; for ( unsigned i = 0 ; i < num_vars ; ++ i ) { tout << " ▁ + ▁ " << values [ i + 1 ] << " ▁ * ▁ " << mk_pp ( m_ctx . get_var ( i ) , m ) << " ▁ " ; } tout << " ▁ = ▁ 0 \n " ; ) ; expr_ref result ( fml , m ) ; m_replace . apply_substitution ( x , p1 , result ) ; simplify ( result ) ; m_ctx . elim_var ( index - 1 , result , p1 ) ; TRACE ( " qe " , tout << " Reduced : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; return true ; } bool reduce_equation ( expr * p , expr * fml ) { numeral k ; if ( m_arith . is_numeral ( p , k ) && k . is_zero ( ) ) { return false ; } return solve_singular ( p , fml ) || solve_linear ( p , fml ) ; } bool find_variable ( expr * p , unsigned num_vars , app * const * vars , numeral * values , numeral const & k ) { if ( ! is_app ( p ) || to_app ( p ) -> get_num_args ( ) > 0 ) { return false ; } for ( unsigned i = 0 ; i < num_vars ; ++ i ) { if ( p == vars [ i ] ) { values [ i ] += k ; return true ; } } return false ; } bool is_linear ( expr * p , unsigned num_vars , app * const * vars , vector < numeral > & values ) { if ( num_vars == 0 ) { return false ; } values . reset ( ) ; for ( unsigned i = 0 ; i <= num_vars ; ++ i ) { values . push_back ( numeral ( 0 ) ) ; } numeral * vars_ptr = values . c_ptr ( ) + 1 ; ptr_vector < expr > todo ; numeral k ; expr * e1 , * e2 ; todo . push_back ( p ) ; while ( ! todo . empty ( ) ) { p = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( p ) ) { for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e1 , k ) && find_variable ( e2 , num_vars , vars , vars_ptr , k ) ) { // ▁ ok ENDCOM } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e2 , k ) && find_variable ( e1 , num_vars , vars , vars_ptr , k ) ) { // ▁ ok ENDCOM } else if ( find_variable ( p , num_vars , vars , vars_ptr , k ) ) { // ▁ ok ENDCOM } else if ( m_arith . is_numeral ( p , k ) ) { values [ 0 ] += k ; } else { TRACE ( " qe _ verbose " , tout << " non - linear ▁ " << mk_pp ( p , m ) << " \n " ; ) ; return false ; } } return true ; } } ; class bounds_proc { arith_qe_util & m_util ; ast_mark m_mark ; expr_ref_vector m_le_terms , m_ge_terms , m_lt_terms , m_gt_terms ; vector < rational > m_le_coeffs , m_ge_coeffs , m_lt_coeffs , m_gt_coeffs ; app_ref_vector m_le_atoms , m_ge_atoms , m_lt_atoms , m_gt_atoms ; expr_ref_vector m_div_terms ; vector < rational > m_div_coeffs , m_div_divisors ; app_ref_vector m_div_atoms ; app_ref m_div_z ; expr_ref_vector m_nested_div_terms ; vector < rational > m_nested_div_coeffs , m_nested_div_divisors ; app_ref_vector m_nested_div_atoms ; app_ref_vector m_nested_div_z ; rational m_d ; public : bounds_proc ( arith_qe_util & u ) : m_util ( u ) , m_le_terms ( u . get_manager ( ) ) , m_ge_terms ( u . get_manager ( ) ) , m_lt_terms ( u . get_manager ( ) ) , m_gt_terms ( u . get_manager ( ) ) , m_le_atoms ( u . get_manager ( ) ) , m_ge_atoms ( u . get_manager ( ) ) , m_lt_atoms ( u . get_manager ( ) ) , m_gt_atoms ( u . get_manager ( ) ) , m_div_terms ( u . get_manager ( ) ) , m_div_atoms ( u . get_manager ( ) ) , m_div_z ( u . get_manager ( ) ) , m_nested_div_terms ( u . get_manager ( ) ) , m_nested_div_atoms ( u . get_manager ( ) ) , m_nested_div_z ( u . get_manager ( ) ) { reset ( ) ; } bool get_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; app * x = contains_x . x ( ) ; if ( m_mark . is_marked ( a ) || get_le_bound ( contains_x , a ) || get_lt_bound ( contains_x , a ) || get_divides ( contains_x , a ) || get_nested_divs ( contains_x , a ) ) { TRACE ( " qe _ verbose " , tout << " Bound ▁ for ▁ " << mk_pp ( x , m ) << " ▁ within ▁ " << mk_pp ( a , m ) << " \n " ; ) ; m_mark . mark ( a , true ) ; return true ; } else { TRACE ( " qe " , tout << " No ▁ bound ▁ for ▁ " << mk_pp ( x , m ) << " ▁ within ▁ " << mk_pp ( a , m ) << " \n " ; ) ; return false ; } } unsigned lt_size ( ) { return m_lt_terms . size ( ) ; } unsigned le_size ( ) { return m_le_terms . size ( ) ; } unsigned gt_size ( ) { return m_gt_terms . size ( ) ; } unsigned ge_size ( ) { return m_ge_terms . size ( ) ; } unsigned t_size ( bool is_l ) { return is_l ? lt_size ( ) : gt_size ( ) ; } unsigned e_size ( bool is_l ) { return is_l ? le_size ( ) : ge_size ( ) ; } unsigned size ( bool is_strict , bool is_l ) { return is_strict ? t_size ( is_l ) : e_size ( is_l ) ; } expr * const * lt ( ) { return m_lt_terms . c_ptr ( ) ; } expr * const * le ( ) { return m_le_terms . c_ptr ( ) ; } expr * const * gt ( ) { return m_gt_terms . c_ptr ( ) ; } expr * const * ge ( ) { return m_ge_terms . c_ptr ( ) ; } expr * const * t ( bool is_l ) { return is_l ? lt ( ) : gt ( ) ; } expr * const * e ( bool is_l ) { return is_l ? le ( ) : ge ( ) ; } expr * const * exprs ( bool is_strict , bool is_l ) { return is_strict ? t ( is_l ) : e ( is_l ) ; } rational const * lt_coeffs ( ) { return m_lt_coeffs . c_ptr ( ) ; } rational const * le_coeffs ( ) { return m_le_coeffs . c_ptr ( ) ; } rational const * gt_coeffs ( ) { return m_gt_coeffs . c_ptr ( ) ; } rational const * ge_coeffs ( ) { return m_ge_coeffs . c_ptr ( ) ; } rational const * t_coeffs ( bool is_l ) { return is_l ? lt_coeffs ( ) : gt_coeffs ( ) ; } rational const * e_coeffs ( bool is_l ) { return is_l ? le_coeffs ( ) : ge_coeffs ( ) ; } rational const * coeffs ( bool is_strict , bool is_l ) { return is_strict ? t_coeffs ( is_l ) : e_coeffs ( is_l ) ; } app * const * lt_atoms ( ) { return m_lt_atoms . c_ptr ( ) ; } app * const * le_atoms ( ) { return m_le_atoms . c_ptr ( ) ; } app * const * gt_atoms ( ) { return m_gt_atoms . c_ptr ( ) ; } app * const * ge_atoms ( ) { return m_ge_atoms . c_ptr ( ) ; } app * const * t_atoms ( bool is_l ) { return is_l ? lt_atoms ( ) : gt_atoms ( ) ; } app * const * e_atoms ( bool is_l ) { return is_l ? le_atoms ( ) : ge_atoms ( ) ; } app * const * atoms ( bool is_strict , bool is_l ) { return is_strict ? t_atoms ( is_l ) : e_atoms ( is_l ) ; } unsigned div_size ( ) const { return m_div_terms . size ( ) ; } app * const * div_atoms ( ) { return m_div_atoms . c_ptr ( ) ; } rational const * div_coeffs ( ) { return m_div_coeffs . c_ptr ( ) ; } expr * const * div_terms ( ) { return m_div_terms . c_ptr ( ) ; } rational const * divisors ( ) { return m_div_divisors . c_ptr ( ) ; } bool div_z ( rational & d , app_ref & z_bv , app_ref & z ) { if ( m_div_z . get ( ) ) { z = m_div_z ; z_bv = to_app ( z -> get_arg ( 0 ) ) ; d = m_d ; return true ; } if ( m_div_terms . empty ( ) && m_nested_div_terms . empty ( ) ) { return false ; } m_d = rational ( 1 ) ; for ( unsigned i = 0 ; i < m_div_divisors . size ( ) ; ++ i ) { m_d = lcm ( m_div_divisors [ i ] , m_d ) ; } for ( unsigned i = 0 ; i < m_nested_div_divisors . size ( ) ; ++ i ) { m_d = lcm ( m_nested_div_divisors [ i ] , m_d ) ; } if ( abs ( m_d ) . is_one ( ) ) { return false ; } m_util . mk_bounded_var ( m_d , z_bv , m_div_z ) ; z = m_div_z ; d = m_d ; return true ; } unsigned nested_div_size ( ) const { return m_nested_div_terms . size ( ) ; } app * nested_div_atom ( unsigned idx ) { return m_nested_div_atoms [ idx ] . get ( ) ; } rational const & nested_div_coeff ( unsigned idx ) { return m_nested_div_coeffs [ idx ] ; } expr * nested_div_term ( unsigned idx ) { return m_nested_div_terms [ idx ] . get ( ) ; } rational const & nested_divisor ( unsigned idx ) { return m_nested_div_divisors [ idx ] ; } app * nested_div_z ( unsigned idx ) { return m_nested_div_z [ idx ] . get ( ) ; } app * nested_div_z_bv ( unsigned idx ) { return to_app ( m_nested_div_z [ idx ] -> get_arg ( 0 ) ) ; } void reset ( ) { m_lt_terms . reset ( ) ; m_gt_terms . reset ( ) ; m_ge_terms . reset ( ) ; m_le_terms . reset ( ) ; m_gt_coeffs . reset ( ) ; m_lt_coeffs . reset ( ) ; m_ge_coeffs . reset ( ) ; m_le_coeffs . reset ( ) ; m_lt_atoms . reset ( ) ; m_gt_atoms . reset ( ) ; m_le_atoms . reset ( ) ; m_ge_atoms . reset ( ) ; m_div_terms . reset ( ) ; m_div_coeffs . reset ( ) ; m_div_divisors . reset ( ) ; m_div_atoms . reset ( ) ; m_div_z = 0 ; m_nested_div_terms . reset ( ) ; m_nested_div_coeffs . reset ( ) ; m_nested_div_divisors . reset ( ) ; m_nested_div_atoms . reset ( ) ; m_nested_div_z . reset ( ) ; } private : bool get_nested_divs ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; ptr_vector < expr > todo ; todo . push_back ( a ) ; rational k1 , k2 ; expr_ref rest ( m ) ; while ( ! todo . empty ( ) ) { expr * e = todo . back ( ) ; todo . pop_back ( ) ; if ( m_mark . is_marked ( e ) ) { continue ; } m_mark . mark ( e , true ) ; if ( ! contains_x ( e ) ) { continue ; } if ( contains_x . x ( ) == e ) { return false ; } if ( ! is_app ( e ) ) { return false ; } a = to_app ( e ) ; if ( m_util . m_arith . is_mod ( e ) && m_util . m_arith . is_numeral ( to_app ( e ) -> get_arg ( 1 ) , k1 ) && m_util . get_coeff ( contains_x , to_app ( e ) -> get_arg ( 0 ) , k2 , rest ) ) { app_ref z ( m ) , z_bv ( m ) ; m_util . mk_bounded_var ( k1 , z_bv , z ) ; m_nested_div_terms . push_back ( rest ) ; m_nested_div_divisors . push_back ( k1 ) ; m_nested_div_coeffs . push_back ( k2 ) ; m_nested_div_atoms . push_back ( a ) ; m_nested_div_z . push_back ( z ) ; continue ; } unsigned num_args = a -> get_num_args ( ) ; for ( unsigned i = 0 ; i < num_args ; ++ i ) { todo . push_back ( a -> get_arg ( i ) ) ; } } return true ; } bool get_le_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) ; rational k ; if ( m_util . is_le ( a , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { // ▁ k * x ▁ + ▁ rest ▁ < = ▁ 0 ENDCOM if ( m_util . is_real ( contains_x . x ( ) ) ) { m_util . mk_div ( rest , abs ( k ) , rest ) ; k = k . is_pos ( ) ? rational :: one ( ) : rational :: minus_one ( ) ; } if ( k . is_neg ( ) ) { m_le_terms . push_back ( rest ) ; m_le_coeffs . push_back ( k ) ; m_le_atoms . push_back ( a ) ; } else { m_ge_terms . push_back ( rest ) ; m_ge_coeffs . push_back ( k ) ; m_ge_atoms . push_back ( a ) ; } return true ; } return false ; } bool get_lt_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) , na ( m ) ; rational k ; if ( m_util . is_lt ( a , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { // ▁ k * x ▁ + ▁ rest ▁ < ▁ 0 ENDCOM } else if ( m_util . is_neg ( a , na ) && is_app ( na ) && m_util . is_ge ( to_app ( na ) , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { // ▁ not ▁ ( k * x ▁ + ▁ rest ▁ > = ▁ 0 ) ENDCOM // ▁ k * x ▁ + ▁ rest ▁ < ▁ 0 ENDCOM } else { return false ; } SASSERT ( m_util . is_real ( contains_x . x ( ) ) ) ; m_util . mk_div ( rest , abs ( k ) , rest ) ; if ( k . is_neg ( ) ) { m_lt_terms . push_back ( rest ) ; m_lt_coeffs . push_back ( rational :: minus_one ( ) ) ; m_lt_atoms . push_back ( a ) ; } else { m_gt_terms . push_back ( rest ) ; m_gt_coeffs . push_back ( rational :: one ( ) ) ; m_gt_atoms . push_back ( a ) ; } return true ; } bool get_divides ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) ; app_ref a2 ( m ) ; numeral k , k2 ; if ( m_util . is_divides ( a , k , p ) && m_util . get_coeff ( contains_x , p , k2 , rest ) ) { m_div_terms . push_back ( rest ) ; m_div_divisors . push_back ( k ) ; m_div_coeffs . push_back ( k2 ) ; m_div_atoms . push_back ( a ) ; return true ; } if ( m_util . is_not_divides ( a , a2 , k , p ) && m_util . get_coeff ( contains_x , p , k2 , rest ) ) { m_div_terms . push_back ( rest ) ; m_div_divisors . push_back ( k ) ; m_div_coeffs . push_back ( k2 ) ; m_div_atoms . push_back ( a2 ) ; return true ; } return false ; } public : void display ( std :: ostream & out ) { ast_manager & m = m_util . get_manager ( ) ; for ( unsigned i = 0 ; i < lt_size ( ) ; ++ i ) { out << mk_pp ( lt ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < le_size ( ) ; ++ i ) { out << mk_pp ( le ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < gt_size ( ) ; ++ i ) { out << mk_pp ( gt ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < ge_size ( ) ; ++ i ) { out << mk_pp ( ge ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } } } ; class x_subst { arith_qe_util & m_super ; expr_ref m_t ; rational m_coeff ; public : x_subst ( arith_qe_util & s ) : m_super ( s ) , m_t ( s . get_manager ( ) ) , m_coeff ( rational :: one ( ) ) { } void set_term ( expr * t ) { m_t = t ; } void set_coeff ( rational const & k ) { m_coeff = k ; } expr * get_term ( ) const { return m_t ; } rational get_coeff ( ) const { return m_coeff ; } expr_ref mk_term ( rational const & c , expr * t ) { // ▁ return ▁ t ▁ + ▁ c * m _ t ENDCOM ast_manager & m = m_super . get_manager ( ) ; if ( m_t . get ( ) ) { return expr_ref ( m_super . mk_add ( m_super . mk_mul ( c , m_t ) , t ) , m ) ; } else { return expr_ref ( t , m ) ; } } rational mk_coeff ( rational const & k ) { return k * m_coeff ; } } ; struct branch_formula { expr * m_fml ; app * m_var ; unsigned m_branch ; expr * m_result ; rational m_coeff ; expr * m_term ; branch_formula ( ) : m_fml ( 0 ) , m_var ( 0 ) , m_branch ( 0 ) , m_result ( 0 ) , m_term ( 0 ) { } branch_formula ( expr * fml , app * var , unsigned b , expr * r , rational coeff , expr * term ) : m_fml ( fml ) , m_var ( var ) , m_branch ( b ) , m_result ( r ) , m_coeff ( coeff ) , m_term ( term ) { } unsigned mk_hash ( ) const { return mk_mix ( m_fml ? m_fml -> hash ( ) : 0 , m_var ? m_var -> hash ( ) : 0 , m_branch ) ; } bool mk_eq ( branch_formula const & other ) const { return m_fml == other . m_fml && m_var == other . m_var && m_branch == other . m_branch ; } struct hash { typedef branch_formula data ; unsigned operator ( ) ( data const & d ) const { return d . mk_hash ( ) ; } } ; struct eq { typedef branch_formula data ; bool operator ( ) ( data const & x , data const & y ) const { return x . mk_eq ( y ) ; } } ; } ; class arith_plugin : public qe_solver_plugin { typedef obj_pair_map < app , expr , bounds_proc * > bounds_cache ; typedef obj_pair_map < expr , expr , expr * > resolve_cache ; typedef hashtable < branch_formula , branch_formula :: hash , branch_formula :: eq > subst_cache ; arith_qe_util m_util ; expr_ref_vector m_trail ; bounds_cache m_bounds_cache ; subst_cache m_subst ; public : arith_plugin ( i_solver_context & ctx , ast_manager & m , smt_params & p ) : qe_solver_plugin ( m , m . mk_family_id ( " arith " ) , ctx ) , m_util ( m , p , ctx ) , m_trail ( m ) { } ~ arith_plugin ( ) { bounds_cache :: iterator it = m_bounds_cache . begin ( ) , end = m_bounds_cache . end ( ) ; for ( ; it != end ; ++ it ) { dealloc ( it -> get_value ( ) ) ; } } virtual void assign ( contains_app & contains_x , expr * fml , rational const & vl ) { SASSERT ( vl . is_unsigned ( ) ) ; app * x = contains_x . x ( ) ; unsigned v = vl . get_unsigned ( ) ; expr_ref result ( fml , m ) ; unsigned t_size , e_size ; x_subst x_t ( m_util ) ; if ( get_cache ( x , fml , v , result ) ) { return ; } bounds_proc & bounds = get_bounds ( x , fml ) ; bool is_lower = get_bound_sizes ( bounds , x , t_size , e_size ) ; assign_nested_divs ( contains_x , bounds , result ) ; assign_divs ( contains_x , bounds , x_t , result ) ; // assign _ all ( contains _ x , ▁ fml ) ; ENDCOM if ( v == 0 ) { // ▁ index ▁ is ▁ for ▁ the ▁ infinity ▁ case . ENDCOM // ▁ assert ▁ v ▁ = > ▁ ~ ( x ▁ < = ▁ t ) ▁ each ▁ t ENDCOM // ▁ assert ▁ v ▁ = > ▁ ( x ▁ > = ▁ s ) ▁ each ▁ s ENDCOM mk_non_bounds ( bounds , true , is_lower , result ) ; mk_non_bounds ( bounds , false , is_lower , result ) ; mk_non_resolve ( bounds , true , is_lower , result ) ; mk_non_resolve ( bounds , false , is_lower , result ) ; m_util . simplify ( result ) ; add_cache ( x , fml , v , result , x_t . get_coeff ( ) , x_t . get_term ( ) ) ; TRACE ( " qe " , tout << vl << " ▁ " << mk_pp ( x , m ) << " ▁ infinite ▁ case \n " ; tout << mk_pp ( fml , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; ) ; return ; } unsigned index = v - 1 ; bool is_strict = e_size <= index ; bool is_eq = false ; SASSERT ( index < t_size + e_size ) ; if ( is_strict ) { index -= e_size ; TRACE ( " qe _ verbose " , bounds . display ( tout ) ; ) ; } else if ( m_util . is_real ( x ) ) { SASSERT ( 0 == ( e_size & 0x1 ) ) ; is_eq = ( 0 == ( index & 0x1 ) ) ; index /= 2 ; e_size /= 2 ; } SASSERT ( is_strict || index < e_size ) ; SASSERT ( ! is_strict || index < t_size ) ; // ▁ index ▁ is ▁ for ▁ the ▁ upper / lower - bound ▁ case . ENDCOM // ▁ assert ▁ v ▁ = > ▁ ( x ▁ < = ▁ t _ i ) ▁ ENDCOM // ▁ assert ▁ v ▁ = > ▁ ( x ▁ < = ▁ t _ j ▁ = > ▁ t _ i ▁ < = ▁ t _ j ) , ▁ add ▁ new ▁ atom ▁ to ▁ stack . ENDCOM // ▁ assert ▁ v ▁ = > ▁ ( x ▁ > = ▁ s ▁ = > ▁ s ▁ < = ▁ t _ i ) , ▁ add ▁ new ▁ atom ▁ to ▁ stack . ENDCOM // ▁ assert ▁ v ▁ = > ▁ ( x ▁ < ▁ t _ j ▁ = > ▁ t _ i ▁ < ▁ t _ j ) ENDCOM SASSERT ( index < bounds . size ( is_strict , is_lower ) ) ; expr_ref t ( bounds . exprs ( is_strict , is_lower ) [ index ] , m ) ; rational a = bounds . coeffs ( is_strict , is_lower ) [ index ] ; mk_bounds ( bounds , x , true , is_eq , is_strict , is_lower , index , a , t , result ) ; mk_bounds ( bounds , x , false , is_eq , is_strict , is_lower , index , a , t , result ) ; t = x_t . mk_term ( a , t ) ; a = x_t . mk_coeff ( a ) ; mk_resolve ( bounds , x , x_t , true , is_eq , is_strict , is_lower , index , a , t , result ) ; mk_resolve ( bounds , x , x_t , false , is_eq , is_strict , is_lower , index , a , t , result ) ; m_util . simplify ( result ) ; add_cache ( x , fml , v , result , x_t . get_coeff ( ) , x_t . get_term ( ) ) ; TRACE ( " qe " , { tout << vl << " ▁ " << mk_pp ( bounds . atoms ( is_strict , is_lower ) [ index ] , m ) << " \n " ; tout << mk_pp ( fml , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; } ) ; } virtual bool get_num_branches ( contains_app & contains_x , expr * fml , rational & nb ) { app * x = contains_x . x ( ) ; if ( ! update_bounds ( contains_x , fml ) ) { return false ; } bounds_proc & bounds = get_bounds ( x , fml ) ; unsigned t_size , e_size ; get_bound_sizes ( bounds , x , t_size , e_size ) ; nb = rational ( t_size + e_size + 1 ) ; return true ; } virtual void subst ( contains_app & contains_x , rational const & vl , expr_ref & fml , expr_ref * def ) { SASSERT ( vl . is_unsigned ( ) ) ; if ( def ) { get_def ( contains_x , vl . get_unsigned ( ) , fml , * def ) ; } VERIFY ( get_cache ( contains_x . x ( ) , fml , vl . get_unsigned ( ) , fml ) ) ; TRACE ( " qe " , tout << mk_pp ( contains_x . x ( ) , m ) << " ▁ " << vl << " \n " << mk_pp ( fml , m ) << " \n " ; ) ; } virtual bool project ( contains_app & x , model_ref & model , expr_ref & fml ) { if ( ! update_bounds ( x , fml ) ) { TRACE ( " qe " , tout << mk_pp ( x . x ( ) , m ) << " ▁ failed ▁ to ▁ update ▁ bounds \n " ; ) ; return false ; } if ( m_util . m_arith . is_real ( x . x ( ) ) ) { return project_real ( x , model , fml ) ; } else { return project_int ( x , model , fml ) ; } } virtual unsigned get_weight ( contains_app & contains_x , expr * fml ) { return 2 ; } virtual bool solve ( conj_enum & conjs , expr * fml ) { return m_util . solve ( conjs , fml ) ; } virtual bool mk_atom ( expr * e , bool p , expr_ref & result ) { return m_util . mk_atom ( e , p , result ) ; } virtual bool is_uninterpreted ( app * f ) { switch ( f -> get_decl_kind ( ) ) { case OP_NUM : case OP_LE : case OP_LT : case OP_GE : case OP_GT : case OP_ADD : case OP_SUB : case OP_UMINUS : return false ; case OP_MOD : if ( m_util . m_arith . is_numeral ( f -> get_arg ( 1 ) ) ) { return false ; } return true ; case OP_MUL : { arith_util & a = m_util . m_arith ; expr * m , * n ; if ( a . is_mul ( f , m , n ) && ( a . is_numeral ( m ) || a . is_numeral ( n ) ) ) { return false ; } return true ; } default : return true ; } } private : /* * STRNEWLINE ▁ \brief ▁ Compute ▁ least ▁ upper / greatest ▁ lower ▁ bounds ▁ for ▁ x . STRNEWLINE STRNEWLINE ▁ Assume : STRNEWLINE ▁ ( not ▁ ( = ▁ k ▁ 0 ) ) STRNEWLINE ▁ ( < = ▁ 0 ▁ ( mod ▁ m ▁ k ) ) ▁ STRNEWLINE ▁ ( < ▁ ( mod ▁ m ▁ k ) ▁ ( abs ▁ k ) ) STRNEWLINE ▁ ( = ▁ m ▁ ( + ▁ ( * ▁ k ▁ ( div ▁ m ▁ k ) ) ▁ ( mod ▁ m ▁ k ) ) ) STRNEWLINE ▁ i . e . ▁ STRNEWLINE ▁ k ▁ * ▁ ( e ▁ div ▁ k ) ▁ + ▁ ( e ▁ mod ▁ k ) ▁ = ▁ e STRNEWLINE STRNEWLINE ▁ STRNEWLINE ▁ When ▁ k ▁ is ▁ positive , ▁ least ▁ upper ▁ bound ▁ STRNEWLINE ▁ for ▁ x ▁ such ▁ that : ▁ k * x ▁ < = ▁ e ▁ is ▁ e ▁ div ▁ k STRNEWLINE STRNEWLINE ▁ When ▁ k ▁ is ▁ negative , ▁ greatest ▁ lower ▁ bound ▁ STRNEWLINE ▁ for ▁ x ▁ such ▁ that ▁ k * x ▁ < = ▁ e ▁ is ▁ e ▁ div ▁ k STRNEWLINE STRNEWLINE ▁ k ▁ * ▁ ( e ▁ div ▁ k ) ▁ + ▁ ( e ▁ mod ▁ k ) ▁ = ▁ e ▁ STRNEWLINE ▁ */ expr_ref mk_idiv ( expr * e , numeral k ) { SASSERT ( ! k . is_zero ( ) ) ; arith_util & a = m_util . m_arith ; if ( k . is_one ( ) ) { return expr_ref ( e , m ) ; } if ( k . is_minus_one ( ) ) { return expr_ref ( a . mk_uminus ( e ) , m ) ; } SASSERT ( a . is_int ( e ) ) ; return expr_ref ( a . mk_idiv ( e , a . mk_numeral ( k , true ) ) , m ) ; } void get_def ( contains_app & contains_x , unsigned v , expr * fml , expr_ref & def ) { app * x = contains_x . x ( ) ; x_subst x_t ( m_util ) ; bounds_proc & bounds = get_bounds ( x , fml ) ; branch_formula bf ; VERIFY ( m_subst . find ( branch_formula ( fml , x , v , 0 , rational :: zero ( ) , 0 ) , bf ) ) ; x_t . set_term ( bf . m_term ) ; x_t . set_coeff ( bf . m_coeff ) ; // ▁ x ▁ is ▁ of ▁ the ▁ form : ▁ x _ t . get _ coeff ( ) * x ' ▁ + ▁ x _ t . get _ term ( ) ENDCOM CTRACE ( " qe " , x_t . get_term ( ) , tout << x_t . get_coeff ( ) << " ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; // ▁ a * x ▁ + ▁ t ▁ < = ▁ 0 ENDCOM // ▁ a * ( c * x ' ▁ + ▁ s ) ▁ + ▁ t ▁ < = ▁ 0 ENDCOM // ▁ a * c * x ' ▁ + ▁ a * s ▁ + ▁ t ▁ < = ▁ 0 ENDCOM unsigned t_size , e_size , sz ; bool is_lower = get_bound_sizes ( bounds , x , t_size , e_size ) ; bool is_strict ; if ( v == 0 ) { is_strict = false ; sz = bounds . size ( is_strict , ! is_lower ) ; expr_ref_vector terms ( m ) ; if ( sz == 0 ) { terms . push_back ( m_util . mk_zero ( x ) ) ; } for ( unsigned i = 0 ; i < sz ; ++ i ) { // ▁ a * x ▁ + ▁ term ▁ < = ▁ 0 ENDCOM expr_ref term ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; rational a = bounds . coeffs ( is_strict , ! is_lower ) [ i ] ; if ( x_t . get_term ( ) ) { // ▁ x ▁ : = ▁ coeff ▁ * ▁ x ' ▁ + ▁ s ▁ ENDCOM // ▁ solve ▁ instead ▁ for ENDCOM // ▁ a * coeff * x ' ▁ + ▁ term ▁ + ▁ a * s ▁ < = ▁ 0 ENDCOM TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; SASSERT ( x_t . get_coeff ( ) . is_pos ( ) ) ; term = m_util . mk_add ( term , m_util . mk_mul ( a , x_t . get_term ( ) ) ) ; a = a * x_t . get_coeff ( ) ; } TRACE ( " qe " , tout << a << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( term , m ) << " ▁ < = ▁ 0 \n " ; ) ; SASSERT ( a . is_int ( ) ) ; SASSERT ( is_lower == a . is_pos ( ) ) ; // ▁ a * x ▁ + ▁ t ▁ < = ▁ 0 ENDCOM // ▁ x ▁ < = ▁ - t ▁ div ▁ a ▁ + ▁ 1 ENDCOM term = m_util . mk_uminus ( term ) ; term = mk_idiv ( term , a ) ; terms . push_back ( term ) ; TRACE ( " qe " , tout << " a : ▁ " << a << " ▁ term : ▁ " << mk_pp ( term , m ) << " \n " ; ) ; } is_strict = true ; sz = bounds . size ( is_strict , ! is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { expr_ref term ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; SASSERT ( abs ( bounds . coeffs ( is_strict , ! is_lower ) [ i ] ) . is_one ( ) ) ; if ( is_lower ) { // ▁ x ▁ + ▁ t ▁ < ▁ 0 ENDCOM // ▁ x ▁ < = ▁ - t ▁ - 1 ENDCOM term = m_util . mk_uminus ( m_util . mk_add ( term , m_util . mk_one ( x ) ) ) ; } else { // ▁ - x ▁ + ▁ t ▁ < ▁ 0 ENDCOM // ▁ t ▁ + ▁ 1 ▁ < = ▁ x ENDCOM term = m_util . mk_add ( term , m_util . mk_one ( x ) ) ; } terms . push_back ( term ) ; } if ( is_lower ) { def = m_util . mk_min ( terms . size ( ) , terms . c_ptr ( ) ) ; } else { def = m_util . mk_max ( terms . size ( ) , terms . c_ptr ( ) ) ; } if ( x_t . get_term ( ) ) { // ▁ x ▁ : = ▁ coeff ▁ * ▁ x ▁ + ▁ s ENDCOM TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; def = m_util . mk_add ( m_util . mk_mul ( x_t . get_coeff ( ) , def ) , x_t . get_term ( ) ) ; } m_util . simplify ( def ) ; return ; } -- v ; is_strict = e_size <= v ; SASSERT ( v < t_size + e_size ) ; if ( is_strict ) { v -= e_size ; TRACE ( " qe _ verbose " , bounds . display ( tout ) ; ) ; } else if ( m_util . is_real ( x ) ) { SASSERT ( 0 == ( e_size & 0x1 ) ) ; v /= 2 ; e_size /= 2 ; } SASSERT ( is_strict || v < e_size ) ; SASSERT ( ! is_strict || v < t_size ) ; // ▁ index ▁ is ▁ for ▁ the ▁ upper / lower - bound ▁ case . ENDCOM // ▁ assert ▁ v ▁ = > ▁ ( x ▁ < = ▁ t _ i ) ▁ ENDCOM SASSERT ( v < bounds . size ( is_strict , is_lower ) ) ; def = bounds . exprs ( is_strict , is_lower ) [ v ] ; rational a = bounds . coeffs ( is_strict , is_lower ) [ v ] ; if ( x_t . get_term ( ) ) { // ▁ x ▁ : = ▁ coeff ▁ * ▁ x ' ▁ + ▁ s ▁ ENDCOM // ▁ solve ▁ instead ▁ for ENDCOM // ▁ a * coeff * x ' ▁ + ▁ term ▁ + ▁ a * s ▁ < = ▁ 0 ENDCOM TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; SASSERT ( x_t . get_coeff ( ) . is_pos ( ) ) ; def = m_util . mk_add ( def , m_util . mk_mul ( a , x_t . get_term ( ) ) ) ; a = a * x_t . get_coeff ( ) ; } SASSERT ( a . is_int ( ) ) ; SASSERT ( is_lower != a . is_pos ( ) ) ; // ▁ a * x ▁ + ▁ t ▁ < = ▁ 0 ENDCOM // ▁ x ▁ < = ▁ - t ▁ div ▁ a ▁ ENDCOM def = m_util . mk_uminus ( def ) ; def = mk_idiv ( def , a ) ; if ( x_t . get_term ( ) ) { // ▁ x ▁ : = ▁ coeff ▁ * ▁ x ▁ + ▁ s ENDCOM def = m_util . mk_add ( m_util . mk_mul ( x_t . get_coeff ( ) , def ) , x_t . get_term ( ) ) ; } if ( is_strict ) { SASSERT ( m_util . m_arith . is_real ( x ) ) ; // ▁ We ▁ actually ▁ want ▁ a ▁ supremum , ▁ such ▁ that ▁ dual ▁ inequalities ▁ are ▁ satisfied . ENDCOM // ▁ i . e . ▁ for ▁ every ▁ dual ▁ inequality ▁ , ▁ if ▁ the ▁ dual ▁ bound ▁ is ▁ feasible , ▁ make ▁ sure ▁ to ENDCOM // ▁ choose ▁ a ▁ value ▁ in ▁ the ▁ feasible ▁ range . ENDCOM def = m_util . mk_sub ( def , m_util . mk_one ( x ) ) ; } m_util . simplify ( def ) ; TRACE ( " qe " , tout << " TBD ▁ ( for ▁ Real ) : ▁ " << a << " ▁ " << mk_pp ( def , m ) << " \n " ; ) ; } expr_ref mk_not ( expr * e ) { expr * r ; if ( m . is_not ( e , r ) ) { return expr_ref ( r , m ) ; } return expr_ref ( m . mk_not ( e ) , m ) ; } // ▁ Projection ▁ function ▁ for ▁ x ▁ of ▁ type ▁ real . ENDCOM // ▁ TBD : ▁ model - based ▁ selection ▁ soundness / completeness ? ENDCOM // ▁ when ▁ model ▁ selects ▁ bound ▁ different ▁ from ▁ what ▁ is ▁ the ▁ smaller ▁ half , ▁ what ▁ then ? ENDCOM // ▁ shouldn ' t ▁ we ▁ find ▁ candidate ▁ among ▁ either ▁ lt ▁ or ▁ gt , ▁ and ▁ then ▁ if ▁ both ▁ can ▁ be ▁ found ENDCOM // ▁ only ▁ then ▁ select ▁ which ▁ one ▁ to ▁ go ▁ with . ▁ Then ▁ assign ▁ has ▁ to ▁ be ▁ context - aware . ENDCOM // ▁ Perhaps ▁ not ▁ really : ▁ the ▁ model ▁ is ▁ used ▁ as ▁ a ▁ hint . ENDCOM bool project_real ( contains_app & x , model_ref & model , expr_ref & fml ) { SASSERT ( m_util . m_arith . is_real ( x . x ( ) ) ) ; model_evaluator model_eval ( * model ) ; bounds_proc & bounds = get_bounds ( x . x ( ) , fml ) ; bool is_lower = bounds . le_size ( ) + bounds . lt_size ( ) < bounds . ge_size ( ) + bounds . gt_size ( ) ; unsigned e_size = bounds . e_size ( is_lower ) ; numeral bound1 , bound2 , vl , x_val ; unsigned idx1 , idx2 ; bool found1 = find_min_max ( is_lower , false , bounds , model_eval , bound1 , idx1 ) ; bool found2 = find_min_max ( is_lower , true , bounds , model_eval , bound2 , idx2 ) ; if ( ! found1 && ! found2 ) { vl = numeral ( 0 ) ; } else if ( found2 && ( ! found1 || bound2 <= bound1 ) ) { // ▁ strict ▁ indices ▁ come ▁ after ▁ non - strict ▁ indices . ▁ There ▁ ENDCOM // ▁ is ▁ a ▁ pair ▁ of ▁ index ▁ values ▁ for ▁ non - strict ▁ inequalities ▁ ENDCOM // ▁ corresponding ▁ to ▁ the ▁ disjunction ▁ ( x ▁ < ▁ t ▁ | | ▁ x ▁ = ▁ t ) ENDCOM vl = numeral ( 1 + 2 * e_size + idx2 ) ; } else if ( found1 && ( ! found2 || bound1 < bound2 ) ) { expr_ref val_x ( m ) ; model_eval ( x . x ( ) , val_x ) ; VERIFY ( m_util . m_arith . is_numeral ( val_x , x_val ) ) ; if ( x_val == bound1 ) { vl = numeral ( 1 + 2 * idx1 ) ; // ▁ even ▁ indicates ▁ equality ▁ between ▁ x ▁ and ▁ bound . ENDCOM } else { vl = numeral ( 1 + 2 * idx1 + 1 ) ; // ▁ odd ▁ indicates ▁ strict ▁ bound . ENDCOM } } assign ( x , fml , vl ) ; subst ( x , vl , fml , 0 ) ; TRACE ( " qe " , tout << mk_pp ( fml , m ) << " \n " ; ) ; return true ; } bool project_int ( contains_app & x , model_ref & model , expr_ref & fml ) { model_evaluator model_eval ( * model ) ; bounds_proc & bounds = get_bounds ( x . x ( ) , fml ) ; SASSERT ( m_util . m_arith . is_int ( x . x ( ) ) ) ; SASSERT ( bounds . lt_size ( ) == 0 && bounds . gt_size ( ) == 0 ) ; bool is_lower = bounds . le_size ( ) < bounds . ge_size ( ) ; numeral bound , vl , x_val ; unsigned idx = bounds . le_size ( ) + bounds . ge_size ( ) ; bool found = find_min_max ( is_lower , false , bounds , model_eval , bound , idx ) ; if ( found ) { SASSERT ( idx < bounds . size ( false , is_lower ) ) ; vl = numeral ( 1 + idx ) ; } else { vl = numeral ( 0 ) ; } assign ( x , fml , vl ) ; subst ( x , vl , fml , 0 ) ; TRACE ( " qe " , tout << mk_pp ( fml , m ) << " \n " ; ) ; return true ; } bool find_min_max ( bool is_lower , bool is_strict , bounds_proc & bounds , model_evaluator & eval , rational & bound , unsigned & idx ) { bool found = false ; unsigned num_bounds = bounds . size ( is_strict , is_lower ) ; rational num ; for ( unsigned i = 0 ; i < num_bounds ; ++ i ) { expr_ref vl ( m ) ; eval ( bounds . atoms ( is_strict , is_lower ) [ i ] , vl ) ; if ( ! m . is_true ( vl ) ) { continue ; } eval ( bounds . exprs ( is_strict , is_lower ) [ i ] , vl ) ; VERIFY ( m_util . m_arith . is_numeral ( vl , num ) ) ; num /= abs ( bounds . coeffs ( is_strict , is_lower ) [ i ] ) ; if ( found ) { if ( is_lower ? ( num < bound ) : ( num > bound ) ) { bound = num ; idx = i ; } } else { found = true ; idx = i ; bound = num ; } } return found ; } bool get_bound_sizes ( bounds_proc & bounds , app * x , unsigned & t_size , unsigned & e_size ) { unsigned le_size = bounds . le_size ( ) ; unsigned ge_size = bounds . ge_size ( ) ; if ( m_util . is_real ( x ) ) { le_size *= 2 ; ge_size *= 2 ; } if ( le_size + bounds . lt_size ( ) < ge_size + bounds . gt_size ( ) ) { e_size = le_size ; t_size = bounds . lt_size ( ) ; return true ; } else { e_size = ge_size ; t_size = bounds . gt_size ( ) ; return false ; } } void add_cache ( app * x , expr * fml , unsigned v , expr * result , rational coeff , expr * term ) { m_trail . push_back ( x ) ; m_trail . push_back ( fml ) ; m_trail . push_back ( result ) ; if ( term ) m_trail . push_back ( term ) ; m_subst . insert ( branch_formula ( fml , x , v , result , coeff , term ) ) ; } bool get_cache ( app * x , expr * fml , unsigned v , expr_ref & result ) { branch_formula bf ; if ( ! m_subst . find ( branch_formula ( fml , x , v , 0 , rational :: zero ( ) , 0 ) , bf ) ) { return false ; } SASSERT ( bf . m_result ) ; result = bf . m_result ; return true ; } void assign_divs ( contains_app & contains_x , bounds_proc & bounds , x_subst & x_t , expr_ref & result ) { app * x = contains_x . x ( ) ; app_ref z ( m ) , z_bv ( m ) ; rational d ; if ( ! bounds . div_z ( d , z_bv , z ) ) { return ; } m_ctx . add_var ( z_bv ) ; // ▁ assert ▁ ENDCOM // ▁ z ▁ < ▁ d ENDCOM // ▁ d ▁ | ▁ ( x ▁ - ▁ z ) ENDCOM // ▁ ( c ▁ | ▁ ax ▁ + ▁ t ▁ < - > ▁ c ▁ | ▁ az ▁ + ▁ t ) ▁ for ▁ each ▁ divisor . ENDCOM // ▁ z ▁ < ▁ d ENDCOM expr * z_lt_d = m_util . m_arith . mk_le ( z , m_util . m_arith . mk_numeral ( d - rational ( 1 ) , true ) ) ; m_ctx . add_constraint ( false , z_lt_d ) ; // ▁ result ▁ < - ▁ result ▁ & ▁ z ▁ < = ▁ d ▁ - ▁ 1 ENDCOM SASSERT ( ! abs ( d ) . is_one ( ) ) ; rational d1 = d - rational ( 1 ) ; expr_ref tmp ( m ) ; m_util . m_arith_rewriter . mk_le ( z , m_util . m_arith . mk_numeral ( d1 , true ) , tmp ) ; m_util . m_bool_rewriter . mk_and ( result , tmp , result ) ; // ▁ d ▁ | ▁ ( x ▁ - ▁ z ) ENDCOM expr_ref t1 ( m ) , new_atom ( m ) ; t1 = m_util . mk_sub ( x , z ) ; m_util . mk_divides ( d , t1 , new_atom ) ; m_ctx . add_constraint ( false , new_atom ) ; // ▁ ( c ▁ | ▁ ax ▁ + ▁ t ▁ < - > ▁ c ▁ | ▁ az ▁ + ▁ t ) ▁ for ▁ each ▁ divisor . ENDCOM mk_div_equivs ( bounds , z , result ) ; // ▁ update ▁ x _ t ▁ to ▁ map ▁ x ▁ | - > ▁ dx ▁ + ▁ z ENDCOM x_t . set_term ( z ) ; x_t . set_coeff ( d ) ; } // ▁ ( c ▁ | ▁ ax ▁ + ▁ t ▁ < - > ▁ c ▁ | ▁ az ▁ + ▁ t ) ▁ for ▁ each ▁ divisor . ENDCOM void mk_div_equivs ( bounds_proc & bounds , expr * z , expr_ref & result ) { unsigned sz = bounds . div_size ( ) ; app * const * atoms = bounds . div_atoms ( ) ; rational const * coeffs = bounds . div_coeffs ( ) ; expr * const * terms = bounds . div_terms ( ) ; rational const * divisors = bounds . divisors ( ) ; expr_ref new_atom ( m ) , t1 ( m ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * atm = atoms [ i ] ; t1 = m_util . mk_add ( m_util . mk_mul ( coeffs [ i ] , z ) , terms [ i ] ) ; m_util . mk_divides ( divisors [ i ] , t1 , new_atom ) ; m_util . m_replace . apply_substitution ( atm , new_atom . get ( ) , result ) ; m_ctx . add_constraint ( false , mk_not ( atm ) , new_atom ) ; m_ctx . add_constraint ( false , mk_not ( new_atom ) , atm ) ; } } void assign_nested_divs ( contains_app & contains_x , bounds_proc & bounds , expr_ref & result ) { unsigned num_nested_divs = bounds . nested_div_size ( ) ; if ( num_nested_divs == 0 ) { return ; } app_ref z ( m ) , z_bv ( m ) ; rational d ; VERIFY ( bounds . div_z ( d , z_bv , z ) ) ; for ( unsigned i = 0 ; i < num_nested_divs ; ++ i ) { // ▁ mod _ term ▁ = ▁ arg _ 0 ▁ mod ▁ k ENDCOM app * atm = bounds . nested_div_atom ( i ) ; rational const & k = bounds . nested_divisor ( i ) ; app * z1_bv = bounds . nested_div_z_bv ( i ) ; app * z1 = bounds . nested_div_z ( i ) ; m_ctx . add_var ( z1_bv ) ; // ▁ assert ENDCOM // ▁ z ▁ < ▁ k ENDCOM // ▁ ( coeff * x ▁ + ▁ rest ▁ - ▁ z ) ▁ mod ▁ k ▁ = = ▁ 0 ENDCOM expr * z_lt_k = m_util . m_arith . mk_le ( z1 , m_util . m_arith . mk_numeral ( k - rational ( 1 ) , true ) ) ; m_ctx . add_constraint ( false , z_lt_k ) ; expr * e1 = m_util . m_arith . mk_sub ( atm -> get_arg ( 0 ) , z1 ) ; expr * e2 = atm -> get_arg ( 1 ) ; expr_ref mod_term2 ( m_util . m_arith . mk_mod ( e1 , e2 ) , m ) ; m_util . simplify ( mod_term2 ) ; m_ctx . add_constraint ( false , m . mk_eq ( mod_term2 , m_util . mk_zero ( mod_term2 ) ) ) ; m_util . m_replace . apply_substitution ( atm , z1 , result ) ; // ▁ conjoin ▁ ( coeff * z ▁ + ▁ rest ▁ - ▁ z1 ) ▁ mod ▁ k ▁ = = ▁ 0 ▁ to ▁ result ENDCOM expr_ref mod_eq ( m ) , tmp1 ( m ) , tmp2 ( m ) ; tmp2 = m_util . mk_numeral ( bounds . nested_div_coeff ( i ) , true ) ; tmp1 = m_util . m_arith . mk_mul ( tmp2 , z1 ) ; tmp2 = m_util . m_arith . mk_sub ( bounds . nested_div_term ( i ) , z ) ; tmp2 = m_util . m_arith . mk_add ( tmp1 , tmp2 ) ; tmp1 = m_util . m_arith . mk_mod ( tmp2 , bounds . nested_div_atom ( i ) -> get_arg ( 1 ) ) ; mod_eq = m . mk_eq ( tmp1 , m_util . mk_zero ( z ) ) ; m_util . simplify ( mod_eq ) ; result = m . mk_and ( result , mod_eq ) ; TRACE ( " qe " , tout << mk_pp ( mod_eq , m ) << " \n " ; ) ; } } bounds_proc & get_bounds ( app * x , expr * fml ) { bounds_proc * result = 0 ; VERIFY ( m_bounds_cache . find ( x , fml , result ) ) ; return * result ; } void mk_non_bounds ( bounds_proc & bounds , bool is_strict , bool is_lower , expr_ref & result ) { unsigned sz = bounds . size ( is_strict , is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , is_lower ) [ i ] ; m_ctx . add_constraint ( true , mk_not ( e ) ) ; m_util . m_replace . apply_substitution ( e , m . mk_false ( ) , result ) ; } } void mk_non_resolve ( bounds_proc & bounds , bool is_strict , bool is_lower , expr_ref & result ) { unsigned sz = bounds . size ( is_strict , ! is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , ! is_lower ) [ i ] ; m_ctx . add_constraint ( true , e ) ; m_util . m_replace . apply_substitution ( e , m . mk_true ( ) , result ) ; } } // ▁ phi [ x ▁ < ▁ t , ▁ x ▁ < = ▁ s , ▁ x ▁ > = ▁ u , ▁ x ▁ > ▁ v ] ENDCOM // ▁ x ▁ = ▁ + oo : ▁ phi [ false , ▁ false , ▁ true , ▁ true ] ENDCOM // ▁ x ▁ < ▁ t : ▁ phi [ true , ▁ t - e ▁ < ▁ s , ▁ t ▁ - ▁ e ▁ > = ▁ u , ▁ t ▁ - ▁ e ▁ > ▁ v ] ▁ = = ▁ phi [ true , ▁ t ▁ < = ▁ s , ▁ t ▁ > ▁ u , ▁ t ▁ > ▁ v ] ENDCOM // ▁ x ▁ < ▁ s : ▁ phi [ s - e ▁ < ▁ t , ▁ true , ▁ s ▁ - ▁ e ▁ > = ▁ u , ▁ s ▁ - ▁ e ▁ > ▁ v ] ▁ = = ▁ phi [ s ▁ < = ▁ t , ▁ true , ▁ s ▁ > ▁ u , ▁ s ▁ > ▁ v ] ENDCOM // ▁ x ▁ = ▁ s : ▁ phi [ s ▁ < ▁ t , ▁ true , ▁ s ▁ > = ▁ u , ▁ s ▁ > ▁ v ] ENDCOM // ▁ assert ▁ ENDCOM // ▁ path1 ▁ = > ▁ x ▁ < ▁ t ▁ ENDCOM // ▁ bounds : ENDCOM // ▁ path1 ▁ = > ▁ x ▁ < ▁ t ' ▁ = > ▁ t ▁ < ▁ t ' ▁ when ▁ index ( t ' ) ▁ < ▁ index ( t ) ENDCOM // ▁ path1 ▁ = > ▁ x ▁ < ▁ t ' ▁ = > ▁ t ▁ < = ▁ t ' ▁ when ▁ index ( t ' ) ▁ > = ▁ index ( t ) ENDCOM // ▁ path1 ▁ = > ▁ x ▁ < = ▁ s ▁ = > ▁ t ▁ < = ▁ s ENDCOM // ▁ resolve : ENDCOM // ▁ path1 ▁ = > ▁ x ▁ > = ▁ u ▁ = > ▁ t ▁ > ▁ u ENDCOM // ▁ path1 ▁ = > ▁ x ▁ > ▁ v ▁ = > ▁ t ▁ > ▁ v ENDCOM // ▁ symmetry ▁ reduction : ENDCOM // ▁ path2 ▁ = > ▁ x ▁ < = ▁ s ENDCOM // ▁ bounds : ENDCOM // ▁ path2 ▁ = > ▁ x ▁ < ▁ s ▁ = > ▁ x ▁ < ▁ t ▁ = > ▁ s ▁ < = ▁ t ENDCOM // ▁ path2 ▁ = > ▁ x ▁ = ▁ s ▁ = > ▁ x ▁ < ▁ t ▁ = > ▁ s ▁ < ▁ t ENDCOM // ▁ path2 ▁ = > ▁ x ▁ < = ▁ s ▁ = > ▁ x ▁ < = ▁ s ' ▁ = > ▁ s ▁ < ▁ s ' ▁ when ▁ index ( s ' ) ▁ < ▁ index ( s ) ENDCOM // ▁ path2 ▁ = > ▁ x ▁ < = ▁ s ▁ = > ▁ x ▁ < = ▁ s ' ▁ = > ▁ s ▁ < = ▁ s ' ▁ when ▁ index ( s ' ) ▁ > = ▁ index ( s ) ENDCOM // ▁ resolve : ENDCOM // ▁ path2 ▁ = > ▁ x ▁ < ▁ s ▁ = > ▁ x ▁ > = ▁ u ▁ = > ▁ s ▁ > ▁ u ENDCOM // ▁ path2 ▁ = > ▁ x ▁ = ▁ s ▁ = > ▁ x ▁ > = ▁ u ▁ = > ▁ s ▁ > = ▁ u ENDCOM // ▁ path2 ▁ = > ▁ x ▁ < = ▁ s ▁ = > ▁ x ▁ > ▁ v ▁ = > ▁ s ▁ > ▁ v ENDCOM void mk_bound ( bool is_strict , bool is_lower , rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { if ( is_strict ) { if ( is_lower ) { // ▁ b * t ▁ > ▁ a * s ENDCOM m_util . mk_strict_bound ( b , s , a , t , result ) ; } else { // ▁ b * t ▁ < ▁ a * s ENDCOM m_util . mk_strict_bound ( a , t , b , s , result ) ; } } else { if ( is_lower ) { // ▁ b * t ▁ > = ▁ a * s ENDCOM m_util . mk_bound ( b , s , a , t , result ) ; } else { // ▁ b * t ▁ < = ▁ a * s ENDCOM m_util . mk_bound ( a , t , b , s , result ) ; } } m_util . simplify ( result ) ; TRACE ( " qe " , tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; tout << ( is_lower ? " is - lower " : " is - upper " ) << " \n " ; tout << " a : ▁ " << a << " ▁ " << mk_pp ( t , m ) << " \n " ; tout << " b : ▁ " << b << " ▁ " << mk_pp ( s , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; ) ; } // ▁ a * x ▁ < = ▁ t , ▁ a * x ▁ < ▁ t ENDCOM /* STRNEWLINE ▁ - ▁ bounds ▁ STRNEWLINE ▁ - ▁ add _ assertion ▁ - ▁ flag ▁ whether ▁ to ▁ add ▁ side - effect ▁ to ▁ state STRNEWLINE ▁ - ▁ x ▁ - ▁ the ▁ variable ▁ to ▁ be ▁ eliminated STRNEWLINE ▁ - ▁ is _ strict ▁ - ▁ whether ▁ to ▁ loop ▁ over ▁ strict ▁ inequalities STRNEWLINE ▁ - ▁ is _ eq _ ctx ▁ - ▁ whether ▁ non - strict ▁ inequality ▁ is ▁ to ▁ be ▁ treated ▁ as ▁ equality ▁ case . STRNEWLINE ▁ - ▁ is _ strict _ ctx ▁ - ▁ whether ▁ ' atm ' ▁ is ▁ a ▁ strict ▁ inequality STRNEWLINE ▁ - ▁ is _ lower ▁ - ▁ whether ▁ ' x ' ▁ is ▁ given ▁ a ▁ lower - bound ▁ in ▁ ' atm ' STRNEWLINE ▁ - ▁ index ▁ - ▁ index ▁ of ▁ ' atm ' ▁ in ▁ ' bounds ' ▁ ' atm ▁ = ▁ bounds [ index ] ' STRNEWLINE ▁ - ▁ a ▁ - ▁ coefficient ▁ to ▁ ' x ' ▁ in ▁ ' atm ' STRNEWLINE ▁ - ▁ t ▁ - ▁ upper / lower ▁ bound ▁ to ▁ ' x ' ▁ in ▁ ' atm ' STRNEWLINE ▁ */ void mk_bounds ( bounds_proc & bounds , app * x , bool is_strict , bool is_eq_ctx , bool is_strict_ctx , bool is_lower , unsigned index , rational const & a , expr * t , expr_ref & result ) { TRACE ( " qe " , tout << mk_pp ( t , m ) << " \n " ; ) ; SASSERT ( ! is_eq_ctx || ! is_strict_ctx ) ; unsigned sz = bounds . size ( is_strict , is_lower ) ; expr_ref tmp ( m ) , eq ( m ) ; bool same_strict = ( is_strict == is_strict_ctx ) ; bool non_strict_real = m_util . is_real ( x ) && ! is_strict_ctx ; app * atm = bounds . atoms ( is_strict_ctx , is_lower ) [ index ] ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , is_lower ) [ i ] ; expr_ref s ( bounds . exprs ( is_strict , is_lower ) [ i ] , m ) ; rational b = bounds . coeffs ( is_strict , is_lower ) [ i ] ; if ( same_strict && i == index ) { if ( non_strict_real ) { m_util . mk_eq ( a , x , t , eq ) ; TRACE ( " qe " , tout << " a : " << a << " ▁ x : ▁ " << mk_pp ( x , m ) << " t : ▁ " << mk_pp ( t , m ) << " ▁ eq : ▁ " << mk_pp ( eq , m ) << " \n " ; ) ; if ( is_eq_ctx ) { m_ctx . add_constraint ( true , eq ) ; } else { m_ctx . add_constraint ( true , mk_not ( eq ) ) ; m_ctx . add_constraint ( true , e ) ; } } else { m_ctx . add_constraint ( true , e ) ; } m_util . m_replace . apply_substitution ( atm , m . mk_true ( ) , result ) ; continue ; } // ▁ Break ▁ symmetries ▁ by ▁ using ▁ index : ENDCOM // ▁ bounds ▁ before ▁ me ▁ are ▁ strictly ▁ larger . ENDCOM // ▁ Cases : ENDCOM // ▁ ax ▁ < = ▁ t ▁ & ▁ ax ▁ ! = ▁ t ▁ & ▁ bx ▁ < ▁ s ▁ = > ▁ bt ▁ < = ▁ as ENDCOM // ▁ ax ▁ < = ▁ t ▁ & ▁ ax ▁ = ▁ t ▁ & ▁ bx ▁ < ▁ s ▁ = > ▁ bt ▁ < ▁ as ENDCOM // ▁ bx ▁ < = ▁ s ▁ = > ▁ bt ▁ < ▁ as ▁ or ▁ bt ▁ < = ▁ as ▁ depending ▁ on ▁ symmetry ENDCOM bool result_is_strict = ( non_strict_real && is_eq_ctx && is_strict ) || ( same_strict && i < index ) ; mk_bound ( result_is_strict , is_lower , a , t , b , s , tmp ) ; m_util . m_replace . apply_substitution ( e , tmp . get ( ) , result ) ; TRACE ( " qe " , tout << ( result_is_strict ? " strict ▁ result " : " non - strict ▁ result " ) << " \n " ; tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; tout << mk_pp ( atm , m ) << " ▁ & ▁ " ; tout << mk_pp ( e , m ) << " ▁ - - > ▁ " ; tout << mk_pp ( tmp . get ( ) , m ) << " \n " ; ) ; m_ctx . add_constraint ( true , mk_not ( e ) , tmp ) ; } } // ▁ x ▁ < = ▁ t ENDCOM // ▁ x ▁ ! = ▁ t ▁ = > ▁ x ▁ > = ▁ u ▁ = > ▁ t ▁ > ▁ u ENDCOM // ▁ x ▁ = ▁ t ▁ = > ▁ x ▁ > = ▁ u ▁ = > ▁ t ▁ > = ▁ u ENDCOM void mk_resolve ( bounds_proc & bounds , app * x , x_subst & x_t , bool is_strict , bool is_eq_ctx , bool is_strict_ctx , bool is_lower , unsigned index , rational const & a , expr * t , expr_ref & result ) { expr_ref tmp ( m ) ; unsigned sz = bounds . size ( is_strict , ! is_lower ) ; bool is_strict_real = ! is_eq_ctx && m_util . is_real ( x ) && ! is_strict_ctx ; bool strict_resolve = is_strict || is_strict_ctx || is_strict_real ; app * atm = bounds . atoms ( is_strict_ctx , is_lower ) [ index ] ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , ! is_lower ) [ i ] ; expr_ref s ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; rational b = bounds . coeffs ( is_strict , ! is_lower ) [ i ] ; SASSERT ( ! b . is_zero ( ) ) ; SASSERT ( b . is_pos ( ) != a . is_pos ( ) ) ; s = x_t . mk_term ( b , s ) ; b = x_t . mk_coeff ( b ) ; m_util . mk_resolve ( x , strict_resolve , a , t , b , s , tmp ) ; expr_ref save_result ( result ) ; m_util . m_replace . apply_substitution ( e , tmp . get ( ) , result ) ; m_ctx . add_constraint ( true , mk_not ( e ) , tmp ) ; TRACE ( " qe _ verbose " , tout << mk_pp ( atm , m ) << " ▁ " ; tout << mk_pp ( e , m ) << " ▁ = = > \n " ; tout << mk_pp ( tmp , m ) << " \n " ; tout << " old ▁ fml : ▁ " << mk_pp ( save_result , m ) << " \n " ; tout << " new ▁ fml : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; } } bool update_bounds ( bounds_proc & bounds , contains_app & contains_x , expr * fml , atom_set const & tbl , bool is_pos ) { app_ref tmp ( m ) ; atom_set :: iterator it = tbl . begin ( ) , end = tbl . end ( ) ; for ( ; it != end ; ++ it ) { app * e = * it ; if ( ! contains_x ( e ) ) { continue ; } if ( ! is_pos ) { SASSERT ( ! m . is_not ( e ) ) ; tmp = m . mk_not ( e ) ; e = tmp ; } if ( ! bounds . get_bound ( contains_x , e ) ) { return false ; } } return true ; } bool update_bounds ( contains_app & contains_x , expr * fml ) { bounds_proc * bounds = 0 ; if ( m_bounds_cache . find ( contains_x . x ( ) , fml , bounds ) ) { return true ; } bounds = alloc ( bounds_proc , m_util ) ; if ( ! update_bounds ( * bounds , contains_x , fml , m_ctx . pos_atoms ( ) , true ) ) { dealloc ( bounds ) ; return false ; } if ( ! update_bounds ( * bounds , contains_x , fml , m_ctx . neg_atoms ( ) , false ) ) { dealloc ( bounds ) ; return false ; } m_trail . push_back ( contains_x . x ( ) ) ; m_trail . push_back ( fml ) ; m_bounds_cache . insert ( contains_x . x ( ) , fml , bounds ) ; return true ; } } ; // ▁ non - linear ▁ arithmetic ENDCOM class nlarith_plugin : public qe_solver_plugin { typedef obj_map < app , unsigned > weight_m ; typedef obj_pair_map < expr , expr , nlarith :: branch_conditions * > bcs_t ; typedef obj_map < expr , weight_m * > weights_t ; bcs_t m_cache ; weights_t m_weights ; th_rewriter m_rewriter ; nlarith :: util m_util ; expr_safe_replace m_replace ; expr_ref_vector m_trail ; factor_rewriter_star m_factor_rw ; bool m_produce_models ; public : nlarith_plugin ( i_solver_context & ctx , ast_manager & m , bool produce_models ) : qe_solver_plugin ( m , m . mk_family_id ( " arith " ) , ctx ) , m_rewriter ( m ) , m_util ( m ) , m_replace ( m ) , m_trail ( m ) , m_factor_rw ( m ) , m_produce_models ( produce_models ) { TRACE ( " qe " , tout << " produce ▁ models : ▁ " << produce_models << " \n " ; ) ; m_util . set_enable_linear ( true ) ; // ▁ ( produce _ models ) ; ENDCOM } virtual ~ nlarith_plugin ( ) { bcs_t :: iterator it = m_cache . begin ( ) , end = m_cache . end ( ) ; for ( ; it != end ; ++ it ) { dealloc ( it -> get_value ( ) ) ; } weights_t :: iterator it2 = m_weights . begin ( ) , e2 = m_weights . end ( ) ; for ( ; it2 != e2 ; ++ it2 ) { dealloc ( it2 -> get_value ( ) ) ; } } virtual bool simplify ( expr_ref & fml ) { expr_ref tmp ( m ) , tmp2 ( m ) ; m_factor_rw ( fml , tmp ) ; m_rewriter ( tmp , tmp2 ) ; if ( fml . get ( ) != tmp2 . get ( ) ) { fml = tmp2 ; return true ; } return false ; } virtual void assign ( contains_app & x , expr * fml , rational const & vl ) { nlarith :: branch_conditions * brs ; VERIFY ( m_cache . find ( x . x ( ) , fml , brs ) ) ; SASSERT ( vl . is_unsigned ( ) ) ; SASSERT ( vl . get_unsigned ( ) < brs -> size ( ) ) ; expr * branch_fml = brs -> branches ( vl . get_unsigned ( ) ) ; expr_ref result ( m ) , tmp ( m ) ; m_factor_rw ( branch_fml , tmp ) ; m_rewriter ( tmp , result ) ; TRACE ( " qe " , tout << vl << " ▁ " << mk_pp ( result . get ( ) , m ) << " \n " ; ) ; m_ctx . add_constraint ( true , result ) ; } virtual bool get_num_branches ( contains_app & x , expr * fml , rational & num_branches ) { nlarith :: branch_conditions * brs ; if ( m_cache . find ( x . x ( ) , fml , brs ) ) { num_branches = rational ( brs -> size ( ) ) ; return true ; } expr_ref_vector lits ( m ) ; update_bounds ( lits , m_ctx . pos_atoms ( ) , true ) ; update_bounds ( lits , m_ctx . neg_atoms ( ) , false ) ; brs = alloc ( nlarith :: branch_conditions , m ) ; TRACE ( " nlarith " , tout << mk_pp ( fml , m ) << " \n " ; ) ; if ( ! m_util . create_branches ( x . x ( ) , lits . size ( ) , lits . c_ptr ( ) , * brs ) ) { TRACE ( " nlarith " , tout << " no ▁ branches ▁ for ▁ " << mk_pp ( x . x ( ) , m ) << " \n " ; ) ; dealloc ( brs ) ; return false ; } num_branches = rational ( brs -> size ( ) ) ; insert_cache ( x . x ( ) , fml , brs ) ; return true ; } virtual void subst ( contains_app & x , rational const & vl , expr_ref & fml , expr_ref * def ) { nlarith :: branch_conditions * brs ; VERIFY ( m_cache . find ( x . x ( ) , fml , brs ) ) ; SASSERT ( vl . is_unsigned ( ) ) ; SASSERT ( vl . get_unsigned ( ) < brs -> size ( ) ) ; unsigned j = vl . get_unsigned ( ) ; m_replace . reset ( ) ; for ( unsigned i = 0 ; i < brs -> preds ( ) . size ( ) ; ++ i ) { m_replace . insert ( brs -> preds ( i ) , brs -> subst ( j ) [ i ] ) ; } m_replace ( fml ) ; expr_ref tmp ( m . mk_and ( brs -> constraints ( j ) , fml ) , m ) ; m_factor_rw ( tmp , fml ) ; if ( def ) { m_factor_rw ( brs -> def ( j ) , * def ) ; } } virtual unsigned get_weight ( contains_app & x , expr * fml ) { obj_map < app , unsigned > * weights = 0 ; unsigned weight = 0 ; if ( ! m_weights . find ( fml , weights ) ) { weights = alloc ( weight_m ) ; m_weights . insert ( fml , weights ) ; m_trail . push_back ( fml ) ; ptr_vector < app > nl_vars ; m_util . extract_non_linear ( to_app ( fml ) , nl_vars ) ; for ( unsigned i = 0 ; i < nl_vars . size ( ) ; ++ i ) { weights -> insert ( nl_vars [ i ] , 100 ) ; } } if ( weights -> find ( x . x ( ) , weight ) ) { return weight ; } return UINT_MAX ; } virtual bool solve ( conj_enum & conjs , expr * fml ) { return false ; } // ▁ we ▁ don ' t ▁ need ▁ to ▁ modify ▁ the ▁ atom . ENDCOM virtual bool mk_atom ( expr * e , bool p , expr_ref & result ) { return false ; } virtual bool is_uninterpreted ( app * f ) { if ( m_produce_models ) { return true ; } switch ( f -> get_decl_kind ( ) ) { case OP_NUM : case OP_LE : case OP_LT : case OP_GE : case OP_GT : case OP_ADD : case OP_SUB : case OP_UMINUS : return false ; case OP_MUL : { arith_util a ( m ) ; expr * m , * n ; if ( a . is_mul ( f , m , n ) && ( a . is_numeral ( m ) || a . is_numeral ( n ) ) ) { return false ; } return true ; } default : return true ; } return true ; } private : void insert_cache ( app * x , expr * e , nlarith :: branch_conditions * brs ) { m_trail . push_back ( x ) ; m_trail . push_back ( e ) ; m_cache . insert ( x , e , brs ) ; } void update_bounds ( expr_ref_vector & lits , atom_set const & tbl , bool is_pos ) { atom_set :: iterator it = tbl . begin ( ) , end = tbl . end ( ) ; for ( ; it != end ; ++ it ) { app * e = * it ; lits . push_back ( is_pos ? e : m . mk_not ( e ) ) ; } } } ; qe_solver_plugin * mk_arith_plugin ( i_solver_context & ctx , bool produce_models , smt_params & p ) { if ( p . m_nlquant_elim ) { return alloc ( nlarith_plugin , ctx , ctx . get_manager ( ) , produce_models ) ; } else { return alloc ( arith_plugin , ctx , ctx . get_manager ( ) , p ) ; } } } </DOCUMENT>
<DOCUMENT_ID="Horizon-Blue/playground/tree/master/Solutions-to-OJs/USACO/Chapter1/1.1/02_your-ride-is-here.cpp"> /* STRNEWLINE ID : ▁ skyline12 STRNEWLINE PROG : ▁ ride STRNEWLINE LANG : ▁ C + + 11 STRNEWLINE */ # include < iostream > # include < fstream > # include < string > using namespace std ; int main ( ) { ofstream fout ( " ride . out " ) ; ifstream fin ( " ride . in " ) ; string a , b ; fin >> a >> b ; int anum = 1 , bnum = 1 ; for ( char c : a ) anum *= c - ' A ' + 1 ; for ( char c : b ) bnum *= c - ' A ' + 1 ; if ( anum % 47 == bnum % 47 ) fout << " GO " << endl ; else fout << " STAY " << endl ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="ichu501/WinObjC/tree/master/deps/3rdparty/icu/icu/source/test/intltest/tsmthred.cpp"> /* * * * * STRNEWLINE ▁ * ▁ COPYRIGHT : STRNEWLINE ▁ * ▁ Copyright ▁ ( c ) ▁ 1999-2014 , ▁ International ▁ Business ▁ Machines ▁ Corporation ▁ and STRNEWLINE ▁ * ▁ others . ▁ All ▁ Rights ▁ Reserved . STRNEWLINE ▁ * * * * */ # if defined ( hpux ) # ifndef _INCLUDE_POSIX_SOURCE # define _INCLUDE_POSIX_SOURCE # endif # endif # include " simplethread . h " # include " unicode / utypes . h " # include " unicode / ustring . h " # include " umutex . h " # include " cmemory . h " # include " cstring . h " # include " uparse . h " # include " unicode / localpointer . h " # include " unicode / resbund . h " # include " unicode / udata . h " # include " unicode / uloc . h " # include " unicode / locid . h " # include " putilimp . h " # include " intltest . h " # include " tsmthred . h " # include " unicode / ushape . h " # include " unicode / translit . h " # include " sharedobject . h " # include " unifiedcache . h " # include " uassert . h " # if U_PLATFORM_USES_ONLY_WIN32_API /* ▁ Prefer ▁ native ▁ Windows ▁ APIs ▁ even ▁ if ▁ POSIX ▁ is ▁ implemented ▁ ( i . e . , ▁ on ▁ Cygwin ) . ▁ */ # undef POSIX # elif U_PLATFORM_IMPLEMENTS_POSIX # define POSIX # else # undef POSIX # endif /* ▁ Needed ▁ by ▁ z / OS ▁ to ▁ get ▁ usleep ▁ */ # if U_PLATFORM == U_PF_OS390 # define __DOT1 1 # define __UU # ifndef _XPG4_2 # define _XPG4_2 # endif # include < unistd . h > # endif # if defined ( POSIX ) # define HAVE_IMP # if ( ICU_USE_THREADS == 1 ) # include < pthread . h > # endif # if defined ( __hpux ) && defined ( HPUX_CMA ) # if defined ( read ) // ▁ read ▁ being ▁ defined ▁ as ▁ cma _ read ▁ causes ▁ trouble ▁ with ▁ iostream : : read ENDCOM # undef read # endif # endif /* ▁ Define ▁ _ _ EXTENSIONS _ _ ▁ for ▁ Solaris ▁ and ▁ old ▁ friends ▁ in ▁ strict ▁ mode . ▁ */ # ifndef __EXTENSIONS__ # define __EXTENSIONS__ # endif # if U_PLATFORM == U_PF_OS390 # include < sys / types . h > # endif # if U_PLATFORM != U_PF_OS390 # include < signal . h > # endif /* ▁ Define ▁ _ XPG4_2 ▁ for ▁ Solaris ▁ and ▁ friends . ▁ */ # ifndef _XPG4_2 # define _XPG4_2 # endif /* ▁ Define ▁ _ _ USE _ XOPEN _ EXTENDED ▁ for ▁ Linux ▁ and ▁ glibc . ▁ */ # ifndef __USE_XOPEN_EXTENDED # define __USE_XOPEN_EXTENDED # endif /* ▁ Define ▁ _ INCLUDE _ XOPEN _ SOURCE _ EXTENDED ▁ for ▁ HP / UX ▁ ( 11 ? ) . ▁ */ # ifndef _INCLUDE_XOPEN_SOURCE_EXTENDED # define _INCLUDE_XOPEN_SOURCE_EXTENDED # endif # include < unistd . h > # endif /* ▁ HPUX ▁ */ # ifdef sleep # undef sleep # endif # define TSMTHREAD_FAIL ( msg ) errln ( " % s ▁ at ▁ file ▁ % s , ▁ line ▁ % d " , msg , __FILE__ , __LINE__ ) # define TSMTHREAD_ASSERT ( expr ) { if ( ! ( expr ) ) { TSMTHREAD_FAIL ( " Fail " ) ; } } MultithreadTest :: MultithreadTest ( ) { } MultithreadTest :: ~ MultithreadTest ( ) { } # if ( ICU_USE_THREADS == 0 ) void MultithreadTest :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * /* par */ ) { if ( exec ) logln ( " TestSuite ▁ MultithreadTest : ▁ " ) ; if ( index == 0 ) name = " NO _ THREADED _ TESTS " ; else name = " " ; if ( exec ) { logln ( " MultithreadTest ▁ - ▁ test ▁ DISABLED . ▁ ▁ ICU _ USE _ THREADS ▁ set ▁ to ▁ 0 , ▁ check ▁ your ▁ configuration ▁ if ▁ this ▁ is ▁ a ▁ problem . . " ) ; } } # else # include < stdio . h > # include < string . h > # include < ctype . h > // ▁ tolower , ▁ toupper ENDCOM # include " unicode / putil . h " // ▁ for ▁ mthreadtest ENDCOM # include " unicode / numfmt . h " # include " unicode / choicfmt . h " # include " unicode / msgfmt . h " # include " unicode / locid . h " # include " unicode / coll . h " # include " unicode / calendar . h " # include " ucaconf . h " void SimpleThread :: errorFunc ( ) { // ▁ * ( char ▁ * )0 ▁ = ▁ 3 ; ▁ // ▁ Force ▁ entry ▁ into ▁ a ▁ debugger ▁ via ▁ a ▁ crash ; ENDCOM } void MultithreadTest :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * /* par */ ) { if ( exec ) logln ( " TestSuite ▁ MultithreadTest : ▁ " ) ; switch ( index ) { case 0 : name = " TestThreads " ; if ( exec ) TestThreads ( ) ; break ; case 1 : name = " TestMutex " ; if ( exec ) TestMutex ( ) ; break ; case 2 : name = " TestThreadedIntl " ; # if ! UCONFIG_NO_FORMATTING if ( exec ) { TestThreadedIntl ( ) ; } # endif break ; case 3 : name = " TestCollators " ; # if ! UCONFIG_NO_COLLATION if ( exec ) { TestCollators ( ) ; } # endif /* ▁ # if ▁ ! UCONFIG _ NO _ COLLATION ▁ */ break ; case 4 : name = " TestString " ; if ( exec ) { TestString ( ) ; } break ; case 5 : name = " TestArabicShapingThreads " ; if ( exec ) { TestArabicShapingThreads ( ) ; } break ; case 6 : name = " TestAnyTranslit " ; if ( exec ) { TestAnyTranslit ( ) ; } break ; case 7 : name = " TestConditionVariables " ; if ( exec ) { TestConditionVariables ( ) ; } break ; case 8 : name = " TestUnifiedCache " ; if ( exec ) { TestUnifiedCache ( ) ; } break ; default : name = " " ; break ; // needed ▁ to ▁ end ▁ loop ENDCOM } } // ▁ TestThreads ▁ - - ▁ see ▁ if ▁ threads ▁ really ▁ work ▁ at ▁ all . ENDCOM // ▁ Set ▁ up ▁ N ▁ threads ▁ pointing ▁ at ▁ N ▁ chars . ▁ When ▁ they ▁ are ▁ started , ▁ they ▁ will ENDCOM // ▁ each ▁ sleep ▁ 1 ▁ second ▁ and ▁ then ▁ set ▁ their ▁ chars . ▁ At ▁ the ▁ end ▁ we ▁ make ▁ sure ▁ they ENDCOM // ▁ are ▁ all ▁ set . ENDCOM # define THREADTEST_NRTHREADS 8 # define ARABICSHAPE_THREADTEST 30 class TestThreadsThread : public SimpleThread { public : TestThreadsThread ( char * whatToChange ) { fWhatToChange = whatToChange ; } virtual void run ( ) { SimpleThread :: sleep ( 1000 ) ; Mutex m ; * fWhatToChange = ' * ' ; } private : char * fWhatToChange ; } ; // ▁ TestArabicShapeThreads ▁ - - ▁ see ▁ if ▁ calls ▁ to ▁ u _ shapeArabic ▁ in ▁ many ▁ threads ▁ works ▁ successfully ENDCOM // ▁ Set ▁ up ▁ N ▁ threads ▁ pointing ▁ at ▁ N ▁ chars . ▁ When ▁ they ▁ are ▁ started , ▁ they ▁ will ▁ make ▁ calls ▁ to ▁ doTailTest ▁ which ▁ tests ENDCOM // ▁ u _ shapeArabic , ▁ if ▁ the ▁ calls ▁ are ▁ successful ▁ it ▁ will ▁ the ▁ set ▁ * ▁ chars . ENDCOM // ▁ At ▁ the ▁ end ▁ we ▁ make ▁ sure ▁ all ▁ threads ▁ managed ▁ to ▁ run ▁ u _ shapeArabic ▁ successfully . ENDCOM // ▁ This ▁ is ▁ a ▁ unit ▁ test ▁ for ▁ ticket ▁ 9473 ENDCOM class TestArabicShapeThreads : public SimpleThread { public : TestArabicShapeThreads ( char * whatToChange ) { fWhatToChange = whatToChange ; } virtual void run ( ) { if ( doTailTest ( ) == TRUE ) * fWhatToChange = ' * ' ; } private : char * fWhatToChange ; UBool doTailTest ( void ) { static const UChar src [ ] = { 0x0020 , 0x0633 , 0 } ; static const UChar dst_old [ ] = { 0xFEB1 , 0x200B , 0 } ; static const UChar dst_new [ ] = { 0xFEB1 , 0xFE73 , 0 } ; UChar dst [ 3 ] = { 0x0000 , 0x0000 , 0 } ; int32_t length ; UErrorCode status ; IntlTest inteltst = IntlTest ( ) ; status = U_ZERO_ERROR ; length = u_shapeArabic ( src , - 1 , dst , UPRV_LENGTHOF ( dst ) , U_SHAPE_LETTERS_SHAPE | U_SHAPE_SEEN_TWOCELL_NEAR , & status ) ; if ( U_FAILURE ( status ) ) { inteltst . errln ( " Fail : ▁ status ▁ % s \n " , u_errorName ( status ) ) ; return FALSE ; } else if ( length != 2 ) { inteltst . errln ( " Fail : ▁ len ▁ % d ▁ expected ▁ 3 \n " , length ) ; return FALSE ; } else if ( u_strncmp ( dst , dst_old , UPRV_LENGTHOF ( dst ) ) ) { inteltst . errln ( " Fail : ▁ got ▁ U + % 04X ▁ U + % 04X ▁ expected ▁ U + % 04X ▁ U + % 04X \n " , dst [ 0 ] , dst [ 1 ] , dst_old [ 0 ] , dst_old [ 1 ] ) ; return FALSE ; } // " Trying ▁ new ▁ tail ENDCOM status = U_ZERO_ERROR ; length = u_shapeArabic ( src , - 1 , dst , UPRV_LENGTHOF ( dst ) , U_SHAPE_LETTERS_SHAPE | U_SHAPE_SEEN_TWOCELL_NEAR | U_SHAPE_TAIL_NEW_UNICODE , & status ) ; if ( U_FAILURE ( status ) ) { inteltst . errln ( " Fail : ▁ status ▁ % s \n " , u_errorName ( status ) ) ; return FALSE ; } else if ( length != 2 ) { inteltst . errln ( " Fail : ▁ len ▁ % d ▁ expected ▁ 3 \n " , length ) ; return FALSE ; } else if ( u_strncmp ( dst , dst_new , UPRV_LENGTHOF ( dst ) ) ) { inteltst . errln ( " Fail : ▁ got ▁ U + % 04X ▁ U + % 04X ▁ expected ▁ U + % 04X ▁ U + % 04X \n " , dst [ 0 ] , dst [ 1 ] , dst_new [ 0 ] , dst_new [ 1 ] ) ; return FALSE ; } return TRUE ; } } ; void MultithreadTest :: TestThreads ( ) { char threadTestChars [ THREADTEST_NRTHREADS + 1 ] ; SimpleThread * threads [ THREADTEST_NRTHREADS ] ; int32_t numThreadsStarted = 0 ; int32_t i ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { threadTestChars [ i ] = ' ▁ ' ; threads [ i ] = new TestThreadsThread ( & threadTestChars [ i ] ) ; } threadTestChars [ THREADTEST_NRTHREADS ] = ' \0' ; logln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ Firing ▁ off ▁ threads . . ▁ " ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { if ( threads [ i ] -> start ( ) != 0 ) { errln ( " Error ▁ starting ▁ thread ▁ % d " , i ) ; } else { numThreadsStarted ++ ; } SimpleThread :: sleep ( 100 ) ; logln ( " ▁ Subthread ▁ started . " ) ; } logln ( " Waiting ▁ for ▁ threads ▁ to ▁ be ▁ set . . " ) ; if ( numThreadsStarted == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ started ▁ for ▁ testing ! " ) ; return ; } int32_t patience = 40 ; // ▁ seconds ▁ to ▁ wait ENDCOM while ( patience -- ) { int32_t count = 0 ; umtx_lock ( NULL ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { if ( threadTestChars [ i ] == ' * ' ) { count ++ ; } } umtx_unlock ( NULL ) ; if ( count == THREADTEST_NRTHREADS ) { logln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ Got ▁ all ▁ threads ! ▁ cya " ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { delete threads [ i ] ; } return ; } logln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ Waiting . . " ) ; SimpleThread :: sleep ( 500 ) ; } errln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ PATIENCE ▁ EXCEEDED ! ! ▁ Still ▁ missing ▁ some . " ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { delete threads [ i ] ; } } void MultithreadTest :: TestArabicShapingThreads ( ) { char threadTestChars [ ARABICSHAPE_THREADTEST + 1 ] ; SimpleThread * threads [ ARABICSHAPE_THREADTEST ] ; int32_t numThreadsStarted = 0 ; int32_t i ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { threadTestChars [ i ] = ' ▁ ' ; threads [ i ] = new TestArabicShapeThreads ( & threadTestChars [ i ] ) ; } threadTestChars [ ARABICSHAPE_THREADTEST ] = ' \0' ; logln ( " - > ▁ do ▁ TestArabicShapingThreads ▁ < - ▁ Firing ▁ off ▁ threads . . ▁ " ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { if ( threads [ i ] -> start ( ) != 0 ) { errln ( " Error ▁ starting ▁ thread ▁ % d " , i ) ; } else { numThreadsStarted ++ ; } // SimpleThread : : sleep ( 100 ) ; ENDCOM logln ( " ▁ Subthread ▁ started . " ) ; } logln ( " Waiting ▁ for ▁ threads ▁ to ▁ be ▁ set . . " ) ; if ( numThreadsStarted == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ started ▁ for ▁ testing ! " ) ; return ; } int32_t patience = 100 ; // ▁ seconds ▁ to ▁ wait ENDCOM while ( patience -- ) { int32_t count = 0 ; umtx_lock ( NULL ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { if ( threadTestChars [ i ] == ' * ' ) { count ++ ; } } umtx_unlock ( NULL ) ; if ( count == ARABICSHAPE_THREADTEST ) { logln ( " - > TestArabicShapingThreads ▁ < - ▁ Got ▁ all ▁ threads ! ▁ cya " ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { delete threads [ i ] ; } return ; } logln ( " - > ▁ TestArabicShapingThreads ▁ < - ▁ Waiting . . " ) ; SimpleThread :: sleep ( 500 ) ; } errln ( " - > ▁ TestArabicShapingThreads ▁ < - ▁ PATIENCE ▁ EXCEEDED ! ! ▁ Still ▁ missing ▁ some . " ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { delete threads [ i ] ; } } // ▁ TestMutex ▁ - ▁ a ▁ simple ▁ ( non - stress ) ▁ test ▁ to ▁ verify ▁ that ▁ ICU ▁ mutexes ENDCOM // ▁ are ▁ actually ▁ mutexing . ▁ Does ▁ not ▁ test ▁ the ▁ use ▁ of ENDCOM // ▁ mutexes ▁ within ▁ ICU ▁ services , ▁ but ▁ rather ▁ that ▁ the ENDCOM // ▁ platform ' s ▁ mutex ▁ support ▁ is ▁ at ▁ least ▁ superficially ▁ there . ENDCOM static UMutex gTestMutexA = U_MUTEX_INITIALIZER ; static UMutex gTestMutexB = U_MUTEX_INITIALIZER ; static int gThreadsStarted = 0 ; static int gThreadsInMiddle = 0 ; static int gThreadsDone = 0 ; static const int TESTMUTEX_THREAD_COUNT = 4 ; static int safeIncr ( int & var , int amt ) { // ▁ Thread ▁ safe ▁ ( using ▁ global ▁ mutex ) ▁ increment ▁ of ▁ a ▁ variable . ENDCOM // ▁ Return ▁ the ▁ updated ▁ value . ENDCOM // ▁ Can ▁ also ▁ be ▁ used ▁ as ▁ a ▁ safe ▁ load ▁ of ▁ a ▁ variable ▁ by ▁ incrementing ▁ it ▁ by ▁ 0 . ENDCOM Mutex m ; var += amt ; return var ; } class TestMutexThread : public SimpleThread { public : virtual void run ( ) { // ▁ This ▁ is ▁ the ▁ code ▁ that ▁ each ▁ of ▁ the ▁ spawned ▁ threads ▁ runs . ENDCOM // ▁ All ▁ of ▁ the ▁ spawned ▁ threads ▁ bunch ▁ up ▁ together ▁ at ▁ each ▁ of ▁ the ▁ two ▁ mutexes ENDCOM // ▁ because ▁ the ▁ main ▁ holds ▁ the ▁ mutexes ▁ until ▁ they ▁ do . ENDCOM safeIncr ( gThreadsStarted , 1 ) ; umtx_lock ( & gTestMutexA ) ; umtx_unlock ( & gTestMutexA ) ; safeIncr ( gThreadsInMiddle , 1 ) ; umtx_lock ( & gTestMutexB ) ; umtx_unlock ( & gTestMutexB ) ; safeIncr ( gThreadsDone , 1 ) ; } } ; void MultithreadTest :: TestMutex ( ) { // ▁ Start ▁ up ▁ the ▁ test ▁ threads . ▁ They ▁ should ▁ all ▁ pile ▁ up ▁ waiting ▁ on ENDCOM // ▁ gTestMutexA , ▁ which ▁ we ▁ ( the ▁ main ▁ thread ) ▁ hold ▁ until ▁ the ▁ test ▁ threads ENDCOM // ▁ all ▁ get ▁ there . ENDCOM gThreadsStarted = 0 ; gThreadsInMiddle = 0 ; gThreadsDone = 0 ; umtx_lock ( & gTestMutexA ) ; TestMutexThread * threads [ TESTMUTEX_THREAD_COUNT ] ; int i ; int32_t numThreadsStarted = 0 ; for ( i = 0 ; i < TESTMUTEX_THREAD_COUNT ; i ++ ) { threads [ i ] = new TestMutexThread ; if ( threads [ i ] -> start ( ) != 0 ) { errln ( " Error ▁ starting ▁ thread ▁ % d " , i ) ; } else { numThreadsStarted ++ ; } } if ( numThreadsStarted == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ started ▁ for ▁ testing ! " ) ; return ; } int patience = 0 ; while ( safeIncr ( gThreadsStarted , 0 ) != TESTMUTEX_THREAD_COUNT ) { if ( patience ++ > 24 ) { TSMTHREAD_FAIL ( " Patience ▁ Exceeded " ) ; return ; } SimpleThread :: sleep ( 500 ) ; } // ▁ None ▁ of ▁ the ▁ test ▁ threads ▁ should ▁ have ▁ advanced ▁ past ▁ the ▁ first ▁ mutex . ENDCOM TSMTHREAD_ASSERT ( gThreadsInMiddle == 0 ) ; TSMTHREAD_ASSERT ( gThreadsDone == 0 ) ; // ▁ All ▁ of ▁ the ▁ test ▁ threads ▁ have ▁ made ▁ it ▁ to ▁ the ▁ first ▁ mutex . ENDCOM // ▁ We ▁ ( the ▁ main ▁ thread ) ▁ now ▁ let ▁ them ▁ advance ▁ to ▁ the ▁ second ▁ mutex , ENDCOM // ▁ where ▁ they ▁ should ▁ all ▁ pile ▁ up ▁ again . ENDCOM umtx_lock ( & gTestMutexB ) ; umtx_unlock ( & gTestMutexA ) ; patience = 0 ; while ( safeIncr ( gThreadsInMiddle , 0 ) != TESTMUTEX_THREAD_COUNT ) { if ( patience ++ > 24 ) { TSMTHREAD_FAIL ( " Patience ▁ Exceeded " ) ; return ; } SimpleThread :: sleep ( 500 ) ; } TSMTHREAD_ASSERT ( gThreadsDone == 0 ) ; // ▁ All ▁ test ▁ threads ▁ made ▁ it ▁ to ▁ the ▁ second ▁ mutex . ENDCOM // ▁ Now ▁ let ▁ them ▁ proceed ▁ from ▁ there . ▁ They ▁ will ▁ all ▁ terminate . ENDCOM umtx_unlock ( & gTestMutexB ) ; patience = 0 ; while ( safeIncr ( gThreadsDone , 0 ) != TESTMUTEX_THREAD_COUNT ) { if ( patience ++ > 24 ) { TSMTHREAD_FAIL ( " Patience ▁ Exceeded " ) ; return ; } SimpleThread :: sleep ( 500 ) ; } // ▁ All ▁ threads ▁ made ▁ it ▁ by ▁ both ▁ mutexes . ENDCOM for ( i = 0 ; i < TESTMUTEX_THREAD_COUNT ; i ++ ) { delete threads [ i ] ; } } // ▁ class ▁ ThreadWithStatus ▁ - ▁ a ▁ thread ▁ that ▁ we ▁ can ▁ check ▁ the ▁ status ▁ and ▁ error ▁ condition ▁ of ENDCOM class ThreadWithStatus : public SimpleThread { public : UBool getError ( ) { return ( fErrors > 0 ) ; } UBool getError ( UnicodeString & fillinError ) { fillinError = fErrorString ; return ( fErrors > 0 ) ; } virtual ~ ThreadWithStatus ( ) { } protected : ThreadWithStatus ( ) : fErrors ( 0 ) { } void error ( const UnicodeString & error ) { fErrors ++ ; fErrorString = error ; SimpleThread :: errorFunc ( ) ; } void error ( ) { error ( " An ▁ error ▁ occured . " ) ; } private : int32_t fErrors ; UnicodeString fErrorString ; } ; // ▁ TestMultithreadedIntl . ▁ Test ▁ ICU ▁ Formatting ▁ n ▁ a ▁ multi - threaded ▁ environment ENDCOM // ▁ * ▁ Show ▁ exactly ▁ where ▁ the ▁ string ' s ▁ differences ▁ lie . ENDCOM UnicodeString showDifference ( const UnicodeString & expected , const UnicodeString & result ) { UnicodeString res ; res = expected + " < Expected \n " ; if ( expected . length ( ) != result . length ( ) ) res += " ▁ [ ▁ Different ▁ lengths ▁ ] ▁ \n " ; else { for ( int32_t i = 0 ; i < expected . length ( ) ; i ++ ) { if ( expected [ i ] == result [ i ] ) { res += " ▁ " ; } else { res += " | " ; } } res += " < Differences " ; res += " \n " ; } res += result + " < Result \n " ; return res ; } // ▁ FormatThreadTest ▁ - ▁ a ▁ thread ▁ that ▁ tests ▁ performing ▁ a ▁ number ▁ of ▁ numberformats . ENDCOM const int kFormatThreadIterations = 100 ; // ▁ # ▁ of ▁ iterations ▁ per ▁ thread ENDCOM const int kFormatThreadThreads = 10 ; // ▁ # ▁ of ▁ threads ▁ to ▁ spawn ENDCOM # if ! UCONFIG_NO_FORMATTING struct FormatThreadTestData { double number ; UnicodeString string ; FormatThreadTestData ( double a , const UnicodeString & b ) : number ( a ) , string ( b ) { } } ; // ▁ " Someone ▁ from ▁ { 2 } ▁ is ▁ receiving ▁ a ▁ # {0 } ▁ error ▁ - ▁ { 1 } . ▁ Their ▁ telephone ▁ call ▁ is ▁ costing ▁ { 3 ▁ number , currency } . " ENDCOM static void formatErrorMessage ( UErrorCode & realStatus , const UnicodeString & pattern , const Locale & theLocale , UErrorCode inStatus0 , /* ▁ statusString ▁ 1 ▁ */ const Locale & inCountry2 , double currency3 , // ▁ these ▁ numbers ▁ are ▁ the ▁ message ▁ arguments . ENDCOM UnicodeString & result ) { if ( U_FAILURE ( realStatus ) ) return ; // ▁ you ▁ messed ▁ up ENDCOM UnicodeString errString1 ( u_errorName ( inStatus0 ) ) ; UnicodeString countryName2 ; inCountry2 . getDisplayCountry ( theLocale , countryName2 ) ; Formattable myArgs [ ] = { Formattable ( ( int32_t ) inStatus0 ) , // ▁ inStatus0 ▁ { 0 } ENDCOM Formattable ( errString1 ) , // ▁ statusString1 ▁ { 1 } ENDCOM Formattable ( countryName2 ) , // ▁ inCountry2 ▁ { 2 } ENDCOM Formattable ( currency3 ) // ▁ currency3 ▁ { 3 , number , currency } ENDCOM } ; MessageFormat * fmt = new MessageFormat ( " MessageFormat ' s ▁ API ▁ is ▁ broken ! ! ! ! ! ! ! ! ! ! ! " , realStatus ) ; fmt -> setLocale ( theLocale ) ; fmt -> applyPattern ( pattern , realStatus ) ; if ( U_FAILURE ( realStatus ) ) { delete fmt ; return ; } FieldPosition ignore = 0 ; fmt -> format ( myArgs , 4 , result , ignore , realStatus ) ; delete fmt ; } /* * STRNEWLINE ▁ * ▁ Shared ▁ formatters ▁ & ▁ data ▁ used ▁ by ▁ instances ▁ of ▁ ThreadSafeFormat . STRNEWLINE ▁ * ▁ Exactly ▁ one ▁ instance ▁ of ▁ this ▁ class ▁ is ▁ created , ▁ and ▁ it ▁ is ▁ then ▁ shared ▁ concurrently STRNEWLINE ▁ * ▁ by ▁ the ▁ multiple ▁ instances ▁ of ▁ ThreadSafeFormat . STRNEWLINE ▁ */ class ThreadSafeFormatSharedData { public : ThreadSafeFormatSharedData ( UErrorCode & status ) ; ~ ThreadSafeFormatSharedData ( ) ; LocalPointer < NumberFormat > fFormat ; Formattable fYDDThing ; Formattable fBBDThing ; UnicodeString fYDDStr ; UnicodeString fBBDStr ; } ; const ThreadSafeFormatSharedData * gSharedData = NULL ; ThreadSafeFormatSharedData :: ThreadSafeFormatSharedData ( UErrorCode & status ) { fFormat . adoptInstead ( NumberFormat :: createCurrencyInstance ( Locale :: getUS ( ) , status ) ) ; static const UChar kYDD [ ] = { 0x59 , 0x44 , 0x44 , 0x00 } ; static const UChar kBBD [ ] = { 0x42 , 0x42 , 0x44 , 0x00 } ; fYDDThing . adoptObject ( new CurrencyAmount ( 123.456 , kYDD , status ) ) ; fBBDThing . adoptObject ( new CurrencyAmount ( 987.654 , kBBD , status ) ) ; if ( U_FAILURE ( status ) ) { return ; } fFormat -> format ( fYDDThing , fYDDStr , NULL , status ) ; fFormat -> format ( fBBDThing , fBBDStr , NULL , status ) ; gSharedData = this ; } ThreadSafeFormatSharedData :: ~ ThreadSafeFormatSharedData ( ) { gSharedData = NULL ; } /* * STRNEWLINE ▁ * ▁ Class ▁ for ▁ thread - safe ▁ testing ▁ of ▁ format . STRNEWLINE ▁ * ▁ Instances ▁ of ▁ this ▁ class ▁ appear ▁ as ▁ members ▁ of ▁ class ▁ FormatThreadTest . STRNEWLINE ▁ * ▁ Multiple ▁ instances ▁ of ▁ FormatThreadTest ▁ coexist . STRNEWLINE ▁ * ▁ ThreadSafeFormat : : doStuff ( ) ▁ is ▁ called ▁ concurrently ▁ to ▁ test ▁ the ▁ thread ▁ safety ▁ of STRNEWLINE ▁ * ▁ various ▁ shared ▁ format ▁ operations . STRNEWLINE ▁ */ class ThreadSafeFormat { public : /* ▁ give ▁ a ▁ unique ▁ offset ▁ to ▁ each ▁ thread ▁ */ ThreadSafeFormat ( UErrorCode & status ) ; UBool doStuff ( int32_t offset , UnicodeString & appendErr , UErrorCode & status ) const ; private : LocalPointer < NumberFormat > fFormat ; // ▁ formatter ▁ - ▁ en _ US ▁ constructed ▁ currency ENDCOM } ; ThreadSafeFormat :: ThreadSafeFormat ( UErrorCode & status ) { fFormat . adoptInstead ( NumberFormat :: createCurrencyInstance ( Locale :: getUS ( ) , status ) ) ; } static const UChar kUSD [ ] = { 0x55 , 0x53 , 0x44 , 0x00 } ; UBool ThreadSafeFormat :: doStuff ( int32_t offset , UnicodeString & appendErr , UErrorCode & status ) const { UBool okay = TRUE ; if ( u_strcmp ( fFormat -> getCurrency ( ) , kUSD ) ) { appendErr . append ( " fFormat ▁ currency ▁ ! = ▁ " ) . append ( kUSD ) . append ( " , ▁ = " ) . append ( fFormat -> getCurrency ( ) ) . append ( " ! ▁ " ) ; okay = FALSE ; } if ( u_strcmp ( gSharedData -> fFormat -> getCurrency ( ) , kUSD ) ) { appendErr . append ( " gFormat ▁ currency ▁ ! = ▁ " ) . append ( kUSD ) . append ( " , ▁ = " ) . append ( gSharedData -> fFormat -> getCurrency ( ) ) . append ( " ! ▁ " ) ; okay = FALSE ; } UnicodeString str ; const UnicodeString * o = NULL ; Formattable f ; const NumberFormat * nf = NULL ; // ▁ only ▁ operate ▁ on ▁ it ▁ as ▁ const . ENDCOM switch ( offset % 4 ) { case 0 : f = gSharedData -> fYDDThing ; o = & gSharedData -> fYDDStr ; nf = gSharedData -> fFormat . getAlias ( ) ; break ; case 1 : f = gSharedData -> fBBDThing ; o = & gSharedData -> fBBDStr ; nf = gSharedData -> fFormat . getAlias ( ) ; break ; case 2 : f = gSharedData -> fYDDThing ; o = & gSharedData -> fYDDStr ; nf = fFormat . getAlias ( ) ; break ; case 3 : f = gSharedData -> fBBDThing ; o = & gSharedData -> fBBDStr ; nf = fFormat . getAlias ( ) ; break ; } nf -> format ( f , str , NULL , status ) ; if ( * o != str ) { appendErr . append ( showDifference ( * o , str ) ) ; okay = FALSE ; } return okay ; } UBool U_CALLCONV isAcceptable ( void * , const char * , const char * , const UDataInfo * ) { return TRUE ; } // static ▁ UMTX ▁ debugMutex ▁ = ▁ NULL ; ENDCOM // static ▁ UMTX ▁ gDebugMutex ; ENDCOM class FormatThreadTest : public ThreadWithStatus { public : int fNum ; int fTraceInfo ; LocalPointer < ThreadSafeFormat > fTSF ; FormatThreadTest ( ) // ▁ constructor ▁ is ▁ NOT ▁ multithread ▁ safe . ENDCOM : ThreadWithStatus ( ) , fNum ( 0 ) , fTraceInfo ( 0 ) , fTSF ( NULL ) , fOffset ( 0 ) // ▁ the ▁ locale ▁ to ▁ use ENDCOM { UErrorCode status = U_ZERO_ERROR ; // ▁ TODO : ▁ rearrange ▁ code ▁ to ▁ allow ▁ checking ▁ of ▁ status . ENDCOM fTSF . adoptInstead ( new ThreadSafeFormat ( status ) ) ; static int32_t fgOffset = 0 ; fgOffset += 3 ; fOffset = fgOffset ; } virtual void run ( ) { fTraceInfo = 1 ; LocalPointer < NumberFormat > percentFormatter ; UErrorCode status = U_ZERO_ERROR ; # if 0 // ▁ debugging ▁ code , ENDCOM for ( int i = 0 ; i < 4000 ; i ++ ) { status = U_ZERO_ERROR ; UDataMemory * data1 = udata_openChoice ( 0 , " res " , " en _ US " , isAcceptable , 0 , & status ) ; UDataMemory * data2 = udata_openChoice ( 0 , " res " , " fr " , isAcceptable , 0 , & status ) ; udata_close ( data1 ) ; udata_close ( data2 ) ; if ( U_FAILURE ( status ) ) { error ( " udata _ openChoice ▁ failed . \n " ) ; break ; } } return ; # endif # if 0 // ▁ debugging ▁ code , ENDCOM int m ; for ( m = 0 ; m < 4000 ; m ++ ) { status = U_ZERO_ERROR ; UResourceBundle * res = NULL ; const char * localeName = NULL ; Locale loc = Locale :: getEnglish ( ) ; localeName = loc . getName ( ) ; // ▁ localeName ▁ = ▁ " en " ; ENDCOM // ▁ ResourceBundle ▁ bund ▁ = ▁ ResourceBundle ( 0 , ▁ loc , ▁ status ) ; ENDCOM // umtx _ lock ( & gDebugMutex ) ; ENDCOM res = ures_open ( NULL , localeName , & status ) ; // umtx _ unlock ( & gDebugMutex ) ; ENDCOM // umtx _ lock ( & gDebugMutex ) ; ENDCOM ures_close ( res ) ; // umtx _ unlock ( & gDebugMutex ) ; ENDCOM if ( U_FAILURE ( status ) ) { error ( " Resource ▁ bundle ▁ construction ▁ failed . \n " ) ; break ; } } return ; # endif // ▁ Keep ▁ this ▁ data ▁ here ▁ to ▁ avoid ▁ static ▁ initialization . ENDCOM FormatThreadTestData kNumberFormatTestData [ ] = { FormatThreadTestData ( ( double ) 5.0 , UnicodeString ( "5" , " " ) ) , FormatThreadTestData ( 6.0 , UnicodeString ( "6" , " " ) ) , FormatThreadTestData ( 20.0 , UnicodeString ( "20" , " " ) ) , FormatThreadTestData ( 8.0 , UnicodeString ( "8" , " " ) ) , FormatThreadTestData ( 8.3 , UnicodeString ( "8.3" , " " ) ) , FormatThreadTestData ( 12345 , UnicodeString ( "12,345" , " " ) ) , FormatThreadTestData ( 81890.23 , UnicodeString ( "81,890.23" , " " ) ) , } ; int32_t kNumberFormatTestDataLength = UPRV_LENGTHOF ( kNumberFormatTestData ) ; // ▁ Keep ▁ this ▁ data ▁ here ▁ to ▁ avoid ▁ static ▁ initialization . ENDCOM FormatThreadTestData kPercentFormatTestData [ ] = { FormatThreadTestData ( ( double ) 5.0 , CharsToUnicodeString ( "500\\u00a0 % " ) ) , FormatThreadTestData ( 1.0 , CharsToUnicodeString ( "100\\u00a0 % " ) ) , FormatThreadTestData ( 0.26 , CharsToUnicodeString ( "26\\u00a0 % " ) ) , FormatThreadTestData ( 16384.99 , CharsToUnicodeString ( "1\\u00a0638\\u00a0499\\u00a0 % " ) ) , // ▁ U + 00a0 ▁ = ▁ NBSP ENDCOM FormatThreadTestData ( 81890.23 , CharsToUnicodeString ( "8\\u00a0189\\u00a0023\\u00a0 % " ) ) , } ; int32_t kPercentFormatTestDataLength = UPRV_LENGTHOF ( kPercentFormatTestData ) ; int32_t iteration ; status = U_ZERO_ERROR ; LocalPointer < NumberFormat > formatter ( NumberFormat :: createInstance ( Locale :: getEnglish ( ) , status ) ) ; if ( U_FAILURE ( status ) ) { error ( " Error ▁ on ▁ NumberFormat : : createInstance ( ) . " ) ; goto cleanupAndReturn ; } percentFormatter . adoptInstead ( NumberFormat :: createPercentInstance ( Locale :: getFrench ( ) , status ) ) ; if ( U_FAILURE ( status ) ) { error ( " Error ▁ on ▁ NumberFormat : : createPercentInstance ( ) . " ) ; goto cleanupAndReturn ; } for ( iteration = 0 ; ! getError ( ) && iteration < kFormatThreadIterations ; iteration ++ ) { int32_t whichLine = ( iteration + fOffset ) % kNumberFormatTestDataLength ; UnicodeString output ; formatter -> format ( kNumberFormatTestData [ whichLine ] . number , output ) ; if ( 0 != output . compare ( kNumberFormatTestData [ whichLine ] . string ) ) { error ( " format ( ) . . ▁ expected ▁ " + kNumberFormatTestData [ whichLine ] . string + " ▁ got ▁ " + output ) ; goto cleanupAndReturn ; } // ▁ Now ▁ check ▁ percent . ENDCOM output . remove ( ) ; whichLine = ( iteration + fOffset ) % kPercentFormatTestDataLength ; percentFormatter -> format ( kPercentFormatTestData [ whichLine ] . number , output ) ; if ( 0 != output . compare ( kPercentFormatTestData [ whichLine ] . string ) ) { error ( " percent ▁ format ( ) . . ▁ \n " + showDifference ( kPercentFormatTestData [ whichLine ] . string , output ) ) ; goto cleanupAndReturn ; } // ▁ Test ▁ message ▁ error ENDCOM const int kNumberOfMessageTests = 3 ; UErrorCode statusToCheck ; UnicodeString patternToCheck ; Locale messageLocale ; Locale countryToCheck ; double currencyToCheck ; UnicodeString expected ; // ▁ load ▁ the ▁ cases . ENDCOM switch ( ( iteration + fOffset ) % kNumberOfMessageTests ) { default : case 0 : statusToCheck = U_FILE_ACCESS_ERROR ; patternToCheck = "0 : Someone ▁ from ▁ { 2 } ▁ is ▁ receiving ▁ a ▁ # {0 } " " ▁ error ▁ - ▁ { 1 } . ▁ Their ▁ telephone ▁ call ▁ is ▁ costing ▁ " " { 3 , number , currency } . " ; // ▁ number , currency ENDCOM messageLocale = Locale ( " en " , " US " ) ; countryToCheck = Locale ( " " , " HR " ) ; currencyToCheck = 8192.77 ; expected = "0 : Someone ▁ from ▁ Croatia ▁ is ▁ receiving ▁ a ▁ # 4 ▁ error ▁ - ▁ " " U _ FILE _ ACCESS _ ERROR . ▁ Their ▁ telephone ▁ call ▁ is ▁ costing ▁ $ 8,192.77 . " ; break ; case 1 : statusToCheck = U_INDEX_OUTOFBOUNDS_ERROR ; patternToCheck = "1 : A ▁ customer ▁ in ▁ { 2 } ▁ is ▁ receiving ▁ a ▁ # {0 } ▁ error ▁ - ▁ { 1 } . ▁ " " Their ▁ telephone ▁ call ▁ is ▁ costing ▁ { 3 , number , currency } . " ; // ▁ number , currency ENDCOM messageLocale = Locale ( " de " , " DE @ currency = DEM " ) ; countryToCheck = Locale ( " " , " BF " ) ; currencyToCheck = 2.32 ; expected = CharsToUnicodeString ( "1 : A ▁ customer ▁ in ▁ Burkina ▁ Faso ▁ is ▁ receiving ▁ a ▁ # 8 ▁ error ▁ - ▁ U _ INDEX _ OUTOFBOUNDS _ ERROR . ▁ " " Their ▁ telephone ▁ call ▁ is ▁ costing ▁ 2,32\\u00A0DM . " ) ; break ; case 2 : statusToCheck = U_MEMORY_ALLOCATION_ERROR ; patternToCheck = "2 : user ▁ in ▁ { 2 } ▁ is ▁ receiving ▁ a ▁ # {0 } ▁ error ▁ - ▁ { 1 } . ▁ " " They ▁ insist ▁ they ▁ just ▁ spent ▁ { 3 , number , currency } ▁ " " on ▁ memory . " ; // ▁ number , currency ENDCOM messageLocale = Locale ( " de " , " AT @ currency = ATS " ) ; // ▁ Austrian ▁ German ENDCOM countryToCheck = Locale ( " " , " US " ) ; // ▁ hmm ENDCOM currencyToCheck = 40193.12 ; expected = CharsToUnicodeString ( "2 : user ▁ in ▁ Vereinigte ▁ Staaten ▁ is ▁ receiving ▁ a ▁ # 7 ▁ error " " ▁ - ▁ U _ MEMORY _ ALLOCATION _ ERROR . ▁ They ▁ insist ▁ they ▁ just ▁ spent " " ▁ \\u00f6S\\u00A040.193,12 ▁ on ▁ memory . " ) ; break ; } UnicodeString result ; UErrorCode status = U_ZERO_ERROR ; formatErrorMessage ( status , patternToCheck , messageLocale , statusToCheck , countryToCheck , currencyToCheck , result ) ; if ( U_FAILURE ( status ) ) { UnicodeString tmp ( u_errorName ( status ) ) ; error ( " Failure ▁ on ▁ message ▁ format , ▁ pattern = " + patternToCheck + " , ▁ error ▁ = ▁ " + tmp ) ; goto cleanupAndReturn ; } if ( result != expected ) { error ( " PatternFormat : ▁ \n " + showDifference ( expected , result ) ) ; goto cleanupAndReturn ; } // ▁ test ▁ the ▁ Thread ▁ Safe ▁ Format ENDCOM UnicodeString appendErr ; if ( ! fTSF -> doStuff ( fNum , appendErr , status ) ) { error ( appendErr ) ; goto cleanupAndReturn ; } } /* ▁ end ▁ of ▁ for ▁ loop ▁ */ cleanupAndReturn : // ▁ while ▁ ( fNum ▁ = = ▁ 4 ) ▁ { SimpleThread : : sleep ( 10000 ) ; } ▁ // ▁ Force ▁ a ▁ failure ▁ by ▁ preventing ▁ thread ▁ from ▁ finishing ENDCOM fTraceInfo = 2 ; } private : int32_t fOffset ; // ▁ where ▁ we ▁ are ▁ testing ▁ from . ENDCOM } ; // ▁ * * ▁ The ▁ actual ▁ test ▁ function . ENDCOM void MultithreadTest :: TestThreadedIntl ( ) { int i ; UnicodeString theErr ; UBool haveDisplayedInfo [ kFormatThreadThreads ] ; static const int32_t PATIENCE_SECONDS = 45 ; UErrorCode threadSafeErr = U_ZERO_ERROR ; ThreadSafeFormatSharedData sharedData ( threadSafeErr ) ; assertSuccess ( " initializing ▁ ThreadSafeFormat " , threadSafeErr , TRUE ) ; // ▁ Create ▁ and ▁ start ▁ the ▁ test ▁ threads ENDCOM logln ( " Spawning : ▁ % d ▁ threads ▁ * ▁ % d ▁ iterations ▁ each . " , kFormatThreadThreads , kFormatThreadIterations ) ; LocalArray < FormatThreadTest > tests ( new FormatThreadTest [ kFormatThreadThreads ] ) ; for ( int32_t j = 0 ; j < kFormatThreadThreads ; j ++ ) { tests [ j ] . fNum = j ; int32_t threadStatus = tests [ j ] . start ( ) ; if ( threadStatus != 0 ) { errln ( " System ▁ Error ▁ % d ▁ starting ▁ thread ▁ number ▁ % d . " , threadStatus , j ) ; SimpleThread :: errorFunc ( ) ; return ; } haveDisplayedInfo [ j ] = FALSE ; } // ▁ Spin , ▁ waiting ▁ for ▁ the ▁ test ▁ threads ▁ to ▁ finish . ENDCOM UBool stillRunning ; UDate startTime , endTime ; startTime = Calendar :: getNow ( ) ; double lastComplaint = 0 ; do { /* ▁ Spin ▁ until ▁ the ▁ test ▁ threads ▁ complete . ▁ */ stillRunning = FALSE ; endTime = Calendar :: getNow ( ) ; double elapsedSeconds = ( ( int32_t ) ( endTime - startTime ) / U_MILLIS_PER_SECOND ) ; if ( elapsedSeconds > PATIENCE_SECONDS ) { errln ( " Patience ▁ exceeded . ▁ Test ▁ is ▁ taking ▁ too ▁ long . " ) ; return ; } else if ( ( elapsedSeconds - lastComplaint ) > 2.0 ) { infoln ( " % .1f ▁ seconds ▁ elapsed ▁ ( still ▁ waiting . . ) " , elapsedSeconds ) ; lastComplaint = elapsedSeconds ; } /* STRNEWLINE ▁ The ▁ following ▁ sleep ▁ must ▁ be ▁ here ▁ because ▁ the ▁ * BSD ▁ operating ▁ systems STRNEWLINE ▁ have ▁ a ▁ brain ▁ dead ▁ thread ▁ scheduler . ▁ They ▁ starve ▁ the ▁ child ▁ threads ▁ from STRNEWLINE ▁ CPU ▁ time . STRNEWLINE ▁ */ SimpleThread :: sleep ( 1 ) ; // ▁ yield ENDCOM for ( i = 0 ; i < kFormatThreadThreads ; i ++ ) { if ( tests [ i ] . isRunning ( ) ) { stillRunning = TRUE ; } else if ( haveDisplayedInfo [ i ] == FALSE ) { logln ( " Thread ▁ # ▁ % d ▁ is ▁ complete . . " , i ) ; if ( tests [ i ] . getError ( theErr ) ) { dataerrln ( UnicodeString ( " # " ) + i + " : ▁ " + theErr ) ; SimpleThread :: errorFunc ( ) ; } haveDisplayedInfo [ i ] = TRUE ; } } } while ( stillRunning ) ; // ▁ All ▁ threads ▁ have ▁ finished . ENDCOM assertSuccess ( " finalizing ▁ ThreadSafeFormat " , threadSafeErr , TRUE ) ; } # endif /* ▁ # if ▁ ! UCONFIG _ NO _ FORMATTING ▁ */ // ▁ Collation ▁ threading ▁ test ENDCOM # if ! UCONFIG_NO_COLLATION # define kCollatorThreadThreads 10 // ▁ # ▁ of ▁ threads ▁ to ▁ spawn ENDCOM # define kCollatorThreadPatience kCollatorThreadThreads * 30 struct Line { UChar buff [ 25 ] ; int32_t buflen ; } ; static UBool skipLineBecauseOfBug ( const UChar * s , int32_t length ) { // ▁ TODO : ▁ Fix ▁ ICU ▁ ticket ▁ # 8052 ENDCOM if ( length >= 3 && ( s [ 0 ] == 0xfb2 || s [ 0 ] == 0xfb3 ) && s [ 1 ] == 0x334 && ( s [ 2 ] == 0xf73 || s [ 2 ] == 0xf75 || s [ 2 ] == 0xf81 ) ) { return TRUE ; } return FALSE ; } static UCollationResult normalizeResult ( int32_t result ) { return result < 0 ? UCOL_LESS : result == 0 ? UCOL_EQUAL : UCOL_GREATER ; } class CollatorThreadTest : public ThreadWithStatus { private : const Collator * coll ; const Line * lines ; int32_t noLines ; UBool isAtLeastUCA62 ; public : CollatorThreadTest ( ) : ThreadWithStatus ( ) , coll ( NULL ) , lines ( NULL ) , noLines ( 0 ) , isAtLeastUCA62 ( TRUE ) { } ; void setCollator ( Collator * c , Line * l , int32_t nl , UBool atLeastUCA62 ) { coll = c ; lines = l ; noLines = nl ; isAtLeastUCA62 = atLeastUCA62 ; } virtual void run ( ) { uint8_t sk1 [ 1024 ] , sk2 [ 1024 ] ; uint8_t * oldSk = NULL , * newSk = sk1 ; int32_t oldLen = 0 ; int32_t prev = 0 ; int32_t i = 0 ; for ( i = 0 ; i < noLines ; i ++ ) { if ( lines [ i ] . buflen == 0 ) { continue ; } if ( skipLineBecauseOfBug ( lines [ i ] . buff , lines [ i ] . buflen ) ) { continue ; } int32_t resLen = coll -> getSortKey ( lines [ i ] . buff , lines [ i ] . buflen , newSk , 1024 ) ; if ( oldSk != NULL ) { int32_t skres = strcmp ( ( char * ) oldSk , ( char * ) newSk ) ; int32_t cmpres = coll -> compare ( lines [ prev ] . buff , lines [ prev ] . buflen , lines [ i ] . buff , lines [ i ] . buflen ) ; int32_t cmpres2 = coll -> compare ( lines [ i ] . buff , lines [ i ] . buflen , lines [ prev ] . buff , lines [ prev ] . buflen ) ; if ( cmpres != - cmpres2 ) { error ( UnicodeString ( " Compare ▁ result ▁ not ▁ symmetrical ▁ on ▁ line ▁ " ) + ( i + 1 ) ) ; break ; } if ( cmpres != normalizeResult ( skres ) ) { error ( UnicodeString ( " Difference ▁ between ▁ coll - > compare ▁ and ▁ sortkey ▁ compare ▁ on ▁ line ▁ " ) + ( i + 1 ) ) ; break ; } int32_t res = cmpres ; if ( res == 0 && ! isAtLeastUCA62 ) { // ▁ Up ▁ to ▁ UCA ▁ 6.1 , ▁ the ▁ collation ▁ test ▁ files ▁ use ▁ a ▁ custom ▁ tie - breaker , ENDCOM // ▁ comparing ▁ the ▁ raw ▁ input ▁ strings . ENDCOM res = u_strcmpCodePointOrder ( lines [ prev ] . buff , lines [ i ] . buff ) ; // ▁ Starting ▁ with ▁ UCA ▁ 6.2 , ▁ the ▁ collation ▁ test ▁ files ▁ use ▁ the ▁ standard ▁ UCA ▁ tie - breaker , ENDCOM // ▁ comparing ▁ the ▁ NFD ▁ versions ▁ of ▁ the ▁ input ▁ strings , ENDCOM // ▁ which ▁ we ▁ do ▁ via ▁ setting ▁ strength = identical . ENDCOM } if ( res > 0 ) { error ( UnicodeString ( " Line ▁ is ▁ not ▁ greater ▁ or ▁ equal ▁ than ▁ previous ▁ line , ▁ for ▁ line ▁ " ) + ( i + 1 ) ) ; break ; } } oldSk = newSk ; oldLen = resLen ; ( void ) oldLen ; // ▁ Suppress ▁ set ▁ but ▁ not ▁ used ▁ warning . ENDCOM prev = i ; newSk = ( newSk == sk1 ) ? sk2 : sk1 ; } } } ; void MultithreadTest :: TestCollators ( ) { UErrorCode status = U_ZERO_ERROR ; FILE * testFile = NULL ; char testDataPath [ 1024 ] ; strcpy ( testDataPath , IntlTest :: getSourceTestData ( status ) ) ; if ( U_FAILURE ( status ) ) { errln ( " ERROR : ▁ could ▁ not ▁ open ▁ test ▁ data ▁ % s " , u_errorName ( status ) ) ; return ; } strcat ( testDataPath , " CollationTest _ " ) ; const char * type = " NON _ IGNORABLE " ; const char * ext = " . txt " ; if ( testFile ) { fclose ( testFile ) ; } char buffer [ 1024 ] ; strcpy ( buffer , testDataPath ) ; strcat ( buffer , type ) ; size_t bufLen = strlen ( buffer ) ; // ▁ we ▁ try ▁ to ▁ open ▁ 3 ▁ files : ENDCOM // ▁ path / CollationTest _ type . txt ENDCOM // ▁ path / CollationTest _ type _ SHORT . txt ENDCOM // ▁ path / CollationTest _ type _ STUB . txt ENDCOM // ▁ we ▁ are ▁ going ▁ to ▁ test ▁ with ▁ the ▁ first ▁ one ▁ that ▁ we ▁ manage ▁ to ▁ open . ENDCOM strcpy ( buffer + bufLen , ext ) ; testFile = fopen ( buffer , " rb " ) ; if ( testFile == 0 ) { strcpy ( buffer + bufLen , " _ SHORT " ) ; strcat ( buffer , ext ) ; testFile = fopen ( buffer , " rb " ) ; if ( testFile == 0 ) { strcpy ( buffer + bufLen , " _ STUB " ) ; strcat ( buffer , ext ) ; testFile = fopen ( buffer , " rb " ) ; if ( testFile == 0 ) { * ( buffer + bufLen ) = 0 ; dataerrln ( " could ▁ not ▁ open ▁ any ▁ of ▁ the ▁ conformance ▁ test ▁ files , ▁ tried ▁ opening ▁ base ▁ % s " , buffer ) ; return ; } else { infoln ( " INFO : ▁ Working ▁ with ▁ the ▁ stub ▁ file . \n " " If ▁ you ▁ need ▁ the ▁ full ▁ conformance ▁ test , ▁ please \n " " download ▁ the ▁ appropriate ▁ data ▁ files ▁ from : \n " " http : // source . icu - project . org / repos / icu / tools / trunk / unicodetools / com / ibm / text / data / " ) ; } } } LocalArray < Line > lines ( new Line [ 200000 ] ) ; memset ( lines . getAlias ( ) , 0 , sizeof ( Line ) * 200000 ) ; int32_t lineNum = 0 ; UChar bufferU [ 1024 ] ; uint32_t first = 0 ; while ( fgets ( buffer , 1024 , testFile ) != NULL ) { if ( * buffer == 0 || buffer [ 0 ] == ' # ' ) { // ▁ Store ▁ empty ▁ and ▁ comment ▁ lines ▁ so ▁ that ▁ errors ▁ are ▁ reported ENDCOM // ▁ for ▁ the ▁ real ▁ test ▁ file ▁ lines . ENDCOM lines [ lineNum ] . buflen = 0 ; lines [ lineNum ] . buff [ 0 ] = 0 ; } else { int32_t buflen = u_parseString ( buffer , bufferU , 1024 , & first , & status ) ; lines [ lineNum ] . buflen = buflen ; u_memcpy ( lines [ lineNum ] . buff , bufferU , buflen ) ; lines [ lineNum ] . buff [ buflen ] = 0 ; } lineNum ++ ; } fclose ( testFile ) ; if ( U_FAILURE ( status ) ) { dataerrln ( " Couldn ' t ▁ read ▁ the ▁ test ▁ file ! " ) ; return ; } UVersionInfo uniVersion ; static const UVersionInfo v62 = { 6 , 2 , 0 , 0 } ; u_getUnicodeVersion ( uniVersion ) ; UBool isAtLeastUCA62 = uprv_memcmp ( uniVersion , v62 , 4 ) >= 0 ; LocalPointer < Collator > coll ( Collator :: createInstance ( Locale :: getRoot ( ) , status ) ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " Couldn ' t ▁ open ▁ UCA ▁ collator " ) ; return ; } coll -> setAttribute ( UCOL_NORMALIZATION_MODE , UCOL_ON , status ) ; coll -> setAttribute ( UCOL_CASE_FIRST , UCOL_OFF , status ) ; coll -> setAttribute ( UCOL_CASE_LEVEL , UCOL_OFF , status ) ; coll -> setAttribute ( UCOL_STRENGTH , isAtLeastUCA62 ? UCOL_IDENTICAL : UCOL_TERTIARY , status ) ; coll -> setAttribute ( UCOL_ALTERNATE_HANDLING , UCOL_NON_IGNORABLE , status ) ; int32_t noSpawned = 0 ; int32_t spawnResult = 0 ; LocalArray < CollatorThreadTest > tests ( new CollatorThreadTest [ kCollatorThreadThreads ] ) ; logln ( UnicodeString ( " Spawning : ▁ " ) + kCollatorThreadThreads + " ▁ threads ▁ * ▁ " + kFormatThreadIterations + " ▁ iterations ▁ each . " ) ; int32_t j = 0 ; for ( j = 0 ; j < kCollatorThreadThreads ; j ++ ) { // logln ( " Setting ▁ collator ▁ % i " , ▁ j ) ; ENDCOM tests [ j ] . setCollator ( coll . getAlias ( ) , lines . getAlias ( ) , lineNum , isAtLeastUCA62 ) ; } for ( j = 0 ; j < kCollatorThreadThreads ; j ++ ) { log ( " % i ▁ " , j ) ; spawnResult = tests [ j ] . start ( ) ; if ( spawnResult != 0 ) { infoln ( " THREAD ▁ INFO : ▁ Couldn ' t ▁ spawn ▁ more ▁ than ▁ % i ▁ threads " , noSpawned ) ; break ; } noSpawned ++ ; } logln ( " Spawned ▁ all " ) ; if ( noSpawned == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ spawned . " ) ; return ; } for ( int32_t patience = kCollatorThreadPatience ; patience > 0 ; patience -- ) { logln ( " Waiting . . . " ) ; int32_t i ; int32_t terrs = 0 ; int32_t completed = 0 ; for ( i = 0 ; i < kCollatorThreadThreads ; i ++ ) { if ( tests [ i ] . isRunning ( ) == FALSE ) { completed ++ ; // logln ( UnicodeString ( " Test ▁ # " ) ▁ + ▁ i ▁ + ▁ " ▁ is ▁ complete . . ▁ " ) ; ENDCOM UnicodeString theErr ; if ( tests [ i ] . getError ( theErr ) ) { terrs ++ ; errln ( UnicodeString ( " # " ) + i + " : ▁ " + theErr ) ; } // ▁ print ▁ out ▁ the ▁ error , ▁ too , ▁ if ▁ any . ENDCOM } } logln ( " Completed ▁ % i ▁ tests " , completed ) ; if ( completed == noSpawned ) { logln ( " Done ! ▁ All ▁ % i ▁ tests ▁ are ▁ finished " , noSpawned ) ; if ( terrs ) { errln ( " There ▁ were ▁ errors . " ) ; SimpleThread :: errorFunc ( ) ; } return ; } SimpleThread :: sleep ( 900 ) ; } errln ( " patience ▁ exceeded . ▁ " ) ; SimpleThread :: errorFunc ( ) ; } # endif /* ▁ # if ▁ ! UCONFIG _ NO _ COLLATION ▁ */ // ▁ StringThreadTest2 ENDCOM const int kStringThreadIterations = 2500 ; // ▁ # ▁ of ▁ iterations ▁ per ▁ thread ENDCOM const int kStringThreadThreads = 10 ; // ▁ # ▁ of ▁ threads ▁ to ▁ spawn ENDCOM const int kStringThreadPatience = 120 ; // ▁ time ▁ in ▁ seconds ▁ to ▁ wait ▁ for ▁ all ▁ threads ENDCOM class StringThreadTest2 : public ThreadWithStatus { public : int fNum ; int fTraceInfo ; const UnicodeString * fSharedString ; StringThreadTest2 ( const UnicodeString * sharedString , int num ) // ▁ constructor ▁ is ▁ NOT ▁ multithread ▁ safe . ENDCOM : ThreadWithStatus ( ) , fNum ( num ) , fTraceInfo ( 0 ) , fSharedString ( sharedString ) { } ; virtual void run ( ) { fTraceInfo = 1 ; int loopCount = 0 ; for ( loopCount = 0 ; loopCount < kStringThreadIterations ; loopCount ++ ) { if ( * fSharedString != " This ▁ is ▁ the ▁ original ▁ test ▁ string . " ) { error ( " Original ▁ string ▁ is ▁ corrupt . " ) ; break ; } UnicodeString s1 = * fSharedString ; s1 += " cat ▁ this " ; UnicodeString s2 ( s1 ) ; UnicodeString s3 = * fSharedString ; s2 = s3 ; s3 . truncate ( 12 ) ; s2 . truncate ( 0 ) ; } // ▁ while ▁ ( fNum ▁ = = ▁ 4 ) ▁ { SimpleThread : : sleep ( 10000 ) ; } ▁ // ▁ Force ▁ a ▁ failure ▁ by ▁ preventing ▁ thread ▁ from ▁ finishing ENDCOM fTraceInfo = 2 ; } } ; // ▁ * * ▁ The ▁ actual ▁ test ▁ function . ENDCOM void MultithreadTest :: TestString ( ) { int patience ; int terrs = 0 ; int j ; UnicodeString * testString = new UnicodeString ( " This ▁ is ▁ the ▁ original ▁ test ▁ string . " ) ; // ▁ Not ▁ using ▁ LocalArray < StringThreadTest2 > ▁ tests [ kStringThreadThreads ] ; ENDCOM // ▁ because ▁ we ▁ don ' t ▁ always ▁ want ▁ to ▁ delete ▁ them . ENDCOM // ▁ See ▁ the ▁ comments ▁ below ▁ the ▁ cleanupAndReturn ▁ label . ENDCOM StringThreadTest2 * tests [ kStringThreadThreads ] ; for ( j = 0 ; j < kStringThreadThreads ; j ++ ) { tests [ j ] = new StringThreadTest2 ( testString , j ) ; } logln ( UnicodeString ( " Spawning : ▁ " ) + kStringThreadThreads + " ▁ threads ▁ * ▁ " + kStringThreadIterations + " ▁ iterations ▁ each . " ) ; for ( j = 0 ; j < kStringThreadThreads ; j ++ ) { int32_t threadStatus = tests [ j ] -> start ( ) ; if ( threadStatus != 0 ) { errln ( " System ▁ Error ▁ % d ▁ starting ▁ thread ▁ number ▁ % d . " , threadStatus , j ) ; SimpleThread :: errorFunc ( ) ; goto cleanupAndReturn ; } } for ( patience = kStringThreadPatience ; patience > 0 ; patience -- ) { logln ( " Waiting . . . " ) ; int32_t i ; terrs = 0 ; int32_t completed = 0 ; for ( i = 0 ; i < kStringThreadThreads ; i ++ ) { if ( tests [ i ] -> isRunning ( ) == FALSE ) { completed ++ ; logln ( UnicodeString ( " Test ▁ # " ) + i + " ▁ is ▁ complete . . ▁ " ) ; UnicodeString theErr ; if ( tests [ i ] -> getError ( theErr ) ) { terrs ++ ; errln ( UnicodeString ( " # " ) + i + " : ▁ " + theErr ) ; } // ▁ print ▁ out ▁ the ▁ error , ▁ too , ▁ if ▁ any . ENDCOM } } if ( completed == kStringThreadThreads ) { logln ( " Done ! " ) ; if ( terrs ) { errln ( " There ▁ were ▁ errors . " ) ; } break ; } SimpleThread :: sleep ( 900 ) ; } if ( patience <= 0 ) { errln ( " patience ▁ exceeded . ▁ " ) ; // ▁ while ▁ ( TRUE ) ▁ { SimpleThread : : sleep ( 10000 ) ; } ▁ // ▁ TODO : ▁ for ▁ debugging . ▁ Sleep ▁ forever ▁ on ▁ failure . ENDCOM terrs ++ ; } if ( terrs > 0 ) { SimpleThread :: errorFunc ( ) ; } cleanupAndReturn : if ( terrs == 0 ) { /* STRNEWLINE ▁ Don ' t ▁ clean ▁ up ▁ if ▁ there ▁ are ▁ errors . ▁ This ▁ prevents ▁ crashes ▁ if ▁ the STRNEWLINE ▁ threads ▁ are ▁ still ▁ running ▁ and ▁ using ▁ this ▁ data . ▁ This ▁ will ▁ only ▁ happen STRNEWLINE ▁ if ▁ there ▁ is ▁ an ▁ error ▁ with ▁ the ▁ test , ▁ ICU , ▁ or ▁ the ▁ machine ▁ is ▁ too ▁ slow . STRNEWLINE ▁ It ' s ▁ better ▁ to ▁ leak ▁ than ▁ crash . STRNEWLINE ▁ */ for ( j = 0 ; j < kStringThreadThreads ; j ++ ) { delete tests [ j ] ; } delete testString ; } } // ▁ Test ▁ for ▁ ticket ▁ # 10673 , ▁ race ▁ in ▁ cache ▁ code ▁ in ▁ AnyTransliterator . ENDCOM // ▁ It ' s ▁ difficult ▁ to ▁ make ▁ the ▁ original ▁ unsafe ▁ code ▁ actually ▁ fail , ▁ but ENDCOM // ▁ this ▁ test ▁ will ▁ fairly ▁ reliably ▁ take ▁ the ▁ code ▁ path ▁ for ▁ races ▁ in ENDCOM // ▁ populating ▁ the ▁ cache . ENDCOM # if ! UCONFIG_NO_TRANSLITERATION class TxThread : public SimpleThread { private : Transliterator * fSharedTranslit ; public : UBool fSuccess ; TxThread ( Transliterator * tx ) : fSharedTranslit ( tx ) , fSuccess ( FALSE ) { } ; ~ TxThread ( ) ; void run ( ) ; } ; TxThread :: ~ TxThread ( ) { } void TxThread :: run ( ) { UnicodeString greekString ( " \\u03B4\\u03B9\\u03B1\\u03C6\\u03BF\\u03C1\\u03B5\\u03C4\\u03B9\\u03BA\\u03BF\\u03CD\\u03C2" ) ; greekString = greekString . unescape ( ) ; fSharedTranslit -> transliterate ( greekString ) ; fSuccess = greekString [ 0 ] == 0x64 ; // ▁ ' d ' . ▁ The ▁ whole ▁ transliterated ▁ string ▁ is ▁ " diaphoretikous " ▁ ( accented ▁ u ) . ENDCOM } # endif void MultithreadTest :: TestAnyTranslit ( ) { # if ! UCONFIG_NO_TRANSLITERATION UErrorCode status = U_ZERO_ERROR ; LocalPointer < Transliterator > tx ( Transliterator :: createInstance ( " Any - Latin " , UTRANS_FORWARD , status ) ) ; if ( U_FAILURE ( status ) ) { dataerrln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ status ▁ = ▁ % s " , __FILE__ , __LINE__ , u_errorName ( status ) ) ; return ; } TxThread * threads [ 4 ] ; int32_t i ; for ( i = 0 ; i < 4 ; i ++ ) { threads [ i ] = new TxThread ( tx . getAlias ( ) ) ; } for ( i = 0 ; i < 4 ; i ++ ) { threads [ i ] -> start ( ) ; } int32_t patience = 100 ; UBool success ; UBool someThreadRunning ; do { someThreadRunning = FALSE ; success = TRUE ; for ( i = 0 ; i < 4 ; i ++ ) { if ( threads [ i ] -> isRunning ( ) ) { someThreadRunning = TRUE ; SimpleThread :: sleep ( 10 ) ; break ; } else { if ( threads [ i ] -> fSuccess == FALSE ) { success = FALSE ; } } } } while ( someThreadRunning && -- patience > 0 ) ; if ( patience <= 0 ) { errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ one ▁ or ▁ more ▁ threads ▁ did ▁ not ▁ complete . " , __FILE__ , __LINE__ ) ; } if ( success == FALSE ) { errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ transliteration ▁ result ▁ incorrect . " , __FILE__ , __LINE__ ) ; } for ( i = 0 ; i < 4 ; i ++ ) { delete threads [ i ] ; } # endif // ▁ ! UCONFIG _ NO _ TRANSLITERATION ENDCOM } // ▁ Condition ▁ Variables ▁ Test ENDCOM // ▁ Create ▁ a ▁ swarm ▁ of ▁ threads . ENDCOM // ▁ Using ▁ a ▁ mutex ▁ and ▁ a ▁ condition ▁ variables ▁ each ▁ thread ENDCOM // ▁ Increments ▁ a ▁ global ▁ count ▁ of ▁ started ▁ threads . ENDCOM // ▁ Broadcasts ▁ that ▁ it ▁ has ▁ started . ENDCOM // ▁ Waits ▁ on ▁ the ▁ condition ▁ that ▁ all ▁ threads ▁ have ▁ started . ENDCOM // ▁ Increments ▁ a ▁ global ▁ count ▁ of ▁ finished ▁ threads . ENDCOM // ▁ Waits ▁ on ▁ the ▁ condition ▁ that ▁ all ▁ threads ▁ have ▁ finished . ENDCOM // ▁ Exits . ENDCOM class CondThread : public SimpleThread { public : CondThread ( ) : fFinished ( false ) { } ; ~ CondThread ( ) { } ; void run ( ) ; bool fFinished ; } ; static UMutex gCTMutex = U_MUTEX_INITIALIZER ; static UConditionVar gCTConditionVar = U_CONDITION_INITIALIZER ; int gConditionTestOne = 1 ; // ▁ Value ▁ one . ▁ Non - const , ▁ extern ▁ linkage ▁ to ▁ inhibit ENDCOM // ▁ compiler ▁ assuming ▁ a ▁ known ▁ value . ENDCOM int gStartedThreads ; int gFinishedThreads ; static const int NUMTHREADS = 10 ; static MultithreadTest * gThisTest = NULL ; // ▁ Make ▁ test ▁ frame ▁ work ▁ functions ▁ available ▁ to ENDCOM // ▁ non - member ▁ functions . ENDCOM // ▁ Worker ▁ thread ▁ function . ENDCOM void CondThread :: run ( ) { umtx_lock ( & gCTMutex ) ; gStartedThreads += gConditionTestOne ; umtx_condBroadcast ( & gCTConditionVar ) ; while ( gStartedThreads < NUMTHREADS ) { if ( gFinishedThreads != 0 ) { gThisTest -> errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ gStartedThreads ▁ = ▁ % d , ▁ gFinishedThreads ▁ = ▁ % d " , __FILE__ , __LINE__ , gStartedThreads , gFinishedThreads ) ; } umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } gFinishedThreads += gConditionTestOne ; fFinished = true ; umtx_condBroadcast ( & gCTConditionVar ) ; while ( gFinishedThreads < NUMTHREADS ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } umtx_unlock ( & gCTMutex ) ; } void MultithreadTest :: TestConditionVariables ( ) { gThisTest = this ; gStartedThreads = 0 ; gFinishedThreads = 0 ; int i ; umtx_lock ( & gCTMutex ) ; CondThread * threads [ NUMTHREADS ] ; for ( i = 0 ; i < NUMTHREADS ; ++ i ) { threads [ i ] = new CondThread ; threads [ i ] -> start ( ) ; } while ( gStartedThreads < NUMTHREADS ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } while ( gFinishedThreads < NUMTHREADS ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } umtx_unlock ( & gCTMutex ) ; for ( i = 0 ; i < NUMTHREADS ; ++ i ) { if ( ! threads [ i ] -> fFinished ) { errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ threads [ % d ] - > fFinished ▁ = = ▁ false " , __FILE__ , __LINE__ , i ) ; } delete threads [ i ] ; } } static const char * gCacheLocales [ ] = { " en _ US " , " en _ GB " , " fr _ FR " , " fr " } ; static int32_t gObjectsCreated = 0 ; static const int32_t CACHE_LOAD = 3 ; class UCTMultiThreadItem : public SharedObject { public : char * value ; UCTMultiThreadItem ( const char * x ) : value ( NULL ) { value = uprv_strdup ( x ) ; } virtual ~ UCTMultiThreadItem ( ) { uprv_free ( value ) ; } } ; U_NAMESPACE_BEGIN template < > U_EXPORT const UCTMultiThreadItem * LocaleCacheKey < UCTMultiThreadItem > :: createObject ( const void * /* unused */ , UErrorCode & /* ▁ status ▁ */ ) const { // ▁ Since ▁ multiple ▁ threads ▁ are ▁ hitting ▁ the ▁ cache ▁ for ▁ the ▁ first ▁ time , ENDCOM // ▁ no ▁ objects ▁ should ▁ be ▁ created ▁ yet . ENDCOM umtx_lock ( & gCTMutex ) ; if ( gObjectsCreated != 0 ) { gThisTest -> errln ( " Expected ▁ no ▁ objects ▁ to ▁ be ▁ created ▁ yet . " ) ; } umtx_unlock ( & gCTMutex ) ; // ▁ Big , ▁ expensive ▁ object ▁ that ▁ takes ▁ 1 ▁ second ▁ to ▁ create . ENDCOM SimpleThread :: sleep ( 1000 ) ; // ▁ Log ▁ that ▁ we ▁ created ▁ an ▁ object . ENDCOM umtx_lock ( & gCTMutex ) ; ++ gObjectsCreated ; umtx_unlock ( & gCTMutex ) ; UCTMultiThreadItem * result = new UCTMultiThreadItem ( fLoc . getName ( ) ) ; result -> addRef ( ) ; return result ; } U_NAMESPACE_END class UnifiedCacheThread : public SimpleThread { public : UnifiedCacheThread ( const char * loc ) : fLoc ( loc ) { } ; ~ UnifiedCacheThread ( ) { } ; void run ( ) ; const char * fLoc ; } ; void UnifiedCacheThread :: run ( ) { UErrorCode status = U_ZERO_ERROR ; const UnifiedCache * cache = UnifiedCache :: getInstance ( status ) ; U_ASSERT ( status == U_ZERO_ERROR ) ; const UCTMultiThreadItem * item = NULL ; cache -> get ( LocaleCacheKey < UCTMultiThreadItem > ( fLoc ) , item , status ) ; U_ASSERT ( item != NULL ) ; if ( uprv_strcmp ( fLoc , item -> value ) ) { gThisTest -> errln ( " Expected ▁ % s , ▁ got ▁ % s " , fLoc , item -> value ) ; } item -> removeRef ( ) ; // ▁ Mark ▁ this ▁ thread ▁ as ▁ finished ENDCOM umtx_lock ( & gCTMutex ) ; ++ gFinishedThreads ; umtx_condBroadcast ( & gCTConditionVar ) ; umtx_unlock ( & gCTMutex ) ; } void MultithreadTest :: TestUnifiedCache ( ) { UErrorCode status = U_ZERO_ERROR ; const UnifiedCache * cache = UnifiedCache :: getInstance ( status ) ; U_ASSERT ( cache != NULL ) ; cache -> flush ( ) ; gThisTest = this ; gFinishedThreads = 0 ; gObjectsCreated = 0 ; UnifiedCacheThread * threads [ CACHE_LOAD ] [ UPRV_LENGTHOF ( gCacheLocales ) ] ; for ( int32_t i = 0 ; i < CACHE_LOAD ; ++ i ) { for ( int32_t j = 0 ; j < UPRV_LENGTHOF ( gCacheLocales ) ; ++ j ) { threads [ i ] [ j ] = new UnifiedCacheThread ( gCacheLocales [ j ] ) ; threads [ i ] [ j ] -> start ( ) ; } } // ▁ Wait ▁ on ▁ all ▁ the ▁ threads ▁ to ▁ complete ▁ verify ▁ that ▁ LENGTHOF ( gCacheLocales ) ENDCOM // ▁ objects ▁ were ▁ created . ENDCOM umtx_lock ( & gCTMutex ) ; while ( gFinishedThreads < CACHE_LOAD * UPRV_LENGTHOF ( gCacheLocales ) ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } assertEquals ( " Objects ▁ created " , UPRV_LENGTHOF ( gCacheLocales ) , gObjectsCreated ) ; umtx_unlock ( & gCTMutex ) ; // ▁ clean ▁ up ▁ threads ENDCOM for ( int32_t i = 0 ; i < CACHE_LOAD ; ++ i ) { for ( int32_t j = 0 ; j < UPRV_LENGTHOF ( gCacheLocales ) ; ++ j ) { delete threads [ i ] [ j ] ; } } } # endif // ▁ ICU _ USE _ THREADS ENDCOM </DOCUMENT>
<DOCUMENT_ID="thientu/drake/tree/master/util/drakeGeometryUtil.cpp"> # include " drakeGeometryUtil . h " # include < iostream > # include < cmath > # include < limits > # include < stdexcept > # include < Eigen / Sparse > # include " expmap2quat . h " using namespace Eigen ; double angleDiff ( double phi1 , double phi2 ) { double d = phi2 - phi1 ; if ( d > 0.0 ) { d = fmod ( d + M_PI , 2 * M_PI ) - M_PI ; } else { d = fmod ( d - M_PI , 2 * M_PI ) + M_PI ; } return d ; } Vector4d quatConjugate ( const Eigen :: Vector4d & q ) { Vector4d q_conj ; q_conj << q ( 0 ) , - q ( 1 ) , - q ( 2 ) , - q ( 3 ) ; return q_conj ; } Eigen :: Matrix4d dquatConjugate ( ) { Matrix4d dq_conj = Matrix4d :: Identity ( ) ; dq_conj ( 1 , 1 ) = - 1.0 ; dq_conj ( 2 , 2 ) = - 1.0 ; dq_conj ( 3 , 3 ) = - 1.0 ; return dq_conj ; } Eigen :: Vector4d quatProduct ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { double w1 = q1 ( 0 ) ; double w2 = q2 ( 0 ) ; const auto & v1 = q1 . tail < 3 > ( ) ; const auto & v2 = q2 . tail < 3 > ( ) ; Vector4d r ; r << w1 * w2 - v1 . dot ( v2 ) , v1 . cross ( v2 ) + w1 * v2 + w2 * v1 ; return r ; } Eigen :: Matrix < double , 4 , 8 > dquatProduct ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { double w1 = q1 ( 0 ) ; double w2 = q2 ( 0 ) ; const auto & v1 = q1 . tail < 3 > ( ) ; const auto & v2 = q2 . tail < 3 > ( ) ; Matrix < double , 4 , 8 > dr ; dr . row ( 0 ) << w2 , - v2 . transpose ( ) , w1 , - v1 . transpose ( ) ; dr . row ( 1 ) << q2 ( 1 ) , q2 ( 0 ) , q2 ( 3 ) , - q2 ( 2 ) , q1 ( 1 ) , q1 ( 0 ) , - q1 ( 3 ) , q1 ( 2 ) ; dr . row ( 2 ) << q2 ( 2 ) , - q2 ( 3 ) , q2 ( 0 ) , q2 ( 1 ) , q1 ( 2 ) , q1 ( 3 ) , q1 ( 0 ) , - q1 ( 1 ) ; dr . row ( 3 ) << q2 ( 3 ) , q2 ( 2 ) , - q2 ( 1 ) , q2 ( 0 ) , q1 ( 3 ) , - q1 ( 2 ) , q1 ( 1 ) , q1 ( 0 ) ; return dr ; } Eigen :: Vector3d quatRotateVec ( const Eigen :: Vector4d & q , const Eigen :: Vector3d & v ) { Vector4d v_quat ; v_quat << 0 , v ; Vector4d q_times_v = quatProduct ( q , v_quat ) ; Vector4d q_conj = quatConjugate ( q ) ; Vector4d v_rot = quatProduct ( q_times_v , q_conj ) ; Vector3d r = v_rot . bottomRows < 3 > ( ) ; return r ; } Eigen :: Matrix < double , 3 , 7 > dquatRotateVec ( const Eigen :: Vector4d & q , const Eigen :: Vector3d & v ) { Matrix < double , 4 , 7 > dq ; dq << Matrix4d :: Identity ( ) , MatrixXd :: Zero ( 4 , 3 ) ; Matrix < double , 4 , 7 > dv = Matrix < double , 4 , 7 > :: Zero ( ) ; dv . bottomRightCorner < 3 , 3 > ( ) = Matrix3d :: Identity ( ) ; Matrix < double , 8 , 7 > dqdv ; dqdv << dq , dv ; Vector4d v_quat ; v_quat << 0 , v ; Vector4d q_times_v = quatProduct ( q , v_quat ) ; Matrix < double , 4 , 8 > dq_times_v_tmp = dquatProduct ( q , v_quat ) ; Matrix < double , 4 , 7 > dq_times_v = dq_times_v_tmp * dqdv ; Matrix < double , 4 , 7 > dq_conj = dquatConjugate ( ) * dq ; Matrix < double , 8 , 7 > dq_times_v_dq_conj ; dq_times_v_dq_conj << dq_times_v , dq_conj ; Matrix < double , 4 , 8 > dv_rot_tmp = dquatProduct ( q_times_v , quatConjugate ( q ) ) ; Matrix < double , 4 , 7 > dv_rot = dv_rot_tmp * dq_times_v_dq_conj ; Eigen :: Matrix < double , 3 , 7 > dr = dv_rot . bottomRows ( 3 ) ; return dr ; } Eigen :: Vector4d quatDiff ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { return quatProduct ( quatConjugate ( q1 ) , q2 ) ; } Eigen :: Matrix < double , 4 , 8 > dquatDiff ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { auto dr = dquatProduct ( quatConjugate ( q1 ) , q2 ) ; dr . block < 4 , 3 > ( 0 , 1 ) = - dr . block < 4 , 3 > ( 0 , 1 ) ; return dr ; } double quatDiffAxisInvar ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 , const Eigen :: Vector3d & u ) { Vector4d r = quatDiff ( q1 , q2 ) ; double e = - 2.0 + 2 * r ( 0 ) * r ( 0 ) + 2 * pow ( u ( 0 ) * r ( 1 ) + u ( 1 ) * r ( 2 ) + u ( 2 ) * r ( 3 ) , 2 ) ; return e ; } Eigen :: Matrix < double , 1 , 11 > dquatDiffAxisInvar ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 , const Eigen :: Vector3d & u ) { Vector4d r = quatDiff ( q1 , q2 ) ; Matrix < double , 4 , 8 > dr = dquatDiff ( q1 , q2 ) ; Matrix < double , 1 , 11 > de ; const auto & rvec = r . tail < 3 > ( ) ; de << 4.0 * r ( 0 ) * dr . row ( 0 ) + 4.0 * u . transpose ( ) * rvec * u . transpose ( ) * dr . block < 3 , 8 > ( 1 , 0 ) , 4.0 * u . transpose ( ) * rvec * rvec . transpose ( ) ; return de ; } double quatNorm ( const Eigen :: Vector4d & q ) { return std :: acos ( q ( 0 ) ) ; } Eigen :: Vector4d slerp ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 , double interpolation_parameter ) { /* STRNEWLINE ▁ * ▁ Q ▁ = ▁ slerp ( q1 , ▁ q2 , ▁ f ) ▁ Spherical ▁ linear ▁ interpolation ▁ between ▁ two ▁ quaternions STRNEWLINE ▁ * ▁ This ▁ function ▁ uses ▁ the ▁ implementation ▁ given ▁ in ▁ Algorithm ▁ 8 ▁ of ▁ [ 1 ] . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ q1 ▁ Initial ▁ quaternion ▁ ( w , ▁ x , ▁ y , ▁ z ) STRNEWLINE ▁ * ▁ @ param ▁ q2 ▁ Final ▁ quaternion ▁ ( w , ▁ x , ▁ y , ▁ z ) STRNEWLINE ▁ * ▁ @ param ▁ f ▁ Interpolation ▁ parameter ▁ between ▁ 0 ▁ and ▁ 1 ▁ ( inclusive ) STRNEWLINE ▁ * ▁ @ retval ▁ Q ▁ Interpolated ▁ quaternion ( s ) . ▁ 4 - by - 1 ▁ vector . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ [ 1 ] ▁ Kuffner , ▁ J . J . , ▁ " Effective ▁ sampling ▁ and ▁ distance ▁ metrics ▁ for ▁ 3D ▁ rigid STRNEWLINE ▁ * ▁ body ▁ path ▁ planning , " ▁ Robotics ▁ and ▁ Automation , ▁ 2004 . ▁ Proceedings . ▁ ICRA ▁ ' 04 . STRNEWLINE ▁ * ▁ 2004 ▁ IEEE ▁ International ▁ Conference ▁ on ▁ , ▁ vol . 4 , ▁ no . , ▁ pp . 3993,3998 ▁ Vol . 4 , STRNEWLINE ▁ * ▁ April ▁ 26 - May ▁ 1 , ▁ 2004 STRNEWLINE ▁ * ▁ doi : ▁ 10.1109 / ROBOT . 2004.1308895 STRNEWLINE ▁ */ // ▁ Compute ▁ the ▁ quaternion ▁ inner ▁ product ENDCOM double lambda = ( q1 . transpose ( ) * q2 ) . value ( ) ; int q2_sign ; if ( lambda < 0.0 ) { // ▁ The ▁ quaternions ▁ are ▁ pointing ▁ in ▁ opposite ▁ directions , ▁ so ▁ use ▁ the ▁ equivalent ▁ alternative ▁ representation ▁ for ▁ q2 ENDCOM lambda = - lambda ; q2_sign = - 1 ; } else { q2_sign = 1 ; } // ▁ Calculate ▁ interpolation ▁ factors ENDCOM // ▁ TODO : ▁ do ▁ we ▁ really ▁ want ▁ an ▁ epsilon ▁ so ▁ small ? ENDCOM double r , s ; if ( std :: abs ( 1.0 - lambda ) < std :: numeric_limits < double > :: epsilon ( ) ) { // ▁ The ▁ quaternions ▁ are ▁ nearly ▁ parallel , ▁ so ▁ use ▁ linear ▁ interpolation ENDCOM r = 1.0 - interpolation_parameter ; s = interpolation_parameter ; } else { double alpha = std :: acos ( lambda ) ; double gamma = 1.0 / std :: sin ( alpha ) ; r = std :: sin ( ( 1.0 - interpolation_parameter ) * alpha ) * gamma ; s = std :: sin ( interpolation_parameter * alpha ) * gamma ; } Vector4d ret = q1 * r ; ret += q2_sign * q2 * s ; return ret ; } Vector4d uniformlyRandomAxisAngle ( std :: default_random_engine & generator ) { std :: normal_distribution < double > normal ; std :: uniform_real_distribution < double > uniform ( - M_PI , M_PI ) ; double angle = uniform ( generator ) ; Vector3d axis = Vector3d ( normal ( generator ) , normal ( generator ) , normal ( generator ) ) ; axis . normalize ( ) ; Vector4d a ; a << axis , angle ; return a ; } Vector4d uniformlyRandomQuat ( std :: default_random_engine & generator ) { return axis2quat ( uniformlyRandomAxisAngle ( generator ) ) ; } Eigen :: Matrix3d uniformlyRandomRotmat ( std :: default_random_engine & generator ) { return axis2rotmat ( uniformlyRandomAxisAngle ( generator ) ) ; } Eigen :: Vector3d uniformlyRandomRPY ( std :: default_random_engine & generator ) { return axis2rpy ( uniformlyRandomAxisAngle ( generator ) ) ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > quat2rpy ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto q_normalized = q . normalized ( ) ; auto w = q_normalized ( 0 ) ; auto x = q_normalized ( 1 ) ; auto y = q_normalized ( 2 ) ; auto z = q_normalized ( 3 ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > ret ; ret << std :: atan2 ( 2.0 * ( w * x + y * z ) , w * w + z * z - ( x * x + y * y ) ) , std :: asin ( 2.0 * ( w * y - z * x ) ) , std :: atan2 ( 2.0 * ( w * z + x * y ) , w * w + x * x - ( y * y + z * z ) ) ; return ret ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > quat2rotmat ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto q_normalized = q . normalized ( ) ; auto w = q_normalized ( 0 ) ; auto x = q_normalized ( 1 ) ; auto y = q_normalized ( 2 ) ; auto z = q_normalized ( 3 ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > M ; M . row ( 0 ) << w * w + x * x - y * y - z * z , 2.0 * x * y - 2.0 * w * z , 2.0 * x * z + 2.0 * w * y ; M . row ( 1 ) << 2.0 * x * y + 2.0 * w * z , w * w + y * y - x * x - z * z , 2.0 * y * z - 2.0 * w * x ; M . row ( 2 ) << 2.0 * x * z - 2.0 * w * y , 2.0 * y * z + 2.0 * w * x , w * w + z * z - x * x - y * y ; return M ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > quat2axis ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto q_normalized = q . normalized ( ) ; auto s = std :: sqrt ( 1.0 - q_normalized ( 0 ) * q_normalized ( 0 ) ) + std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) ; Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > a ; a << q_normalized . template tail < 3 > ( ) / s , 2.0 * std :: acos ( q_normalized ( 0 ) ) ; return a ; } template < typename Derived > Eigen :: Vector4d axis2quat ( const Eigen :: MatrixBase < Derived > & a ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto axis = a . template head < 3 > ( ) ; auto angle = a ( 3 ) ; auto arg = 0.5 * angle ; auto c = std :: cos ( arg ) ; auto s = std :: sin ( arg ) ; Eigen :: Vector4d ret ; ret << c , s * axis ; return ret ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > axis2rotmat ( const Eigen :: MatrixBase < Derived > & a ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; const auto & axis = ( a . template head < 3 > ( ) ) / ( a . template head < 3 > ( ) ) . norm ( ) ; const auto & theta = a ( 3 ) ; auto x = axis ( 0 ) ; auto y = axis ( 1 ) ; auto z = axis ( 2 ) ; auto ctheta = std :: cos ( theta ) ; auto stheta = std :: sin ( theta ) ; auto c = 1 - ctheta ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > R ; R << ctheta + x * x * c , x * y * c - z * stheta , x * z * c + y * stheta , y * x * c + z * stheta , ctheta + y * y * c , y * z * c - x * stheta , z * x * c - y * stheta , z * y * c + x * stheta , ctheta + z * z * c ; return R ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > axis2rpy ( const Eigen :: MatrixBase < Derived > & a ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; return quat2rpy ( axis2quat ( a ) ) ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rotmat2axis ( const Eigen :: MatrixBase < Derived > & R ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 , 3 ) ; typename Derived :: Scalar theta = std :: acos ( ( R . trace ( ) - 1.0 ) / 2.0 ) ; Vector4d a ; if ( theta > std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) ) { a << R ( 2 , 1 ) - R ( 1 , 2 ) , R ( 0 , 2 ) - R ( 2 , 0 ) , R ( 1 , 0 ) - R ( 0 , 1 ) , theta ; a . head < 3 > ( ) *= 1.0 / ( 2.0 * std :: sin ( theta ) ) ; } else { a << 1.0 , 0.0 , 0.0 , 0.0 ; } return a ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rotmat2quat ( const Eigen :: MatrixBase < Derived > & M ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 , 3 ) ; using namespace std ; Matrix < typename Derived :: Scalar , 4 , 3 > A ; A . row ( 0 ) << 1.0 , 1.0 , 1.0 ; A . row ( 1 ) << 1.0 , - 1.0 , - 1.0 ; A . row ( 2 ) << - 1.0 , 1.0 , - 1.0 ; A . row ( 3 ) << - 1.0 , - 1.0 , 1.0 ; Matrix < typename Derived :: Scalar , 4 , 1 > B = A * M . diagonal ( ) ; typename Matrix < typename Derived :: Scalar , 4 , 1 > :: Index ind , max_col ; typename Derived :: Scalar val = B . maxCoeff ( & ind , & max_col ) ; typename Derived :: Scalar w , x , y , z ; switch ( ind ) { case 0 : { // ▁ val ▁ = ▁ trace ( M ) ENDCOM w = sqrt ( 1.0 + val ) / 2.0 ; typename Derived :: Scalar w4 = w * 4.0 ; x = ( M ( 2 , 1 ) - M ( 1 , 2 ) ) / w4 ; y = ( M ( 0 , 2 ) - M ( 2 , 0 ) ) / w4 ; z = ( M ( 1 , 0 ) - M ( 0 , 1 ) ) / w4 ; break ; } case 1 : { // ▁ val ▁ = ▁ M ( 1,1 ) ▁ - ▁ M ( 2,2 ) ▁ - ▁ M ( 3,3 ) ENDCOM double s = 2.0 * sqrt ( 1.0 + val ) ; w = ( M ( 2 , 1 ) - M ( 1 , 2 ) ) / s ; x = 0.25 * s ; y = ( M ( 0 , 1 ) + M ( 1 , 0 ) ) / s ; z = ( M ( 0 , 2 ) + M ( 2 , 0 ) ) / s ; break ; } case 2 : { // ▁ % ▁ val ▁ = ▁ M ( 2,2 ) ▁ - ▁ M ( 1,1 ) ▁ - ▁ M ( 3,3 ) ENDCOM double s = 2.0 * ( sqrt ( 1.0 + val ) ) ; w = ( M ( 0 , 2 ) - M ( 2 , 0 ) ) / s ; x = ( M ( 0 , 1 ) + M ( 1 , 0 ) ) / s ; y = 0.25 * s ; z = ( M ( 1 , 2 ) + M ( 2 , 1 ) ) / s ; break ; } default : { // ▁ val ▁ = ▁ M ( 3,3 ) ▁ - ▁ M ( 2,2 ) ▁ - ▁ M ( 1,1 ) ENDCOM double s = 2.0 * ( sqrt ( 1.0 + val ) ) ; w = ( M ( 1 , 0 ) - M ( 0 , 1 ) ) / s ; x = ( M ( 0 , 2 ) + M ( 2 , 0 ) ) / s ; y = ( M ( 1 , 2 ) + M ( 2 , 1 ) ) / s ; z = 0.25 * s ; break ; } } Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > q ; q << w , x , y , z ; return q ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > rotmat2rpy ( const Eigen :: MatrixBase < Derived > & R ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 , 3 ) ; using namespace std ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > rpy ; rpy << atan2 ( R ( 2 , 1 ) , R ( 2 , 2 ) ) , atan2 ( - R ( 2 , 0 ) , sqrt ( pow ( R ( 2 , 1 ) , 2.0 ) + pow ( R ( 2 , 2 ) , 2.0 ) ) ) , atan2 ( R ( 1 , 0 ) , R ( 0 , 0 ) ) ; return rpy ; } template < typename Derived > DLLEXPORT Eigen :: Matrix < typename Derived :: Scalar , Eigen :: Dynamic , 1 > rotmat2Representation ( const Eigen :: MatrixBase < Derived > & R , int rotation_type ) { typedef typename Derived :: Scalar Scalar ; Eigen :: Matrix < Scalar , Eigen :: Dynamic , 1 > ret ; switch ( rotation_type ) { case 0 : return Eigen :: Matrix < Scalar , Eigen :: Dynamic , 1 > ( 0 , 1 ) ; case 1 : return rotmat2rpy ( R ) ; case 2 : return rotmat2quat ( R ) ; default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } } template < typename Scalar > DLLEXPORT GradientVar < Scalar , Eigen :: Dynamic , 1 > rotmat2Representation ( const GradientVar < Scalar , SPACE_DIMENSION , SPACE_DIMENSION > & R , int rotation_type ) { GradientVar < Scalar , Eigen :: Dynamic , 1 > ret ( rotationRepresentationSize ( rotation_type ) , 1 , R . getNumVariables ( ) , R . maxOrder ( ) ) ; switch ( rotation_type ) { case 0 : // ▁ empty ▁ matrix , ▁ already ▁ done ENDCOM break ; case 1 : ret . value ( ) = rotmat2rpy ( R . value ( ) ) ; if ( R . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = drotmat2rpy ( R . value ( ) , R . gradient ( ) . value ( ) ) ; } break ; case 2 : ret . value ( ) = rotmat2quat ( R . value ( ) ) ; if ( R . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = drotmat2quat ( R . value ( ) , R . gradient ( ) . value ( ) ) ; } break ; default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } return ret ; } template < typename Derived > GradientVar < typename Derived :: Scalar , QUAT_SIZE , 1 > expmap2quat ( const Eigen :: MatrixBase < Derived > & v , const int gradient_order ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; GradientVar < typename Derived :: Scalar , QUAT_SIZE , 1 > ret ( QUAT_SIZE , 1 , EXPMAP_SIZE , gradient_order ) ; auto theta = v . norm ( ) ; if ( theta < pow ( std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) , 0.25 ) ) { ret . value ( ) = expmap2quatDegenerate ( v , theta ) ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = dexpmap2quatDegenerate ( v , theta ) ; if ( gradient_order > 1 ) { ret . gradient ( ) . gradient ( ) . value ( ) = ddexpmap2quatDegenerate ( v , theta ) ; if ( gradient_order > 2 ) { throw std :: runtime_error ( " expmap2quat ▁ does ▁ not ▁ support ▁ gradient ▁ order ▁ larger ▁ than ▁ 2" ) ; } } } } else { ret . value ( ) = expmap2quatNonDegenerate ( v , theta ) ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = dexpmap2quatNonDegenerate ( v , theta ) ; if ( gradient_order > 1 ) { ret . gradient ( ) . gradient ( ) . value ( ) = ddexpmap2quatNonDegenerate ( v , theta ) ; if ( gradient_order > 2 ) { throw std :: runtime_error ( " expmap2quat ▁ does ▁ not ▁ support ▁ gradient ▁ order ▁ larger ▁ than ▁ 2" ) ; } } } } return ret ; } DLLEXPORT int rotationRepresentationSize ( int rotation_type ) { switch ( rotation_type ) { case 0 : return 0 ; break ; case 1 : return 3 ; break ; case 2 : return 4 ; break ; default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rpy2axis ( const Eigen :: MatrixBase < Derived > & rpy ) { return quat2axis ( rpy2quat ( rpy ) ) ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rpy2quat ( const Eigen :: MatrixBase < Derived > & rpy ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; auto rpy_2 = ( rpy / 2.0 ) . array ( ) ; auto s = rpy_2 . sin ( ) ; auto c = rpy_2 . cos ( ) ; Vector4d q ; q << c ( 0 ) * c ( 1 ) * c ( 2 ) + s ( 0 ) * s ( 1 ) * s ( 2 ) , s ( 0 ) * c ( 1 ) * c ( 2 ) - c ( 0 ) * s ( 1 ) * s ( 2 ) , c ( 0 ) * s ( 1 ) * c ( 2 ) + s ( 0 ) * c ( 1 ) * s ( 2 ) , c ( 0 ) * c ( 1 ) * s ( 2 ) - s ( 0 ) * s ( 1 ) * c ( 2 ) ; q /= q . norm ( ) + std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) ; return q ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > rpy2rotmat ( const Eigen :: MatrixBase < Derived > & rpy ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; auto rpy_array = rpy . array ( ) ; auto s = rpy_array . sin ( ) ; auto c = rpy_array . cos ( ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > R ; R . row ( 0 ) << c ( 2 ) * c ( 1 ) , c ( 2 ) * s ( 1 ) * s ( 0 ) - s ( 2 ) * c ( 0 ) , c ( 2 ) * s ( 1 ) * c ( 0 ) + s ( 2 ) * s ( 0 ) ; R . row ( 1 ) << s ( 2 ) * c ( 1 ) , s ( 2 ) * s ( 1 ) * s ( 0 ) + c ( 2 ) * c ( 0 ) , s ( 2 ) * s ( 1 ) * c ( 0 ) - c ( 2 ) * s ( 0 ) ; R . row ( 2 ) << - s ( 1 ) , c ( 1 ) * s ( 0 ) , c ( 1 ) * c ( 0 ) ; return R ; } Matrix3d rotz ( double theta ) { // ▁ returns ▁ 3D ▁ rotation ▁ matrix ▁ ( about ▁ the ▁ z ▁ axis ) ENDCOM Matrix3d M ; double c = cos ( theta ) ; double s = sin ( theta ) ; M << c , - s , 0 , s , c , 0 , 0 , 0 , 1 ; return M ; } void rotz ( double theta , Matrix3d & M , Matrix3d & dM , Matrix3d & ddM ) { double c = cos ( theta ) , s = sin ( theta ) ; M << c , - s , 0 , s , c , 0 , 0 , 0 , 1 ; dM << - s , - c , 0 , c , - s , 0 , 0 , 0 , 0 ; ddM << - c , s , 0 , - s , - c , 0 , 0 , 0 , 0 ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 9 , 3 > drpy2rotmat ( const Eigen :: MatrixBase < Derived > & rpy ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; auto rpy_array = rpy . array ( ) ; auto s = rpy_array . sin ( ) ; auto c = rpy_array . cos ( ) ; Eigen :: Matrix < typename Derived :: Scalar , 9 , 3 > dR ; dR . row ( 0 ) << 0 , c ( 2 ) * - s ( 1 ) , c ( 1 ) * - s ( 2 ) ; dR . row ( 1 ) << 0 , - s ( 1 ) * s ( 2 ) , c ( 2 ) * c ( 1 ) ; dR . row ( 2 ) << 0 , - c ( 1 ) , 0 ; dR . row ( 3 ) << c ( 2 ) * s ( 1 ) * c ( 0 ) - s ( 2 ) * - s ( 0 ) , c ( 2 ) * c ( 1 ) * s ( 0 ) , - s ( 2 ) * s ( 1 ) * s ( 0 ) - c ( 2 ) * c ( 0 ) ; dR . row ( 4 ) << s ( 2 ) * s ( 1 ) * c ( 0 ) + c ( 2 ) * - s ( 0 ) , s ( 2 ) * c ( 1 ) * s ( 0 ) , c ( 2 ) * s ( 1 ) * s ( 0 ) - s ( 2 ) * c ( 0 ) ; dR . row ( 5 ) << c ( 1 ) * c ( 0 ) , - s ( 1 ) * s ( 0 ) , 0 ; dR . row ( 6 ) << c ( 2 ) * s ( 1 ) * - s ( 0 ) + s ( 2 ) * c ( 0 ) , c ( 2 ) * c ( 1 ) * c ( 0 ) , - s ( 2 ) * s ( 1 ) * c ( 0 ) + c ( 2 ) * s ( 0 ) ; dR . row ( 7 ) << s ( 2 ) * s ( 1 ) * - s ( 0 ) - c ( 2 ) * c ( 0 ) , s ( 2 ) * c ( 1 ) * c ( 0 ) , c ( 2 ) * s ( 1 ) * c ( 0 ) + s ( 2 ) * s ( 0 ) ; dR . row ( 8 ) << c ( 1 ) * - s ( 0 ) , - s ( 1 ) * c ( 0 ) , 0 ; return dR ; } // ▁ NOTE : ▁ not ▁ reshaping ▁ second ▁ derivative ▁ to ▁ Matlab ▁ geval ▁ output ▁ format ! ENDCOM template < typename Derived > void normalizeVec ( const Eigen :: MatrixBase < Derived > & x , typename Derived :: PlainObject & x_norm , typename Gradient < Derived , Derived :: RowsAtCompileTime , 1 > :: type * dx_norm , typename Gradient < Derived , Derived :: RowsAtCompileTime , 2 > :: type * ddx_norm ) { typename Derived :: Scalar xdotx = x . squaredNorm ( ) ; typename Derived :: Scalar norm_x = std :: sqrt ( xdotx ) ; x_norm = x / norm_x ; if ( dx_norm ) { dx_norm -> setIdentity ( x . rows ( ) , x . rows ( ) ) ; ( * dx_norm ) -= x * x . transpose ( ) / xdotx ; ( * dx_norm ) /= norm_x ; if ( ddx_norm ) { auto dx_norm_transpose = transposeGrad ( * dx_norm , x . rows ( ) ) ; auto ddx_norm_times_norm = - matGradMultMat ( x_norm , x_norm . transpose ( ) , ( * dx_norm ) , dx_norm_transpose ) ; auto dnorm_inv = - x . transpose ( ) / ( xdotx * norm_x ) ; ( * ddx_norm ) = ddx_norm_times_norm / norm_x ; auto temp = ( * dx_norm ) * norm_x ; typename Derived :: Index n = x . rows ( ) ; for ( int col = 0 ; col < n ; col ++ ) { auto column_as_matrix = ( dnorm_inv ( 0 , col ) * temp ) ; for ( int row_block = 0 ; row_block < n ; row_block ++ ) { ddx_norm -> block ( row_block * n , col , n , 1 ) += column_as_matrix . col ( row_block ) ; } } } } } template < typename Derived > typename Gradient < Matrix < typename Derived :: Scalar , 3 , 3 > , QUAT_SIZE > :: type dquat2rotmat ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , QUAT_SIZE ) ; typename Gradient < Matrix < typename Derived :: Scalar , 3 , 3 > , QUAT_SIZE > :: type ret ; typename Eigen :: MatrixBase < Derived > :: PlainObject qtilde ; typename Gradient < Derived , QUAT_SIZE > :: type dqtilde ; normalizeVec ( q , qtilde , & dqtilde ) ; typedef typename Derived :: Scalar Scalar ; Scalar w = qtilde ( 0 ) ; Scalar x = qtilde ( 1 ) ; Scalar y = qtilde ( 2 ) ; Scalar z = qtilde ( 3 ) ; ret << w , x , - y , - z , z , y , x , w , - y , z , - w , x , - z , y , x , - w , w , - x , y , - z , x , w , z , y , y , z , w , x , - x , - w , z , y , w , - x , - y , z ; ret *= 2.0 ; ret *= dqtilde ; return ret ; } template < typename DerivedR , typename DerivedDR > typename Gradient < Eigen :: Matrix < typename DerivedR :: Scalar , RPY_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type drotmat2rpy ( const Eigen :: MatrixBase < DerivedR > & R , const Eigen :: MatrixBase < DerivedDR > & dR ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedR > , SPACE_DIMENSION , SPACE_DIMENSION ) ; EIGEN_STATIC_ASSERT ( Eigen :: MatrixBase < DerivedDR > :: RowsAtCompileTime == RotmatSize , THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE ) ; typename DerivedDR :: Index nq = dR . cols ( ) ; typedef typename DerivedR :: Scalar Scalar ; typedef typename Gradient < Eigen :: Matrix < Scalar , RPY_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type ReturnType ; ReturnType drpy ( RPY_SIZE , nq ) ; auto dR11_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 0 , R . rows ( ) ) ; auto dR21_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 0 , R . rows ( ) ) ; auto dR31_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 0 , R . rows ( ) ) ; auto dR32_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 1 , R . rows ( ) ) ; auto dR33_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 2 , R . rows ( ) ) ; Scalar sqterm = R ( 2 , 1 ) * R ( 2 , 1 ) + R ( 2 , 2 ) * R ( 2 , 2 ) ; using namespace std ; // ▁ droll _ dq ENDCOM drpy . row ( 0 ) = ( R ( 2 , 2 ) * dR32_dq - R ( 2 , 1 ) * dR33_dq ) / sqterm ; // ▁ dpitch _ dq ENDCOM Scalar sqrt_sqterm = sqrt ( sqterm ) ; drpy . row ( 1 ) = ( - sqrt_sqterm * dR31_dq + R ( 2 , 0 ) / sqrt_sqterm * ( R ( 2 , 1 ) * dR32_dq + R ( 2 , 2 ) * dR33_dq ) ) / ( R ( 2 , 0 ) * R ( 2 , 0 ) + R ( 2 , 1 ) * R ( 2 , 1 ) + R ( 2 , 2 ) * R ( 2 , 2 ) ) ; // ▁ dyaw _ dq ENDCOM sqterm = R ( 0 , 0 ) * R ( 0 , 0 ) + R ( 1 , 0 ) * R ( 1 , 0 ) ; drpy . row ( 2 ) = ( R ( 0 , 0 ) * dR21_dq - R ( 1 , 0 ) * dR11_dq ) / sqterm ; return drpy ; } template < typename DerivedR , typename DerivedDR > typename Gradient < Eigen :: Matrix < typename DerivedR :: Scalar , QUAT_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type drotmat2quat ( const Eigen :: MatrixBase < DerivedR > & R , const Eigen :: MatrixBase < DerivedDR > & dR ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedR > , SPACE_DIMENSION , SPACE_DIMENSION ) ; EIGEN_STATIC_ASSERT ( Eigen :: MatrixBase < DerivedDR > :: RowsAtCompileTime == RotmatSize , THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE ) ; typedef typename DerivedR :: Scalar Scalar ; typedef typename Gradient < Eigen :: Matrix < Scalar , QUAT_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type ReturnType ; typename DerivedDR :: Index nq = dR . cols ( ) ; auto dR11_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 0 , R . rows ( ) ) ; auto dR12_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 1 , R . rows ( ) ) ; auto dR13_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 2 , R . rows ( ) ) ; auto dR21_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 0 , R . rows ( ) ) ; auto dR22_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 1 , R . rows ( ) ) ; auto dR23_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 2 , R . rows ( ) ) ; auto dR31_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 0 , R . rows ( ) ) ; auto dR32_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 1 , R . rows ( ) ) ; auto dR33_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 2 , R . rows ( ) ) ; Matrix < Scalar , 4 , 3 > A ; A . row ( 0 ) << 1.0 , 1.0 , 1.0 ; A . row ( 1 ) << 1.0 , - 1.0 , - 1.0 ; A . row ( 2 ) << - 1.0 , 1.0 , - 1.0 ; A . row ( 3 ) << - 1.0 , - 1.0 , 1.0 ; Matrix < Scalar , 4 , 1 > B = A * R . diagonal ( ) ; typename Matrix < Scalar , 4 , 1 > :: Index ind , max_col ; Scalar val = B . maxCoeff ( & ind , & max_col ) ; ReturnType dq ( QUAT_SIZE , nq ) ; using namespace std ; switch ( ind ) { case 0 : { // ▁ val ▁ = ▁ trace ( M ) ENDCOM auto dvaldq = dR11_dq + dR22_dq + dR33_dq ; auto dwdq = dvaldq / ( 4.0 * sqrt ( 1.0 + val ) ) ; auto w = sqrt ( 1.0 + val ) / 2.0 ; auto wsquare4 = 4.0 * w * w ; dq . row ( 0 ) = dwdq ; dq . row ( 1 ) = ( ( dR32_dq - dR23_dq ) * w - ( R ( 2 , 1 ) - R ( 1 , 2 ) ) * dwdq ) / wsquare4 ; dq . row ( 2 ) = ( ( dR13_dq - dR31_dq ) * w - ( R ( 0 , 2 ) - R ( 2 , 0 ) ) * dwdq ) / wsquare4 ; dq . row ( 3 ) = ( ( dR21_dq - dR12_dq ) * w - ( R ( 1 , 0 ) - R ( 0 , 1 ) ) * dwdq ) / wsquare4 ; break ; } case 1 : { // ▁ val ▁ = ▁ M ( 1,1 ) ▁ - ▁ M ( 2,2 ) ▁ - ▁ M ( 3,3 ) ENDCOM auto dvaldq = dR11_dq - dR22_dq - dR33_dq ; auto s = 2.0 * sqrt ( 1.0 + val ) ; auto ssquare = s * s ; auto dsdq = dvaldq / sqrt ( 1.0 + val ) ; dq . row ( 0 ) = ( ( dR32_dq - dR23_dq ) * s - ( R ( 2 , 1 ) - R ( 1 , 2 ) ) * dsdq ) / ssquare ; dq . row ( 1 ) = .25 * dsdq ; dq . row ( 2 ) = ( ( dR12_dq + dR21_dq ) * s - ( R ( 0 , 1 ) + R ( 1 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 3 ) = ( ( dR13_dq + dR31_dq ) * s - ( R ( 0 , 2 ) + R ( 2 , 0 ) ) * dsdq ) / ssquare ; break ; } case 2 : { // ▁ val ▁ = ▁ M ( 2,2 ) ▁ - ▁ M ( 1,1 ) ▁ - ▁ M ( 3,3 ) ENDCOM auto dvaldq = - dR11_dq + dR22_dq - dR33_dq ; auto s = 2.0 * ( sqrt ( 1.0 + val ) ) ; auto ssquare = s * s ; auto dsdq = dvaldq / sqrt ( 1.0 + val ) ; dq . row ( 0 ) = ( ( dR13_dq - dR31_dq ) * s - ( R ( 0 , 2 ) - R ( 2 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 1 ) = ( ( dR12_dq + dR21_dq ) * s - ( R ( 0 , 1 ) + R ( 1 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 2 ) = .25 * dsdq ; dq . row ( 3 ) = ( ( dR23_dq + dR32_dq ) * s - ( R ( 1 , 2 ) + R ( 2 , 1 ) ) * dsdq ) / ssquare ; break ; } default : { // ▁ val ▁ = ▁ M ( 3,3 ) ▁ - ▁ M ( 2,2 ) ▁ - ▁ M ( 1,1 ) ENDCOM auto dvaldq = - dR11_dq - dR22_dq + dR33_dq ; auto s = 2.0 * ( sqrt ( 1.0 + val ) ) ; auto ssquare = s * s ; auto dsdq = dvaldq / sqrt ( 1.0 + val ) ; dq . row ( 0 ) = ( ( dR21_dq - dR12_dq ) * s - ( R ( 1 , 0 ) - R ( 0 , 1 ) ) * dsdq ) / ssquare ; dq . row ( 1 ) = ( ( dR13_dq + dR31_dq ) * s - ( R ( 0 , 2 ) + R ( 2 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 2 ) = ( ( dR23_dq + dR32_dq ) * s - ( R ( 1 , 2 ) + R ( 2 , 1 ) ) * dsdq ) / ssquare ; dq . row ( 3 ) = .25 * dsdq ; break ; } } return dq ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > vectorToSkewSymmetric ( const Eigen :: MatrixBase < Derived > & p ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , SPACE_DIMENSION ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > ret ; ret << 0.0 , - p ( 2 ) , p ( 1 ) , p ( 2 ) , 0.0 , - p ( 0 ) , - p ( 1 ) , p ( 0 ) , 0.0 ; return ret ; } template < typename DerivedA , typename DerivedB > Eigen :: Matrix < typename DerivedA :: Scalar , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b , const typename Gradient < DerivedA , Eigen :: Dynamic > :: type & da , const typename Gradient < DerivedB , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename DerivedA :: Scalar , 3 , Eigen :: Dynamic > ret ( 3 , da . cols ( ) ) ; ret . noalias ( ) = da . colwise ( ) . cross ( b ) ; ret . noalias ( ) -= db . colwise ( ) . cross ( a ) ; return ret ; } template < typename DerivedQ , typename DerivedM , typename DerivedDM > void angularvel2quatdotMatrix ( const Eigen :: MatrixBase < DerivedQ > & q , Eigen :: MatrixBase < DerivedM > & M , Eigen :: MatrixBase < DerivedDM > * dM ) { // ▁ note : ▁ not ▁ normalizing ▁ to ▁ match ▁ MATLAB ▁ implementation ENDCOM M . resize ( QUAT_SIZE , SPACE_DIMENSION ) ; M . row ( 0 ) << - q ( 1 ) , - q ( 2 ) , - q ( 3 ) ; M . row ( 1 ) << q ( 0 ) , q ( 3 ) , - q ( 2 ) ; M . row ( 2 ) << - q ( 3 ) , q ( 0 ) , q ( 1 ) ; M . row ( 3 ) << q ( 2 ) , - q ( 1 ) , q ( 0 ) ; M *= 0.5 ; if ( dM ) { ( * dM ) << 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.5 , 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 ; } } template < typename DerivedQ , typename DerivedM > void quatdot2angularvelMatrix ( const Eigen :: MatrixBase < DerivedQ > & q , Eigen :: MatrixBase < DerivedM > & M , typename Gradient < DerivedM , QUAT_SIZE , 1 > :: type * dM ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedQ > , QUAT_SIZE ) ; EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedM > , SPACE_DIMENSION , QUAT_SIZE ) ; typename DerivedQ :: PlainObject qtilde ; if ( dM ) { typename Gradient < DerivedQ , QUAT_SIZE > :: type dqtilde ; normalizeVec ( q , qtilde , & dqtilde ) ; ( * dM ) << 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , 0.0 ; ( * dM ) *= dqtilde ; } else { normalizeVec ( q , qtilde ) ; } M << - qtilde ( 1 ) , qtilde ( 0 ) , - qtilde ( 3 ) , qtilde ( 2 ) , - qtilde ( 2 ) , qtilde ( 3 ) , qtilde ( 0 ) , - qtilde ( 1 ) , - qtilde ( 3 ) , - qtilde ( 2 ) , qtilde ( 1 ) , qtilde ( 0 ) ; M *= 2.0 ; } template < typename DerivedRPY , typename DerivedPhi , typename DerivedDPhi , typename DerivedDDPhi > void angularvel2rpydotMatrix ( const Eigen :: MatrixBase < DerivedRPY > & rpy , typename Eigen :: MatrixBase < DerivedPhi > & phi , typename Eigen :: MatrixBase < DerivedDPhi > * dphi , typename Eigen :: MatrixBase < DerivedDDPhi > * ddphi ) { phi . resize ( RPY_SIZE , SPACE_DIMENSION ) ; typedef typename DerivedRPY :: Scalar Scalar ; Scalar p = rpy ( 1 ) ; Scalar y = rpy ( 2 ) ; using namespace std ; Scalar sy = sin ( y ) ; Scalar cy = cos ( y ) ; Scalar sp = sin ( p ) ; Scalar cp = cos ( p ) ; Scalar tp = sp / cp ; phi << cy / cp , sy / cp , 0.0 , - sy , cy , 0.0 , cy * tp , tp * sy , 1.0 ; if ( dphi ) { dphi -> resize ( phi . size ( ) , RPY_SIZE ) ; Scalar sp2 = sp * sp ; Scalar cp2 = cp * cp ; ( * dphi ) << 0.0 , ( cy * sp ) / cp2 , - sy / cp , 0.0 , 0.0 , - cy , 0.0 , cy + ( cy * sp2 ) / cp2 , - ( sp * sy ) / cp , 0.0 , ( sp * sy ) / cp2 , cy / cp , 0.0 , 0.0 , - sy , 0.0 , sy + ( sp2 * sy ) / cp2 , ( cy * sp ) / cp , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; if ( ddphi ) { ddphi -> resize ( dphi -> size ( ) , RPY_SIZE ) ; Scalar cp3 = cp2 * cp ; ( * ddphi ) << 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - ( cy * ( cp2 - 2.0 ) ) / cp3 , ( sp * sy ) / ( sp2 - 1.0 ) , 0.0 , 0.0 , 0.0 , 0.0 , ( 2.0 * cy * sp ) / cp3 , sy / ( sp2 - 1.0 ) , 0.0 , ( 2.0 * sy - cp2 * sy ) / cp3 , ( cy * sp ) / cp2 , 0.0 , 0.0 , 0.0 , 0.0 , ( 2.0 * sp * sy ) / cp3 , cy / cp2 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , ( sp * sy ) / ( sp2 - 1.0 ) , - cy / cp , 0.0 , 0.0 , sy , 0.0 , sy / ( sp2 - 1.0 ) , - ( cy * sp ) / cp , 0.0 , ( cy * sp ) / cp2 , - sy / cp , 0.0 , 0.0 , - cy , 0.0 , cy / cp2 , - ( sp * sy ) / cp , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; } } } template < typename Derived > DLLEXPORT GradientVar < typename Derived :: Scalar , Eigen :: Dynamic , SPACE_DIMENSION > angularvel2RepresentationDotMatrix ( int rotation_type , const Eigen :: MatrixBase < Derived > & qrot , int gradient_order ) { // ▁ note : ▁ gradients ▁ w . r . t . ▁ qrot ENDCOM GradientVar < typename Derived :: Scalar , Eigen :: Dynamic , SPACE_DIMENSION > ret ( qrot . rows ( ) , SPACE_DIMENSION , qrot . rows ( ) , gradient_order ) ; switch ( rotation_type ) { case 0 : // ▁ done ENDCOM break ; case 1 : { if ( gradient_order > 1 ) { angularvel2rpydotMatrix ( qrot , ret . value ( ) , & ret . gradient ( ) . value ( ) , & ret . gradient ( ) . gradient ( ) . value ( ) ) ; } else if ( gradient_order > 0 ) { angularvel2rpydotMatrix ( qrot , ret . value ( ) , & ret . gradient ( ) . value ( ) , ( MatrixXd * ) nullptr ) ; } else { angularvel2rpydotMatrix ( qrot , ret . value ( ) , ( MatrixXd * ) nullptr , ( MatrixXd * ) nullptr ) ; } break ; } case 2 : { if ( gradient_order > 1 ) { ret . gradient ( ) . gradient ( ) . value ( ) . setZero ( ) ; } if ( gradient_order > 0 ) { angularvel2quatdotMatrix ( qrot , ret . value ( ) , & ret . gradient ( ) . value ( ) ) ; } else { angularvel2quatdotMatrix ( qrot , ret . value ( ) , ( MatrixXd * ) nullptr ) ; } break ; } default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } return ret ; } template < typename DerivedRPY , typename DerivedE > void rpydot2angularvelMatrix ( const Eigen :: MatrixBase < DerivedRPY > & rpy , Eigen :: MatrixBase < DerivedE > & E , typename Gradient < DerivedE , RPY_SIZE , 1 > :: type * dE ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedRPY > , RPY_SIZE ) ; EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedE > , SPACE_DIMENSION , RPY_SIZE ) ; typedef typename DerivedRPY :: Scalar Scalar ; Scalar p = rpy ( 1 ) ; Scalar y = rpy ( 2 ) ; Scalar sp = sin ( p ) ; Scalar cp = cos ( p ) ; Scalar sy = sin ( y ) ; Scalar cy = cos ( y ) ; using namespace std ; E << cp * cy , - sy , 0.0 , cp * sy , cy , 0.0 , - sp , 0.0 , 1.0 ; if ( dE ) { ( * dE ) << 0.0 , - sp * cy , - cp * sy , 0.0 , - sp * sy , cp * cy , 0.0 , - cp , 0.0 , 0.0 , 0.0 , - cy , 0.0 , 0.0 , - sy , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; } } template < typename DerivedM > typename TransformSpatial < DerivedM > :: type transformSpatialMotion ( const Eigen :: Transform < typename DerivedM :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedM > & M ) { Eigen :: Matrix < typename DerivedM :: Scalar , TWIST_SIZE , DerivedM :: ColsAtCompileTime > ret ( TWIST_SIZE , M . cols ( ) ) ; ret . template topRows < 3 > ( ) . noalias ( ) = T . linear ( ) * M . template topRows < 3 > ( ) ; ret . template bottomRows < 3 > ( ) . noalias ( ) = - ret . template topRows < 3 > ( ) . colwise ( ) . cross ( T . translation ( ) ) ; ret . template bottomRows < 3 > ( ) . noalias ( ) += T . linear ( ) * M . template bottomRows < 3 > ( ) ; return ret ; } template < typename DerivedF > typename TransformSpatial < DerivedF > :: type transformSpatialForce ( const Eigen :: Transform < typename DerivedF :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedF > & F ) { Eigen :: Matrix < typename DerivedF :: Scalar , TWIST_SIZE , DerivedF :: ColsAtCompileTime > ret ( TWIST_SIZE , F . cols ( ) ) ; ret . template bottomRows < 3 > ( ) . noalias ( ) = T . linear ( ) * F . template bottomRows < 3 > ( ) . eval ( ) ; ret . template topRows < 3 > ( ) = - ret . template bottomRows < 3 > ( ) . colwise ( ) . cross ( T . translation ( ) ) ; ret . template topRows < 3 > ( ) . noalias ( ) += T . linear ( ) * F . template topRows < 3 > ( ) ; return ret ; } template < typename DerivedI > GradientVar < typename DerivedI :: Scalar , TWIST_SIZE , TWIST_SIZE > transformSpatialInertia ( const Eigen :: Transform < typename DerivedI :: Scalar , SPACE_DIMENSION , Eigen :: Isometry > & T_current_to_new , const typename Gradient < typename Eigen :: Transform < typename DerivedI :: Scalar , SPACE_DIMENSION , Eigen :: Isometry > :: MatrixType , Eigen :: Dynamic > :: type * dT_current_to_new , const Eigen :: MatrixBase < DerivedI > & I ) { int gradient_order ; typename DerivedI :: Index nq ; if ( dT_current_to_new ) { gradient_order = 1 ; nq = dT_current_to_new -> cols ( ) ; } else { nq = 0 ; gradient_order = 0 ; } GradientVar < typename DerivedI :: Scalar , TWIST_SIZE , TWIST_SIZE > ret ( TWIST_SIZE , TWIST_SIZE , nq , gradient_order ) ; auto I_half_transformed = transformSpatialForce ( T_current_to_new , I ) ; ret . value ( ) = transformSpatialForce ( T_current_to_new , I_half_transformed . transpose ( ) ) ; if ( gradient_order > 0 ) { auto dI = Eigen :: Matrix < typename DerivedI :: Scalar , DerivedI :: SizeAtCompileTime , Eigen :: Dynamic > :: Zero ( I . size ( ) , nq ) . eval ( ) ; // ▁ TODO : ▁ would ▁ be ▁ better ▁ not ▁ to ▁ evaluate ▁ and ▁ make ▁ another ▁ explicit ▁ instantiation ENDCOM auto dI_half_transformed = dTransformSpatialForce ( T_current_to_new , I , * dT_current_to_new , dI ) ; auto dI_half_transformed_transpose = transposeGrad ( dI_half_transformed , I_half_transformed . rows ( ) ) ; ret . gradient ( ) . value ( ) = dTransformSpatialForce ( T_current_to_new , I_half_transformed . transpose ( ) , * dT_current_to_new , dI_half_transformed_transpose ) ; } return ret ; } template < typename DerivedA , typename DerivedB > typename TransformSpatial < DerivedB > :: type crossSpatialMotion ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b ) { typename TransformSpatial < DerivedB > :: type ret ( TWIST_SIZE , b . cols ( ) ) ; ret . template topRows < 3 > ( ) = - b . template topRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; ret . template bottomRows < 3 > ( ) = - b . template topRows < 3 > ( ) . colwise ( ) . cross ( a . template bottomRows < 3 > ( ) ) ; ret . template bottomRows < 3 > ( ) -= b . template bottomRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; return ret ; } template < typename DerivedA , typename DerivedB > typename TransformSpatial < DerivedB > :: type crossSpatialForce ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b ) { typename TransformSpatial < DerivedB > :: type ret ( TWIST_SIZE , b . cols ( ) ) ; ret . template topRows < 3 > ( ) = - b . template topRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; ret . template topRows < 3 > ( ) -= b . template bottomRows < 3 > ( ) . colwise ( ) . cross ( a . template bottomRows < 3 > ( ) ) ; ret . template bottomRows < 3 > ( ) = - b . template bottomRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; return ret ; } template < typename DerivedA , typename DerivedB > Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > dCrossSpatialMotion ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b , const typename Gradient < DerivedA , Eigen :: Dynamic > :: type & da , const typename Gradient < DerivedB , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > ret ( TWIST_SIZE , da . cols ( ) ) ; ret . row ( 0 ) = - da . row ( 2 ) * b [ 1 ] + da . row ( 1 ) * b [ 2 ] - a [ 2 ] * db . row ( 1 ) + a [ 1 ] * db . row ( 2 ) ; ret . row ( 1 ) = da . row ( 2 ) * b [ 0 ] - da . row ( 0 ) * b [ 2 ] + a [ 2 ] * db . row ( 0 ) - a [ 0 ] * db . row ( 2 ) ; ret . row ( 2 ) = - da . row ( 1 ) * b [ 0 ] + da . row ( 0 ) * b [ 1 ] - a [ 1 ] * db . row ( 0 ) + a [ 0 ] * db . row ( 1 ) ; ret . row ( 3 ) = - da . row ( 5 ) * b [ 1 ] + da . row ( 4 ) * b [ 2 ] - da . row ( 2 ) * b [ 4 ] + da . row ( 1 ) * b [ 5 ] - a [ 5 ] * db . row ( 1 ) + a [ 4 ] * db . row ( 2 ) - a [ 2 ] * db . row ( 4 ) + a [ 1 ] * db . row ( 5 ) ; ret . row ( 4 ) = da . row ( 5 ) * b [ 0 ] - da . row ( 3 ) * b [ 2 ] + da . row ( 2 ) * b [ 3 ] - da . row ( 0 ) * b [ 5 ] + a [ 5 ] * db . row ( 0 ) - a [ 3 ] * db . row ( 2 ) + a [ 2 ] * db . row ( 3 ) - a [ 0 ] * db . row ( 5 ) ; ret . row ( 5 ) = - da . row ( 4 ) * b [ 0 ] + da . row ( 3 ) * b [ 1 ] - da . row ( 1 ) * b [ 3 ] + da . row ( 0 ) * b [ 4 ] - a [ 4 ] * db . row ( 0 ) + a [ 3 ] * db . row ( 1 ) - a [ 1 ] * db . row ( 3 ) + a [ 0 ] * db . row ( 4 ) ; return ret ; } template < typename DerivedA , typename DerivedB > Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > dCrossSpatialForce ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b , const typename Gradient < DerivedA , Eigen :: Dynamic > :: type & da , const typename Gradient < DerivedB , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > ret ( TWIST_SIZE , da . cols ( ) ) ; ret . row ( 0 ) = da . row ( 2 ) * b [ 1 ] - da . row ( 1 ) * b [ 2 ] + da . row ( 5 ) * b [ 4 ] - da . row ( 4 ) * b [ 5 ] + a [ 2 ] * db . row ( 1 ) - a [ 1 ] * db . row ( 2 ) + a [ 5 ] * db . row ( 4 ) - a [ 4 ] * db . row ( 5 ) ; ret . row ( 1 ) = - da . row ( 2 ) * b [ 0 ] + da . row ( 0 ) * b [ 2 ] - da . row ( 5 ) * b [ 3 ] + da . row ( 3 ) * b [ 5 ] - a [ 2 ] * db . row ( 0 ) + a [ 0 ] * db . row ( 2 ) - a [ 5 ] * db . row ( 3 ) + a [ 3 ] * db . row ( 5 ) ; ret . row ( 2 ) = da . row ( 1 ) * b [ 0 ] - da . row ( 0 ) * b [ 1 ] + da . row ( 4 ) * b [ 3 ] - da . row ( 3 ) * b [ 4 ] + a [ 1 ] * db . row ( 0 ) - a [ 0 ] * db . row ( 1 ) + a [ 4 ] * db . row ( 3 ) - a [ 3 ] * db . row ( 4 ) ; ret . row ( 3 ) = da . row ( 2 ) * b [ 4 ] - da . row ( 1 ) * b [ 5 ] + a [ 2 ] * db . row ( 4 ) - a [ 1 ] * db . row ( 5 ) ; ret . row ( 4 ) = - da . row ( 2 ) * b [ 3 ] + da . row ( 0 ) * b [ 5 ] - a [ 2 ] * db . row ( 3 ) + a [ 0 ] * db . row ( 5 ) ; ret . row ( 5 ) = da . row ( 1 ) * b [ 3 ] - da . row ( 0 ) * b [ 4 ] + a [ 1 ] * db . row ( 3 ) - a [ 0 ] * db . row ( 4 ) ; ret = - ret ; return ret ; } template < typename DerivedS , typename DerivedQdotToV > typename DHomogTrans < DerivedQdotToV > :: type dHomogTrans ( const Eigen :: Transform < typename DerivedQdotToV :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedS > & S , const Eigen :: MatrixBase < DerivedQdotToV > & qdot_to_v ) { const int nq_at_compile_time = DerivedQdotToV :: ColsAtCompileTime ; typename DerivedQdotToV :: Index nq = qdot_to_v . cols ( ) ; auto qdot_to_twist = ( S * qdot_to_v ) . eval ( ) ; const int numel = HOMOGENEOUS_TRANSFORM_SIZE ; Eigen :: Matrix < typename DerivedQdotToV :: Scalar , numel , nq_at_compile_time > ret ( numel , nq ) ; const auto & Rx = T . linear ( ) . col ( 0 ) ; const auto & Ry = T . linear ( ) . col ( 1 ) ; const auto & Rz = T . linear ( ) . col ( 2 ) ; const auto & qdot_to_omega_x = qdot_to_twist . row ( 0 ) ; const auto & qdot_to_omega_y = qdot_to_twist . row ( 1 ) ; const auto & qdot_to_omega_z = qdot_to_twist . row ( 2 ) ; ret . template middleRows < 3 > ( 0 ) = - Rz * qdot_to_omega_y + Ry * qdot_to_omega_z ; ret . row ( 3 ) . setZero ( ) ; ret . template middleRows < 3 > ( 4 ) = Rz * qdot_to_omega_x - Rx * qdot_to_omega_z ; ret . row ( 7 ) . setZero ( ) ; ret . template middleRows < 3 > ( 8 ) = - Ry * qdot_to_omega_x + Rx * qdot_to_omega_y ; ret . row ( 11 ) . setZero ( ) ; ret . template middleRows < 3 > ( 12 ) = T . linear ( ) * qdot_to_twist . bottomRows ( 3 ) ; ret . row ( 15 ) . setZero ( ) ; return ret ; } template < typename DerivedDT > typename DHomogTrans < DerivedDT > :: type dHomogTransInv ( const Eigen :: Transform < typename DerivedDT :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedDT > & dT ) { typename DerivedDT :: Index nq = dT . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_cols = { 3 } ; auto dR = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , R_cols , T . Rows ) ; auto dp = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , p_cols , T . Rows ) ; auto dinvT_R = transposeGrad ( dR , R . rows ( ) ) ; auto dinvT_p = ( - R . transpose ( ) * dp - matGradMult ( dinvT_R , p ) ) . eval ( ) ; const int numel = HOMOGENEOUS_TRANSFORM_SIZE ; Eigen :: Matrix < typename DerivedDT :: Scalar , numel , DerivedDT :: ColsAtCompileTime > ret ( numel , nq ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dinvT_R , rows , R_cols , T . Rows ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dinvT_p , rows , p_cols , T . Rows ) ; // ▁ zero ▁ out ▁ gradient ▁ of ▁ elements ▁ in ▁ last ▁ row : ENDCOM const int last_row = 3 ; for ( int col = 0 ; col < T . HDim ; col ++ ) { ret . row ( last_row + col * T . Rows ) . setZero ( ) ; } return ret ; } template < typename Scalar , typename DerivedX , typename DerivedDT , typename DerivedDX > typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime , 1 > :: type dTransformSpatialMotion ( const Eigen :: Transform < Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedX > & X , const Eigen :: MatrixBase < DerivedDT > & dT , const Eigen :: MatrixBase < DerivedDX > & dX ) { assert ( dT . cols ( ) == dX . cols ( ) ) ; typename DerivedDT :: Index nq = dT . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_cols = { 3 } ; auto dR = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , R_cols , T . Rows ) ; auto dp = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , p_cols , T . Rows ) ; typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime , 1 > :: type ret ( X . size ( ) , nq ) ; std :: array < int , 3 > Xomega_rows = { 0 , 1 , 2 } ; std :: array < int , 3 > Xv_rows = { 3 , 4 , 5 } ; for ( int col = 0 ; col < X . cols ( ) ; col ++ ) { auto Xomega_col = X . template block < 3 , 1 > ( 0 , col ) ; auto Xv_col = X . template block < 3 , 1 > ( 3 , col ) ; auto RXomega_col = ( R * Xomega_col ) . eval ( ) ; std :: array < int , 1 > col_array = { col } ; auto dXomega_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xomega_rows , col_array , X . rows ( ) ) ; auto dXv_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xv_rows , col_array , X . rows ( ) ) ; auto domega_part_col = ( R * dXomega_col + matGradMult ( dR , Xomega_col ) ) . eval ( ) ; auto dv_part_col = ( R * dXv_col + matGradMult ( dR , Xv_col ) ) . eval ( ) ; dv_part_col += dp . colwise ( ) . cross ( RXomega_col ) ; dv_part_col -= domega_part_col . colwise ( ) . cross ( p ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , domega_part_col , Xomega_rows , col_array , X . rows ( ) ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dv_part_col , Xv_rows , col_array , X . rows ( ) ) ; } return ret ; } template < typename Scalar , typename DerivedX , typename DerivedDT , typename DerivedDX > typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime > :: type dTransformSpatialForce ( const Eigen :: Transform < Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedX > & X , const Eigen :: MatrixBase < DerivedDT > & dT , const Eigen :: MatrixBase < DerivedDX > & dX ) { assert ( dT . cols ( ) == dX . cols ( ) ) ; typename DerivedDT :: Index nq = dT . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_cols = { 3 } ; auto dR = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , R_cols , T . Rows ) ; auto dp = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , p_cols , T . Rows ) ; typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime > :: type ret ( X . size ( ) , nq ) ; std :: array < int , 3 > Xomega_rows = { 0 , 1 , 2 } ; std :: array < int , 3 > Xv_rows = { 3 , 4 , 5 } ; for ( int col = 0 ; col < X . cols ( ) ; col ++ ) { auto Xomega_col = X . template block < 3 , 1 > ( 0 , col ) ; auto Xv_col = X . template block < 3 , 1 > ( 3 , col ) ; auto RXv_col = ( R * Xv_col ) . eval ( ) ; std :: array < int , 1 > col_array = { col } ; auto dXomega_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xomega_rows , col_array , X . rows ( ) ) ; auto dXv_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xv_rows , col_array , X . rows ( ) ) ; auto domega_part_col = ( R * dXomega_col ) . eval ( ) ; domega_part_col += matGradMult ( dR , Xomega_col ) ; auto dv_part_col = ( R * dXv_col ) . eval ( ) ; dv_part_col += matGradMult ( dR , Xv_col ) ; domega_part_col += dp . colwise ( ) . cross ( RXv_col ) ; domega_part_col -= dv_part_col . colwise ( ) . cross ( p ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , domega_part_col , Xomega_rows , col_array , X . rows ( ) ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dv_part_col , Xv_rows , col_array , X . rows ( ) ) ; } return ret ; } template < typename Scalar > DLLEXPORT void cylindrical2cartesian ( const Matrix < Scalar , 3 , 1 > & m_cylinder_axis , const Matrix < Scalar , 3 , 1 > & m_cylinder_x_dir , const Matrix < Scalar , 3 , 1 > & cylinder_origin , const Matrix < Scalar , 6 , 1 > & x_cylinder , const Matrix < Scalar , 6 , 1 > & v_cylinder , Matrix < Scalar , 6 , 1 > & x_cartesian , Matrix < Scalar , 6 , 1 > & v_cartesian , Matrix < Scalar , 6 , 6 > & J , Matrix < Scalar , 6 , 1 > & Jdotv ) { Matrix < Scalar , 3 , 1 > cylinder_axis = m_cylinder_axis / m_cylinder_axis . norm ( ) ; Matrix < Scalar , 3 , 1 > cylinder_x_dir = m_cylinder_x_dir / m_cylinder_x_dir . norm ( ) ; Matrix < Scalar , 3 , 3 > R_cylinder2cartesian ; R_cylinder2cartesian . col ( 0 ) = cylinder_x_dir ; R_cylinder2cartesian . col ( 1 ) = cylinder_axis . cross ( cylinder_x_dir ) ; R_cylinder2cartesian . col ( 2 ) = cylinder_axis ; double radius = x_cylinder ( 0 ) ; double theta = x_cylinder ( 1 ) ; double c_theta = cos ( theta ) ; double s_theta = sin ( theta ) ; double height = x_cylinder ( 2 ) ; double radius_dot = v_cylinder ( 0 ) ; double theta_dot = v_cylinder ( 1 ) ; double height_dot = v_cylinder ( 2 ) ; Matrix < Scalar , 3 , 1 > x_pos_cartesian ; x_pos_cartesian << radius * c_theta , radius * s_theta , height ; x_pos_cartesian = R_cylinder2cartesian * x_pos_cartesian + cylinder_origin ; Matrix < Scalar , 3 , 1 > v_pos_cartesian ; v_pos_cartesian << radius * - s_theta * theta_dot + radius_dot * c_theta , radius * c_theta * theta_dot + radius_dot * s_theta , height_dot ; v_pos_cartesian = R_cylinder2cartesian * v_pos_cartesian ; Vector3d x_rpy_cylinder = x_cylinder . block ( 3 , 0 , 3 , 1 ) ; Matrix < Scalar , 3 , 3 > R_tangent = rpy2rotmat ( x_rpy_cylinder ) ; Matrix < Scalar , 3 , 3 > R_tangent2cylinder ; Matrix < Scalar , 3 , 3 > dR_tangent2cylinder ; Matrix < Scalar , 3 , 3 > ddR_tangent2cylinder ; rotz ( theta - M_PI / 2 , R_tangent2cylinder , dR_tangent2cylinder , ddR_tangent2cylinder ) ; Matrix < Scalar , 3 , 3 > dR_tangent2cylinder_dtheta = dR_tangent2cylinder ; Matrix < Scalar , 3 , 3 > R_cylinder = R_tangent2cylinder * R_tangent ; Matrix < Scalar , 3 , 3 > R_cartesian = R_cylinder2cartesian * R_cylinder ; Matrix < Scalar , 3 , 1 > x_rpy_cartesian = rotmat2rpy ( R_cartesian ) ; x_cartesian . block ( 0 , 0 , 3 , 1 ) = x_pos_cartesian ; x_cartesian . block ( 3 , 0 , 3 , 1 ) = x_rpy_cartesian ; v_cartesian . block ( 0 , 0 , 3 , 1 ) = v_pos_cartesian ; v_cartesian . block ( 3 , 0 , 3 , 1 ) = theta_dot * R_cylinder2cartesian . col ( 2 ) + R_cylinder2cartesian * R_tangent2cylinder * v_cylinder . block ( 3 , 0 , 3 , 1 ) ; J = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; J . block ( 0 , 0 , 3 , 1 ) << c_theta , s_theta , 0 ; J . block ( 0 , 1 , 3 , 1 ) << radius * - s_theta , radius * c_theta , 0 ; J . block ( 0 , 2 , 3 , 1 ) << 0 , 0 , 1 ; J . block ( 0 , 0 , 3 , 3 ) = R_cylinder2cartesian * J . block ( 0 , 0 , 3 , 3 ) ; J . block ( 3 , 1 , 3 , 1 ) = R_cylinder2cartesian . col ( 2 ) ; J . block ( 3 , 3 , 3 , 3 ) = R_cylinder2cartesian * R_tangent2cylinder ; Matrix < Scalar , 3 , 3 > dJ1_dradius = Matrix < Scalar , 3 , 3 > :: Zero ( ) ; dJ1_dradius ( 0 , 1 ) = - s_theta ; dJ1_dradius ( 1 , 1 ) = c_theta ; Matrix < Scalar , 3 , 3 > dJ1_dtheta = Matrix < Scalar , 3 , 3 > :: Zero ( ) ; dJ1_dtheta ( 0 , 0 ) = - s_theta ; dJ1_dtheta ( 0 , 1 ) = - radius * c_theta ; dJ1_dtheta ( 1 , 0 ) = c_theta ; dJ1_dtheta ( 1 , 1 ) = - radius * s_theta ; Jdotv . block ( 0 , 0 , 3 , 1 ) = R_cylinder2cartesian * ( dJ1_dradius * radius_dot + dJ1_dtheta * theta_dot ) * v_cylinder . block ( 0 , 0 , 3 , 1 ) ; Jdotv . block ( 3 , 0 , 3 , 1 ) = R_cylinder2cartesian * dR_tangent2cylinder_dtheta * theta_dot * v_cylinder . block ( 3 , 0 , 3 , 1 ) ; } template < typename Scalar > DLLEXPORT void cartesian2cylindrical ( const Eigen :: Matrix < Scalar , 3 , 1 > & m_cylinder_axis , const Eigen :: Matrix < Scalar , 3 , 1 > & m_cylinder_x_dir , const Eigen :: Matrix < Scalar , 3 , 1 > & cylinder_origin , const Eigen :: Matrix < Scalar , 6 , 1 > & x_cartesian , const Eigen :: Matrix < Scalar , 6 , 1 > & v_cartesian , Eigen :: Matrix < Scalar , 6 , 1 > & x_cylinder , Eigen :: Matrix < Scalar , 6 , 1 > & v_cylinder , Eigen :: Matrix < Scalar , 6 , 6 > & J , Eigen :: Matrix < Scalar , 6 , 1 > & Jdotv ) { Matrix < Scalar , 3 , 1 > cylinder_axis = m_cylinder_axis / m_cylinder_axis . norm ( ) ; Matrix < Scalar , 3 , 1 > cylinder_x_dir = m_cylinder_x_dir / m_cylinder_x_dir . norm ( ) ; Matrix < Scalar , 3 , 3 > R_cylinder2cartesian ; R_cylinder2cartesian . col ( 0 ) = cylinder_x_dir ; R_cylinder2cartesian . col ( 1 ) = cylinder_axis . cross ( cylinder_x_dir ) ; R_cylinder2cartesian . col ( 2 ) = cylinder_axis ; Matrix < Scalar , 3 , 3 > R_cartesian2cylinder = R_cylinder2cartesian . transpose ( ) ; Matrix < Scalar , 3 , 1 > x_pos_cylinder = R_cartesian2cylinder * ( x_cartesian . block ( 0 , 0 , 3 , 1 ) - cylinder_origin ) ; Matrix < Scalar , 3 , 1 > v_pos_cylinder = R_cartesian2cylinder * v_cartesian . block ( 0 , 0 , 3 , 1 ) ; double radius = sqrt ( pow ( x_pos_cylinder ( 0 ) , 2 ) + pow ( x_pos_cylinder ( 1 ) , 2 ) ) ; double radius_dot = ( x_pos_cylinder ( 0 ) * v_pos_cylinder ( 0 ) + x_pos_cylinder ( 1 ) * v_pos_cylinder ( 1 ) ) / radius ; double theta = atan2 ( x_pos_cylinder ( 1 ) , x_pos_cylinder ( 0 ) ) ; double radius_square = pow ( radius , 2 ) ; double radius_cubic = pow ( radius , 3 ) ; double radius_quad = pow ( radius , 4 ) ; double theta_dot = ( - x_pos_cylinder ( 1 ) * v_pos_cylinder ( 0 ) + x_pos_cylinder ( 0 ) * v_pos_cylinder ( 1 ) ) / radius_square ; double height = x_pos_cylinder ( 2 ) ; double height_dot = v_pos_cylinder ( 2 ) ; x_cylinder ( 0 ) = radius ; x_cylinder ( 1 ) = theta ; x_cylinder ( 2 ) = height ; v_cylinder ( 0 ) = radius_dot ; v_cylinder ( 1 ) = theta_dot ; v_cylinder ( 2 ) = height_dot ; Matrix < Scalar , 3 , 3 > R_tangent2cylinder ; Matrix < Scalar , 3 , 3 > dR_tangent2cylinder ; Matrix < Scalar , 3 , 3 > ddR_tangent2cylinder ; rotz ( theta - M_PI / 2 , R_tangent2cylinder , dR_tangent2cylinder , ddR_tangent2cylinder ) ; Matrix < Scalar , 3 , 3 > R_cylinder2tangent = R_tangent2cylinder . transpose ( ) ; Vector3d x_rpy_cartesian = x_cartesian . block ( 3 , 0 , 3 , 1 ) ; Matrix < Scalar , 3 , 3 > R_cartesian = rpy2rotmat ( x_rpy_cartesian ) ; x_cylinder . block ( 3 , 0 , 3 , 1 ) = rotmat2rpy ( R_cylinder2tangent * R_cartesian2cylinder * R_cartesian ) ; J = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; Matrix < Scalar , 6 , 6 > Jdot = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; J ( 0 , 0 ) = x_pos_cylinder ( 0 ) / radius ; J ( 0 , 1 ) = x_pos_cylinder ( 1 ) / radius ; J ( 1 , 0 ) = - x_pos_cylinder ( 1 ) / radius_square ; J ( 1 , 1 ) = x_pos_cylinder ( 0 ) / radius_square ; J ( 2 , 2 ) = 1.0 ; J . block ( 0 , 0 , 3 , 3 ) = J . block ( 0 , 0 , 3 , 3 ) * R_cartesian2cylinder ; Jdot ( 0 , 0 ) = pow ( x_pos_cylinder ( 1 ) , 2 ) / radius_cubic * v_pos_cylinder ( 0 ) - x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_cubic * v_pos_cylinder ( 1 ) ; Jdot ( 0 , 1 ) = - x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_cubic * v_pos_cylinder ( 0 ) + pow ( x_pos_cylinder ( 0 ) , 2 ) / radius_cubic * v_pos_cylinder ( 1 ) ; Jdot ( 1 , 0 ) = 2 * x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_quad * v_pos_cylinder ( 0 ) + ( pow ( x_pos_cylinder ( 1 ) , 2 ) - pow ( x_pos_cylinder ( 0 ) , 2 ) ) / radius_quad * v_pos_cylinder ( 1 ) ; Jdot ( 1 , 1 ) = ( pow ( x_pos_cylinder ( 1 ) , 2 ) - pow ( x_pos_cylinder ( 0 ) , 2 ) ) / radius_quad * v_pos_cylinder ( 0 ) - 2 * x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_quad * v_pos_cylinder ( 1 ) ; Jdot . block ( 0 , 0 , 3 , 3 ) = Jdot . block ( 0 , 0 , 3 , 3 ) * R_cartesian2cylinder ; v_cylinder . block ( 3 , 0 , 3 , 1 ) = R_cylinder2tangent * R_cartesian2cylinder * v_cartesian . block ( 3 , 0 , 3 , 1 ) - theta_dot * R_cylinder2tangent . col ( 2 ) ; J . block ( 3 , 0 , 3 , 3 ) = R_cylinder2tangent . col ( 2 ) * - J . block ( 1 , 0 , 1 , 3 ) ; J . block ( 3 , 3 , 3 , 3 ) = R_cylinder2tangent * R_cartesian2cylinder ; Jdot . block ( 3 , 0 , 3 , 3 ) = dR_tangent2cylinder . row ( 2 ) . transpose ( ) * - J . block ( 1 , 0 , 1 , 3 ) * theta_dot + R_cylinder2tangent . col ( 2 ) * - Jdot . block ( 1 , 0 , 1 , 3 ) ; Jdot . block ( 3 , 3 , 3 , 3 ) = dR_tangent2cylinder . transpose ( ) * theta_dot * R_cartesian2cylinder ; Jdotv = Jdot * v_cartesian ; } DLLEXPORT GradientVar < double , 3 , 1 > quat2expmap ( const Ref < const Vector4d > & q , int gradient_order ) { double t = sqrt ( 1 - q ( 0 ) * q ( 0 ) ) ; bool is_degenerate = ( t * t < std :: numeric_limits < double > :: epsilon ( ) ) ; double s = is_degenerate ? 2.0 : 2.0 * acos ( q ( 0 ) ) / t ; GradientVar < double , 3 , 1 > ret ( 3 , 1 , 4 , gradient_order ) ; ret . value ( ) = s * q . tail ( 3 ) ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = Matrix < double , 3 , 4 > :: Zero ( ) ; double dsdq1 = is_degenerate ? 0.0 : ( - 2 * t + 2 * acos ( q ( 0 ) ) * q ( 0 ) ) / pow ( t , 3 ) ; ret . gradient ( ) . value ( ) . col ( 0 ) = q . tail ( 3 ) * dsdq1 ; ret . gradient ( ) . value ( ) . block ( 0 , 1 , 3 , 3 ) = Matrix3d :: Identity ( ) * s ; } else if ( gradient_order > 1 ) { throw std :: runtime_error ( " gradient _ order > 1 ▁ is ▁ not ▁ supported ▁ in ▁ quat2expmap " ) ; } return ret ; } DLLEXPORT GradientVar < double , 3 , 1 > flipExpmap ( const Ref < const Vector3d > & expmap , int gradient_order ) { if ( gradient_order > 1 ) { throw std :: runtime_error ( " gradient _ order > 1 ▁ is ▁ not ▁ supported ▁ in ▁ flipExpmap " ) ; } double expmap_norm = expmap . norm ( ) ; bool is_degenerate = ( expmap_norm < std :: numeric_limits < double > :: epsilon ( ) ) ; GradientVar < double , 3 , 1 > ret ( 3 , 1 , 3 , gradient_order ) ; Matrix3d eye3 = Matrix3d :: Identity ( ) ; if ( is_degenerate ) { ret . value ( ) = expmap ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = eye3 ; } } else { ret . value ( ) = expmap - expmap / expmap_norm * 2 * M_PI ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = eye3 - ( expmap_norm * expmap_norm * eye3 - expmap * expmap . transpose ( ) ) / pow ( expmap_norm , 3 ) * 2 * M_PI ; } } return ret ; } DLLEXPORT GradientVar < double , 3 , 1 > unwrapExpmap ( const Ref < const Vector3d > & expmap1 , const Ref < const Vector3d > & expmap2 , int gradient_order ) { auto expmap2_flip = flipExpmap ( expmap2 , gradient_order ) ; double distance1 = ( expmap1 - expmap2 ) . squaredNorm ( ) ; double distance2 = ( expmap1 - expmap2_flip . value ( ) ) . squaredNorm ( ) ; if ( distance1 > distance2 ) { return expmap2_flip ; } else { GradientVar < double , 3 , 1 > ret ( 3 , 1 , 3 , gradient_order ) ; ret . value ( ) = expmap2 ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) ; } return ret ; } } void quat2expmapSequence ( const Ref < const Matrix < double , 4 , Dynamic >> & quat , const Ref < const Matrix < double , 4 , Dynamic >> & quat_dot , Ref < Matrix < double , 3 , Dynamic >> expmap , Ref < Matrix < double , 3 , Dynamic >> expmap_dot ) { DenseIndex N = quat . cols ( ) ; if ( quat_dot . cols ( ) != N ) { throw std :: runtime_error ( " quat _ dot ▁ must ▁ have ▁ the ▁ same ▁ number ▁ of ▁ columns ▁ as ▁ quat ▁ in ▁ quat2expmapSequence " ) ; } expmap . resize ( 3 , N ) ; expmap_dot . resize ( 3 , N ) ; for ( int i = 0 ; i < N ; i ++ ) { auto expmap_grad = quat2expmap ( quat . col ( i ) , 1 ) ; expmap . col ( i ) = expmap_grad . value ( ) ; expmap_dot . col ( i ) = expmap_grad . gradient ( ) . value ( ) * quat_dot . col ( i ) ; if ( i >= 1 ) { auto closest_grad = closestExpmap ( expmap . col ( i - 1 ) , expmap . col ( i ) , 1 ) ; expmap . col ( i ) = closest_grad . value ( ) ; expmap_dot . col ( i ) = closest_grad . gradient ( ) . value ( ) * expmap_dot . col ( i ) ; } } } DLLEXPORT GradientVar < double , 3 , 1 > closestExpmap ( const Ref < const Vector3d > & expmap1 , const Ref < const Vector3d > & expmap2 , int gradient_order ) { if ( gradient_order > 1 ) { throw std :: runtime_error ( " closestExpmap ▁ only ▁ supports ▁ first ▁ order ▁ gradient " ) ; } double expmap1_norm = expmap1 . norm ( ) ; double expmap2_norm = expmap2 . norm ( ) ; GradientVar < double , 3 , 1 > ret ( 3 , 1 , 3 , gradient_order ) ; if ( expmap2_norm < std :: numeric_limits < double > :: epsilon ( ) ) { if ( expmap1_norm > std :: numeric_limits < double > :: epsilon ( ) ) { Vector3d expmap1_axis = expmap1 / expmap1_norm ; int expmap1_round = static_cast < int > ( expmap1_norm / ( 2 * M_PI ) + 0.5 ) ; ret . value ( ) = expmap1_axis * expmap1_round * 2 * M_PI ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Zero ( ) ; } return ret ; } else { ret . value ( ) = expmap2 ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) ; } } } else { Vector3d expmap2_axis = expmap2 / expmap2_norm ; Matrix3d dexpmap2_axis_dexpmap2 = ( expmap2_norm * Matrix3d :: Identity ( ) - expmap2 * expmap2 . transpose ( ) / expmap2_norm ) / pow ( expmap2_norm , 2 ) ; double expmap2_closest_k = ( expmap2_axis . transpose ( ) * expmap1 - expmap2_norm ) / ( 2 * M_PI ) ; int expmap2_closest_k1 ; int expmap2_closest_k2 ; if ( expmap2_closest_k > 0 ) { expmap2_closest_k1 = ( int ) expmap2_closest_k ; } else { expmap2_closest_k1 = ( int ) expmap2_closest_k - 1 ; } expmap2_closest_k2 = expmap2_closest_k1 + 1 ; Vector3d expmap2_closest1 = expmap2 + 2 * expmap2_closest_k1 * M_PI * expmap2_axis ; Vector3d expmap2_closest2 = expmap2 + 2 * expmap2_closest_k2 * M_PI * expmap2_axis ; if ( ( expmap2_closest1 - expmap1 ) . norm ( ) < ( expmap2_closest2 - expmap1 ) . norm ( ) ) { ret . value ( ) = expmap2_closest1 ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) + 2 * dexpmap2_axis_dexpmap2 * ( double ) expmap2_closest_k1 * M_PI ; } return ret ; } else { ret . value ( ) = expmap2_closest2 ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) + 2 * dexpmap2_axis_dexpmap2 * ( double ) expmap2_closest_k2 * M_PI ; } return ret ; } } return ret ; } // ▁ explicit ▁ instantiations ENDCOM template DLLEXPORT void normalizeVec ( const MatrixBase < Vector3d > & x , Vector3d & x_norm , Gradient < Vector3d , 3 , 1 > :: type * , Gradient < Vector3d , 3 , 2 > :: type * ) ; template DLLEXPORT void normalizeVec ( const MatrixBase < Vector4d > & x , Vector4d & x_norm , Gradient < Vector4d , 4 , 1 > :: type * , Gradient < Vector4d , 4 , 2 > :: type * ) ; template DLLEXPORT void normalizeVec ( const MatrixBase < Map < Vector4d > > & x , Vector4d & x_norm , Gradient < Vector4d , 4 , 1 > :: type * , Gradient < Vector4d , 4 , 2 > :: type * ) ; template DLLEXPORT void normalizeVec ( const MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 4 , 1 , false > > & x , Vector4d & x_norm , Gradient < Vector4d , 4 , 1 > :: type * , Gradient < Vector4d , 4 , 2 > :: type * ) ; template DLLEXPORT Vector4d quat2axis ( const MatrixBase < Vector4d > & ) ; template DLLEXPORT Matrix3d quat2rotmat ( const MatrixBase < Vector4d > & q ) ; template DLLEXPORT Matrix3d quat2rotmat ( const MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 4 , 1 , false > > & q ) ; template DLLEXPORT Matrix < Map < Matrix < double , 4 , 1 , 0 , 4 , 1 > const , 0 , Stride < 0 , 0 > > :: Scalar , 3 , 3 , 0 , 3 , 3 > quat2rotmat < Map < Matrix < double , 4 , 1 , 0 , 4 , 1 > const , 0 , Stride < 0 , 0 > > > ( MatrixBase < Map < Matrix < double , 4 , 1 , 0 , 4 , 1 > const , 0 , Stride < 0 , 0 > > > const & ) ; template DLLEXPORT Vector3d quat2rpy ( const MatrixBase < Vector4d > & ) ; template DLLEXPORT Vector4d axis2quat ( const MatrixBase < Vector4d > & ) ; template DLLEXPORT Matrix3d axis2rotmat ( const MatrixBase < Vector4d > & ) ; template DLLEXPORT Vector3d axis2rpy ( const MatrixBase < Vector4d > & ) ; template DLLEXPORT Vector4d rotmat2axis ( const MatrixBase < Matrix3d > & ) ; template DLLEXPORT Vector4d rotmat2quat ( const MatrixBase < Matrix3d > & ) ; template DLLEXPORT Vector3d rotmat2rpy ( const MatrixBase < Matrix3d > & ) ; template DLLEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Matrix < double , 4 , 4 , 0 , 4 , 4 > , 3 , 3 , false > :: Scalar , - 1 , 1 , 0 , - 1 , 1 > rotmat2Representation < Eigen :: Block < Eigen :: Matrix < double , 4 , 4 , 0 , 4 , 4 > , 3 , 3 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 4 , 4 , 0 , 4 , 4 > , 3 , 3 , false > > const & , int ) ; template DLLEXPORT GradientVar < double , Eigen :: Dynamic , 1 > rotmat2Representation ( const GradientVar < double , SPACE_DIMENSION , SPACE_DIMENSION > & R , int rotation_type ) ; template DLLEXPORT GradientVar < double , QUAT_SIZE , 1 > expmap2quat ( const MatrixBase < Vector3d > & v , const int gradient_order ) ; template DLLEXPORT GradientVar < double , QUAT_SIZE , 1 > expmap2quat ( const MatrixBase < Map < Vector3d >> & v , const int gradient_order ) ; template DLLEXPORT GradientVar < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > :: Scalar , 4 , 1 > expmap2quat < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > > const & , int ) ; template DLLEXPORT Vector4d rpy2axis ( const Eigen :: MatrixBase < Vector3d > & ) ; template DLLEXPORT Vector4d rpy2quat ( const Eigen :: MatrixBase < Vector3d > & ) ; template DLLEXPORT Matrix3d rpy2rotmat ( const Eigen :: MatrixBase < Vector3d > & ) ; template DLLEXPORT Matrix3d rpy2rotmat ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 3 , 1 , false >> & ) ; template DLLEXPORT Matrix < double , 9 , 3 > drpy2rotmat ( const Eigen :: MatrixBase < Vector3d > & ) ; template DLLEXPORT Matrix < double , 9 , 3 > drpy2rotmat ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 3 , 1 , false >> & ) ; template DLLEXPORT Vector4d quat2axis ( const MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Matrix3d quat2rotmat ( const MatrixBase < Map < Vector4d > > & q ) ; template DLLEXPORT Vector3d quat2rpy ( const MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Vector4d axis2quat ( const MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Matrix3d axis2rotmat ( const MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Vector3d axis2rpy ( const MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Vector4d rotmat2axis ( const MatrixBase < Map < Matrix3d > > & ) ; template DLLEXPORT Vector4d rotmat2quat ( const MatrixBase < Map < Matrix3d > > & ) ; template DLLEXPORT Vector3d rotmat2rpy ( const MatrixBase < Map < Matrix3d > > & ) ; template DLLEXPORT Vector4d rpy2axis ( const Eigen :: MatrixBase < Map < Vector3d > > & ) ; template DLLEXPORT Vector4d rpy2quat ( const Eigen :: MatrixBase < Map < Vector3d > > & ) ; template DLLEXPORT Matrix3d rpy2rotmat ( const Eigen :: MatrixBase < Map < Vector3d > > & ) ; template DLLEXPORT Matrix < double , 9 , 3 > drpy2rotmat ( const Eigen :: MatrixBase < Map < Vector3d > > & ) ; template DLLEXPORT Matrix < Block < Matrix4d const , 3 , 3 , false > :: Scalar , 4 , 1 , 0 , 4 , 1 > rotmat2quat < Block < Matrix4d const , 3 , 3 , false > > ( MatrixBase < Block < Matrix4d const , 3 , 3 , false > > const & ) ; template DLLEXPORT Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic > transformSpatialMotion ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic > > & ) ; template DLLEXPORT Eigen :: Matrix < double , TWIST_SIZE , 1 > transformSpatialMotion ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & ) ; template DLLEXPORT TransformSpatial < MatrixXd > :: type transformSpatialMotion < MatrixXd > ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < MatrixXd > & ) ; template DLLEXPORT TransformSpatial < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 6 , - 1 , false > > :: type transformSpatialMotion ( const Eigen :: Isometry3d & T , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 6 , - 1 , false > > & M ) ; template DLLEXPORT TransformSpatial < Matrix < double , TWIST_SIZE , Eigen :: Dynamic > > :: type transformSpatialForce < Matrix < double , TWIST_SIZE , Eigen :: Dynamic >> ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Matrix < double , TWIST_SIZE , Eigen :: Dynamic > > & ) ; template DLLEXPORT TransformSpatial < MatrixXd > :: type transformSpatialForce < MatrixXd > ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < MatrixXd > & ) ; template DLLEXPORT TransformSpatial < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 6 , - 1 , true >> :: type transformSpatialForce ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 6 , - 1 , true > > & ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > :: type transformSpatialForce ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & ) ; template DLLEXPORT TransformSpatial < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > const , 6 , 1 , true > > :: type transformSpatialForce ( const Eigen :: Transform < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > const , 6 , 1 , true > :: Scalar , 3 , 1 , 0 > & , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > const , 6 , 1 , true > > & ) ; template DLLEXPORT TransformSpatial < Map < Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 0 , Stride < 0 , 0 > > > :: type transformSpatialForce < Map < Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 0 , Stride < 0 , 0 > >> ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Map < Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 0 , Stride < 0 , 0 > > > & ) ; template DLLEXPORT GradientVar < double , TWIST_SIZE , TWIST_SIZE > transformSpatialInertia ( const Eigen :: Transform < double , SPACE_DIMENSION , Eigen :: Isometry > & T_current_to_new , const Gradient < Eigen :: Transform < double , SPACE_DIMENSION , Eigen :: Isometry > :: MatrixType , Eigen :: Dynamic > :: type * dT_current_to_new , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , TWIST_SIZE > > & I ) ; template DLLEXPORT GradientVar < double , TWIST_SIZE , TWIST_SIZE > transformSpatialInertia ( const Eigen :: Transform < double , SPACE_DIMENSION , Eigen :: Isometry > & T_current_to_new , const Gradient < Eigen :: Transform < double , SPACE_DIMENSION , Eigen :: Isometry > :: MatrixType , Eigen :: Dynamic > :: type * dT_current_to_new , const Eigen :: MatrixBase < Eigen :: MatrixXd > & I ) ; template DLLEXPORT Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic > dCrossSpatialMotion ( const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & b , const Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic > dCrossSpatialForce ( const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & b , const Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Gradient < Matrix3d , QUAT_SIZE > :: type dquat2rotmat ( const Eigen :: MatrixBase < Vector4d > & ) ; template DLLEXPORT Gradient < Matrix3d , QUAT_SIZE > :: type dquat2rotmat ( const Eigen :: MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Gradient < Matrix3d , QUAT_SIZE > :: type dquat2rotmat ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 4 , 1 , false > > & ) ; template DLLEXPORT Gradient < Vector3d , Dynamic > :: type drotmat2rpy ( const Eigen :: MatrixBase < Matrix3d > & , const Eigen :: MatrixBase < Matrix < double , RotmatSize , Dynamic > > & ) ; template DLLEXPORT Gradient < Vector3d , 6 > :: type drotmat2rpy ( const Eigen :: MatrixBase < Matrix3d > & , const Eigen :: MatrixBase < Matrix < double , RotmatSize , 6 > > & ) ; template DLLEXPORT Gradient < Vector4d , Dynamic > :: type drotmat2quat ( const Eigen :: MatrixBase < Matrix3d > & , const Eigen :: MatrixBase < Matrix < double , RotmatSize , Dynamic > > & ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , 3 > vectorToSkewSymmetric ( const Eigen :: MatrixBase < Eigen :: Vector3d > & ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Vector3d > & a , const Eigen :: MatrixBase < Vector3d > & b , const Gradient < Vector3d , Eigen :: Dynamic > :: type & da , const Gradient < Vector3d , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true >> & a , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false >> & b , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true > > & a , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > > & b , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false >> & a , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , - 1 , false > , 3 , 1 , true >> & b , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false >> & a , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true >> & b , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true >> & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 >> & b , const Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , 3 , 1 , false >> & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 >> & b , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , 3 , 1 , false > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > :: Scalar , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false > > const & , Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false > , - 1 , 1 > :: type const & ) ; template DLLEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > :: Scalar , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > > const & , Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > , - 1 , 1 > :: type const & ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > , 3 , 1 , true > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > , 3 , 1 , true > > const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , Eigen :: Block < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , 3 , 1 , true > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , 3 , 1 , true > > const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , 3 , 1 , true > , - 1 , 1 > :: type const & ) ; template DLLEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > :: Scalar , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > > const & , Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > , - 1 , 1 > :: type const & ) ; template DLLEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > :: Scalar , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , 1 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , 1 , false > > const & , Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , 1 , false > , - 1 , 1 > :: type const & ) ; template DLLEXPORT DHomogTrans < MatrixXd > :: type dHomogTrans ( const Isometry3d & , const MatrixBase < Matrix < double , TWIST_SIZE , Dynamic > > & , const MatrixBase < MatrixXd > & ) ; template DLLEXPORT DHomogTrans < Matrix < double , HOMOGENEOUS_TRANSFORM_SIZE , Dynamic >> :: type dHomogTransInv ( const Isometry3d & , const MatrixBase < Matrix < double , HOMOGENEOUS_TRANSFORM_SIZE , Dynamic > > & ) ; template DLLEXPORT Gradient < Matrix < double , TWIST_SIZE , Dynamic > , Dynamic , 1 > :: type dTransformSpatialMotion ( const Isometry3d & , const MatrixBase < Matrix < double , TWIST_SIZE , Dynamic > > & , const MatrixBase < Matrix < double , HOMOGENEOUS_TRANSFORM_SIZE , Dynamic > > & , const MatrixBase < MatrixXd > & ) ; template DLLEXPORT Gradient < Matrix < double , TWIST_SIZE , 1 > , Dynamic , 1 > :: type dTransformSpatialMotion ( const Isometry3d & , const MatrixBase < Matrix < double , TWIST_SIZE , 1 > > & , const MatrixBase < Matrix < double , HOMOGENEOUS_TRANSFORM_SIZE , Dynamic > > & , const MatrixBase < Matrix < double , TWIST_SIZE , Eigen :: Dynamic > > & ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , TWIST_SIZE , 1 >> :: type crossSpatialMotion ( const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & b ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , TWIST_SIZE , TWIST_SIZE >> :: type crossSpatialMotion ( const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , TWIST_SIZE > > & b ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic >> :: type crossSpatialMotion ( const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic > > & b ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , TWIST_SIZE , 1 >> :: type crossSpatialForce ( const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & b ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , TWIST_SIZE , TWIST_SIZE >> :: type crossSpatialForce ( const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , TWIST_SIZE > > & b ) ; template DLLEXPORT Gradient < Matrix < double , TWIST_SIZE , Dynamic > , Dynamic , 1 > :: type dTransformSpatialForce ( const Isometry3d & , const MatrixBase < Matrix < double , TWIST_SIZE , Dynamic > > & , const MatrixBase < Matrix < double , HOMOGENEOUS_TRANSFORM_SIZE , Dynamic > > & , const MatrixBase < MatrixXd > & ) ; template DLLEXPORT Gradient < Matrix < double , TWIST_SIZE , Dynamic > , Dynamic , 1 > :: type dTransformSpatialForce ( const Isometry3d & , const MatrixBase < Matrix < double , TWIST_SIZE , Dynamic > > & , const MatrixBase < MatrixXd > & , const MatrixBase < MatrixXd > & ) ; template DLLEXPORT Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 6 , - 1 , true > :: ColsAtCompileTime > :: type dTransformSpatialForce ( const Isometry3d & T , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & X , const Eigen :: MatrixBase < Eigen :: Matrix < double , 16 , - 1 , 0 , 16 , - 1 > > & dT , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 6 , - 1 , true > > & dX ) ; template DLLEXPORT Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > :: ColsAtCompileTime > :: type dTransformSpatialForce ( const Isometry3d & T , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 >> & X , const Eigen :: MatrixBase < Eigen :: Matrix < double , 16 , - 1 , 0 , 16 , - 1 >> & dT , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 >> & dX ) ; template DLLEXPORT void cylindrical2cartesian ( const Matrix < double , 3 , 1 > & cylinder_axis , const Matrix < double , 3 , 1 > & cylinder_x_dir , const Matrix < double , 3 , 1 > & cylinder_origin , const Matrix < double , 6 , 1 > & x_cylinder , const Matrix < double , 6 , 1 > & v_cylinder , Matrix < double , 6 , 1 > & x_cartesian , Matrix < double , 6 , 1 > & v_cartesian , Matrix < double , 6 , 6 > & J , Matrix < double , 6 , 1 > & Jdotv ) ; template DLLEXPORT void cartesian2cylindrical ( const Matrix < double , 3 , 1 > & cylinder_axis , const Matrix < double , 3 , 1 > & cylinder_x_dir , const Matrix < double , 3 , 1 > & cylinder_origin , const Matrix < double , 6 , 1 > & x_cartesian , const Matrix < double , 6 , 1 > & v_cartesian , Matrix < double , 6 , 1 > & x_cylinder , Matrix < double , 6 , 1 > & v_cylinder , Matrix < double , 6 , 6 > & J , Matrix < double , 6 , 1 > & Jdotv ) ; template DLLEXPORT void angularvel2quatdotMatrix ( const Eigen :: MatrixBase < Vector4d > & q , Eigen :: MatrixBase < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > > & M , Eigen :: MatrixBase < Gradient < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > , QUAT_SIZE , 1 > :: type > * dM ) ; template DLLEXPORT void angularvel2quatdotMatrix ( const Eigen :: MatrixBase < Map < Vector4d >> & q , Eigen :: MatrixBase < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > > & M , Eigen :: MatrixBase < Gradient < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > , QUAT_SIZE , 1 > :: type > * dM ) ; template DLLEXPORT void angularvel2quatdotMatrix ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 4 , 1 , false > > & q , Eigen :: MatrixBase < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > > & M , Eigen :: MatrixBase < Gradient < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > , QUAT_SIZE , 1 > :: type > * dM ) ; template DLLEXPORT void angularvel2rpydotMatrix ( const Eigen :: MatrixBase < Vector3d > & rpy , Eigen :: MatrixBase < Matrix < double , RPY_SIZE , SPACE_DIMENSION > > & phi , Eigen :: MatrixBase < Gradient < Matrix < double , RPY_SIZE , SPACE_DIMENSION > , RPY_SIZE , 1 > :: type > * dphi , Eigen :: MatrixBase < Gradient < Matrix < double , RPY_SIZE , SPACE_DIMENSION > , RPY_SIZE , 2 > :: type > * ddphi ) ; template DLLEXPORT void angularvel2rpydotMatrix ( const Eigen :: MatrixBase < Vector3d > & rpy , Eigen :: MatrixBase < Matrix < double , RPY_SIZE , SPACE_DIMENSION > > & phi , Eigen :: MatrixBase < Matrix < double , Eigen :: Dynamic , Eigen :: Dynamic > > * dphi , Eigen :: MatrixBase < Matrix < double , Eigen :: Dynamic , Eigen :: Dynamic > > * ddphi ) ; template DLLEXPORT void rpydot2angularvelMatrix ( const Eigen :: MatrixBase < Vector3d > & rpy , Eigen :: MatrixBase < Eigen :: Matrix < double , SPACE_DIMENSION , RPY_SIZE > > & E , Gradient < Matrix < double , SPACE_DIMENSION , RPY_SIZE > , RPY_SIZE , 1 > :: type * dE ) ; template DLLEXPORT void rpydot2angularvelMatrix ( const Eigen :: MatrixBase < Map < Vector3d >> & rpy , Eigen :: MatrixBase < Eigen :: Matrix < double , SPACE_DIMENSION , RPY_SIZE > > & E , Gradient < Matrix < double , SPACE_DIMENSION , RPY_SIZE > , RPY_SIZE , 1 > :: type * dE ) ; template DLLEXPORT void rpydot2angularvelMatrix ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 3 , 1 , false > > & rpy , Eigen :: MatrixBase < Eigen :: Matrix < double , SPACE_DIMENSION , RPY_SIZE > > & E , Gradient < Matrix < double , SPACE_DIMENSION , RPY_SIZE > , RPY_SIZE , 1 > :: type * dE ) ; template DLLEXPORT GradientVar < double , Eigen :: Dynamic , SPACE_DIMENSION > angularvel2RepresentationDotMatrix ( int rotation_type , const Eigen :: MatrixBase < VectorXd > & qrot , int gradient_order ) ; template DLLEXPORT GradientVar < double , Eigen :: Dynamic , SPACE_DIMENSION > angularvel2RepresentationDotMatrix ( int rotation_type , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , - 1 , 1 , false > > & qrot , int gradient_order ) ; template DLLEXPORT GradientVar < double , - 1 , 3 > angularvel2RepresentationDotMatrix < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , - 1 , 1 , false > > ( int , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , - 1 , 1 , false > > const & , int ) ; template DLLEXPORT GradientVar < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , - 1 , 1 , false > :: Scalar , - 1 , 3 > angularvel2RepresentationDotMatrix < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , - 1 , 1 , false > > ( int , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , - 1 , 1 , false > > const & , int ) ; template DLLEXPORT GradientVar < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , - 1 , 1 , false > :: Scalar , - 1 , 3 > angularvel2RepresentationDotMatrix < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , - 1 , 1 , false > > ( int , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , - 1 , 1 , false > > const & , int ) ; template DLLEXPORT void quatdot2angularvelMatrix ( const Eigen :: MatrixBase < Vector4d > & q , Eigen :: MatrixBase < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > > & M , Gradient < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > , QUAT_SIZE , 1 > :: type * dM ) ; template DLLEXPORT void quatdot2angularvelMatrix ( const Eigen :: MatrixBase < Map < Vector4d >> & q , Eigen :: MatrixBase < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > > & M , Gradient < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > , QUAT_SIZE , 1 > :: type * dM ) ; template DLLEXPORT void quatdot2angularvelMatrix ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 4 , 1 , false > > & q , Eigen :: MatrixBase < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > > & M , Gradient < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > , QUAT_SIZE , 1 > :: type * dM ) ; </DOCUMENT>
<DOCUMENT_ID="afoksha/OpenGL/tree/master/demos/100_Player/player_5.cpp"> # include < iostream > # include < string > # include < thread > # include < mutex > # include < condition_variable > std :: mutex m ; std :: condition_variable cv ; std :: string data ; bool ready = false ; bool processed = false ; void worker_thread ( ) { // ▁ Wait ▁ until ▁ main ( ) ▁ sends ▁ data ENDCOM std :: unique_lock < std :: mutex > lk ( m ) ; cv . wait ( lk , [ ] { return ready ; } ) ; // ▁ after ▁ the ▁ wait , ▁ we ▁ own ▁ the ▁ lock . ENDCOM std :: cout << " Worker ▁ thread ▁ is ▁ processing ▁ data \n " ; data += " ▁ after ▁ processing " ; // ▁ Send ▁ data ▁ back ▁ to ▁ main ( ) ENDCOM processed = true ; std :: cout << " Worker ▁ thread ▁ signals ▁ data ▁ processing ▁ completed \n " ; // ▁ Manual ▁ unlocking ▁ is ▁ done ▁ before ▁ notifying , ▁ to ▁ avoid ▁ waking ▁ up ENDCOM // ▁ the ▁ waiting ▁ thread ▁ only ▁ to ▁ block ▁ again ▁ ( see ▁ notify _ one ▁ for ▁ details ) ENDCOM lk . unlock ( ) ; cv . notify_one ( ) ; } int main ( int argc , char * argv [ ] ) { std :: thread worker ( worker_thread ) ; data = " Example ▁ data " ; // ▁ send ▁ data ▁ to ▁ the ▁ worker ▁ thread ENDCOM { std :: lock_guard < std :: mutex > lk ( m ) ; ready = true ; std :: cout << " main ( ) ▁ signals ▁ data ▁ ready ▁ for ▁ processing \n " ; } cv . notify_one ( ) ; // ▁ wait ▁ for ▁ the ▁ worker ENDCOM { std :: unique_lock < std :: mutex > lk ( m ) ; cv . wait ( lk , [ ] { return processed ; } ) ; } std :: cout << " Back ▁ in ▁ main ( ) , ▁ data ▁ = ▁ " << data << ' \n ' ; worker . join ( ) ; } </DOCUMENT>
<DOCUMENT_ID="verybadsoldier/xbmc/tree/master/xbmc/visualizations/Vortex/angelscript/angelscript/source/as_scriptengine.cpp"> /* STRNEWLINE ▁ AngelCode ▁ Scripting ▁ Library STRNEWLINE ▁ Copyright ▁ ( c ) ▁ 2003-2009 ▁ Andreas ▁ Jonsson STRNEWLINE STRNEWLINE ▁ This ▁ software ▁ is ▁ provided ▁ ' as - is ' , ▁ without ▁ any ▁ express ▁ or ▁ implied STRNEWLINE ▁ warranty . ▁ In ▁ no ▁ event ▁ will ▁ the ▁ authors ▁ be ▁ held ▁ liable ▁ for ▁ any STRNEWLINE ▁ damages ▁ arising ▁ from ▁ the ▁ use ▁ of ▁ this ▁ software . STRNEWLINE STRNEWLINE ▁ Permission ▁ is ▁ granted ▁ to ▁ anyone ▁ to ▁ use ▁ this ▁ software ▁ for ▁ any STRNEWLINE ▁ purpose , ▁ including ▁ commercial ▁ applications , ▁ and ▁ to ▁ alter ▁ it ▁ and STRNEWLINE ▁ redistribute ▁ it ▁ freely , ▁ subject ▁ to ▁ the ▁ following ▁ restrictions : STRNEWLINE STRNEWLINE ▁ 1 . ▁ The ▁ origin ▁ of ▁ this ▁ software ▁ must ▁ not ▁ be ▁ misrepresented ; ▁ you STRNEWLINE ▁ must ▁ not ▁ claim ▁ that ▁ you ▁ wrote ▁ the ▁ original ▁ software . ▁ If ▁ you ▁ use STRNEWLINE ▁ this ▁ software ▁ in ▁ a ▁ product , ▁ an ▁ acknowledgment ▁ in ▁ the ▁ product STRNEWLINE ▁ documentation ▁ would ▁ be ▁ appreciated ▁ but ▁ is ▁ not ▁ required . STRNEWLINE STRNEWLINE ▁ 2 . ▁ Altered ▁ source ▁ versions ▁ must ▁ be ▁ plainly ▁ marked ▁ as ▁ such , ▁ and STRNEWLINE ▁ must ▁ not ▁ be ▁ misrepresented ▁ as ▁ being ▁ the ▁ original ▁ software . STRNEWLINE STRNEWLINE ▁ 3 . ▁ This ▁ notice ▁ may ▁ not ▁ be ▁ removed ▁ or ▁ altered ▁ from ▁ any ▁ source STRNEWLINE ▁ distribution . STRNEWLINE STRNEWLINE ▁ The ▁ original ▁ version ▁ of ▁ this ▁ library ▁ can ▁ be ▁ located ▁ at : STRNEWLINE ▁ http : // www . angelcode . com / angelscript / STRNEWLINE STRNEWLINE ▁ Andreas ▁ Jonsson STRNEWLINE ▁ andreas @ angelcode . com STRNEWLINE */ // ▁ as _ scriptengine . cpp ENDCOM // ▁ The ▁ implementation ▁ of ▁ the ▁ script ▁ engine ▁ interface ENDCOM # include < stdlib . h > # include " as _ config . h " # include " as _ scriptengine . h " # include " as _ builder . h " # include " as _ context . h " # include " as _ string _ util . h " # include " as _ tokenizer . h " # include " as _ texts . h " # include " as _ module . h " # include " as _ callfunc . h " # include " as _ arrayobject . h " # include " as _ generic . h " # include " as _ scriptobject . h " # include " as _ compiler . h " BEGIN_AS_NAMESPACE extern " C " { AS_API const char * asGetLibraryVersion ( ) { # ifdef _DEBUG return ANGELSCRIPT_VERSION_STRING " ▁ DEBUG " ; # else return ANGELSCRIPT_VERSION_STRING ; # endif } AS_API const char * asGetLibraryOptions ( ) { const char * string = " ▁ " // ▁ Options ENDCOM # ifdef AS_MAX_PORTABILITY " AS _ MAX _ PORTABILITY ▁ " # endif # ifdef AS_DEBUG " AS _ DEBUG ▁ " # endif # ifdef AS_NO_CLASS_METHODS " AS _ NO _ CLASS _ METHODS ▁ " # endif # ifdef AS_USE_DOUBLE_AS_FLOAT " AS _ USE _ DOUBLE _ AS _ FLOAT ▁ " # endif # ifdef AS_64BIT_PTR " AS _ 64BIT _ PTR ▁ " # endif # ifdef AS_NO_THREADS " AS _ NO _ THREADS ▁ " # endif # ifdef AS_NO_ATOMIC " AS _ NO _ ATOMIC ▁ " # endif // ▁ Target ▁ system ENDCOM # ifdef AS_WIN " AS _ WIN ▁ " # endif # ifdef AS_LINUX " AS _ LINUX ▁ " # endif # ifdef AS_MAC " AS _ MAC ▁ " # endif # ifdef AS_BSD " AS _ BSD ▁ " # endif # ifdef AS_XBOX " AS _ XBOX ▁ " # endif # ifdef AS_XBOX360 " AS _ XBOX360 ▁ " # endif # ifdef AS_PSP " AS _ PSP ▁ " # endif # ifdef AS_PS2 " AS _ PS2 ▁ " # endif # ifdef AS_PS3 " AS _ PS3 ▁ " # endif # ifdef AS_DC " AS _ DC ▁ " # endif # ifdef AS_GC " AS _ GC ▁ " # endif # ifdef AS_WII " AS _ WII ▁ " # endif # ifdef AS_IPHONE " AS _ IPHONE ▁ " # endif # ifdef AS_ANDROID " AS _ ANDROID ▁ " # endif // ▁ CPU ▁ family ENDCOM # ifdef AS_PPC " AS _ PPC ▁ " # endif # ifdef AS_PPC_64 " AS _ PPC _ 64 ▁ " # endif # ifdef AS_X86 " AS _ X86 ▁ " # endif # ifdef AS_MIPS " AS _ MIPS ▁ " # endif # ifdef AS_SH4 " AS _ SH4 ▁ " # endif # ifdef AS_XENON " AS _ XENON ▁ " # endif # ifdef AS_ARM " AS _ ARM ▁ " # endif ; return string ; } AS_API asIScriptEngine * asCreateScriptEngine ( asDWORD version ) { // ▁ Verify ▁ the ▁ version ▁ that ▁ the ▁ application ▁ expects ENDCOM if ( ( version / 10000 ) != ( ANGELSCRIPT_VERSION / 10000 ) ) return 0 ; if ( ( version / 100 ) % 100 != ( ANGELSCRIPT_VERSION / 100 ) % 100 ) return 0 ; if ( ( version % 100 ) > ( ANGELSCRIPT_VERSION % 100 ) ) return 0 ; // ▁ Verify ▁ the ▁ size ▁ of ▁ the ▁ types ENDCOM asASSERT ( sizeof ( asBYTE ) == 1 ) ; asASSERT ( sizeof ( asWORD ) == 2 ) ; asASSERT ( sizeof ( asDWORD ) == 4 ) ; asASSERT ( sizeof ( asQWORD ) == 8 ) ; asASSERT ( sizeof ( asPWORD ) == sizeof ( void * ) ) ; // ▁ Verify ▁ the ▁ boolean ▁ type ENDCOM asASSERT ( sizeof ( bool ) == AS_SIZEOF_BOOL ) ; asASSERT ( true == VALUE_OF_BOOLEAN_TRUE ) ; // ▁ Verify ▁ endianess ENDCOM # ifdef AS_BIG_ENDIAN asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x00010203 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x0001020304050607 ) ) ; # else asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x03020100 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x0706050403020100 ) ) ; # endif return asNEW ( asCScriptEngine ) ( ) ; } int asCScriptEngine :: SetEngineProperty ( asEEngineProp property , asPWORD value ) { switch ( property ) { case asEP_ALLOW_UNSAFE_REFERENCES : ep . allowUnsafeReferences = value ? true : false ; break ; case asEP_OPTIMIZE_BYTECODE : ep . optimizeByteCode = value ? true : false ; break ; case asEP_COPY_SCRIPT_SECTIONS : ep . copyScriptSections = value ? true : false ; break ; case asEP_MAX_STACK_SIZE : // ▁ The ▁ size ▁ is ▁ given ▁ in ▁ bytes , ▁ but ▁ we ▁ only ▁ store ▁ dwords ENDCOM ep . maximumContextStackSize = ( int ) value / 4 ; if ( initialContextStackSize > ep . maximumContextStackSize ) initialContextStackSize = ep . maximumContextStackSize ; break ; case asEP_USE_CHARACTER_LITERALS : ep . useCharacterLiterals = value ? true : false ; break ; case asEP_ALLOW_MULTILINE_STRINGS : ep . allowMultilineStrings = value ? true : false ; break ; case asEP_ALLOW_IMPLICIT_HANDLE_TYPES : ep . allowImplicitHandleTypes = value ? true : false ; break ; case asEP_BUILD_WITHOUT_LINE_CUES : ep . buildWithoutLineCues = value ? true : false ; break ; case asEP_INIT_GLOBAL_VARS_AFTER_BUILD : ep . initGlobalVarsAfterBuild = value ? true : false ; break ; case asEP_REQUIRE_ENUM_SCOPE : ep . requireEnumScope = value ? true : false ; break ; case asEP_SCRIPT_SCANNER : if ( value <= 1 ) ep . scanner = ( int ) value ; else return asINVALID_ARG ; break ; case asEP_INCLUDE_JIT_INSTRUCTIONS : ep . includeJitInstructions = value ? true : false ; break ; case asEP_STRING_ENCODING : if ( value <= 1 ) ep . stringEncoding = ( int ) value ; else return asINVALID_ARG ; break ; default : return asINVALID_ARG ; } return asSUCCESS ; } asPWORD asCScriptEngine :: GetEngineProperty ( asEEngineProp property ) { switch ( property ) { case asEP_ALLOW_UNSAFE_REFERENCES : return ep . allowUnsafeReferences ; case asEP_OPTIMIZE_BYTECODE : return ep . optimizeByteCode ; case asEP_COPY_SCRIPT_SECTIONS : return ep . copyScriptSections ; case asEP_MAX_STACK_SIZE : return ep . maximumContextStackSize * 4 ; case asEP_USE_CHARACTER_LITERALS : return ep . useCharacterLiterals ; case asEP_ALLOW_MULTILINE_STRINGS : return ep . allowMultilineStrings ; case asEP_ALLOW_IMPLICIT_HANDLE_TYPES : return ep . allowImplicitHandleTypes ; case asEP_BUILD_WITHOUT_LINE_CUES : return ep . buildWithoutLineCues ; case asEP_INIT_GLOBAL_VARS_AFTER_BUILD : return ep . initGlobalVarsAfterBuild ; case asEP_REQUIRE_ENUM_SCOPE : return ep . requireEnumScope ; case asEP_SCRIPT_SCANNER : return ep . scanner ; case asEP_INCLUDE_JIT_INSTRUCTIONS : return ep . includeJitInstructions ; case asEP_STRING_ENCODING : return ep . stringEncoding ; } return 0 ; } } // ▁ extern ▁ " C " ENDCOM asCScriptEngine :: asCScriptEngine ( ) { // ▁ Instanciate ▁ the ▁ thread ▁ manager ENDCOM if ( threadManager == 0 ) threadManager = asNEW ( asCThreadManager ) ; else threadManager -> AddRef ( ) ; // ▁ Engine ▁ properties ENDCOM ep . allowUnsafeReferences = false ; ep . optimizeByteCode = true ; ep . copyScriptSections = true ; ep . maximumContextStackSize = 0 ; // ▁ no ▁ limit ENDCOM ep . useCharacterLiterals = false ; ep . allowMultilineStrings = false ; ep . allowImplicitHandleTypes = false ; ep . buildWithoutLineCues = false ; ep . initGlobalVarsAfterBuild = true ; ep . requireEnumScope = false ; ep . scanner = 1 ; // ▁ utf8 . ▁ 0 ▁ = ▁ ascii ENDCOM ep . includeJitInstructions = false ; ep . stringEncoding = 0 ; // ▁ utf8 . ▁ 1 ▁ = ▁ utf16 ENDCOM gc . engine = this ; refCount . set ( 1 ) ; stringFactory = 0 ; configFailed = false ; isPrepared = false ; isBuilding = false ; lastModule = 0 ; userData = 0 ; initialContextStackSize = 1024 ; // ▁ 1 ▁ KB ENDCOM typeIdSeqNbr = 0 ; currentGroup = & defaultGroup ; msgCallback = 0 ; jitCompiler = 0 ; // ▁ Reserve ▁ function ▁ id ▁ 0 ▁ for ▁ no ▁ function ENDCOM scriptFunctions . PushLast ( 0 ) ; // ▁ Make ▁ sure ▁ typeId ▁ for ▁ the ▁ built - in ▁ primitives ▁ are ▁ defined ▁ according ▁ to ▁ asETypeIdFlags ENDCOM int id ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttVoid , false ) ) ; asASSERT ( id == asTYPEID_VOID ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttBool , false ) ) ; asASSERT ( id == asTYPEID_BOOL ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt8 , false ) ) ; asASSERT ( id == asTYPEID_INT8 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt16 , false ) ) ; asASSERT ( id == asTYPEID_INT16 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt , false ) ) ; asASSERT ( id == asTYPEID_INT32 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt64 , false ) ) ; asASSERT ( id == asTYPEID_INT64 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt8 , false ) ) ; asASSERT ( id == asTYPEID_UINT8 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt16 , false ) ) ; asASSERT ( id == asTYPEID_UINT16 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt , false ) ) ; asASSERT ( id == asTYPEID_UINT32 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt64 , false ) ) ; asASSERT ( id == asTYPEID_UINT64 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttFloat , false ) ) ; asASSERT ( id == asTYPEID_FLOAT ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttDouble , false ) ) ; asASSERT ( id == asTYPEID_DOUBLE ) ; defaultArrayObjectType = 0 ; RegisterArrayObject ( this ) ; RegisterScriptObject ( this ) ; RegisterScriptFunction ( this ) ; RegisterObjectTypeGCBehaviours ( this ) ; } asCScriptEngine :: ~ asCScriptEngine ( ) { asASSERT ( refCount . get ( ) == 0 ) ; asUINT n ; // ▁ The ▁ modules ▁ must ▁ be ▁ deleted ▁ first , ▁ as ▁ they ▁ may ▁ use ENDCOM // ▁ object ▁ types ▁ from ▁ the ▁ config ▁ groups ENDCOM for ( n = ( asUINT ) scriptModules . GetLength ( ) ; n -- > 0 ; ) { if ( scriptModules [ n ] ) { asDELETE ( scriptModules [ n ] , asCModule ) ; } } scriptModules . SetLength ( 0 ) ; GarbageCollect ( asGC_FULL_CYCLE ) ; // ▁ Delete ▁ the ▁ functions ▁ for ▁ template ▁ types ▁ that ▁ may ▁ references ▁ object ▁ types ENDCOM for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] ) { asUINT f ; // ▁ Delete ▁ the ▁ factory ▁ stubs ▁ first ENDCOM for ( f = 0 ; f < templateTypes [ n ] -> beh . factories . GetLength ( ) ; f ++ ) { scriptFunctions [ templateTypes [ n ] -> beh . factories [ f ] ] -> Release ( ) ; } templateTypes [ n ] -> beh . factories . Allocate ( 0 , false ) ; // ▁ Delete ▁ the ▁ specialized ▁ functions ENDCOM for ( f = 1 ; f < templateTypes [ n ] -> beh . operators . GetLength ( ) ; f += 2 ) { if ( scriptFunctions [ templateTypes [ n ] -> beh . operators [ f ] ] -> objectType == templateTypes [ n ] ) { scriptFunctions [ templateTypes [ n ] -> beh . operators [ f ] ] -> Release ( ) ; templateTypes [ n ] -> beh . operators [ f ] = 0 ; } } } } // ▁ Do ▁ one ▁ more ▁ garbage ▁ collect ▁ to ▁ free ▁ gc ▁ objects ▁ that ▁ were ▁ global ▁ variables ENDCOM GarbageCollect ( asGC_FULL_CYCLE ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; // ▁ Break ▁ all ▁ relationship ▁ between ▁ remaining ▁ class ▁ types ▁ and ▁ functions ENDCOM for ( n = 0 ; n < classTypes . GetLength ( ) ; n ++ ) { if ( classTypes [ n ] ) classTypes [ n ] -> ReleaseAllFunctions ( ) ; if ( classTypes [ n ] -> derivedFrom ) { classTypes [ n ] -> derivedFrom -> Release ( ) ; classTypes [ n ] -> derivedFrom = 0 ; } } GarbageCollect ( asGC_FULL_CYCLE ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; asSMapNode < int , asCDataType * > * cursor = 0 ; while ( mapTypeIdToDataType . MoveFirst ( & cursor ) ) { asDELETE ( mapTypeIdToDataType . GetValue ( cursor ) , asCDataType ) ; mapTypeIdToDataType . Erase ( cursor ) ; } defaultGroup . RemoveConfiguration ( this ) ; while ( configGroups . GetLength ( ) ) { // ▁ Delete ▁ config ▁ groups ▁ in ▁ the ▁ right ▁ order ENDCOM asCConfigGroup * grp = configGroups . PopLast ( ) ; if ( grp ) { asDELETE ( grp , asCConfigGroup ) ; } } for ( n = 0 ; n < registeredGlobalProps . GetLength ( ) ; n ++ ) { if ( registeredGlobalProps [ n ] ) { asDELETE ( registeredGlobalProps [ n ] , asCGlobalProperty ) ; } } registeredGlobalProps . SetLength ( 0 ) ; FreeUnusedGlobalProperties ( ) ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] ) { // ▁ Clear ▁ the ▁ sub ▁ type ▁ before ▁ deleting ▁ the ▁ template ▁ type ▁ so ▁ that ▁ the ▁ sub ▁ type ▁ isn ' t ▁ freed ▁ to ▁ soon ENDCOM templateTypes [ n ] -> templateSubType = asCDataType :: CreateNullHandle ( ) ; asDELETE ( templateTypes [ n ] , asCObjectType ) ; } } templateTypes . SetLength ( 0 ) ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] ) { // ▁ Clear ▁ the ▁ sub ▁ type ▁ before ▁ deleting ▁ the ▁ template ▁ type ▁ so ▁ that ▁ the ▁ sub ▁ type ▁ isn ' t ▁ freed ▁ to ▁ soon ENDCOM objectTypes [ n ] -> templateSubType = asCDataType :: CreateNullHandle ( ) ; asDELETE ( objectTypes [ n ] , asCObjectType ) ; } } objectTypes . SetLength ( 0 ) ; for ( n = 0 ; n < templateSubTypes . GetLength ( ) ; n ++ ) { if ( templateSubTypes [ n ] ) { asDELETE ( templateSubTypes [ n ] , asCObjectType ) ; } } templateSubTypes . SetLength ( 0 ) ; registeredTypeDefs . SetLength ( 0 ) ; registeredEnums . SetLength ( 0 ) ; registeredObjTypes . SetLength ( 0 ) ; for ( n = 0 ; n < registeredGlobalFuncs . GetLength ( ) ; n ++ ) { if ( registeredGlobalFuncs [ n ] ) registeredGlobalFuncs [ n ] -> Release ( ) ; } registeredGlobalFuncs . SetLength ( 0 ) ; scriptTypeBehaviours . ReleaseAllFunctions ( ) ; functionBehaviours . ReleaseAllFunctions ( ) ; objectTypeBehaviours . ReleaseAllFunctions ( ) ; // ▁ Free ▁ string ▁ constants ENDCOM for ( n = 0 ; n < stringConstants . GetLength ( ) ; n ++ ) { asDELETE ( stringConstants [ n ] , asCString ) ; } stringConstants . SetLength ( 0 ) ; // ▁ Free ▁ the ▁ script ▁ section ▁ names ENDCOM for ( n = 0 ; n < scriptSectionNames . GetLength ( ) ; n ++ ) { asDELETE ( scriptSectionNames [ n ] , asCString ) ; } scriptSectionNames . SetLength ( 0 ) ; // ▁ Release ▁ the ▁ thread ▁ manager ENDCOM threadManager -> Release ( ) ; } // ▁ interface ENDCOM int asCScriptEngine :: AddRef ( ) { return refCount . atomicInc ( ) ; } // ▁ interface ENDCOM int asCScriptEngine :: Release ( ) { int r = refCount . atomicDec ( ) ; if ( r == 0 ) { asDELETE ( this , asCScriptEngine ) ; return 0 ; } return r ; } // ▁ interface ENDCOM void * asCScriptEngine :: SetUserData ( void * data ) { void * old = userData ; userData = data ; return old ; } // ▁ interface ENDCOM void * asCScriptEngine :: GetUserData ( ) { return userData ; } // ▁ interface ENDCOM int asCScriptEngine :: SetMessageCallback ( const asSFuncPtr & callback , void * obj , asDWORD callConv ) { msgCallback = true ; msgCallbackObj = obj ; bool isObj = false ; if ( ( unsigned ) callConv == asCALL_GENERIC ) { msgCallback = false ; return asNOT_SUPPORTED ; } if ( ( unsigned ) callConv >= asCALL_THISCALL ) { isObj = true ; if ( obj == 0 ) { msgCallback = false ; return asINVALID_ARG ; } } int r = DetectCallingConvention ( isObj , callback , callConv , & msgCallbackFunc ) ; if ( r < 0 ) msgCallback = false ; return r ; } // ▁ interface ENDCOM int asCScriptEngine :: ClearMessageCallback ( ) { msgCallback = false ; return 0 ; } // ▁ interface ENDCOM int asCScriptEngine :: WriteMessage ( const char * section , int row , int col , asEMsgType type , const char * message ) { // ▁ Validate ▁ input ▁ parameters ENDCOM if ( section == 0 || message == 0 ) return asINVALID_ARG ; // ▁ If ▁ there ▁ is ▁ no ▁ callback ▁ then ▁ there ' s ▁ nothing ▁ to ▁ do ENDCOM if ( ! msgCallback ) return 0 ; asSMessageInfo msg ; msg . section = section ; msg . row = row ; msg . col = col ; msg . type = type ; msg . message = message ; if ( msgCallbackFunc . callConv < ICC_THISCALL ) CallGlobalFunction ( & msg , msgCallbackObj , & msgCallbackFunc , 0 ) ; else CallObjectMethod ( msgCallbackObj , & msg , & msgCallbackFunc , 0 ) ; return 0 ; } int asCScriptEngine :: SetJITCompiler ( asIJITCompiler * compiler ) { jitCompiler = compiler ; return asSUCCESS ; } asIJITCompiler * asCScriptEngine :: GetJITCompiler ( ) { return jitCompiler ; } // ▁ interface ENDCOM asETokenClass asCScriptEngine :: ParseToken ( const char * string , size_t stringLength , int * tokenLength ) { if ( stringLength == 0 ) stringLength = strlen ( string ) ; size_t len ; asCTokenizer t ; asETokenClass tc ; t . GetToken ( string , stringLength , & len , & tc ) ; if ( tokenLength ) * tokenLength = ( int ) len ; return tc ; } // ▁ interface ENDCOM asIScriptModule * asCScriptEngine :: GetModule ( const char * module , asEGMFlags flag ) { asCModule * mod = GetModule ( module , false ) ; if ( flag == asGM_ALWAYS_CREATE ) { if ( mod != 0 ) { asDELETE ( mod , asCModule ) ; } return GetModule ( module , true ) ; } if ( mod == 0 && flag == asGM_CREATE_IF_NOT_EXISTS ) { return GetModule ( module , true ) ; } return mod ; } // ▁ interface ENDCOM int asCScriptEngine :: DiscardModule ( const char * module ) { asCModule * mod = GetModule ( module , false ) ; if ( mod == 0 ) return asNO_MODULE ; asDELETE ( mod , asCModule ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; return 0 ; } void asCScriptEngine :: ClearUnusedTypes ( ) { // ▁ Build ▁ a ▁ list ▁ of ▁ all ▁ types ▁ to ▁ check ▁ for ENDCOM asCArray < asCObjectType * > types ; types = classTypes ; types . Concatenate ( templateInstanceTypes ) ; // ▁ Go ▁ through ▁ all ▁ modules ENDCOM asUINT n ; for ( n = 0 ; n < scriptModules . GetLength ( ) && types . GetLength ( ) ; n ++ ) { asCModule * mod = scriptModules [ n ] ; if ( mod ) { // ▁ Functions / Methods / Globals ▁ are ▁ handled ▁ after ▁ this ENDCOM // ▁ Go ▁ through ▁ all ▁ type ▁ declarations ENDCOM asUINT m ; for ( m = 0 ; m < mod -> classTypes . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> classTypes [ m ] ) ; for ( m = 0 ; m < mod -> enumTypes . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> enumTypes [ m ] ) ; for ( m = 0 ; m < mod -> typeDefs . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> typeDefs [ m ] ) ; } } // ▁ Go ▁ through ▁ all ▁ function ▁ parameters ▁ and ▁ remove ▁ used ▁ types ENDCOM for ( n = 0 ; n < scriptFunctions . GetLength ( ) && types . GetLength ( ) ; n ++ ) { asCScriptFunction * func = scriptFunctions [ n ] ; if ( func ) { // ▁ Ignore ▁ factory ▁ stubs ENDCOM if ( func -> name == " factstub " ) continue ; asCObjectType * ot = func -> returnType . GetObjectType ( ) ; if ( ot != 0 && ot != func -> objectType ) if ( func -> name != ot -> name ) RemoveTypeAndRelatedFromList ( types , ot ) ; for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { ot = func -> parameterTypes [ p ] . GetObjectType ( ) ; if ( ot != 0 && ot != func -> objectType ) if ( func -> name != ot -> name ) RemoveTypeAndRelatedFromList ( types , ot ) ; } } } // ▁ Go ▁ through ▁ all ▁ global ▁ properties ENDCOM for ( n = 0 ; n < globalProperties . GetLength ( ) && types . GetLength ( ) ; n ++ ) { if ( globalProperties [ n ] && globalProperties [ n ] -> type . GetObjectType ( ) ) RemoveTypeAndRelatedFromList ( types , globalProperties [ n ] -> type . GetObjectType ( ) ) ; } // ▁ All ▁ that ▁ remains ▁ in ▁ the ▁ list ▁ after ▁ this ▁ can ▁ be ▁ discarded , ▁ since ▁ they ▁ are ▁ no ▁ longer ▁ used ENDCOM for ( ; ; ) { bool didClearTemplateInstanceType = false ; for ( n = 0 ; n < types . GetLength ( ) ; n ++ ) { // ▁ Template ▁ types ▁ and ▁ script ▁ classes ▁ will ▁ have ▁ two ▁ references ▁ for ▁ each ▁ factory ▁ stub ENDCOM int refCount = ( ( types [ n ] -> flags & asOBJ_TEMPLATE ) || ( types [ n ] -> flags & asOBJ_SCRIPT_OBJECT ) ) ? 2 * ( int ) types [ n ] -> beh . factories . GetLength ( ) : 0 ; if ( types [ n ] -> GetRefCount ( ) == refCount ) { if ( types [ n ] -> flags & asOBJ_TEMPLATE ) { didClearTemplateInstanceType = true ; RemoveTemplateInstanceType ( types [ n ] ) ; } else { RemoveFromTypeIdMap ( types [ n ] ) ; asDELETE ( types [ n ] , asCObjectType ) ; int i = classTypes . IndexOf ( types [ n ] ) ; if ( i == ( signed ) classTypes . GetLength ( ) - 1 ) classTypes . PopLast ( ) ; else classTypes [ i ] = classTypes . PopLast ( ) ; } // ▁ Remove ▁ the ▁ type ▁ from ▁ the ▁ array ENDCOM if ( n < types . GetLength ( ) - 1 ) types [ n ] = types . PopLast ( ) ; else types . PopLast ( ) ; n -- ; } } if ( didClearTemplateInstanceType == false ) break ; } } void asCScriptEngine :: RemoveTypeAndRelatedFromList ( asCArray < asCObjectType * > & types , asCObjectType * ot ) { // ▁ Remove ▁ the ▁ type ▁ from ▁ the ▁ list ENDCOM int i = types . IndexOf ( ot ) ; if ( i == - 1 ) return ; if ( i == ( signed ) types . GetLength ( ) - 1 ) types . PopLast ( ) ; else types [ i ] = types . PopLast ( ) ; // ▁ If ▁ the ▁ type ▁ is ▁ an ▁ template ▁ type , ▁ then ▁ remove ▁ all ▁ sub ▁ types ▁ as ▁ well ENDCOM if ( ot -> templateSubType . GetObjectType ( ) ) { while ( ot -> templateSubType . GetObjectType ( ) ) { ot = ot -> templateSubType . GetObjectType ( ) ; RemoveTypeAndRelatedFromList ( types , ot ) ; } return ; } // ▁ If ▁ the ▁ type ▁ is ▁ a ▁ class , ▁ then ▁ remove ▁ all ▁ properties ▁ types ▁ as ▁ well ENDCOM if ( ot -> properties . GetLength ( ) ) { for ( asUINT n = 0 ; n < ot -> properties . GetLength ( ) ; n ++ ) RemoveTypeAndRelatedFromList ( types , ot -> properties [ n ] -> type . GetObjectType ( ) ) ; } } // ▁ internal ENDCOM int asCScriptEngine :: GetFactoryIdByDecl ( const asCObjectType * ot , const char * decl ) { asCModule * mod = 0 ; // ▁ Is ▁ this ▁ a ▁ script ▁ class ? ENDCOM if ( ot -> flags & asOBJ_SCRIPT_OBJECT && ot -> size > 0 ) mod = scriptFunctions [ ot -> beh . factory ] -> module ; asCBuilder bld ( this , mod ) ; asCScriptFunction func ( this , mod , - 1 ) ; int r = bld . ParseFunctionDeclaration ( 0 , decl , & func , false ) ; if ( r < 0 ) return asINVALID_DECLARATION ; // ▁ Search ▁ for ▁ matching ▁ factory ▁ function ENDCOM int id = - 1 ; for ( size_t n = 0 ; n < ot -> beh . factories . GetLength ( ) ; n ++ ) { asCScriptFunction * f = scriptFunctions [ ot -> beh . factories [ n ] ] ; if ( f -> IsSignatureEqual ( & func ) ) { id = ot -> beh . factories [ n ] ; break ; } } if ( id == - 1 ) return asNO_FUNCTION ; return id ; } // ▁ internal ENDCOM int asCScriptEngine :: GetMethodIdByDecl ( const asCObjectType * ot , const char * decl , asCModule * mod ) { asCBuilder bld ( this , mod ) ; asCScriptFunction func ( this , mod , - 1 ) ; int r = bld . ParseFunctionDeclaration ( 0 , decl , & func , false ) ; if ( r < 0 ) return asINVALID_DECLARATION ; // ▁ Set ▁ the ▁ object ▁ type ▁ so ▁ that ▁ the ▁ signature ▁ can ▁ be ▁ properly ▁ compared ENDCOM // ▁ This ▁ cast ▁ is ▁ OK , ▁ it ▁ will ▁ only ▁ be ▁ used ▁ for ▁ comparison ENDCOM func . objectType = const_cast < asCObjectType * > ( ot ) ; // ▁ Search ▁ script ▁ functions ▁ for ▁ matching ▁ interface ENDCOM int id = - 1 ; for ( size_t n = 0 ; n < ot -> methods . GetLength ( ) ; ++ n ) { if ( func . IsSignatureEqual ( scriptFunctions [ ot -> methods [ n ] ] ) ) { if ( id == - 1 ) id = ot -> methods [ n ] ; else return asMULTIPLE_FUNCTIONS ; } } if ( id == - 1 ) return asNO_FUNCTION ; return id ; } // ▁ Internal ENDCOM asCString asCScriptEngine :: GetFunctionDeclaration ( int funcID ) { asCString str ; asCScriptFunction * func = GetScriptFunction ( funcID ) ; if ( func ) str = func -> GetDeclarationStr ( ) ; return str ; } asCScriptFunction * asCScriptEngine :: GetScriptFunction ( int funcId ) { if ( funcId < 0 || funcId >= ( int ) scriptFunctions . GetLength ( ) ) return 0 ; return scriptFunctions [ funcId ] ; } asIScriptContext * asCScriptEngine :: CreateContext ( ) { asIScriptContext * ctx = 0 ; CreateContext ( & ctx , false ) ; return ctx ; } int asCScriptEngine :: CreateContext ( asIScriptContext * * context , bool isInternal ) { * context = asNEW ( asCContext ) ( this , ! isInternal ) ; // ▁ We ▁ need ▁ to ▁ make ▁ sure ▁ the ▁ engine ▁ has ▁ been ▁ ENDCOM // ▁ prepared ▁ before ▁ any ▁ context ▁ is ▁ executed ENDCOM PrepareEngine ( ) ; return 0 ; } int asCScriptEngine :: RegisterObjectProperty ( const char * obj , const char * declaration , int byteOffset ) { int r ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; r = bld . ParseDataType ( obj , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; // ▁ Verify ▁ that ▁ the ▁ correct ▁ config ▁ group ▁ is ▁ used ENDCOM if ( currentGroup -> FindType ( dt . GetObjectType ( ) -> name . AddressOf ( ) ) == 0 ) return ConfigError ( asWRONG_CONFIG_GROUP ) ; asCDataType type ; asCString name ; if ( ( r = bld . VerifyProperty ( & dt , declaration , name , type ) ) < 0 ) return ConfigError ( r ) ; // ▁ Store ▁ the ▁ property ▁ info ENDCOM if ( dt . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_OBJECT ) ; asCObjectProperty * prop = asNEW ( asCObjectProperty ) ; prop -> name = name ; prop -> type = type ; prop -> byteOffset = byteOffset ; dt . GetObjectType ( ) -> properties . PushLast ( prop ) ; currentGroup -> RefConfigGroup ( FindConfigGroupForObjectType ( type . GetObjectType ( ) ) ) ; return asSUCCESS ; } int asCScriptEngine :: RegisterInterface ( const char * name ) { if ( name == 0 ) return ConfigError ( asINVALID_NAME ) ; // ▁ Verify ▁ if ▁ the ▁ name ▁ has ▁ been ▁ registered ▁ as ▁ a ▁ type ▁ already ENDCOM asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) return asALREADY_REGISTERED ; } // ▁ Use ▁ builder ▁ to ▁ parse ▁ the ▁ datatype ENDCOM asCDataType dt ; asCBuilder bld ( this , 0 ) ; bool oldMsgCallback = msgCallback ; msgCallback = false ; int r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r >= 0 ) return ConfigError ( asERROR ) ; // ▁ Make ▁ sure ▁ the ▁ name ▁ is ▁ not ▁ a ▁ reserved ▁ keyword ENDCOM asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , strlen ( name ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( name ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; // ▁ Don ' t ▁ have ▁ to ▁ check ▁ against ▁ members ▁ of ▁ object ENDCOM // ▁ types ▁ as ▁ they ▁ are ▁ allowed ▁ to ▁ use ▁ the ▁ names ENDCOM // ▁ Register ▁ the ▁ object ▁ type ▁ for ▁ the ▁ interface ENDCOM asCObjectType * st = asNEW ( asCObjectType ) ( this ) ; st -> flags = asOBJ_REF | asOBJ_SCRIPT_OBJECT ; st -> size = 0 ; // ▁ Cannot ▁ be ▁ instanciated ENDCOM st -> name = name ; // ▁ Use ▁ the ▁ default ▁ script ▁ class ▁ behaviours ENDCOM st -> beh . factory = 0 ; st -> beh . addref = scriptTypeBehaviours . beh . addref ; scriptFunctions [ st -> beh . addref ] -> AddRef ( ) ; st -> beh . release = scriptTypeBehaviours . beh . release ; scriptFunctions [ st -> beh . release ] -> AddRef ( ) ; st -> beh . copy = 0 ; objectTypes . PushLast ( st ) ; registeredObjTypes . PushLast ( st ) ; currentGroup -> objTypes . PushLast ( st ) ; return asSUCCESS ; } int asCScriptEngine :: RegisterInterfaceMethod ( const char * intf , const char * declaration ) { // ▁ Verify ▁ that ▁ the ▁ correct ▁ config ▁ group ▁ is ▁ set . ENDCOM if ( currentGroup -> FindType ( intf ) == 0 ) return ConfigError ( asWRONG_CONFIG_GROUP ) ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( intf , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_INTERFACE ) ; func -> objectType = dt . GetObjectType ( ) ; r = bld . ParseFunctionDeclaration ( func -> objectType , declaration , func , false ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } // ▁ Check ▁ name ▁ conflicts ENDCOM r = bld . CheckNameConflictMember ( dt , func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; func -> objectType -> methods . PushLast ( func -> id ) ; // ▁ The ▁ refCount ▁ was ▁ already ▁ set ▁ to ▁ 1 ENDCOM func -> ComputeSignatureId ( ) ; // ▁ If ▁ parameter ▁ type ▁ from ▁ other ▁ groups ▁ are ▁ used , ▁ add ▁ references ENDCOM // ▁ TODO : ▁ The ▁ code ▁ for ▁ adding ▁ references ▁ to ▁ config ▁ groups ▁ is ▁ repeated ▁ in ▁ a ▁ lot ▁ of ▁ places ENDCOM if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } // ▁ Return ▁ function ▁ id ▁ as ▁ success ENDCOM return func -> id ; } int asCScriptEngine :: RegisterObjectType ( const char * name , int byteSize , asDWORD flags ) { int r ; isPrepared = false ; // ▁ Verify ▁ flags ENDCOM // ▁ Must ▁ have ▁ either ▁ asOBJ _ REF ▁ or ▁ asOBJ _ VALUE ENDCOM if ( flags & asOBJ_REF ) { // ▁ Can ▁ optionally ▁ have ▁ the ▁ asOBJ _ GC , ▁ asOBJ _ NOHANDLE , ▁ asOBJ _ SCOPED , ▁ or ▁ asOBJ _ TEMPLATE ▁ flag ▁ set , ▁ but ▁ nothing ▁ else ENDCOM if ( flags & ~ ( asOBJ_REF | asOBJ_GC | asOBJ_NOHANDLE | asOBJ_SCOPED | asOBJ_TEMPLATE ) ) return ConfigError ( asINVALID_ARG ) ; // ▁ flags ▁ are ▁ exclusive ENDCOM if ( ( flags & asOBJ_GC ) && ( flags & ( asOBJ_NOHANDLE | asOBJ_SCOPED ) ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_NOHANDLE ) && ( flags & ( asOBJ_GC | asOBJ_SCOPED ) ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_SCOPED ) && ( flags & ( asOBJ_GC | asOBJ_NOHANDLE ) ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_VALUE ) { // ▁ Cannot ▁ use ▁ reference ▁ flags ENDCOM // ▁ TODO : ▁ template : ▁ Should ▁ be ▁ possible ▁ to ▁ register ▁ a ▁ value ▁ type ▁ as ▁ template ▁ type ENDCOM if ( flags & ( asOBJ_REF | asOBJ_GC | asOBJ_SCOPED ) ) return ConfigError ( asINVALID_ARG ) ; // ▁ If ▁ the ▁ app ▁ type ▁ is ▁ given , ▁ we ▁ must ▁ validate ▁ the ▁ flags ENDCOM if ( flags & asOBJ_APP_CLASS ) { // ▁ Must ▁ not ▁ set ▁ the ▁ primitive ▁ or ▁ float ▁ flag ENDCOM if ( flags & ( asOBJ_APP_PRIMITIVE | asOBJ_APP_FLOAT ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_APP_PRIMITIVE ) { // ▁ Must ▁ not ▁ set ▁ the ▁ class ▁ flags ▁ nor ▁ the ▁ float ▁ flag ENDCOM if ( flags & ( asOBJ_APP_CLASS | asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT | asOBJ_APP_FLOAT ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_APP_FLOAT ) { // ▁ Must ▁ not ▁ set ▁ the ▁ class ▁ flags ▁ nor ▁ the ▁ primitive ▁ flag ENDCOM if ( flags & ( asOBJ_APP_CLASS | asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT | asOBJ_APP_PRIMITIVE ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & ( asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT ) ) { // ▁ Must ▁ not ▁ set ▁ the ▁ class ▁ properties , ▁ without ▁ the ▁ class ▁ flag ENDCOM return ConfigError ( asINVALID_ARG ) ; } } else return ConfigError ( asINVALID_ARG ) ; // ▁ Don ' t ▁ allow ▁ anything ▁ else ▁ than ▁ the ▁ defined ▁ flags ENDCOM if ( flags - ( flags & asOBJ_MASK_VALID_FLAGS ) ) return ConfigError ( asINVALID_ARG ) ; // ▁ Value ▁ types ▁ must ▁ have ▁ a ▁ defined ▁ size ENDCOM if ( ( flags & asOBJ_VALUE ) && byteSize == 0 ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_VALUE_TYPE_MUST_HAVE_SIZE ) ; return ConfigError ( asINVALID_ARG ) ; } // ▁ Verify ▁ type ▁ name ENDCOM if ( name == 0 ) return ConfigError ( asINVALID_NAME ) ; asCString typeName ; asCBuilder bld ( this , 0 ) ; if ( flags & asOBJ_TEMPLATE ) { asCString subtypeName ; r = bld . ParseTemplateDecl ( name , & typeName , & subtypeName ) ; if ( r < 0 ) return r ; // ▁ Verify ▁ that ▁ the ▁ template ▁ name ▁ hasn ' t ▁ been ▁ registered ▁ as ▁ a ▁ type ▁ already ENDCOM asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = typeName ; type -> size = byteSize ; type -> flags = flags ; // ▁ Store ▁ it ▁ in ▁ the ▁ object ▁ types ENDCOM objectTypes . PushLast ( type ) ; // ▁ Define ▁ a ▁ template ▁ subtype ENDCOM asCObjectType * subtype = 0 ; for ( n = 0 ; n < templateSubTypes . GetLength ( ) ; n ++ ) { if ( templateSubTypes [ n ] -> name == subtypeName ) { subtype = templateSubTypes [ n ] ; break ; } } if ( subtype == 0 ) { // ▁ Create ▁ the ▁ new ▁ subtype ▁ if ▁ not ▁ already ▁ existing ENDCOM subtype = asNEW ( asCObjectType ) ( this ) ; subtype -> name = subtypeName ; subtype -> size = 0 ; subtype -> flags = asOBJ_TEMPLATE_SUBTYPE ; templateSubTypes . PushLast ( subtype ) ; subtype -> AddRef ( ) ; } type -> templateSubType = asCDataType :: CreateObject ( subtype , false ) ; subtype -> AddRef ( ) ; currentGroup -> objTypes . PushLast ( type ) ; if ( defaultArrayObjectType == 0 ) { // ▁ TODO : ▁ The ▁ default ▁ array ▁ object ▁ type ▁ should ▁ be ▁ defined ▁ by ▁ the ▁ application ENDCOM // ▁ The ▁ default ▁ array ▁ object ▁ type ▁ is ▁ registered ▁ by ▁ the ▁ engine ▁ itself ENDCOM defaultArrayObjectType = type ; type -> AddRef ( ) ; } else { registeredObjTypes . PushLast ( type ) ; } } else { typeName = name ; // ▁ Verify ▁ if ▁ the ▁ name ▁ has ▁ been ▁ registered ▁ as ▁ a ▁ type ▁ already ENDCOM asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] && templateTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } // ▁ Verify ▁ the ▁ most ▁ recently ▁ created ▁ template ▁ instance ▁ type ENDCOM asCObjectType * mostRecentTemplateInstanceType = 0 ; if ( templateInstanceTypes . GetLength ( ) ) mostRecentTemplateInstanceType = templateInstanceTypes [ templateInstanceTypes . GetLength ( ) - 1 ] ; // ▁ Use ▁ builder ▁ to ▁ parse ▁ the ▁ datatype ENDCOM asCDataType dt ; bool oldMsgCallback = msgCallback ; msgCallback = false ; r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; // ▁ If ▁ the ▁ builder ▁ fails , ▁ then ▁ the ▁ type ▁ name ENDCOM // ▁ is ▁ new ▁ and ▁ it ▁ should ▁ be ▁ registered ENDCOM if ( r < 0 ) { // ▁ Make ▁ sure ▁ the ▁ name ▁ is ▁ not ▁ a ▁ reserved ▁ keyword ENDCOM asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , typeName . GetLength ( ) , & tokenLen ) ; if ( token != ttIdentifier || typeName . GetLength ( ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; int r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; // ▁ Don ' t ▁ have ▁ to ▁ check ▁ against ▁ members ▁ of ▁ object ENDCOM // ▁ types ▁ as ▁ they ▁ are ▁ allowed ▁ to ▁ use ▁ the ▁ names ENDCOM // ▁ Put ▁ the ▁ data ▁ type ▁ in ▁ the ▁ list ENDCOM asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = typeName ; type -> size = byteSize ; type -> flags = flags ; objectTypes . PushLast ( type ) ; registeredObjTypes . PushLast ( type ) ; currentGroup -> objTypes . PushLast ( type ) ; } else { // ▁ The ▁ application ▁ is ▁ registering ▁ a ▁ template ▁ specialization ▁ so ▁ we ENDCOM // ▁ need ▁ to ▁ replace ▁ the ▁ template ▁ instance ▁ type ▁ with ▁ the ▁ new ▁ type . ENDCOM // ▁ TODO : ▁ Template : ▁ We ▁ don ' t ▁ require ▁ the ▁ lower ▁ dimensions ▁ to ▁ be ▁ registered ▁ first ▁ for ▁ registered ▁ template ▁ types ENDCOM // ▁ int [ ] [ ] ▁ must ▁ not ▁ be ▁ allowed ▁ to ▁ be ▁ registered ENDCOM // ▁ if ▁ int [ ] ▁ hasn ' t ▁ been ▁ registered ▁ first ENDCOM if ( dt . GetSubType ( ) . IsTemplate ( ) ) return ConfigError ( asLOWER_ARRAY_DIMENSION_NOT_REGISTERED ) ; if ( dt . IsReadOnly ( ) || dt . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; // ▁ Was ▁ the ▁ template ▁ instance ▁ type ▁ created ▁ before ? ENDCOM if ( templateInstanceTypes [ templateInstanceTypes . GetLength ( ) - 1 ] == mostRecentTemplateInstanceType || mostRecentTemplateInstanceType == dt . GetObjectType ( ) ) // ▁ TODO : ▁ Should ▁ have ▁ a ▁ better ▁ error ▁ message ENDCOM return ConfigError ( asNOT_SUPPORTED ) ; // ▁ TODO : ▁ Add ▁ this ▁ again . ▁ The ▁ type ▁ is ▁ used ▁ by ▁ the ▁ factory ▁ stubs ▁ so ▁ we ▁ need ▁ to ▁ discount ▁ that ENDCOM // ▁ Is ▁ the ▁ template ▁ instance ▁ type ▁ already ▁ being ▁ used ? ENDCOM // TABSYMBOL TABSYMBOL TABSYMBOL if ( ▁ dt . GetObjectType ( ) - > GetRefCount ( ) ▁ > ▁ 1 ▁ ) ENDCOM // TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL return ▁ ConfigError ( asNOT _ SUPPORTED ) ; ENDCOM // ▁ Put ▁ the ▁ data ▁ type ▁ in ▁ the ▁ list ENDCOM asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = dt . GetObjectType ( ) -> name ; type -> templateSubType = dt . GetSubType ( ) ; if ( type -> templateSubType . GetObjectType ( ) ) type -> templateSubType . GetObjectType ( ) -> AddRef ( ) ; type -> size = byteSize ; type -> flags = flags ; templateTypes . PushLast ( type ) ; currentGroup -> objTypes . PushLast ( type ) ; // ▁ Remove ▁ the ▁ template ▁ instance ▁ type , ▁ which ▁ will ▁ no ▁ longer ▁ be ▁ used . ENDCOM RemoveTemplateInstanceType ( dt . GetObjectType ( ) ) ; } } return asSUCCESS ; } // ▁ interface ENDCOM int asCScriptEngine :: RegisterObjectBehaviour ( const char * datatype , asEBehaviours behaviour , const char * decl , const asSFuncPtr & funcPointer , asDWORD callConv ) { if ( datatype == 0 ) return ConfigError ( asINVALID_ARG ) ; // ▁ Determine ▁ the ▁ object ▁ type ENDCOM asCBuilder bld ( this , 0 ) ; asCDataType type ; int r = bld . ParseDataType ( datatype , & type ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( type . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_TYPE ) ; if ( type . IsReadOnly ( ) || type . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; return RegisterBehaviourToObjectType ( type . GetObjectType ( ) , behaviour , decl , funcPointer , callConv ) ; } // ▁ internal ENDCOM int asCScriptEngine :: RegisterBehaviourToObjectType ( asCObjectType * objectType , asEBehaviours behaviour , const char * decl , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; if ( behaviour == asBEHAVE_FACTORY || behaviour == asBEHAVE_TEMPLATE_CALLBACK ) { # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; } else { # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_THISCALL && callConv != asCALL_CDECL_OBJLAST && callConv != asCALL_CDECL_OBJFIRST && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif int r = DetectCallingConvention ( true , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; } isPrepared = false ; asSTypeBehaviour * beh = & objectType -> beh ; // ▁ Verify ▁ function ▁ declaration ENDCOM asCScriptFunction func ( this , 0 , - 1 ) ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseFunctionDeclaration ( objectType , decl , & func , true , & internal . paramAutoHandles , & internal . returnAutoHandle ) ; if ( r < 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . name . Format ( " _ beh _ % d _ " , behaviour ) ; if ( behaviour != asBEHAVE_FACTORY ) func . objectType = objectType ; // ▁ Check ▁ if ▁ the ▁ method ▁ restricts ▁ that ▁ use ▁ of ▁ the ▁ template ▁ to ▁ value ▁ types ▁ or ▁ reference ▁ types ENDCOM if ( objectType -> flags & asOBJ_TEMPLATE ) { if ( func . returnType . GetObjectType ( ) == objectType -> templateSubType . GetObjectType ( ) ) { if ( func . returnType . IsObjectHandle ( ) ) objectType -> acceptValueSubType = false ; else if ( ! func . returnType . IsReference ( ) ) objectType -> acceptRefSubType = false ; } for ( asUINT n = 0 ; n < func . parameterTypes . GetLength ( ) ; n ++ ) { if ( func . parameterTypes [ n ] . GetObjectType ( ) == objectType -> templateSubType . GetObjectType ( ) ) { // ▁ TODO : ▁ If ▁ unsafe ▁ references ▁ are ▁ allowed , ▁ then ▁ inout ▁ references ▁ allow ▁ value ▁ types ENDCOM if ( func . parameterTypes [ n ] . IsObjectHandle ( ) || ( func . parameterTypes [ n ] . IsReference ( ) && func . inOutFlags [ n ] == asTM_INOUTREF ) ) objectType -> acceptValueSubType = false ; else if ( ! func . parameterTypes [ n ] . IsReference ( ) ) objectType -> acceptRefSubType = false ; } } } if ( behaviour == asBEHAVE_CONSTRUCT ) { // ▁ TODO : ▁ Add ▁ asBEHAVE _ IMPLICIT _ CONSTRUCT ENDCOM // ▁ Verify ▁ that ▁ the ▁ return ▁ type ▁ is ▁ void ENDCOM if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( objectType -> flags & asOBJ_SCRIPT_OBJECT ) { // ▁ The ▁ script ▁ object ▁ is ▁ a ▁ special ▁ case ENDCOM asASSERT ( func . parameterTypes . GetLength ( ) == 1 ) ; beh -> construct = AddBehaviourFunction ( func , internal ) ; beh -> factory = beh -> construct ; scriptFunctions [ beh -> factory ] -> AddRef ( ) ; beh -> constructors . PushLast ( beh -> construct ) ; beh -> factories . PushLast ( beh -> factory ) ; func . id = beh -> construct ; } else { // ▁ Verify ▁ that ▁ it ▁ is ▁ a ▁ value ▁ type ENDCOM if ( ! ( func . objectType -> flags & asOBJ_VALUE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } // ▁ Implicit ▁ constructors ▁ must ▁ take ▁ one ▁ and ▁ only ▁ one ▁ parameter ENDCOM /* TABSYMBOL TABSYMBOL if ( ▁ behaviour ▁ = = ▁ asBEHAVE _ IMPLICIT _ CONSTRUCT ▁ & & STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL func . parameterTypes . GetLength ( ) ▁ ! = ▁ 1 ▁ ) STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL return ▁ ConfigError ( asINVALID _ DECLARATION ) ; STRNEWLINE TABSYMBOL */ // ▁ TODO : ▁ Verify ▁ that ▁ the ▁ same ▁ constructor ▁ hasn ' t ▁ been ▁ registered ▁ already ENDCOM // ▁ Store ▁ all ▁ constructors ▁ in ▁ a ▁ list ENDCOM if ( func . parameterTypes . GetLength ( ) == 0 ) { func . id = beh -> construct = AddBehaviourFunction ( func , internal ) ; beh -> constructors . PushLast ( beh -> construct ) ; } else { func . id = AddBehaviourFunction ( func , internal ) ; beh -> constructors . PushLast ( func . id ) ; /* STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL if ( ▁ behaviour ▁ = = ▁ asBEHAVE _ IMPLICIT _ CONSTRUCT ▁ ) STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL { STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL beh - > operators . PushLast ( behaviour ) ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL beh - > operators . PushLast ( func . id ) ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL } STRNEWLINE TABSYMBOL */ } } } else if ( behaviour == asBEHAVE_DESTRUCT ) { // ▁ Must ▁ be ▁ a ▁ value ▁ type ENDCOM if ( ! ( func . objectType -> flags & asOBJ_VALUE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> destruct ) return ConfigError ( asALREADY_REGISTERED ) ; // ▁ Verify ▁ that ▁ the ▁ return ▁ type ▁ is ▁ void ENDCOM if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ that ▁ there ▁ are ▁ no ▁ parameters ENDCOM if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> destruct = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_FACTORY ) { // ▁ TODO : ▁ Add ▁ asBEHAVE _ IMPLICIT _ FACTORY ENDCOM // ▁ Must ▁ be ▁ a ▁ ref ▁ type ▁ and ▁ must ▁ not ▁ have ▁ asOBJ _ NOHANDLE ENDCOM if ( ! ( objectType -> flags & asOBJ_REF ) || ( objectType -> flags & asOBJ_NOHANDLE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } // ▁ Verify ▁ that ▁ the ▁ return ▁ type ▁ is ▁ a ▁ handle ▁ to ▁ the ▁ type ENDCOM if ( func . returnType != asCDataType :: CreateObjectHandle ( objectType , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Implicit ▁ factories ▁ must ▁ take ▁ one ▁ and ▁ only ▁ one ▁ parameter ENDCOM /* TABSYMBOL TABSYMBOL if ( ▁ behaviour ▁ = = ▁ asBEHAVE _ IMPLICIT _ FACTORY ▁ & & STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL func . parameterTypes . GetLength ( ) ▁ ! = ▁ 1 ▁ ) STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL return ▁ ConfigError ( asINVALID _ DECLARATION ) ; STRNEWLINE */ // ▁ TODO : ▁ Verify ▁ that ▁ the ▁ same ▁ factory ▁ function ▁ hasn ' t ▁ been ▁ registered ▁ already ENDCOM // ▁ The ▁ templates ▁ take ▁ a ▁ hidden ▁ parameter ▁ with ▁ the ▁ object ▁ type ENDCOM if ( ( objectType -> flags & asOBJ_TEMPLATE ) && ( func . parameterTypes . GetLength ( ) == 0 || ! func . parameterTypes [ 0 ] . IsReference ( ) ) ) { return ConfigError ( asINVALID_DECLARATION ) ; } // ▁ Store ▁ all ▁ factory ▁ functions ▁ in ▁ a ▁ list ENDCOM if ( ( func . parameterTypes . GetLength ( ) == 0 ) || ( func . parameterTypes . GetLength ( ) == 1 && ( objectType -> flags & asOBJ_TEMPLATE ) ) ) { func . id = beh -> factory = AddBehaviourFunction ( func , internal ) ; beh -> factories . PushLast ( beh -> factory ) ; } else { func . id = AddBehaviourFunction ( func , internal ) ; beh -> factories . PushLast ( func . id ) ; /* STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL if ( ▁ behaviour ▁ = = ▁ asBEHAVE _ IMPLICIT _ FACTORY ▁ ) STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL { STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL beh - > operators . PushLast ( behaviour ) ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL beh - > operators . PushLast ( func . id ) ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL } STRNEWLINE */ } } else if ( behaviour == asBEHAVE_ADDREF ) { // ▁ Must ▁ be ▁ a ▁ ref ▁ type ▁ and ▁ must ▁ not ▁ have ▁ asOBJ _ NOHANDLE , ▁ nor ▁ asOBJ _ SCOPED ENDCOM if ( ! ( func . objectType -> flags & asOBJ_REF ) || ( func . objectType -> flags & asOBJ_NOHANDLE ) || ( func . objectType -> flags & asOBJ_SCOPED ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> addref ) return ConfigError ( asALREADY_REGISTERED ) ; // ▁ Verify ▁ that ▁ the ▁ return ▁ type ▁ is ▁ void ENDCOM if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ that ▁ there ▁ are ▁ no ▁ parameters ENDCOM if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> addref = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_RELEASE ) { // ▁ Must ▁ be ▁ a ▁ ref ▁ type ▁ and ▁ must ▁ not ▁ have ▁ asOBJ _ NOHANDLE ENDCOM if ( ! ( func . objectType -> flags & asOBJ_REF ) || ( func . objectType -> flags & asOBJ_NOHANDLE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> release ) return ConfigError ( asALREADY_REGISTERED ) ; // ▁ Verify ▁ that ▁ the ▁ return ▁ type ▁ is ▁ void ENDCOM if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ that ▁ there ▁ are ▁ no ▁ parameters ENDCOM if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> release = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_TEMPLATE_CALLBACK ) { // ▁ Must ▁ be ▁ a ▁ template ▁ type ▁ ENDCOM if ( ! ( func . objectType -> flags & asOBJ_TEMPLATE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> templateCallback ) return ConfigError ( asALREADY_REGISTERED ) ; // ▁ Verify ▁ that ▁ the ▁ return ▁ type ▁ is ▁ bool ENDCOM if ( func . returnType != asCDataType :: CreatePrimitive ( ttBool , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ that ▁ there ▁ is ▁ one ▁ parameters ENDCOM if ( func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> templateCallback = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_INDEX ) { // ▁ Verify ▁ that ▁ the ▁ var ▁ type ▁ is ▁ not ▁ used ENDCOM if ( VerifyVarTypeNotInFunction ( & func ) < 0 ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ that ▁ there ▁ is ▁ only ▁ one ▁ parameter ENDCOM if ( func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ that ▁ the ▁ return ▁ type ▁ is ▁ not ▁ void ENDCOM if ( func . returnType . GetTokenType ( ) == ttVoid ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ TODO : ▁ Verify ▁ that ▁ the ▁ operator ▁ hasn ' t ▁ been ▁ registered ▁ already ENDCOM beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else if ( behaviour >= asBEHAVE_FIRST_GC && behaviour <= asBEHAVE_LAST_GC ) { // ▁ Only ▁ allow ▁ GC ▁ behaviours ▁ for ▁ types ▁ registered ▁ to ▁ be ▁ garbage ▁ collected ENDCOM if ( ! ( func . objectType -> flags & asOBJ_GC ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } // ▁ Verify ▁ parameter ▁ count ENDCOM if ( ( behaviour == asBEHAVE_GETREFCOUNT || behaviour == asBEHAVE_SETGCFLAG || behaviour == asBEHAVE_GETGCFLAG ) && func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( behaviour == asBEHAVE_ENUMREFS || behaviour == asBEHAVE_RELEASEREFS ) && func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ return ▁ type ENDCOM if ( behaviour == asBEHAVE_GETREFCOUNT && func . returnType != asCDataType :: CreatePrimitive ( ttInt , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETGCFLAG && func . returnType != asCDataType :: CreatePrimitive ( ttBool , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( behaviour == asBEHAVE_SETGCFLAG || behaviour == asBEHAVE_ENUMREFS || behaviour == asBEHAVE_RELEASEREFS ) && func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETREFCOUNT ) func . id = beh -> gcGetRefCount = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_SETGCFLAG ) func . id = beh -> gcSetFlag = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_GETGCFLAG ) func . id = beh -> gcGetFlag = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_ENUMREFS ) func . id = beh -> gcEnumReferences = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_RELEASEREFS ) func . id = beh -> gcReleaseAllReferences = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_IMPLICIT_VALUE_CAST || behaviour == asBEHAVE_VALUE_CAST ) { // ▁ Verify ▁ parameter ▁ count ENDCOM if ( func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ return ▁ type ENDCOM if ( func . returnType . IsEqualExceptRefAndConst ( asCDataType :: CreatePrimitive ( ttBool , false ) ) ) return ConfigError ( asNOT_SUPPORTED ) ; if ( func . returnType . IsEqualExceptRefAndConst ( asCDataType :: CreatePrimitive ( ttVoid , false ) ) ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ TODO : ▁ verify ▁ that ▁ the ▁ same ▁ cast ▁ is ▁ not ▁ registered ▁ already ▁ ( const ▁ or ▁ non - const ▁ is ▁ treated ▁ the ▁ same ▁ for ▁ the ▁ return ▁ type ) ENDCOM beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else if ( behaviour == asBEHAVE_REF_CAST || behaviour == asBEHAVE_IMPLICIT_REF_CAST ) { // ▁ Verify ▁ parameter ▁ count ENDCOM if ( func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ return ▁ type ENDCOM if ( ! func . returnType . IsObjectHandle ( ) ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ TODO : ▁ verify ▁ that ▁ the ▁ same ▁ cast ▁ is ▁ not ▁ registered ▁ already ▁ ( cosnt ▁ or ▁ non - const ▁ is ▁ treated ▁ the ▁ same ▁ for ▁ the ▁ return ▁ type ) ENDCOM beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else { asASSERT ( false ) ; return ConfigError ( asINVALID_ARG ) ; } // ▁ Return ▁ function ▁ id ▁ as ▁ success ENDCOM return func . id ; } int asCScriptEngine :: VerifyVarTypeNotInFunction ( asCScriptFunction * func ) { // ▁ Don ' t ▁ allow ▁ var ▁ type ▁ in ▁ this ▁ function ENDCOM if ( func -> returnType . GetTokenType ( ) == ttQuestion ) return asINVALID_DECLARATION ; for ( unsigned int n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) if ( func -> parameterTypes [ n ] . GetTokenType ( ) == ttQuestion ) return asINVALID_DECLARATION ; return 0 ; } int asCScriptEngine :: AddBehaviourFunction ( asCScriptFunction & func , asSSystemFunctionInterface & internal ) { asUINT n ; int id = GetNextScriptFunctionId ( ) ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ; newInterface -> func = internal . func ; newInterface -> baseOffset = internal . baseOffset ; newInterface -> callConv = internal . callConv ; newInterface -> scriptReturnSize = internal . scriptReturnSize ; newInterface -> hostReturnInMemory = internal . hostReturnInMemory ; newInterface -> hostReturnFloat = internal . hostReturnFloat ; newInterface -> hostReturnSize = internal . hostReturnSize ; newInterface -> paramSize = internal . paramSize ; newInterface -> takesObjByVal = internal . takesObjByVal ; newInterface -> paramAutoHandles = internal . paramAutoHandles ; newInterface -> returnAutoHandle = internal . returnAutoHandle ; newInterface -> hasAutoHandles = internal . hasAutoHandles ; asCScriptFunction * f = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; asASSERT ( func . name != " " && func . name != " f " ) ; f -> name = func . name ; f -> sysFuncIntf = newInterface ; f -> returnType = func . returnType ; f -> objectType = func . objectType ; f -> id = id ; f -> isReadOnly = func . isReadOnly ; for ( n = 0 ; n < func . parameterTypes . GetLength ( ) ; n ++ ) { f -> parameterTypes . PushLast ( func . parameterTypes [ n ] ) ; f -> inOutFlags . PushLast ( func . inOutFlags [ n ] ) ; } SetScriptFunction ( f ) ; // ▁ If ▁ parameter ▁ type ▁ from ▁ other ▁ groups ▁ are ▁ used , ▁ add ▁ references ENDCOM if ( f -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( f -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( n = 0 ; n < f -> parameterTypes . GetLength ( ) ; n ++ ) { if ( f -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( f -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return id ; } // ▁ interface ENDCOM int asCScriptEngine :: RegisterGlobalProperty ( const char * declaration , void * pointer ) { asCDataType type ; asCString name ; int r ; asCBuilder bld ( this , 0 ) ; if ( ( r = bld . VerifyProperty ( 0 , declaration , name , type ) ) < 0 ) return ConfigError ( r ) ; // ▁ Don ' t ▁ allow ▁ registering ▁ references ▁ as ▁ global ▁ properties ENDCOM if ( type . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; // ▁ Store ▁ the ▁ property ▁ info ENDCOM asCGlobalProperty * prop = AllocateGlobalProperty ( ) ; prop -> name = name ; prop -> type = type ; prop -> SetRegisteredAddress ( pointer ) ; registeredGlobalProps . PushLast ( prop ) ; currentGroup -> globalProps . PushLast ( prop ) ; // ▁ If ▁ from ▁ another ▁ group ▁ add ▁ reference ENDCOM if ( type . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( type . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } return asSUCCESS ; } // ▁ internal ENDCOM asCGlobalProperty * asCScriptEngine :: AllocateGlobalProperty ( ) { asCGlobalProperty * prop = asNEW ( asCGlobalProperty ) ; // ▁ First ▁ check ▁ the ▁ availability ▁ of ▁ a ▁ free ▁ slot ENDCOM if ( freeGlobalPropertyIds . GetLength ( ) ) { prop -> id = freeGlobalPropertyIds . PopLast ( ) ; globalProperties [ prop -> id ] = prop ; return prop ; } prop -> id = ( asUINT ) globalProperties . GetLength ( ) ; globalProperties . PushLast ( prop ) ; return prop ; } // ▁ internal ENDCOM void asCScriptEngine :: FreeUnusedGlobalProperties ( ) { for ( asUINT n = 0 ; n < globalProperties . GetLength ( ) ; n ++ ) { if ( globalProperties [ n ] && globalProperties [ n ] -> refCount . get ( ) == 0 ) { freeGlobalPropertyIds . PushLast ( n ) ; asDELETE ( globalProperties [ n ] , asCGlobalProperty ) ; globalProperties [ n ] = 0 ; } } } // ▁ interface ENDCOM int asCScriptEngine :: GetGlobalPropertyCount ( ) { return ( int ) registeredGlobalProps . GetLength ( ) ; } // ▁ interface ENDCOM // ▁ TODO : ▁ If ▁ the ▁ typeId ▁ ever ▁ encodes ▁ the ▁ const ▁ flag , ▁ then ▁ the ▁ isConst ▁ parameter ▁ should ▁ be ▁ removed ENDCOM int asCScriptEngine :: GetGlobalPropertyByIndex ( asUINT index , const char * * name , int * typeId , bool * isConst , const char * * configGroup , void * * pointer ) { if ( index >= registeredGlobalProps . GetLength ( ) ) return asINVALID_ARG ; if ( name ) * name = registeredGlobalProps [ index ] -> name . AddressOf ( ) ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForGlobalVar ( index ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } if ( typeId ) * typeId = GetTypeIdFromDataType ( registeredGlobalProps [ index ] -> type ) ; if ( isConst ) * isConst = registeredGlobalProps [ index ] -> type . IsReadOnly ( ) ; if ( pointer ) * pointer = registeredGlobalProps [ index ] -> realAddress ; return asSUCCESS ; } // ▁ interface ENDCOM int asCScriptEngine :: RegisterObjectMethod ( const char * obj , const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { if ( obj == 0 ) return ConfigError ( asINVALID_ARG ) ; // ▁ Determine ▁ the ▁ object ▁ type ENDCOM asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( obj , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( dt . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_ARG ) ; return RegisterMethodToObjectType ( dt . GetObjectType ( ) , declaration , funcPointer , callConv ) ; } // ▁ internal ENDCOM int asCScriptEngine :: RegisterMethodToObjectType ( asCObjectType * objectType , const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( true , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; // ▁ We ▁ only ▁ support ▁ these ▁ calling ▁ conventions ▁ for ▁ object ▁ methods ENDCOM # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_THISCALL && callConv != asCALL_CDECL_OBJLAST && callConv != asCALL_CDECL_OBJFIRST && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif isPrepared = false ; // ▁ Put ▁ the ▁ system ▁ function ▁ in ▁ the ▁ list ▁ of ▁ system ▁ functions ENDCOM asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> sysFuncIntf = newInterface ; func -> objectType = objectType ; asCBuilder bld ( this , 0 ) ; r = bld . ParseFunctionDeclaration ( func -> objectType , declaration , func , true , & newInterface -> paramAutoHandles , & newInterface -> returnAutoHandle ) ; if ( r < 0 ) { // ▁ Set ▁ as ▁ dummy ▁ function ▁ before ▁ deleting ENDCOM func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } // ▁ Check ▁ name ▁ conflicts ENDCOM asCDataType x = asCDataType :: CreateObject ( objectType , false ) ; r = bld . CheckNameConflictMember ( x , func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; func -> objectType -> methods . PushLast ( func -> id ) ; SetScriptFunction ( func ) ; // ▁ TODO : ▁ This ▁ code ▁ is ▁ repeated ▁ in ▁ many ▁ places ENDCOM // ▁ If ▁ parameter ▁ type ▁ from ▁ other ▁ groups ▁ are ▁ used , ▁ add ▁ references ENDCOM if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } // ▁ Check ▁ if ▁ the ▁ method ▁ restricts ▁ that ▁ use ▁ of ▁ the ▁ template ▁ to ▁ value ▁ types ▁ or ▁ reference ▁ types ENDCOM if ( func -> objectType -> flags & asOBJ_TEMPLATE ) { if ( func -> returnType . GetObjectType ( ) == func -> objectType -> templateSubType . GetObjectType ( ) ) { if ( func -> returnType . IsObjectHandle ( ) ) func -> objectType -> acceptValueSubType = false ; else if ( ! func -> returnType . IsReference ( ) ) func -> objectType -> acceptRefSubType = false ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) == func -> objectType -> templateSubType . GetObjectType ( ) ) { // ▁ TODO : ▁ If ▁ unsafe ▁ references ▁ are ▁ allowed , ▁ then ▁ inout ▁ references ▁ allow ▁ value ▁ types ENDCOM if ( func -> parameterTypes [ n ] . IsObjectHandle ( ) || ( func -> parameterTypes [ n ] . IsReference ( ) && func -> inOutFlags [ n ] == asTM_INOUTREF ) ) func -> objectType -> acceptValueSubType = false ; else if ( ! func -> parameterTypes [ n ] . IsReference ( ) ) func -> objectType -> acceptRefSubType = false ; } } } // ▁ TODO : ▁ beh . copy ▁ member ▁ will ▁ be ▁ removed , ▁ so ▁ this ▁ is ▁ not ▁ necessary ENDCOM // ▁ Is ▁ this ▁ the ▁ default ▁ copy ▁ behaviour ? ENDCOM if ( func -> name == " opAssign " && func -> parameterTypes . GetLength ( ) == 1 && func -> isReadOnly == false && ( objectType -> flags & asOBJ_SCRIPT_OBJECT || func -> parameterTypes [ 0 ] . IsEqualExceptRefAndConst ( asCDataType :: CreateObject ( func -> objectType , false ) ) ) ) { func -> objectType -> beh . copy = func -> id ; func -> AddRef ( ) ; } // ▁ Return ▁ the ▁ function ▁ id ▁ as ▁ success ENDCOM return func -> id ; } // ▁ interface ENDCOM int asCScriptEngine :: RegisterGlobalFunction ( const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_CDECL && callConv != asCALL_STDCALL && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif isPrepared = false ; // ▁ Put ▁ the ▁ system ▁ function ▁ in ▁ the ▁ list ▁ of ▁ system ▁ functions ENDCOM asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> sysFuncIntf = newInterface ; asCBuilder bld ( this , 0 ) ; r = bld . ParseFunctionDeclaration ( 0 , declaration , func , true , & newInterface -> paramAutoHandles , & newInterface -> returnAutoHandle ) ; if ( r < 0 ) { // ▁ Set ▁ as ▁ dummy ▁ function ▁ before ▁ deleting ENDCOM func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } // ▁ Check ▁ name ▁ conflicts ENDCOM r = bld . CheckNameConflict ( func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; currentGroup -> scriptFunctions . PushLast ( func ) ; registeredGlobalFuncs . PushLast ( func ) ; // ▁ If ▁ parameter ▁ type ▁ from ▁ other ▁ groups ▁ are ▁ used , ▁ add ▁ references ENDCOM if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } // ▁ Return ▁ the ▁ function ▁ id ▁ as ▁ success ENDCOM return func -> id ; } // ▁ interface ENDCOM int asCScriptEngine :: GetGlobalFunctionCount ( ) { return ( int ) registeredGlobalFuncs . GetLength ( ) ; } // ▁ interface ENDCOM int asCScriptEngine :: GetGlobalFunctionIdByIndex ( asUINT index ) { if ( index >= registeredGlobalFuncs . GetLength ( ) ) return asINVALID_ARG ; return registeredGlobalFuncs [ index ] -> id ; } asCObjectType * asCScriptEngine :: GetObjectType ( const char * type ) { // ▁ TODO : ▁ optimize : ▁ Improve ▁ linear ▁ search ENDCOM for ( asUINT n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) if ( objectTypes [ n ] && objectTypes [ n ] -> name == type ) // ▁ TODO : ▁ template : ▁ Should ▁ we ▁ check ▁ the ▁ subtype ▁ in ▁ case ▁ of ▁ template ▁ instances ? ENDCOM return objectTypes [ n ] ; return 0 ; } void asCScriptEngine :: PrepareEngine ( ) { if ( isPrepared ) return ; if ( configFailed ) return ; asUINT n ; for ( n = 0 ; n < scriptFunctions . GetLength ( ) ; n ++ ) { // ▁ Determine ▁ the ▁ host ▁ application ▁ interface ENDCOM if ( scriptFunctions [ n ] && scriptFunctions [ n ] -> funcType == asFUNC_SYSTEM ) { if ( scriptFunctions [ n ] -> sysFuncIntf -> callConv == ICC_GENERIC_FUNC || scriptFunctions [ n ] -> sysFuncIntf -> callConv == ICC_GENERIC_METHOD ) PrepareSystemFunctionGeneric ( scriptFunctions [ n ] , scriptFunctions [ n ] -> sysFuncIntf , this ) ; else PrepareSystemFunction ( scriptFunctions [ n ] , scriptFunctions [ n ] -> sysFuncIntf , this ) ; } } // ▁ Validate ▁ object ▁ type ▁ registrations ENDCOM for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && ! ( objectTypes [ n ] -> flags & asOBJ_SCRIPT_OBJECT ) ) { bool missingBehaviour = false ; const char * infoMsg = 0 ; // ▁ Verify ▁ that ▁ GC ▁ types ▁ have ▁ all ▁ behaviours ENDCOM if ( objectTypes [ n ] -> flags & asOBJ_GC ) { if ( objectTypes [ n ] -> beh . addref == 0 || objectTypes [ n ] -> beh . release == 0 || objectTypes [ n ] -> beh . gcGetRefCount == 0 || objectTypes [ n ] -> beh . gcSetFlag == 0 || objectTypes [ n ] -> beh . gcGetFlag == 0 || objectTypes [ n ] -> beh . gcEnumReferences == 0 || objectTypes [ n ] -> beh . gcReleaseAllReferences == 0 ) { infoMsg = TXT_GC_REQUIRE_ADD_REL_GC_BEHAVIOUR ; missingBehaviour = true ; } } // ▁ Verify ▁ that ▁ scoped ▁ ref ▁ types ▁ have ▁ the ▁ release ▁ behaviour ENDCOM else if ( objectTypes [ n ] -> flags & asOBJ_SCOPED ) { if ( objectTypes [ n ] -> beh . release == 0 ) { infoMsg = TXT_SCOPE_REQUIRE_REL_BEHAVIOUR ; missingBehaviour = true ; } } // ▁ Verify ▁ that ▁ ref ▁ types ▁ have ▁ add ▁ ref ▁ and ▁ release ▁ behaviours ENDCOM else if ( ( objectTypes [ n ] -> flags & asOBJ_REF ) && ! ( objectTypes [ n ] -> flags & asOBJ_NOHANDLE ) ) { if ( objectTypes [ n ] -> beh . addref == 0 || objectTypes [ n ] -> beh . release == 0 ) { infoMsg = TXT_REF_REQUIRE_ADD_REL_BEHAVIOUR ; missingBehaviour = true ; } } // ▁ Verify ▁ that ▁ non - pod ▁ value ▁ types ▁ have ▁ the ▁ constructor ▁ and ▁ destructor ▁ registered ENDCOM else if ( ( objectTypes [ n ] -> flags & asOBJ_VALUE ) && ! ( objectTypes [ n ] -> flags & asOBJ_POD ) ) { if ( objectTypes [ n ] -> beh . construct == 0 || objectTypes [ n ] -> beh . destruct == 0 ) { infoMsg = TXT_NON_POD_REQUIRE_CONSTR_DESTR_BEHAVIOUR ; missingBehaviour = true ; } } if ( missingBehaviour ) { asCString str ; str . Format ( TXT_TYPE_s_IS_MISSING_BEHAVIOURS , objectTypes [ n ] -> name . AddressOf ( ) ) ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , str . AddressOf ( ) ) ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_INFORMATION , infoMsg ) ; ConfigError ( asINVALID_CONFIGURATION ) ; } } } isPrepared = true ; } int asCScriptEngine :: ConfigError ( int err ) { configFailed = true ; return err ; } // ▁ interface ENDCOM int asCScriptEngine :: RegisterStringFactory ( const char * datatype , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_CDECL && callConv != asCALL_STDCALL && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif // ▁ Put ▁ the ▁ system ▁ function ▁ in ▁ the ▁ list ▁ of ▁ system ▁ functions ENDCOM asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> name = " _ string _ factory _ " ; func -> sysFuncIntf = newInterface ; asCBuilder bld ( this , 0 ) ; asCDataType dt ; r = bld . ParseDataType ( datatype , & dt ) ; if ( r < 0 ) { // ▁ Set ▁ as ▁ dummy ▁ before ▁ deleting ENDCOM func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_TYPE ) ; } func -> returnType = dt ; func -> parameterTypes . PushLast ( asCDataType :: CreatePrimitive ( ttInt , true ) ) ; asCDataType parm1 = asCDataType :: CreatePrimitive ( ttUInt8 , true ) ; parm1 . MakeReference ( true ) ; func -> parameterTypes . PushLast ( parm1 ) ; func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; stringFactory = func ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; if ( group == 0 ) group = & defaultGroup ; group -> scriptFunctions . PushLast ( func ) ; } // ▁ Register ▁ function ▁ id ▁ as ▁ success ENDCOM return func -> id ; } // ▁ interface ENDCOM int asCScriptEngine :: GetStringFactoryReturnTypeId ( ) { if ( stringFactory == 0 ) return asNO_FUNCTION ; return GetTypeIdFromDataType ( stringFactory -> returnType ) ; } // ▁ interface ENDCOM asCModule * asCScriptEngine :: GetModule ( const char * _name , bool create ) { // ▁ Accept ▁ null ▁ as ▁ well ▁ as ▁ zero - length ▁ string ENDCOM const char * name = " " ; if ( _name != 0 ) name = _name ; if ( lastModule && lastModule -> name == name ) return lastModule ; // ▁ TODO : ▁ optimize : ▁ Improve ▁ linear ▁ search ENDCOM for ( asUINT n = 0 ; n < scriptModules . GetLength ( ) ; ++ n ) if ( scriptModules [ n ] && scriptModules [ n ] -> name == name ) { lastModule = scriptModules [ n ] ; return lastModule ; } if ( create ) { asCModule * module = asNEW ( asCModule ) ( name , this ) ; scriptModules . PushLast ( module ) ; lastModule = module ; return lastModule ; } return 0 ; } asCModule * asCScriptEngine :: GetModuleFromFuncId ( int id ) { if ( id < 0 ) return 0 ; if ( id >= ( int ) scriptFunctions . GetLength ( ) ) return 0 ; asCScriptFunction * func = scriptFunctions [ id ] ; if ( func == 0 ) return 0 ; return func -> module ; } // ▁ internal ENDCOM int asCScriptEngine :: RequestBuild ( ) { ENTERCRITICALSECTION ( engineCritical ) ; if ( isBuilding ) { LEAVECRITICALSECTION ( engineCritical ) ; return asBUILD_IN_PROGRESS ; } isBuilding = true ; LEAVECRITICALSECTION ( engineCritical ) ; return 0 ; } // ▁ internal ENDCOM void asCScriptEngine :: BuildCompleted ( ) { // ▁ Always ▁ free ▁ up ▁ pooled ▁ memory ▁ after ▁ a ▁ completed ▁ build ENDCOM memoryMgr . FreeUnusedMemory ( ) ; isBuilding = false ; } # ifdef AS_DEPRECATED // ▁ Deprecated ▁ since ▁ 2009-12-08 , ▁ 2.18.0 ENDCOM // ▁ interface ENDCOM int asCScriptEngine :: ExecuteString ( const char * module , const char * script , asIScriptContext * * ctx , asDWORD flags ) { int r ; if ( ( r = RequestBuild ( ) ) < 0 ) return r ; PrepareEngine ( ) ; // ▁ Make ▁ sure ▁ the ▁ config ▁ worked ENDCOM if ( configFailed ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) * ctx = 0 ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_INVALID_CONFIGURATION ) ; isBuilding = false ; return asINVALID_CONFIGURATION ; } asIScriptContext * exec = 0 ; if ( ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { int r = CreateContext ( & exec , false ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) * ctx = 0 ; isBuilding = false ; return r ; } if ( ctx ) { * ctx = exec ; exec -> AddRef ( ) ; } } else { if ( * ctx == 0 ) { isBuilding = false ; return asINVALID_ARG ; } exec = * ctx ; exec -> AddRef ( ) ; } // ▁ Make ▁ sure ▁ the ▁ context ▁ isn ' t ▁ holding ▁ a ▁ reference ▁ to ▁ the ▁ previous ▁ ExecuteString ▁ function ( ) ENDCOM exec -> Unprepare ( ) ; // ▁ Get ▁ the ▁ module ▁ to ▁ compile ▁ the ▁ string ▁ in ENDCOM asCModule * mod = GetModule ( module , true ) ; // ▁ Compile ▁ string ▁ function ENDCOM asCBuilder builder ( this , mod ) ; asCString str = script ; str = " void ▁ ExecuteString ( ) { \n " + str + " \n ; } " ; r = builder . BuildString ( str . AddressOf ( ) , ( asCContext * ) exec ) ; BuildCompleted ( ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { ( * ctx ) -> Release ( ) ; * ctx = 0 ; } exec -> Release ( ) ; return asERROR ; } // ▁ Prepare ▁ and ▁ execute ▁ the ▁ context ENDCOM r = ( ( asCContext * ) exec ) -> Prepare ( ( ( asCContext * ) exec ) -> stringFunction -> id ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { ( * ctx ) -> Release ( ) ; * ctx = 0 ; } exec -> Release ( ) ; return r ; } if ( flags & asEXECSTRING_ONLY_PREPARE ) r = asEXECUTION_PREPARED ; else r = exec -> Execute ( ) ; exec -> Release ( ) ; return r ; } # endif void asCScriptEngine :: RemoveTemplateInstanceType ( asCObjectType * t ) { int n ; // ▁ Destroy ▁ the ▁ factory ▁ stubs ENDCOM for ( n = 0 ; n < ( int ) t -> beh . factories . GetLength ( ) ; n ++ ) { // ▁ Make ▁ sure ▁ the ▁ factory ▁ stub ▁ isn ' t ▁ referencing ▁ this ▁ object ▁ anymore ENDCOM scriptFunctions [ t -> beh . factories [ n ] ] -> ReleaseAllHandles ( this ) ; scriptFunctions [ t -> beh . factories [ n ] ] -> Release ( ) ; } t -> beh . factories . SetLength ( 0 ) ; // ▁ Destroy ▁ the ▁ specialized ▁ functions ENDCOM for ( n = 1 ; n < ( int ) t -> beh . operators . GetLength ( ) ; n += 2 ) { if ( t -> beh . operators [ n ] && scriptFunctions [ t -> beh . operators [ n ] ] -> objectType == t ) { scriptFunctions [ t -> beh . operators [ n ] ] -> Release ( ) ; } } t -> beh . operators . SetLength ( 0 ) ; // ▁ Start ▁ searching ▁ from ▁ the ▁ end ▁ of ▁ the ▁ list , ▁ as ▁ most ▁ of ENDCOM // ▁ the ▁ time ▁ it ▁ will ▁ be ▁ the ▁ last ▁ two ▁ types ENDCOM for ( n = ( int ) templateTypes . GetLength ( ) - 1 ; n >= 0 ; n -- ) { if ( templateTypes [ n ] == t ) { if ( n == ( signed ) templateTypes . GetLength ( ) - 1 ) templateTypes . PopLast ( ) ; else templateTypes [ n ] = templateTypes . PopLast ( ) ; } } for ( n = ( int ) templateInstanceTypes . GetLength ( ) - 1 ; n >= 0 ; n -- ) { if ( templateInstanceTypes [ n ] == t ) { if ( n == ( signed ) templateInstanceTypes . GetLength ( ) - 1 ) templateInstanceTypes . PopLast ( ) ; else templateInstanceTypes [ n ] = templateInstanceTypes . PopLast ( ) ; } } asDELETE ( t , asCObjectType ) ; } asCObjectType * asCScriptEngine :: GetTemplateInstanceType ( asCObjectType * templateType , asCDataType & subType ) { asUINT n ; // ▁ Is ▁ there ▁ any ▁ template ▁ instance ▁ type ▁ or ▁ template ▁ specialization ▁ already ▁ with ▁ this ▁ subtype ? ENDCOM for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] && templateTypes [ n ] -> name == templateType -> name && templateTypes [ n ] -> templateSubType == subType ) return templateTypes [ n ] ; } // ▁ No ▁ previous ▁ template ▁ instance ▁ exists ENDCOM // ▁ Make ▁ sure ▁ this ▁ template ▁ supports ▁ the ▁ subtype ENDCOM if ( ! templateType -> acceptValueSubType && ( subType . IsPrimitive ( ) || ( subType . GetObjectType ( ) -> flags & asOBJ_VALUE ) ) ) return 0 ; if ( ! templateType -> acceptRefSubType && ( subType . IsObject ( ) && ( subType . GetObjectType ( ) -> flags & asOBJ_REF ) ) ) return 0 ; // ▁ Create ▁ a ▁ new ▁ template ▁ instance ▁ type ▁ based ▁ on ▁ the ▁ templateType ENDCOM asCObjectType * ot = asNEW ( asCObjectType ) ( this ) ; ot -> templateSubType = subType ; ot -> flags = templateType -> flags ; ot -> size = templateType -> size ; ot -> name = templateType -> name ; // ▁ Before ▁ filling ▁ in ▁ the ▁ methods , ▁ call ▁ the ▁ template ▁ instance ▁ callback ▁ behaviour ▁ to ▁ validate ▁ the ▁ type ENDCOM if ( templateType -> beh . templateCallback ) { asCScriptFunction * callback = scriptFunctions [ templateType -> beh . templateCallback ] ; if ( ! CallGlobalFunctionRetBool ( ot , 0 , callback -> sysFuncIntf , callback ) ) { // ▁ The ▁ type ▁ cannot ▁ be ▁ instanciated ENDCOM ot -> templateSubType = asCDataType ( ) ; asDELETE ( ot , asCObjectType ) ; return 0 ; } } ot -> methods = templateType -> methods ; for ( n = 0 ; n < ot -> methods . GetLength ( ) ; n ++ ) scriptFunctions [ ot -> methods [ n ] ] -> AddRef ( ) ; // ▁ Store ▁ the ▁ real ▁ factory ▁ in ▁ the ▁ constructor ENDCOM ot -> beh . construct = templateType -> beh . factory ; ot -> beh . constructors = templateType -> beh . factories ; for ( n = 0 ; n < ot -> beh . constructors . GetLength ( ) ; n ++ ) scriptFunctions [ ot -> beh . constructors [ n ] ] -> AddRef ( ) ; // ▁ Generate ▁ factory ▁ stubs ▁ for ▁ each ▁ of ▁ the ▁ factories ENDCOM for ( n = 0 ; n < templateType -> beh . factories . GetLength ( ) ; n ++ ) { int factoryId = templateType -> beh . factories [ n ] ; asCScriptFunction * factory = scriptFunctions [ factoryId ] ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SCRIPT ) ; func -> name = " factstub " ; func -> id = GetNextScriptFunctionId ( ) ; func -> returnType = asCDataType :: CreateObjectHandle ( ot , false ) ; // ▁ Skip ▁ the ▁ first ▁ parameter ▁ as ▁ this ▁ is ▁ the ▁ object ▁ type ▁ pointer ▁ that ▁ the ▁ stub ▁ will ▁ add ENDCOM for ( asUINT p = 1 ; p < factory -> parameterTypes . GetLength ( ) ; p ++ ) { func -> parameterTypes . PushLast ( factory -> parameterTypes [ p ] ) ; func -> inOutFlags . PushLast ( factory -> inOutFlags [ p ] ) ; } SetScriptFunction ( func ) ; asCBuilder builder ( this , 0 ) ; asCCompiler compiler ( this ) ; compiler . CompileTemplateFactoryStub ( & builder , factoryId , ot , func ) ; // ▁ The ▁ function ' s ▁ refCount ▁ was ▁ already ▁ initialized ▁ to ▁ 1 ENDCOM ot -> beh . factories . PushLast ( func -> id ) ; } if ( ot -> beh . factories . GetLength ( ) ) ot -> beh . factory = ot -> beh . factories [ 0 ] ; else { asASSERT ( false ) ; ot -> beh . factory = templateType -> beh . factory ; } ot -> beh . addref = templateType -> beh . addref ; if ( scriptFunctions [ ot -> beh . addref ] ) scriptFunctions [ ot -> beh . addref ] -> AddRef ( ) ; ot -> beh . release = templateType -> beh . release ; if ( scriptFunctions [ ot -> beh . release ] ) scriptFunctions [ ot -> beh . release ] -> AddRef ( ) ; ot -> beh . copy = templateType -> beh . copy ; if ( scriptFunctions [ ot -> beh . copy ] ) scriptFunctions [ ot -> beh . copy ] -> AddRef ( ) ; ot -> beh . operators = templateType -> beh . operators ; for ( n = 1 ; n < ot -> beh . operators . GetLength ( ) ; n += 2 ) { scriptFunctions [ ot -> beh . operators [ n ] ] -> AddRef ( ) ; } ot -> beh . gcGetRefCount = templateType -> beh . gcGetRefCount ; if ( scriptFunctions [ ot -> beh . gcGetRefCount ] ) scriptFunctions [ ot -> beh . gcGetRefCount ] -> AddRef ( ) ; ot -> beh . gcSetFlag = templateType -> beh . gcSetFlag ; if ( scriptFunctions [ ot -> beh . gcSetFlag ] ) scriptFunctions [ ot -> beh . gcSetFlag ] -> AddRef ( ) ; ot -> beh . gcGetFlag = templateType -> beh . gcGetFlag ; if ( scriptFunctions [ ot -> beh . gcGetFlag ] ) scriptFunctions [ ot -> beh . gcGetFlag ] -> AddRef ( ) ; ot -> beh . gcEnumReferences = templateType -> beh . gcEnumReferences ; if ( scriptFunctions [ ot -> beh . gcEnumReferences ] ) scriptFunctions [ ot -> beh . gcEnumReferences ] -> AddRef ( ) ; ot -> beh . gcReleaseAllReferences = templateType -> beh . gcReleaseAllReferences ; if ( scriptFunctions [ ot -> beh . gcReleaseAllReferences ] ) scriptFunctions [ ot -> beh . gcReleaseAllReferences ] -> AddRef ( ) ; // ▁ As ▁ the ▁ new ▁ template ▁ type ▁ is ▁ instanciated , ▁ the ▁ engine ▁ should ENDCOM // ▁ generate ▁ new ▁ functions ▁ to ▁ substitute ▁ the ▁ ones ▁ with ▁ the ▁ template ▁ subtype . ENDCOM for ( n = 1 ; n < ot -> beh . operators . GetLength ( ) ; n += 2 ) { int funcId = ot -> beh . operators [ n ] ; asCScriptFunction * func = scriptFunctions [ funcId ] ; if ( GenerateNewTemplateFunction ( templateType , ot , subType , func , & func ) ) { // ▁ Release ▁ the ▁ old ▁ function , ▁ the ▁ new ▁ one ▁ already ▁ has ▁ its ▁ ref ▁ count ▁ set ▁ to ▁ 1 ENDCOM scriptFunctions [ ot -> beh . operators [ n ] ] -> Release ( ) ; ot -> beh . operators [ n ] = func -> id ; } } // ▁ As ▁ the ▁ new ▁ template ▁ type ▁ is ▁ instanciated , ▁ the ▁ engine ▁ should ENDCOM // ▁ generate ▁ new ▁ functions ▁ to ▁ substitute ▁ the ▁ ones ▁ with ▁ the ▁ template ▁ subtype . ENDCOM for ( n = 0 ; n < ot -> methods . GetLength ( ) ; n ++ ) { int funcId = ot -> methods [ n ] ; asCScriptFunction * func = scriptFunctions [ funcId ] ; if ( GenerateNewTemplateFunction ( templateType , ot , subType , func , & func ) ) { // ▁ Release ▁ the ▁ old ▁ function , ▁ the ▁ new ▁ one ▁ already ▁ has ▁ its ▁ ref ▁ count ▁ set ▁ to ▁ 1 ENDCOM scriptFunctions [ ot -> methods [ n ] ] -> Release ( ) ; ot -> methods [ n ] = func -> id ; } } // ▁ Increase ▁ ref ▁ counter ▁ for ▁ sub ▁ type ▁ if ▁ it ▁ is ▁ an ▁ object ▁ type ENDCOM if ( ot -> templateSubType . GetObjectType ( ) ) ot -> templateSubType . GetObjectType ( ) -> AddRef ( ) ; // ▁ Verify ▁ if ▁ the ▁ subtype ▁ contains ▁ a ▁ garbage ▁ collected ▁ object , ▁ in ▁ which ▁ case ▁ this ▁ template ▁ is ▁ a ▁ potential ▁ circular ▁ reference ENDCOM // ▁ TODO : ▁ We ▁ may ▁ be ▁ a ▁ bit ▁ smarter ▁ here . ▁ If ▁ we ▁ can ▁ guarantee ▁ that ▁ the ▁ array ▁ type ▁ cannot ▁ be ▁ part ▁ of ▁ the ENDCOM // ▁ potential ▁ circular ▁ reference ▁ then ▁ we ▁ don ' t ▁ need ▁ to ▁ set ▁ the ▁ flag ENDCOM if ( ot -> templateSubType . GetObjectType ( ) && ( ot -> templateSubType . GetObjectType ( ) -> flags & asOBJ_GC ) ) ot -> flags |= asOBJ_GC ; else if ( ot -> name == defaultArrayObjectType -> name ) ot -> flags &= ~ asOBJ_GC ; templateTypes . PushLast ( ot ) ; // ▁ We ▁ need ▁ to ▁ store ▁ the ▁ object ▁ type ▁ somewhere ▁ for ▁ clean - up ▁ later ENDCOM // ▁ TODO : ▁ Why ▁ do ▁ we ▁ need ▁ both ▁ templateTypes ▁ and ▁ templateInstanceTypes ? ▁ It ▁ is ▁ possible ▁ to ▁ differ ▁ between ▁ template ▁ instance ▁ and ▁ template ▁ specialization ▁ by ▁ checking ▁ for ▁ the ▁ asOBJ _ TEMPLATE ▁ flag ENDCOM templateInstanceTypes . PushLast ( ot ) ; return ot ; } bool asCScriptEngine :: GenerateNewTemplateFunction ( asCObjectType * templateType , asCObjectType * ot , asCDataType & subType , asCScriptFunction * func , asCScriptFunction * * newFunc ) { bool needNewFunc = false ; if ( func -> returnType . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) || func -> returnType . GetObjectType ( ) == templateType ) needNewFunc = true ; else { for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) || func -> parameterTypes [ p ] . GetObjectType ( ) == templateType ) { needNewFunc = true ; break ; } } } if ( needNewFunc ) { asCScriptFunction * func2 = asNEW ( asCScriptFunction ) ( this , 0 , func -> funcType ) ; func2 -> name = func -> name ; func2 -> id = GetNextScriptFunctionId ( ) ; if ( func -> returnType . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) ) { func2 -> returnType = subType ; if ( func -> returnType . IsObjectHandle ( ) ) func2 -> returnType . MakeHandle ( true , true ) ; func2 -> returnType . MakeReference ( func -> returnType . IsReference ( ) ) ; func2 -> returnType . MakeReadOnly ( func -> returnType . IsReadOnly ( ) ) ; } else if ( func -> returnType . GetObjectType ( ) == templateType ) { if ( func2 -> returnType . IsObjectHandle ( ) ) func2 -> returnType = asCDataType :: CreateObjectHandle ( ot , false ) ; else func2 -> returnType = asCDataType :: CreateObject ( ot , false ) ; func2 -> returnType . MakeReference ( func -> returnType . IsReference ( ) ) ; func2 -> returnType . MakeReadOnly ( func -> returnType . IsReadOnly ( ) ) ; } else func2 -> returnType = func -> returnType ; func2 -> parameterTypes . SetLength ( func -> parameterTypes . GetLength ( ) ) ; for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) ) { func2 -> parameterTypes [ p ] = subType ; if ( func -> parameterTypes [ p ] . IsObjectHandle ( ) ) func2 -> parameterTypes [ p ] . MakeHandle ( true ) ; func2 -> parameterTypes [ p ] . MakeReference ( func -> parameterTypes [ p ] . IsReference ( ) ) ; func2 -> parameterTypes [ p ] . MakeReadOnly ( func -> parameterTypes [ p ] . IsReference ( ) ) ; } else if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType ) { if ( func2 -> parameterTypes [ p ] . IsObjectHandle ( ) ) func2 -> parameterTypes [ p ] = asCDataType :: CreateObjectHandle ( ot , false ) ; else func2 -> parameterTypes [ p ] = asCDataType :: CreateObject ( ot , false ) ; func2 -> parameterTypes [ p ] . MakeReference ( func -> parameterTypes [ p ] . IsReference ( ) ) ; func2 -> parameterTypes [ p ] . MakeReadOnly ( func -> parameterTypes [ p ] . IsReadOnly ( ) ) ; } else func2 -> parameterTypes [ p ] = func -> parameterTypes [ p ] ; } // ▁ TODO : ▁ template : ▁ Must ▁ be ▁ careful ▁ when ▁ instanciating ▁ templates ▁ for ▁ garbage ▁ collected ▁ types ENDCOM // ▁ If ▁ the ▁ template ▁ hasn ' t ▁ been ▁ registered ▁ with ▁ the ▁ behaviours , ▁ it ▁ shouldn ' t ENDCOM // ▁ permit ▁ instanciation ▁ of ▁ garbage ▁ collected ▁ types ▁ that ▁ in ▁ turn ▁ may ▁ refer ▁ to ENDCOM // ▁ this ▁ instance . ENDCOM func2 -> inOutFlags = func -> inOutFlags ; func2 -> isReadOnly = func -> isReadOnly ; func2 -> objectType = ot ; func2 -> stackNeeded = func -> stackNeeded ; func2 -> sysFuncIntf = asNEW ( asSSystemFunctionInterface ) ( * func -> sysFuncIntf ) ; SetScriptFunction ( func2 ) ; // ▁ Return ▁ the ▁ new ▁ function ENDCOM * newFunc = func2 ; } return needNewFunc ; } void asCScriptEngine :: CallObjectMethod ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; CallObjectMethod ( obj , s -> sysFuncIntf , s ) ; } void asCScriptEngine :: CallObjectMethod ( void * obj , asSSystemFunctionInterface * i , asCScriptFunction * s ) { # ifdef __GNUC__ if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { // ▁ For ▁ virtual ▁ thiscalls ▁ we ▁ must ▁ call ▁ the ▁ method ▁ as ▁ a ▁ true ▁ class ▁ method ENDCOM // ▁ so ▁ that ▁ the ▁ compiler ▁ will ▁ lookup ▁ the ▁ function ▁ address ▁ in ▁ the ▁ vftable ENDCOM union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asPWORD baseOffset ; // ▁ Same ▁ size ▁ as ▁ the ▁ pointer ENDCOM } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = asPWORD ( i -> baseOffset ) ; void ( asCSimpleDummy :: * f ) ( ) = p . mthd ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else /* if ( ▁ i - > callConv ▁ = = ▁ ICC _ THISCALL ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJLAST ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJFIRST ▁ ) */ { // ▁ Non - virtual ▁ thiscall ▁ can ▁ be ▁ called ▁ just ▁ like ▁ any ▁ global ▁ function , ▁ passing ▁ the ▁ object ▁ as ▁ the ▁ first ▁ parameter ENDCOM void ( * f ) ( void * ) = ( void ( * ) ( void * ) ) ( i -> func ) ; f ( obj ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; void ( asCSimpleDummy :: * f ) ( ) = p . mthd ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else # endif if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else /* if ( ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJLAST ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJFIRST ▁ ) */ { void ( * f ) ( void * ) = ( void ( * ) ( void * ) ) ( i -> func ) ; f ( obj ) ; } # endif } bool asCScriptEngine :: CallObjectMethodRetBool ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; asSSystemFunctionInterface * i = s -> sysFuncIntf ; # ifdef __GNUC__ if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { // ▁ For ▁ virtual ▁ thiscalls ▁ we ▁ must ▁ call ▁ the ▁ method ▁ as ▁ a ▁ true ▁ class ▁ method ▁ so ▁ that ▁ the ▁ compiler ▁ will ▁ lookup ▁ the ▁ function ▁ address ▁ in ▁ the ▁ vftable ENDCOM union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asDWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = i -> baseOffset ; bool ( asCSimpleDummy :: * f ) ( ) = ( bool ( asCSimpleDummy :: * ) ( ) ) ( p . mthd ) ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else /* if ( ▁ i - > callConv ▁ = = ▁ ICC _ THISCALL ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJLAST ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJFIRST ▁ ) */ { // ▁ Non - virtual ▁ thiscall ▁ can ▁ be ▁ called ▁ just ▁ like ▁ any ▁ global ▁ function , ▁ passing ▁ the ▁ object ▁ as ▁ the ▁ first ▁ parameter ENDCOM bool ( * f ) ( void * ) = ( bool ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; bool ( asCSimpleDummy :: * f ) ( ) = ( bool ( asCSimpleDummy :: * ) ( ) ) p . mthd ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else # endif if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } else /* if ( ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJLAST ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJFIRST ▁ ) */ { bool ( * f ) ( void * ) = ( bool ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # endif } int asCScriptEngine :: CallObjectMethodRetInt ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; asSSystemFunctionInterface * i = s -> sysFuncIntf ; # ifdef __GNUC__ if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( int * ) gen . GetReturnPointer ( ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { // ▁ For ▁ virtual ▁ thiscalls ▁ we ▁ must ▁ call ▁ the ▁ method ▁ as ▁ a ▁ true ▁ class ▁ method ▁ so ▁ that ▁ the ▁ compiler ▁ will ▁ lookup ▁ the ▁ function ▁ address ▁ in ▁ the ▁ vftable ENDCOM union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asDWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = i -> baseOffset ; int ( asCSimpleDummy :: * f ) ( ) = ( int ( asCSimpleDummy :: * ) ( ) ) ( p . mthd ) ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else /* if ( ▁ i - > callConv ▁ = = ▁ ICC _ THISCALL ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJLAST ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJFIRST ▁ ) */ { // ▁ Non - virtual ▁ thiscall ▁ can ▁ be ▁ called ▁ just ▁ like ▁ any ▁ global ▁ function , ▁ passing ▁ the ▁ object ▁ as ▁ the ▁ first ▁ parameter ENDCOM int ( * f ) ( void * ) = ( int ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; int ( asCSimpleDummy :: * f ) ( ) = ( int ( asCSimpleDummy :: * ) ( ) ) p . mthd ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else # endif if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( int * ) gen . GetReturnPointer ( ) ; } else /* if ( ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJLAST ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJFIRST ▁ ) */ { int ( * f ) ( void * ) = ( int ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # endif } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; return CallGlobalFunctionRetPtr ( s -> sysFuncIntf , s ) ; } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( int func , void * param1 ) { asCScriptFunction * s = scriptFunctions [ func ] ; return CallGlobalFunctionRetPtr ( s -> sysFuncIntf , s , param1 ) ; } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { void * ( * f ) ( ) = ( void * ( * ) ( ) ) ( i -> func ) ; return f ( ) ; } else if ( i -> callConv == ICC_STDCALL ) { void * ( STDCALL * f ) ( ) = ( void * ( STDCALL * ) ( ) ) ( i -> func ) ; return f ( ) ; } else { asCGeneric gen ( this , s , 0 , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( void * * ) gen . GetReturnPointer ( ) ; } } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( asSSystemFunctionInterface * i , asCScriptFunction * s , void * param1 ) { if ( i -> callConv == ICC_CDECL ) { void * ( * f ) ( void * ) = ( void * ( * ) ( void * ) ) ( i -> func ) ; return f ( param1 ) ; } else if ( i -> callConv == ICC_STDCALL ) { void * ( STDCALL * f ) ( void * ) = ( void * ( STDCALL * ) ( void * ) ) ( i -> func ) ; return f ( param1 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( void * * ) gen . GetReturnPointer ( ) ; } } void asCScriptEngine :: CallObjectMethod ( void * obj , void * param , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; CallObjectMethod ( obj , param , s -> sysFuncIntf , s ) ; } void asCScriptEngine :: CallObjectMethod ( void * obj , void * param , asSSystemFunctionInterface * i , asCScriptFunction * s ) { # ifdef __GNUC__ if ( i -> callConv == ICC_CDECL_OBJLAST ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param , obj ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , ( asDWORD * ) & param ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else /* if ( ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJFIRST ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ THISCALL ▁ ) */ { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( obj , param ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; void ( asCSimpleDummy :: * f ) ( void * ) = ( void ( asCSimpleDummy :: * ) ( void * ) ) ( p . mthd ) ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( param ) ; } else # endif if ( i -> callConv == ICC_CDECL_OBJLAST ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param , obj ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , ( asDWORD * ) & param ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else /* if ( ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJFIRST ▁ ) */ { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( obj , param ) ; } # endif } void asCScriptEngine :: CallGlobalFunction ( void * param1 , void * param2 , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param1 , param2 ) ; } else if ( i -> callConv == ICC_STDCALL ) { void ( STDCALL * f ) ( void * , void * ) = ( void ( STDCALL * ) ( void * , void * ) ) ( i -> func ) ; f ( param1 , param2 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } } bool asCScriptEngine :: CallGlobalFunctionRetBool ( void * param1 , void * param2 , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { bool ( * f ) ( void * , void * ) = ( bool ( * ) ( void * , void * ) ) ( i -> func ) ; return f ( param1 , param2 ) ; } else if ( i -> callConv == ICC_STDCALL ) { bool ( STDCALL * f ) ( void * , void * ) = ( bool ( STDCALL * ) ( void * , void * ) ) ( i -> func ) ; return f ( param1 , param2 ) ; } else { // ▁ TODO : ▁ When ▁ simulating ▁ a ▁ 64bit ▁ environment ▁ by ▁ defining ▁ AS _ 64BIT _ PTR ▁ on ▁ a ▁ 32bit ▁ platform ▁ this ▁ code ENDCOM // ▁ fails , ▁ because ▁ the ▁ stack ▁ given ▁ to ▁ asCGeneric ▁ is ▁ not ▁ prepared ▁ with ▁ two ▁ 64bit ▁ arguments . ENDCOM asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } } void * asCScriptEngine :: CallAlloc ( asCObjectType * type ) { // ▁ Allocate ▁ 4 ▁ bytes ▁ as ▁ the ▁ smallest ▁ size . ▁ Otherwise ▁ CallSystemFunction ▁ may ▁ try ▁ to ENDCOM // ▁ copy ▁ a ▁ DWORD ▁ onto ▁ a ▁ smaller ▁ memory ▁ block , ▁ in ▁ case ▁ the ▁ object ▁ type ▁ is ▁ return ▁ in ▁ registers . ENDCOM # if defined ( AS_DEBUG ) return ( ( asALLOCFUNCDEBUG_t ) ( userAlloc ) ) ( type -> size < 4 ? 4 : type -> size , __FILE__ , __LINE__ ) ; # else return userAlloc ( type -> size < 4 ? 4 : type -> size ) ; # endif } void asCScriptEngine :: CallFree ( void * obj ) { userFree ( obj ) ; } // ▁ interface ENDCOM void asCScriptEngine :: NotifyGarbageCollectorOfNewObject ( void * obj , int typeId ) { asCObjectType * objType = GetObjectTypeFromTypeId ( typeId ) ; gc . AddScriptObjectToGC ( obj , objType ) ; } // ▁ interface ENDCOM int asCScriptEngine :: GarbageCollect ( asDWORD flags ) { return gc . GarbageCollect ( flags ) ; } // ▁ interface ENDCOM void asCScriptEngine :: GetGCStatistics ( asUINT * currentSize , asUINT * totalDestroyed , asUINT * totalDetected ) { gc . GetStatistics ( currentSize , totalDestroyed , totalDetected ) ; } // ▁ interface ENDCOM void asCScriptEngine :: GCEnumCallback ( void * reference ) { gc . GCEnumCallback ( reference ) ; } // ▁ TODO : ▁ multithread : ▁ The ▁ mapTypeIdToDataType ▁ must ▁ be ▁ protected ▁ with ▁ critical ▁ sections ▁ in ▁ all ▁ functions ▁ that ▁ access ▁ it ENDCOM int asCScriptEngine :: GetTypeIdFromDataType ( const asCDataType & dt ) { if ( dt . IsNullHandle ( ) ) return 0 ; // ▁ Find ▁ the ▁ existing ▁ type ▁ id ENDCOM asSMapNode < int , asCDataType * > * cursor = 0 ; mapTypeIdToDataType . MoveFirst ( & cursor ) ; while ( cursor ) { if ( mapTypeIdToDataType . GetValue ( cursor ) -> IsEqualExceptRefAndConst ( dt ) ) return mapTypeIdToDataType . GetKey ( cursor ) ; mapTypeIdToDataType . MoveNext ( & cursor , cursor ) ; } // ▁ The ▁ type ▁ id ▁ doesn ' t ▁ exist , ▁ create ▁ it ENDCOM // ▁ Setup ▁ the ▁ basic ▁ type ▁ id ENDCOM int typeId = typeIdSeqNbr ++ ; if ( dt . GetObjectType ( ) ) { if ( dt . GetObjectType ( ) -> flags & asOBJ_SCRIPT_OBJECT ) typeId |= asTYPEID_SCRIPTOBJECT ; else if ( dt . GetObjectType ( ) -> flags & asOBJ_TEMPLATE ) typeId |= asTYPEID_SCRIPTARRAY ; // ▁ TODO : ▁ Should ▁ be ▁ asTYPEID _ TEMPLATE ENDCOM else if ( dt . GetObjectType ( ) -> flags & asOBJ_ENUM ) ; // ▁ TODO : ▁ Should ▁ we ▁ have ▁ a ▁ specific ▁ bit ▁ for ▁ this ? ENDCOM else typeId |= asTYPEID_APPOBJECT ; } // ▁ Insert ▁ the ▁ basic ▁ object ▁ type ENDCOM asCDataType * newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( false ) ; mapTypeIdToDataType . Insert ( typeId , newDt ) ; // ▁ If ▁ the ▁ object ▁ type ▁ supports ▁ object ▁ handles ▁ then ▁ register ▁ those ▁ types ▁ as ▁ well ENDCOM // ▁ Note : ▁ Don ' t ▁ check ▁ for ▁ addref , ▁ as ▁ asOBJ _ SCOPED ▁ don ' t ▁ have ▁ this ENDCOM if ( dt . IsObject ( ) && dt . GetObjectType ( ) -> beh . release ) { newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( true ) ; newDt -> MakeHandleToConst ( false ) ; mapTypeIdToDataType . Insert ( typeId | asTYPEID_OBJHANDLE , newDt ) ; newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( true ) ; newDt -> MakeHandleToConst ( true ) ; mapTypeIdToDataType . Insert ( typeId | asTYPEID_OBJHANDLE | asTYPEID_HANDLETOCONST , newDt ) ; } // ▁ Call ▁ the ▁ method ▁ recursively ▁ to ▁ get ▁ the ▁ correct ▁ type ▁ id ENDCOM return GetTypeIdFromDataType ( dt ) ; } const asCDataType * asCScriptEngine :: GetDataTypeFromTypeId ( int typeId ) { asSMapNode < int , asCDataType * > * cursor = 0 ; if ( mapTypeIdToDataType . MoveTo ( & cursor , typeId ) ) return mapTypeIdToDataType . GetValue ( cursor ) ; return 0 ; } asCObjectType * asCScriptEngine :: GetObjectTypeFromTypeId ( int typeId ) { asSMapNode < int , asCDataType * > * cursor = 0 ; if ( mapTypeIdToDataType . MoveTo ( & cursor , typeId ) ) return mapTypeIdToDataType . GetValue ( cursor ) -> GetObjectType ( ) ; return 0 ; } void asCScriptEngine :: RemoveFromTypeIdMap ( asCObjectType * type ) { asSMapNode < int , asCDataType * > * cursor = 0 ; mapTypeIdToDataType . MoveFirst ( & cursor ) ; while ( cursor ) { asCDataType * dt = mapTypeIdToDataType . GetValue ( cursor ) ; asSMapNode < int , asCDataType * > * old = cursor ; mapTypeIdToDataType . MoveNext ( & cursor , cursor ) ; if ( dt -> GetObjectType ( ) == type ) { asDELETE ( dt , asCDataType ) ; mapTypeIdToDataType . Erase ( old ) ; } } } // ▁ interface ENDCOM int asCScriptEngine :: GetTypeIdByDecl ( const char * decl ) { asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( decl , & dt ) ; if ( r < 0 ) return asINVALID_TYPE ; return GetTypeIdFromDataType ( dt ) ; } const char * asCScriptEngine :: GetTypeDeclaration ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( dt == 0 ) return 0 ; asASSERT ( threadManager ) ; asCString * tempString = & threadManager -> GetLocalData ( ) -> string ; * tempString = dt -> Format ( ) ; return tempString -> AddressOf ( ) ; } int asCScriptEngine :: GetSizeOfPrimitiveType ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( dt == 0 ) return 0 ; if ( ! dt -> IsPrimitive ( ) ) return 0 ; return dt -> GetSizeInMemoryBytes ( ) ; } void * asCScriptEngine :: CreateScriptObject ( int typeId ) { // ▁ Make ▁ sure ▁ the ▁ type ▁ id ▁ is ▁ for ▁ an ▁ object ▁ type , ▁ and ▁ not ▁ a ▁ primitive ▁ or ▁ a ▁ handle ENDCOM if ( ( typeId & ( asTYPEID_MASK_OBJECT | asTYPEID_MASK_SEQNBR ) ) != typeId ) return 0 ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return 0 ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; // ▁ Is ▁ the ▁ type ▁ id ▁ valid ? ENDCOM if ( ! dt ) return 0 ; // ▁ Allocate ▁ the ▁ memory ENDCOM asCObjectType * objType = dt -> GetObjectType ( ) ; void * ptr = 0 ; // ▁ Construct ▁ the ▁ object ENDCOM if ( objType -> flags & asOBJ_SCRIPT_OBJECT ) ptr = ScriptObjectFactory ( objType , this ) ; else if ( objType -> flags & asOBJ_TEMPLATE ) // ▁ The ▁ registered ▁ factory ▁ is ▁ moved ▁ to ▁ the ▁ construct ▁ behaviour ▁ when ▁ the ▁ type ▁ is ▁ instanciated ENDCOM ptr = CallGlobalFunctionRetPtr ( objType -> beh . construct , objType ) ; else if ( objType -> flags & asOBJ_REF ) ptr = CallGlobalFunctionRetPtr ( objType -> beh . factory ) ; else { ptr = CallAlloc ( objType ) ; int funcIndex = objType -> beh . construct ; if ( funcIndex ) CallObjectMethod ( ptr , funcIndex ) ; } return ptr ; } void * asCScriptEngine :: CreateScriptObjectCopy ( void * origObj , int typeId ) { void * newObj = CreateScriptObject ( typeId ) ; if ( newObj == 0 ) return 0 ; CopyScriptObject ( newObj , origObj , typeId ) ; return newObj ; } void asCScriptEngine :: CopyScriptObject ( void * dstObj , void * srcObj , int typeId ) { // ▁ Make ▁ sure ▁ the ▁ type ▁ id ▁ is ▁ for ▁ an ▁ object ▁ type , ▁ and ▁ not ▁ a ▁ primitive ▁ or ▁ a ▁ handle ENDCOM if ( ( typeId & ( asTYPEID_MASK_OBJECT | asTYPEID_MASK_SEQNBR ) ) != typeId ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; // ▁ Copy ▁ the ▁ contents ▁ from ▁ the ▁ original ▁ object , ▁ using ▁ the ▁ assignment ▁ operator ENDCOM const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; // ▁ Is ▁ the ▁ type ▁ id ▁ valid ? ENDCOM if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; // ▁ TODO : ▁ beh . copy ▁ will ▁ be ▁ removed , ▁ so ▁ we ▁ need ▁ to ▁ find ▁ the ▁ default ▁ opAssign ▁ method ▁ instead ENDCOM if ( objType -> beh . copy ) { CallObjectMethod ( dstObj , srcObj , objType -> beh . copy ) ; } else if ( objType -> size ) { memcpy ( dstObj , srcObj , objType -> size ) ; } } void asCScriptEngine :: AddRefScriptObject ( void * obj , int typeId ) { // ▁ Make ▁ sure ▁ it ▁ is ▁ not ▁ a ▁ null ▁ pointer ENDCOM if ( obj == 0 ) return ; // ▁ Make ▁ sure ▁ the ▁ type ▁ id ▁ is ▁ for ▁ an ▁ object ▁ type ▁ or ▁ a ▁ handle ENDCOM if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; // ▁ Is ▁ the ▁ type ▁ id ▁ valid ? ENDCOM if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . addref ) { // ▁ Call ▁ the ▁ addref ▁ behaviour ENDCOM CallObjectMethod ( obj , objType -> beh . addref ) ; } } void asCScriptEngine :: ReleaseScriptObject ( void * obj , int typeId ) { // ▁ Make ▁ sure ▁ it ▁ is ▁ not ▁ a ▁ null ▁ pointer ENDCOM if ( obj == 0 ) return ; // ▁ Make ▁ sure ▁ the ▁ type ▁ id ▁ is ▁ for ▁ an ▁ object ▁ type ▁ or ▁ a ▁ handle ENDCOM if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; // ▁ Is ▁ the ▁ type ▁ id ▁ valid ? ENDCOM if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . release ) { // ▁ Call ▁ the ▁ release ▁ behaviour ENDCOM CallObjectMethod ( obj , objType -> beh . release ) ; } else { // ▁ Call ▁ the ▁ destructor ENDCOM if ( objType -> beh . destruct ) CallObjectMethod ( obj , objType -> beh . destruct ) ; // ▁ Then ▁ free ▁ the ▁ memory ENDCOM CallFree ( obj ) ; } } bool asCScriptEngine :: IsHandleCompatibleWithObject ( void * obj , int objTypeId , int handleTypeId ) { // ▁ if ▁ equal , ▁ then ▁ it ▁ is ▁ obvious ▁ they ▁ are ▁ compatible ENDCOM if ( objTypeId == handleTypeId ) return true ; // ▁ Get ▁ the ▁ actual ▁ data ▁ types ▁ from ▁ the ▁ type ▁ ids ENDCOM const asCDataType * objDt = GetDataTypeFromTypeId ( objTypeId ) ; const asCDataType * hdlDt = GetDataTypeFromTypeId ( handleTypeId ) ; // ▁ A ▁ handle ▁ to ▁ const ▁ cannot ▁ be ▁ passed ▁ to ▁ a ▁ handle ▁ that ▁ is ▁ not ▁ referencing ▁ a ▁ const ▁ object ENDCOM if ( objDt -> IsHandleToConst ( ) && ! hdlDt -> IsHandleToConst ( ) ) return false ; if ( objDt -> GetObjectType ( ) == hdlDt -> GetObjectType ( ) ) { // ▁ The ▁ object ▁ type ▁ is ▁ equal ENDCOM return true ; } else if ( objDt -> IsScriptObject ( ) && obj ) { // ▁ There ' s ▁ still ▁ a ▁ chance ▁ the ▁ object ▁ implements ▁ the ▁ requested ▁ interface ENDCOM asCObjectType * objType = ( ( asCScriptObject * ) obj ) -> objType ; if ( objType -> Implements ( hdlDt -> GetObjectType ( ) ) ) return true ; } return false ; } int asCScriptEngine :: BeginConfigGroup ( const char * groupName ) { // ▁ Make ▁ sure ▁ the ▁ group ▁ name ▁ doesn ' t ▁ already ▁ exist ENDCOM for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) return asNAME_TAKEN ; } if ( currentGroup != & defaultGroup ) return asNOT_SUPPORTED ; asCConfigGroup * group = asNEW ( asCConfigGroup ) ( ) ; group -> groupName = groupName ; configGroups . PushLast ( group ) ; currentGroup = group ; return 0 ; } int asCScriptEngine :: EndConfigGroup ( ) { // ▁ Raise ▁ error ▁ if ▁ trying ▁ to ▁ end ▁ the ▁ default ▁ config ENDCOM if ( currentGroup == & defaultGroup ) return asNOT_SUPPORTED ; currentGroup = & defaultGroup ; return 0 ; } int asCScriptEngine :: RemoveConfigGroup ( const char * groupName ) { // ▁ It ▁ is ▁ not ▁ allowed ▁ to ▁ remove ▁ a ▁ group ▁ that ▁ is ▁ still ▁ in ▁ use . ▁ ENDCOM // ▁ It ▁ would ▁ be ▁ possible ▁ to ▁ change ▁ the ▁ code ▁ in ▁ such ▁ a ▁ way ▁ that ENDCOM // ▁ the ▁ group ▁ could ▁ be ▁ removed ▁ even ▁ though ▁ it ▁ was ▁ still ▁ in ▁ use , ENDCOM // ▁ but ▁ that ▁ would ▁ cause ▁ severe ▁ negative ▁ impact ▁ on ▁ runtime ▁ ENDCOM // ▁ performance , ▁ since ▁ the ▁ VM ▁ would ▁ then ▁ have ▁ to ▁ be ▁ able ▁ handle ENDCOM // ▁ situations ▁ where ▁ the ▁ types , ▁ functions , ▁ and ▁ global ▁ variables ENDCOM // ▁ can ▁ be ▁ removed ▁ at ▁ any ▁ time . ENDCOM for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) { asCConfigGroup * group = configGroups [ n ] ; // ▁ Make ▁ sure ▁ the ▁ group ▁ isn ' t ▁ referenced ▁ by ▁ anyone ENDCOM if ( group -> refCount > 0 ) return asCONFIG_GROUP_IS_IN_USE ; // ▁ Verify ▁ if ▁ any ▁ objects ▁ registered ▁ in ▁ this ▁ group ▁ is ▁ still ▁ alive ENDCOM if ( group -> HasLiveObjects ( ) ) return asCONFIG_GROUP_IS_IN_USE ; // ▁ Remove ▁ the ▁ group ▁ from ▁ the ▁ list ENDCOM if ( n == configGroups . GetLength ( ) - 1 ) configGroups . PopLast ( ) ; else configGroups [ n ] = configGroups . PopLast ( ) ; // ▁ Remove ▁ the ▁ configurations ▁ registered ▁ with ▁ this ▁ group ENDCOM group -> RemoveConfiguration ( this ) ; asDELETE ( group , asCConfigGroup ) ; } } return 0 ; } asCConfigGroup * asCScriptEngine :: FindConfigGroupForFunction ( int funcId ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { // ▁ Check ▁ global ▁ functions ENDCOM asUINT m ; for ( m = 0 ; m < configGroups [ n ] -> scriptFunctions . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> scriptFunctions [ m ] -> id == funcId ) return configGroups [ n ] ; } } return 0 ; } asCConfigGroup * asCScriptEngine :: FindConfigGroupForGlobalVar ( int gvarId ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { for ( asUINT m = 0 ; m < configGroups [ n ] -> globalProps . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> globalProps [ m ] -> id == gvarId ) return configGroups [ n ] ; } } return 0 ; } asCConfigGroup * asCScriptEngine :: FindConfigGroupForObjectType ( const asCObjectType * objType ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { for ( asUINT m = 0 ; m < configGroups [ n ] -> objTypes . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> objTypes [ m ] == objType ) return configGroups [ n ] ; } } return 0 ; } int asCScriptEngine :: SetConfigGroupModuleAccess ( const char * groupName , const char * module , bool hasAccess ) { asCConfigGroup * group = 0 ; // ▁ Make ▁ sure ▁ the ▁ group ▁ name ▁ doesn ' t ▁ already ▁ exist ENDCOM for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) { group = configGroups [ n ] ; break ; } } if ( group == 0 ) return asWRONG_CONFIG_GROUP ; return group -> SetModuleAccess ( module , hasAccess ) ; } int asCScriptEngine :: GetNextScriptFunctionId ( ) { if ( freeScriptFunctionIds . GetLength ( ) ) return freeScriptFunctionIds . PopLast ( ) ; int id = ( int ) scriptFunctions . GetLength ( ) ; scriptFunctions . PushLast ( 0 ) ; return id ; } void asCScriptEngine :: SetScriptFunction ( asCScriptFunction * func ) { scriptFunctions [ func -> id ] = func ; } void asCScriptEngine :: FreeScriptFunctionId ( int id ) { if ( id < 0 ) return ; id &= 0xFFFF ; if ( id >= ( int ) scriptFunctions . GetLength ( ) ) return ; if ( scriptFunctions [ id ] ) { asCScriptFunction * func = scriptFunctions [ id ] ; // ▁ Remove ▁ the ▁ function ▁ from ▁ the ▁ list ▁ of ▁ script ▁ functions ENDCOM if ( id == ( int ) scriptFunctions . GetLength ( ) - 1 ) { scriptFunctions . PopLast ( ) ; } else { scriptFunctions [ id ] = 0 ; freeScriptFunctionIds . PushLast ( id ) ; } // ▁ Is ▁ the ▁ function ▁ used ▁ as ▁ signature ▁ id ? ENDCOM if ( func -> signatureId == id ) { // ▁ Remove ▁ the ▁ signature ▁ id ENDCOM signatureIds . RemoveValue ( func ) ; // ▁ Update ▁ all ▁ functions ▁ using ▁ the ▁ signature ▁ id ENDCOM int newSigId = 0 ; for ( asUINT n = 0 ; n < scriptFunctions . GetLength ( ) ; n ++ ) { if ( scriptFunctions [ n ] && scriptFunctions [ n ] -> signatureId == id ) { if ( newSigId == 0 ) { newSigId = scriptFunctions [ n ] -> id ; signatureIds . PushLast ( scriptFunctions [ n ] ) ; } scriptFunctions [ n ] -> signatureId = newSigId ; } } } } } // ▁ interface ENDCOM // ▁ TODO : ▁ typedef : ▁ Accept ▁ complex ▁ types ▁ for ▁ the ▁ typedefs ENDCOM int asCScriptEngine :: RegisterTypedef ( const char * type , const char * decl ) { if ( type == 0 ) return ConfigError ( asINVALID_NAME ) ; // ▁ Verify ▁ if ▁ the ▁ name ▁ has ▁ been ▁ registered ▁ as ▁ a ▁ type ▁ already ENDCOM asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == type ) return asALREADY_REGISTERED ; } // ▁ Grab ▁ the ▁ data ▁ type ENDCOM asCTokenizer t ; size_t tokenLen ; eTokenType token ; asCDataType dataType ; // TABSYMBOL Create ▁ the ▁ data ▁ type ENDCOM token = t . GetToken ( decl , strlen ( decl ) , & tokenLen ) ; switch ( token ) { case ttBool : case ttInt : case ttInt8 : case ttInt16 : case ttInt64 : case ttUInt : case ttUInt8 : case ttUInt16 : case ttUInt64 : case ttFloat : case ttDouble : if ( strlen ( decl ) != tokenLen ) { return ConfigError ( asINVALID_TYPE ) ; } break ; default : return ConfigError ( asINVALID_TYPE ) ; } dataType = asCDataType :: CreatePrimitive ( token , false ) ; // ▁ Make ▁ sure ▁ the ▁ name ▁ is ▁ not ▁ a ▁ reserved ▁ keyword ENDCOM token = t . GetToken ( type , strlen ( type ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( type ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; asCBuilder bld ( this , 0 ) ; int r = bld . CheckNameConflict ( type , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; // ▁ Don ' t ▁ have ▁ to ▁ check ▁ against ▁ members ▁ of ▁ object ENDCOM // ▁ types ▁ as ▁ they ▁ are ▁ allowed ▁ to ▁ use ▁ the ▁ names ENDCOM // ▁ Put ▁ the ▁ data ▁ type ▁ in ▁ the ▁ list ENDCOM asCObjectType * object = asNEW ( asCObjectType ) ( this ) ; object -> flags = asOBJ_TYPEDEF ; object -> size = dataType . GetSizeInMemoryBytes ( ) ; object -> name = type ; object -> templateSubType = dataType ; objectTypes . PushLast ( object ) ; registeredTypeDefs . PushLast ( object ) ; currentGroup -> objTypes . PushLast ( object ) ; return asSUCCESS ; } // ▁ interface ENDCOM int asCScriptEngine :: GetTypedefCount ( ) { return ( int ) registeredTypeDefs . GetLength ( ) ; } // ▁ interface ENDCOM const char * asCScriptEngine :: GetTypedefByIndex ( asUINT index , int * typeId , const char * * configGroup ) { if ( index >= registeredTypeDefs . GetLength ( ) ) return 0 ; if ( typeId ) * typeId = GetTypeIdByDecl ( registeredTypeDefs [ index ] -> name . AddressOf ( ) ) ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForObjectType ( registeredTypeDefs [ index ] ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } return registeredTypeDefs [ index ] -> name . AddressOf ( ) ; } // ▁ interface ENDCOM int asCScriptEngine :: RegisterEnum ( const char * name ) { // TABSYMBOL Check ▁ the ▁ name ENDCOM if ( NULL == name ) return ConfigError ( asINVALID_NAME ) ; // ▁ Verify ▁ if ▁ the ▁ name ▁ has ▁ been ▁ registered ▁ as ▁ a ▁ type ▁ already ENDCOM asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) return asALREADY_REGISTERED ; // ▁ Use ▁ builder ▁ to ▁ parse ▁ the ▁ datatype ENDCOM asCDataType dt ; asCBuilder bld ( this , 0 ) ; bool oldMsgCallback = msgCallback ; msgCallback = false ; int r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r >= 0 ) return ConfigError ( asERROR ) ; // ▁ Make ▁ sure ▁ the ▁ name ▁ is ▁ not ▁ a ▁ reserved ▁ keyword ENDCOM asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , strlen ( name ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( name ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * st = asNEW ( asCObjectType ) ( this ) ; asCDataType dataType ; dataType . CreatePrimitive ( ttInt , false ) ; st -> flags = asOBJ_ENUM ; st -> size = dataType . GetSizeInMemoryBytes ( ) ; st -> name = name ; objectTypes . PushLast ( st ) ; registeredEnums . PushLast ( st ) ; currentGroup -> objTypes . PushLast ( st ) ; return asSUCCESS ; } // ▁ interface ENDCOM int asCScriptEngine :: RegisterEnumValue ( const char * typeName , const char * valueName , int value ) { // ▁ Verify ▁ that ▁ the ▁ correct ▁ config ▁ group ▁ is ▁ used ENDCOM if ( currentGroup -> FindType ( typeName ) == 0 ) return asWRONG_CONFIG_GROUP ; asCDataType dt ; int r ; asCBuilder bld ( this , 0 ) ; r = bld . ParseDataType ( typeName , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; // ▁ Store ▁ the ▁ enum ▁ value ENDCOM asCObjectType * ot = dt . GetObjectType ( ) ; if ( ot == 0 || ! ( ot -> flags & asOBJ_ENUM ) ) return ConfigError ( asINVALID_TYPE ) ; if ( NULL == valueName ) return ConfigError ( asINVALID_NAME ) ; for ( unsigned int n = 0 ; n < ot -> enumValues . GetLength ( ) ; n ++ ) { if ( ot -> enumValues [ n ] -> name == valueName ) return ConfigError ( asALREADY_REGISTERED ) ; } asSEnumValue * e = asNEW ( asSEnumValue ) ; e -> name = valueName ; e -> value = value ; ot -> enumValues . PushLast ( e ) ; return asSUCCESS ; } // ▁ interface ENDCOM int asCScriptEngine :: GetEnumCount ( ) { return ( int ) registeredEnums . GetLength ( ) ; } // ▁ interface ENDCOM const char * asCScriptEngine :: GetEnumByIndex ( asUINT index , int * enumTypeId , const char * * configGroup ) { if ( index >= registeredEnums . GetLength ( ) ) return 0 ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForObjectType ( registeredEnums [ index ] ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } if ( enumTypeId ) * enumTypeId = GetTypeIdByDecl ( registeredEnums [ index ] -> name . AddressOf ( ) ) ; return registeredEnums [ index ] -> name . AddressOf ( ) ; } // ▁ interface ENDCOM int asCScriptEngine :: GetEnumValueCount ( int enumTypeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( enumTypeId ) ; asCObjectType * t = dt -> GetObjectType ( ) ; if ( t == 0 || ! ( t -> GetFlags ( ) & asOBJ_ENUM ) ) return asINVALID_TYPE ; return ( int ) t -> enumValues . GetLength ( ) ; } // ▁ interface ENDCOM const char * asCScriptEngine :: GetEnumValueByIndex ( int enumTypeId , asUINT index , int * outValue ) { // ▁ TODO : ▁ This ▁ same ▁ function ▁ is ▁ implemented ▁ in ▁ as _ module . cpp ▁ as ▁ well . ▁ Perhaps ▁ it ▁ should ▁ be ▁ moved ▁ to ▁ asCObjectType ? ENDCOM const asCDataType * dt = GetDataTypeFromTypeId ( enumTypeId ) ; asCObjectType * t = dt -> GetObjectType ( ) ; if ( t == 0 || ! ( t -> GetFlags ( ) & asOBJ_ENUM ) ) return 0 ; if ( index >= t -> enumValues . GetLength ( ) ) return 0 ; if ( outValue ) * outValue = t -> enumValues [ index ] -> value ; return t -> enumValues [ index ] -> name . AddressOf ( ) ; } // ▁ interface ENDCOM int asCScriptEngine :: GetObjectTypeCount ( ) { return ( int ) registeredObjTypes . GetLength ( ) ; } // ▁ interface ENDCOM asIObjectType * asCScriptEngine :: GetObjectTypeByIndex ( asUINT index ) { if ( index >= registeredObjTypes . GetLength ( ) ) return 0 ; return registeredObjTypes [ index ] ; } // ▁ interface ENDCOM asIObjectType * asCScriptEngine :: GetObjectTypeById ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; // ▁ Is ▁ the ▁ type ▁ id ▁ valid ? ENDCOM if ( ! dt ) return 0 ; // ▁ Enum ▁ types ▁ are ▁ not ▁ objects , ▁ so ▁ we ▁ shouldn ' t ▁ return ▁ an ▁ object ▁ type ▁ for ▁ them ENDCOM if ( dt -> GetObjectType ( ) && dt -> GetObjectType ( ) -> GetFlags ( ) & asOBJ_ENUM ) return 0 ; return dt -> GetObjectType ( ) ; } asIScriptFunction * asCScriptEngine :: GetFunctionDescriptorById ( int funcId ) { return GetScriptFunction ( funcId ) ; } // ▁ internal ENDCOM bool asCScriptEngine :: IsTemplateType ( const char * name ) { // ▁ TODO : ▁ optimize : ▁ Improve ▁ linear ▁ search ENDCOM for ( unsigned int n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) { return objectTypes [ n ] -> flags & asOBJ_TEMPLATE ? true : false ; } } return false ; } // ▁ internal ENDCOM int asCScriptEngine :: AddConstantString ( const char * str , size_t len ) { // ▁ The ▁ str ▁ may ▁ contain ▁ null ▁ chars , ▁ so ▁ we ▁ cannot ▁ use ▁ strlen , ▁ or ▁ strcmp , ▁ or ▁ strcpy ENDCOM // ▁ TODO : ▁ optimize : ▁ Improve ▁ linear ▁ search ENDCOM // ▁ Has ▁ the ▁ string ▁ been ▁ registered ▁ before ? ENDCOM for ( size_t n = 0 ; n < stringConstants . GetLength ( ) ; n ++ ) { if ( stringConstants [ n ] -> Compare ( str , len ) == 0 ) { return ( int ) n ; } } // ▁ No ▁ match ▁ was ▁ found , ▁ add ▁ the ▁ string ENDCOM asCString * cstr = asNEW ( asCString ) ( str , len ) ; stringConstants . PushLast ( cstr ) ; // ▁ The ▁ VM ▁ currently ▁ doesn ' t ▁ handle ▁ string ▁ ids ▁ larger ▁ than ▁ 65535 ENDCOM asASSERT ( stringConstants . GetLength ( ) <= 65536 ) ; return ( int ) stringConstants . GetLength ( ) - 1 ; } // ▁ internal ENDCOM const asCString & asCScriptEngine :: GetConstantString ( int id ) { return * stringConstants [ id ] ; } // ▁ internal ENDCOM int asCScriptEngine :: GetScriptSectionNameIndex ( const char * name ) { // ▁ TODO : ▁ These ▁ names ▁ are ▁ only ▁ released ▁ when ▁ the ▁ engine ▁ is ▁ freed . ▁ The ▁ assumption ▁ is ▁ that ENDCOM // ▁ the ▁ same ▁ script ▁ section ▁ names ▁ will ▁ be ▁ reused ▁ instead ▁ of ▁ there ▁ always ▁ being ▁ new ENDCOM // ▁ names . ▁ Is ▁ this ▁ assumption ▁ valid ? ▁ Do ▁ we ▁ need ▁ to ▁ add ▁ reference ▁ counting ? ENDCOM // ▁ Store ▁ the ▁ script ▁ section ▁ names ▁ for ▁ future ▁ reference ENDCOM for ( asUINT n = 0 ; n < scriptSectionNames . GetLength ( ) ; n ++ ) { if ( scriptSectionNames [ n ] -> Compare ( name ) == 0 ) return n ; } scriptSectionNames . PushLast ( asNEW ( asCString ) ( name ) ) ; return int ( scriptSectionNames . GetLength ( ) - 1 ) ; } END_AS_NAMESPACE </DOCUMENT>
