<DOCUMENT_ID="Lotusun/OfficeHelper/tree/master/src/main/java/com/charlesdream/office/word/objects/Style.java"> package com . charlesdream . office . word . objects ; import com . charlesdream . office . BaseObject ; import com . jacob . com . Dispatch ; /* * STRNEWLINE ▁ * ▁ @ author ▁ Charles ▁ Cui ▁ on ▁ 3/5/2016 . STRNEWLINE ▁ * ▁ @ since ▁ 1.0 STRNEWLINE ▁ */ public class Style extends BaseObject { public Style ( Dispatch dispatch ) { super ( dispatch ) ; } } </DOCUMENT>
<DOCUMENT_ID="apixandru/intellij-community/tree/master/java/java-tests/testData/psi/parser-full/declarationParsing/class/NoType.java"> class ClassName { new X ( ) ; } </DOCUMENT>
<DOCUMENT_ID="aporter/coursera-android/tree/master/Examples/BluetoothSetupAndTransferData/src/course/examples/bluetooth/setupandtransferdata/ConnectionThread.java"> package course . examples . bluetooth . setupandtransferdata ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import android . bluetooth . BluetoothSocket ; import android . os . Handler ; public class ConnectionThread extends Thread { BluetoothSocket mBluetoothSocket ; private final Handler mHandler ; private InputStream mInStream ; private OutputStream mOutStream ; ConnectionThread ( BluetoothSocket socket , Handler handler ) { super ( ) ; mBluetoothSocket = socket ; mHandler = handler ; try { mInStream = mBluetoothSocket . getInputStream ( ) ; mOutStream = mBluetoothSocket . getOutputStream ( ) ; } catch ( IOException e ) { } } @ Override public void run ( ) { byte [ ] buffer = new byte [ 1024 ] ; int bytes ; while ( true ) { try { bytes = mInStream . read ( buffer ) ; String data = new String ( buffer , 0 , bytes ) ; mHandler . obtainMessage ( DataTransferActivity . DATA_RECEIVED , data ) . sendToTarget ( ) ; } catch ( IOException e ) { break ; } } } public void write ( byte [ ] bytes ) { try { mOutStream . write ( bytes ) ; } catch ( IOException e ) { } } } </DOCUMENT>
<DOCUMENT_ID="bobocop/gsn35/tree/master/src/endymion/alarm/senders/GSNAlarmSender.java"> package endymion . alarm . senders ; import endymion . exception . EndymionException ; /* * STRNEWLINE ▁ * ▁ Created ▁ by ▁ Nikola ▁ on ▁ 14.04.2015 . STRNEWLINE ▁ * ▁ The ▁ abstract ▁ class ▁ which ▁ represents ▁ alarm ▁ sender STRNEWLINE ▁ */ public abstract class GSNAlarmSender { /* * STRNEWLINE ▁ * ▁ This ▁ method ▁ is ▁ used ▁ for ▁ setting ▁ the ▁ parameters ▁ needed ▁ for ▁ completing ▁ the ▁ send ▁ operation STRNEWLINE ▁ * ▁ @ param ▁ parameters ▁ - ▁ send ▁ parameters STRNEWLINE ▁ * ▁ @ throws ▁ EndymionException ▁ - ▁ unexpected ▁ parameters ▁ given STRNEWLINE ▁ */ public abstract void setSendParameters ( String ... parameters ) throws EndymionException ; /* * STRNEWLINE ▁ * ▁ This ▁ method ▁ is ▁ used ▁ for ▁ send ▁ operation STRNEWLINE ▁ * ▁ @ param ▁ subjectLine ▁ - ▁ general ▁ message ▁ ( subject ▁ line ▁ in ▁ email ) STRNEWLINE ▁ * ▁ @ param ▁ alarmMessage ▁ - ▁ message ▁ regarding ▁ the ▁ concrete ▁ alarm STRNEWLINE ▁ * ▁ @ throws ▁ EndymionException ▁ - ▁ send ▁ operation ▁ failed STRNEWLINE ▁ */ public abstract void sendAlarm ( String subjectLine , String alarmMessage ) throws EndymionException ; } </DOCUMENT>
<DOCUMENT_ID="nuwanw/product-apim-2015-09-04/tree/master/modules/integration/tests-common/backend-service/src/main/java/org/wso2/am/integration.services/jaxrs/peoplesample/AppConfig.java"> /* STRNEWLINE * Copyright ▁ ( c ) ▁ 2005-2010 , ▁ WSO2 ▁ Inc . ▁ ( http : // www . wso2 . org ) ▁ All ▁ Rights ▁ Reserved . STRNEWLINE * STRNEWLINE * WSO2 ▁ Inc . ▁ licenses ▁ this ▁ file ▁ to ▁ you ▁ under ▁ the ▁ Apache ▁ License , STRNEWLINE * Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except STRNEWLINE * in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE * You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE * STRNEWLINE * http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE * STRNEWLINE * Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , STRNEWLINE * software ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an STRNEWLINE * " AS ▁ IS " ▁ BASIS , ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY STRNEWLINE * KIND , ▁ either ▁ express ▁ or ▁ implied . ▁ See ▁ the ▁ License ▁ for ▁ the STRNEWLINE * specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations STRNEWLINE * under ▁ the ▁ License . STRNEWLINE */ package org . wso2 . am . integration . services . jaxrs . peoplesample ; import org . apache . cxf . bus . spring . SpringBus ; import org . apache . cxf . endpoint . Server ; import org . apache . cxf . jaxrs . JAXRSServerFactoryBean ; import org . codehaus . jackson . jaxrs . JacksonJsonProvider ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import javax . ws . rs . ext . RuntimeDelegate ; import java . util . Arrays ; @ Configuration public class AppConfig { @ Bean ( destroyMethod = " shutdown " ) public SpringBus cxf ( ) { return new SpringBus ( ) ; } @ Bean public Server jaxRsServer ( ) { JAXRSServerFactoryBean factory = RuntimeDelegate . getInstance ( ) . createEndpoint ( jaxRsApiApplication ( ) , JAXRSServerFactoryBean . class ) ; factory . setServiceBeans ( Arrays . < Object > asList ( peopleRestService ( ) ) ) ; factory . setAddress ( " / " + factory . getAddress ( ) ) ; factory . setProviders ( Arrays . < Object > asList ( jsonProvider ( ) ) ) ; return factory . create ( ) ; } @ Bean public JaxRsApiApplication jaxRsApiApplication ( ) { return new JaxRsApiApplication ( ) ; } @ Bean public PeopleRestService peopleRestService ( ) { return new PeopleRestService ( ) ; } @ Bean public PeopleService peopleService ( ) { return new PeopleService ( ) ; } @ Bean public JacksonJsonProvider jsonProvider ( ) { return new JacksonJsonProvider ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="skofra0/pentaho-kettle/tree/master/engine/src/org/pentaho/di/job/JobEntryListener.java"> /* ! ▁ * * * * * STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Pentaho ▁ Data ▁ Integration STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2002-2013 ▁ by ▁ Pentaho ▁ : ▁ http : // www . pentaho . com STRNEWLINE ▁ * STRNEWLINE ▁ * * * * * STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with STRNEWLINE ▁ * ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ * STRNEWLINE ▁ * * * * */ package org . pentaho . di . job ; import org . pentaho . di . core . Result ; import org . pentaho . di . job . entry . JobEntryCopy ; import org . pentaho . di . job . entry . JobEntryInterface ; public interface JobEntryListener { public void beforeExecution ( Job job , JobEntryCopy jobEntryCopy , JobEntryInterface jobEntryInterface ) ; public void afterExecution ( Job job , JobEntryCopy jobEntryCopy , JobEntryInterface jobEntryInterface , Result result ) ; } </DOCUMENT>
<DOCUMENT_ID="pkdevbox/Kundera/tree/master/src/kundera-cassandra/cassandra-ds-driver/src/main/java/com/impetus/kundera/client/cassandra/dsdriver/DSIdGenerator.java"> /* * * * * STRNEWLINE ▁ * ▁ * ▁ Copyright ▁ 2015 ▁ Impetus ▁ Infotech . STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ * * * * */ package com . impetus . kundera . client . cassandra . dsdriver ; import java . util . UUID ; import com . datastax . driver . core . ResultSet ; import com . impetus . kundera . client . Client ; import com . impetus . kundera . generator . AutoGenerator ; /* * STRNEWLINE ▁ * ▁ The ▁ Class ▁ DSIdGenerator . STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ author : ▁ karthikp . manchala STRNEWLINE ▁ */ public class DSIdGenerator implements AutoGenerator { /* STRNEWLINE ▁ * ▁ ( non - Javadoc ) STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ see STRNEWLINE ▁ * ▁ com . impetus . kundera . generator . AutoGenerator # generate ( com . impetus . kundera STRNEWLINE ▁ * ▁ . client . Client , ▁ java . lang . Object ) STRNEWLINE ▁ */ @ Override public Object generate ( Client < ? > client , String dataType ) { final String generatedId = " Select ▁ now ( ) ▁ from ▁ system . schema _ columns " ; ResultSet rSet = ( ( DSClient ) client ) . execute ( generatedId , null ) ; UUID uuid = rSet . iterator ( ) . next ( ) . getUUID ( 0 ) ; return uuid ; } } </DOCUMENT>
<DOCUMENT_ID="likaiwalkman/hadoop/tree/master/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/webapp/dao/TaskAttemptsInfo.java"> /* * STRNEWLINE ▁ * ▁ Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ ( ASF ) ▁ under ▁ one STRNEWLINE ▁ * ▁ or ▁ more ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file STRNEWLINE ▁ * ▁ distributed ▁ with ▁ this ▁ work ▁ for ▁ additional ▁ information STRNEWLINE ▁ * ▁ regarding ▁ copyright ▁ ownership . ▁ The ▁ ASF ▁ licenses ▁ this ▁ file STRNEWLINE ▁ * ▁ to ▁ you ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the STRNEWLINE ▁ * ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance STRNEWLINE ▁ * ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ taskattemptlicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . apache . hadoop . mapreduce . v2 . app . webapp . dao ; import java . util . ArrayList ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = " taskAttempts " ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TaskAttemptsInfo { protected ArrayList < TaskAttemptInfo > taskAttempt = new ArrayList < TaskAttemptInfo > ( ) ; public TaskAttemptsInfo ( ) { } // ▁ JAXB ▁ needs ▁ this ENDCOM public void add ( TaskAttemptInfo taskattemptInfo ) { taskAttempt . add ( taskattemptInfo ) ; } public ArrayList < TaskAttemptInfo > getTaskAttempts ( ) { return taskAttempt ; } } </DOCUMENT>
<DOCUMENT_ID="dslomov/intellij-community/tree/master/java/java-tests/testData/inspection/deadCode/junitAbstractClassWithInheritor/src/ChildTest.java"> public class ChildTest extends AbstractTest { } </DOCUMENT>
<DOCUMENT_ID="noonehide/CoolW/tree/master/app/src/main/java/bauhinia/coolw/beans/City.java"> package bauhinia . coolw . beans ; import com . lidroid . xutils . db . annotation . Column ; import com . lidroid . xutils . db . annotation . Id ; import com . lidroid . xutils . db . annotation . Table ; /* * STRNEWLINE ▁ * ▁ Created ▁ by ▁ bauhinia ▁ on ▁ 2015/9/15 . STRNEWLINE ▁ */ @ Table ( name = " city " ) public class City { @ Id ( column = " _ id " ) int id ; @ Column ( column = " province _ name " ) String city_name ; @ Column ( column = " province _ code " ) String city_code ; @ Column ( column = " province _ id " ) int province_id ; public City ( ) { } public City ( String city_name , String city_code , int province_id ) { this . city_name = city_name ; this . city_code = city_code ; this . province_id = province_id ; } public int getProvince_id ( ) { return province_id ; } public void setProvince_id ( int province_id ) { this . province_id = province_id ; } public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } public String getCity_name ( ) { return city_name ; } public void setCity_name ( String city_name ) { this . city_name = city_name ; } public String getCity_code ( ) { return city_code ; } public void setCity_code ( String city_code ) { this . city_code = city_code ; } } </DOCUMENT>
<DOCUMENT_ID="bhaveshdt/camel/tree/master/components/camel-freemarker/src/test/java/org/apache/camel/component/freemarker/FruitFilter.java"> /* * STRNEWLINE ▁ * ▁ Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ ( ASF ) ▁ under ▁ one ▁ or ▁ more STRNEWLINE ▁ * ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file ▁ distributed ▁ with STRNEWLINE ▁ * ▁ this ▁ work ▁ for ▁ additional ▁ information ▁ regarding ▁ copyright ▁ ownership . STRNEWLINE ▁ * ▁ The ▁ ASF ▁ licenses ▁ this ▁ file ▁ to ▁ You ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 STRNEWLINE ▁ * ▁ ( the ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with STRNEWLINE ▁ * ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . apache . camel . component . freemarker ; public class FruitFilter { public boolean isApple ( String body ) { return " apple " . equalsIgnoreCase ( body ) ; } public boolean isOrange ( String body ) { return " orange " . equalsIgnoreCase ( body ) ; } } </DOCUMENT>
<DOCUMENT_ID="Maccimo/intellij-community/tree/master/java/java-tests/testData/codeInsight/daemonCodeAnalyzer/quickFix/explicit2var/beforeAnonymous.java"> // ▁ " Replace ▁ explicit ▁ type ▁ with ▁ ' var ' " ▁ " true " ENDCOM class MyTest { private void m ( ) { Ru < caret > nnable r = new Runnable ( ) { @ Override public void run ( ) { } } ; } } </DOCUMENT>
<DOCUMENT_ID="jrversteegh/softsailor/tree/master/deps/swig-2.0.4/Examples/ruby/java/Example.java"> public class Example { public int mPublicInt ; public Example ( ) { mPublicInt = 0 ; } public Example ( int IntVal ) { mPublicInt = IntVal ; } public int Add ( int a , int b ) { return ( a + b ) ; } public float Add ( float a , float b ) { return ( a + b ) ; } public String Add ( String a , String b ) { return ( a + b ) ; } public Example Add ( Example a , Example b ) { return new Example ( a . mPublicInt + b . mPublicInt ) ; } } </DOCUMENT>
<DOCUMENT_ID="IllusionRom-deprecated/android_platform_tools_idea/tree/master/java/java-analysis-impl/src/com/intellij/codeInspection/NumericOverflowInspection.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ 2000-2010 ▁ JetBrains ▁ s . r . o . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package com . intellij . codeInspection ; import com . intellij . codeInsight . daemon . GroupNames ; import com . intellij . codeInsight . daemon . JavaErrorMessages ; import com . intellij . openapi . project . Project ; import com . intellij . openapi . util . Key ; import com . intellij . psi . * ; import com . intellij . psi . util . ConstantEvaluationOverflowException ; import com . intellij . psi . util . TypeConversionUtil ; import org . jetbrains . annotations . Nls ; import org . jetbrains . annotations . NotNull ; /* * STRNEWLINE ▁ * ▁ User : ▁ cdr STRNEWLINE ▁ */ public class NumericOverflowInspection extends BaseJavaBatchLocalInspectionTool { private static final Key < String > HAS_OVERFLOW_IN_CHILD = Key . create ( " HAS _ OVERFLOW _ IN _ CHILD " ) ; @ Nls @ NotNull @ Override public String getGroupDisplayName ( ) { return GroupNames . NUMERIC_GROUP_NAME ; } @ Nls @ NotNull @ Override public String getDisplayName ( ) { return " Numeric ▁ overflow " ; } @ NotNull @ Override public String getShortName ( ) { return " NumericOverflow " ; } @ NotNull @ Override public PsiElementVisitor buildVisitor ( @ NotNull final ProblemsHolder holder , boolean isOnTheFly ) { return new JavaElementVisitor ( ) { @ Override public void visitReferenceExpression ( PsiReferenceExpression expression ) { visitExpression ( expression ) ; } @ Override public void visitExpression ( PsiExpression expression ) { boolean info = hasOverflow ( expression , holder . getProject ( ) ) ; if ( info ) { holder . registerProblem ( expression , JavaErrorMessages . message ( " numeric . overflow . in . expression " ) , ProblemHighlightType . GENERIC_ERROR_OR_WARNING ) ; } } } ; } private static boolean hasOverflow ( PsiExpression expr , @ NotNull Project project ) { if ( ! TypeConversionUtil . isNumericType ( expr . getType ( ) ) ) return false ; boolean overflow = false ; try { if ( expr . getUserData ( HAS_OVERFLOW_IN_CHILD ) == null ) { JavaPsiFacade . getInstance ( project ) . getConstantEvaluationHelper ( ) . computeConstantExpression ( expr , true ) ; } else { overflow = true ; } } catch ( ConstantEvaluationOverflowException e ) { overflow = true ; } finally { PsiElement parent = expr . getParent ( ) ; if ( overflow && parent instanceof PsiExpression ) { parent . putUserData ( HAS_OVERFLOW_IN_CHILD , " " ) ; } } return overflow ; } } </DOCUMENT>
<DOCUMENT_ID="dotunolafunmiloye/hadoop-common/tree/master/src/test/core/org/apache/hadoop/io/file/tfile/Timer.java"> /* * STRNEWLINE ▁ * ▁ Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ ( ASF ) ▁ under ▁ one ▁ or ▁ more STRNEWLINE ▁ * ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file ▁ distributed ▁ with ▁ this STRNEWLINE ▁ * ▁ work ▁ for ▁ additional ▁ information ▁ regarding ▁ copyright ▁ ownership . ▁ The ▁ ASF STRNEWLINE ▁ * ▁ licenses ▁ this ▁ file ▁ to ▁ you ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the STRNEWLINE ▁ * ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT STRNEWLINE ▁ * ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ▁ See ▁ the STRNEWLINE ▁ * ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations ▁ under STRNEWLINE ▁ * ▁ the ▁ License . STRNEWLINE ▁ */ package org . apache . hadoop . io . file . tfile ; import java . io . IOException ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; /* * STRNEWLINE ▁ * ▁ this ▁ class ▁ is ▁ a ▁ time ▁ class ▁ to ▁ STRNEWLINE ▁ * ▁ measure ▁ to ▁ measure ▁ the ▁ time ▁ STRNEWLINE ▁ * ▁ taken ▁ for ▁ some ▁ event . STRNEWLINE ▁ */ public class Timer { long startTimeEpoch ; long finishTimeEpoch ; private DateFormat formatter = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; public void startTime ( ) throws IOException { startTimeEpoch = System . currentTimeMillis ( ) ; } public void stopTime ( ) throws IOException { finishTimeEpoch = System . currentTimeMillis ( ) ; } public long getIntervalMillis ( ) throws IOException { return finishTimeEpoch - startTimeEpoch ; } public void printlnWithTimestamp ( String message ) throws IOException { System . out . println ( formatCurrentTime ( ) + " ▁ ▁ " + message ) ; } public String formatTime ( long millis ) { return formatter . format ( millis ) ; } public String getIntervalString ( ) throws IOException { long time = getIntervalMillis ( ) ; return formatTime ( time ) ; } public String formatCurrentTime ( ) { return formatTime ( System . currentTimeMillis ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="deeplearning4j/deeplearning4j/tree/master/nd4j/nd4j-backends/nd4j-api-parent/nd4j-api/src/main/java/org/nd4j/linalg/api/ops/impl/transforms/custom/segment/SegmentMin.java"> /* * * * * STRNEWLINE ▁ * ▁ Copyright ▁ ( c ) ▁ 2015-2018 ▁ Skymind , ▁ Inc . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ and ▁ the ▁ accompanying ▁ materials ▁ are ▁ made ▁ available ▁ under ▁ the STRNEWLINE ▁ * ▁ terms ▁ of ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ which ▁ is ▁ available ▁ at STRNEWLINE ▁ * ▁ https : // www . apache . org / licenses / LICENSE - 2.0 . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT STRNEWLINE ▁ * ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ▁ See ▁ the STRNEWLINE ▁ * ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations STRNEWLINE ▁ * ▁ under ▁ the ▁ License . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ SPDX - License - Identifier : ▁ Apache - 2.0 STRNEWLINE ▁ * * * * */ package org . nd4j . linalg . api . ops . impl . transforms . custom . segment ; import org . nd4j . autodiff . samediff . SDVariable ; import org . nd4j . autodiff . samediff . SameDiff ; import org . nd4j . base . Preconditions ; import org . nd4j . linalg . api . buffer . DataType ; import org . nd4j . linalg . api . ops . DynamicCustomOp ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; /* * STRNEWLINE ▁ * ▁ Segment ▁ min ▁ operation STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ author ▁ Alex ▁ Black STRNEWLINE ▁ */ public class SegmentMin extends DynamicCustomOp { public SegmentMin ( SameDiff sameDiff , SDVariable data , SDVariable segmentIds ) { super ( null , sameDiff , new SDVariable [ ] { data , segmentIds } , false ) ; } public SegmentMin ( ) { } @ Override public String opName ( ) { return " segment _ min " ; } @ Override public String tensorflowName ( ) { return " SegmentMin " ; } @ Override public List < SDVariable > doDiff ( List < SDVariable > gradients ) { return Arrays . asList ( f ( ) . segmentMinBp ( arg ( 0 ) , arg ( 1 ) , gradients . get ( 0 ) ) ) ; } @ Override public List < DataType > calculateOutputDataTypes ( List < DataType > inputDataTypes ) { Preconditions . checkState ( inputDataTypes != null && inputDataTypes . size ( ) == 2 , " Expected ▁ exactly ▁ 2 ▁ input ▁ datatypes ▁ for ▁ % s , ▁ got ▁ % s " , getClass ( ) , inputDataTypes ) ; Preconditions . checkState ( inputDataTypes . get ( 1 ) . isIntType ( ) , " Datatype ▁ for ▁ input ▁ 1 ▁ ( Segment ▁ IDs ) ▁ must ▁ be ▁ an ▁ integer ▁ type , ▁ got ▁ % s " , inputDataTypes . get ( 1 ) ) ; return Collections . singletonList ( inputDataTypes . get ( 0 ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="agibsonccc/cloud-bigtable-client/tree/master/bigtable-hbase/src/main/java/com/google/cloud/bigtable/hbase/adapters/BigtableResultScannerAdapter.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ 2015 ▁ Google ▁ Inc . ▁ All ▁ Rights ▁ Reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package com . google . cloud . bigtable . hbase . adapters ; import com . google . api . client . util . Throwables ; import com . google . bigtable . v1 . Row ; import org . apache . hadoop . hbase . client . AbstractClientScanner ; import org . apache . hadoop . hbase . client . Result ; import org . apache . hadoop . hbase . client . ResultScanner ; import java . io . IOException ; /* * STRNEWLINE ▁ * ▁ Adapt ▁ a ▁ Bigtable ▁ ResultScanner ▁ to ▁ an ▁ HBase ▁ Result ▁ Scanner . STRNEWLINE ▁ */ public class BigtableResultScannerAdapter { final ResponseAdapter < Row , Result > rowAdapter ; public BigtableResultScannerAdapter ( ResponseAdapter < Row , Result > rowAdapter ) { this . rowAdapter = rowAdapter ; } public ResultScanner adapt ( final com . google . cloud . bigtable . grpc . scanner . ResultScanner < Row > bigtableResultScanner ) { return new AbstractClientScanner ( ) { @ Override public Result next ( ) throws IOException { Row row = bigtableResultScanner . next ( ) ; if ( row == null ) { // ▁ Null ▁ signals ▁ EOF . ENDCOM return null ; } return rowAdapter . adaptResponse ( row ) ; } @ Override public void close ( ) { try { bigtableResultScanner . close ( ) ; } catch ( IOException ioe ) { throw Throwables . propagate ( ioe ) ; } } } ; } } </DOCUMENT>
<DOCUMENT_ID="telerik/platform-friends-android/tree/master/Friends/facebook/src/main/java/com/facebook/internal/ImageResponseCache.java"> /* * STRNEWLINE ▁ * ▁ Copyright ▁ 2010 - present ▁ Facebook . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package com . facebook . internal ; import android . content . Context ; import android . util . Log ; import com . facebook . LoggingBehavior ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . HttpURLConnection ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; class ImageResponseCache { static final String TAG = ImageResponseCache . class . getSimpleName ( ) ; private volatile static FileLruCache imageCache ; synchronized static FileLruCache getCache ( Context context ) throws IOException { if ( imageCache == null ) { imageCache = new FileLruCache ( context . getApplicationContext ( ) , TAG , new FileLruCache . Limits ( ) ) ; } return imageCache ; } // ▁ Get ▁ stream ▁ from ▁ cache , ▁ or ▁ return ▁ null ▁ if ▁ the ▁ image ▁ is ▁ not ▁ cached . ENDCOM // ▁ Does ▁ not ▁ throw ▁ if ▁ there ▁ was ▁ an ▁ error . ENDCOM static InputStream getCachedImageStream ( URI url , Context context ) { InputStream imageStream = null ; if ( url != null ) { if ( isCDNURL ( url ) ) { try { FileLruCache cache = getCache ( context ) ; imageStream = cache . get ( url . toString ( ) ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , e . toString ( ) ) ; } } } return imageStream ; } static InputStream interceptAndCacheImageStream ( Context context , HttpURLConnection connection ) throws IOException { InputStream stream = null ; if ( connection . getResponseCode ( ) == HttpURLConnection . HTTP_OK ) { URL url = connection . getURL ( ) ; stream = connection . getInputStream ( ) ; // ▁ Default ▁ stream ▁ in ▁ case ▁ caching ▁ fails ENDCOM try { if ( isCDNURL ( url . toURI ( ) ) ) { FileLruCache cache = getCache ( context ) ; // ▁ Wrap ▁ stream ▁ with ▁ a ▁ caching ▁ stream ENDCOM stream = cache . interceptAndPut ( url . toString ( ) , new BufferedHttpInputStream ( stream , connection ) ) ; } } catch ( IOException e ) { // ▁ Caching ▁ is ▁ best ▁ effort ENDCOM } catch ( URISyntaxException e ) { // ▁ Caching ▁ is ▁ best ▁ effort ENDCOM } } return stream ; } private static boolean isCDNURL ( URI url ) { if ( url != null ) { String uriHost = url . getHost ( ) ; if ( uriHost . endsWith ( " fbcdn . net " ) ) { return true ; } if ( uriHost . startsWith ( " fbcdn " ) && uriHost . endsWith ( " akamaihd . net " ) ) { return true ; } } return false ; } static void clearCache ( Context context ) { try { getCache ( context ) . clearCache ( ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , " clearCache ▁ failed ▁ " + e . getMessage ( ) ) ; } } private static class BufferedHttpInputStream extends BufferedInputStream { HttpURLConnection connection ; BufferedHttpInputStream ( InputStream stream , HttpURLConnection connection ) { super ( stream , Utility . DEFAULT_STREAM_BUFFER_SIZE ) ; this . connection = connection ; } @ Override public void close ( ) throws IOException { super . close ( ) ; Utility . disconnectQuietly ( connection ) ; } } } </DOCUMENT>
<DOCUMENT_ID="JetBrains/intellij-community/tree/master/java/java-tests/testData/codeInsight/daemonCodeAnalyzer/quickFix/lambda2methodReference/afterAmbiguityWithoutSuperMethodNonStatic.java"> // ▁ " Replace ▁ lambda ▁ with ▁ method ▁ reference " ▁ " true " ENDCOM interface I { String foo ( Foo i ) ; } class Foo { public String foo ( ) { return null ; } String foo ( int i ) { return null ; } String foo ( Foo foo ) { return null ; } public static void main ( String [ ] args ) { I i = Foo :: foo ; } } </DOCUMENT>
<DOCUMENT_ID="nezuvian/Library-webapp/tree/master/src/test/java/top2lz/libapp/web/rest/TestUtil.java"> package top2lz . libapp . web . rest ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . fasterxml . jackson . databind . ObjectMapper ; import com . fasterxml . jackson . datatype . joda . JodaModule ; import com . fasterxml . jackson . datatype . joda . ser . DateTimeSerializer ; import com . fasterxml . jackson . datatype . joda . ser . JacksonJodaFormat ; import org . joda . time . DateTime ; import org . springframework . format . annotation . DateTimeFormat ; import org . springframework . format . datetime . joda . DateTimeFormatterFactory ; import org . springframework . http . MediaType ; import java . io . IOException ; import java . nio . charset . Charset ; /* * STRNEWLINE ▁ * ▁ Utility ▁ class ▁ for ▁ testing ▁ REST ▁ controllers . STRNEWLINE ▁ */ public class TestUtil { /* * ▁ MediaType ▁ for ▁ JSON ▁ UTF8 ▁ */ public static final MediaType APPLICATION_JSON_UTF8 = new MediaType ( MediaType . APPLICATION_JSON . getType ( ) , MediaType . APPLICATION_JSON . getSubtype ( ) , Charset . forName ( " utf8" ) ) ; /* * STRNEWLINE ▁ * ▁ Convert ▁ an ▁ object ▁ to ▁ JSON ▁ byte ▁ array . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ object STRNEWLINE ▁ * ▁ the ▁ object ▁ to ▁ convert STRNEWLINE ▁ * ▁ @ return ▁ the ▁ JSON ▁ byte ▁ array STRNEWLINE ▁ * ▁ @ throws ▁ IOException STRNEWLINE ▁ */ public static byte [ ] convertObjectToJsonBytes ( Object object ) throws IOException { ObjectMapper mapper = new ObjectMapper ( ) ; mapper . setSerializationInclusion ( JsonInclude . Include . NON_NULL ) ; JodaModule module = new JodaModule ( ) ; DateTimeFormatterFactory formatterFactory = new DateTimeFormatterFactory ( ) ; formatterFactory . setIso ( DateTimeFormat . ISO . DATE ) ; module . addSerializer ( DateTime . class , new DateTimeSerializer ( new JacksonJodaFormat ( formatterFactory . createDateTimeFormatter ( ) . withZoneUTC ( ) ) ) ) ; mapper . registerModule ( module ) ; return mapper . writeValueAsBytes ( object ) ; } } </DOCUMENT>
<DOCUMENT_ID="Communote/communote-server/tree/master/communote/persistence/src/main/java/com/communote/server/core/tag/TagStoreNotFoundException.java"> package com . communote . server . core . tag ; import com . communote . server . api . core . common . NotFoundException ; /* *  STRNEWLINE ▁ * ▁ Exception ▁ to ▁ indicate , ▁ when ▁ a ▁ TagStore ▁ was ▁ not ▁ found .  STRNEWLINE ▁ * ▁  STRNEWLINE ▁ * ▁ @ author ▁ Communote ▁ GmbH ▁ - ▁ < a ▁ href = " http : // www . communote . com / " > http : // www . communote . com / < / a >  STRNEWLINE ▁ */ public class TagStoreNotFoundException extends NotFoundException { private static final long serialVersionUID = - 5089679368783279854L ; /* *  STRNEWLINE ▁ * ▁ @ param ▁ message STRNEWLINE ▁ * ▁ The ▁ message .  STRNEWLINE ▁ */ public TagStoreNotFoundException ( String message ) { super ( message ) ; } } </DOCUMENT>
<DOCUMENT_ID="mstine/polyglot-osgi/tree/master/lib/osgi/felix/org.apache.felix.framework-1.8.1/src/main/java/org/apache/felix/framework/util/JarFileX.java"> /* ▁ STRNEWLINE ▁ * ▁ Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ ( ASF ) ▁ under ▁ one STRNEWLINE ▁ * ▁ or ▁ more ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file STRNEWLINE ▁ * ▁ distributed ▁ with ▁ this ▁ work ▁ for ▁ additional ▁ information STRNEWLINE ▁ * ▁ regarding ▁ copyright ▁ ownership . ▁ The ▁ ASF ▁ licenses ▁ this ▁ file STRNEWLINE ▁ * ▁ to ▁ you ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the STRNEWLINE ▁ * ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance STRNEWLINE ▁ * ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , STRNEWLINE ▁ * ▁ software ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an STRNEWLINE ▁ * ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY STRNEWLINE ▁ * ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ▁ See ▁ the ▁ License ▁ for ▁ the STRNEWLINE ▁ * ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations STRNEWLINE ▁ * ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . apache . felix . framework . util ; import java . io . File ; import java . io . IOException ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import java . util . zip . ZipEntry ; /* * STRNEWLINE ▁ * ▁ The ▁ purpose ▁ of ▁ this ▁ class ▁ is ▁ to ▁ fix ▁ an ▁ apparent ▁ bug ▁ in ▁ the ▁ JVM ▁ in ▁ versions STRNEWLINE ▁ * ▁ 1.4.2 ▁ and ▁ lower ▁ where ▁ directory ▁ entries ▁ in ▁ ZIP / JAR ▁ files ▁ are ▁ not ▁ correctly STRNEWLINE ▁ * ▁ identified . STRNEWLINE * */ public class JarFileX extends JarFile { public JarFileX ( File file ) throws IOException { super ( file ) ; } public JarFileX ( File file , boolean verify ) throws IOException { super ( file , verify ) ; } public JarFileX ( File file , boolean verify , int mode ) throws IOException { super ( file , verify , mode ) ; } public JarFileX ( String name ) throws IOException { super ( name ) ; } public JarFileX ( String name , boolean verify ) throws IOException { super ( name , verify ) ; } public ZipEntry getEntry ( String name ) { ZipEntry entry = super . getEntry ( name ) ; if ( ( entry != null ) && ( entry . getSize ( ) == 0 ) && ! entry . isDirectory ( ) ) { ZipEntry dirEntry = super . getEntry ( name + ' / ' ) ; if ( dirEntry != null ) { entry = dirEntry ; } } return entry ; } public JarEntry getJarEntry ( String name ) { JarEntry entry = super . getJarEntry ( name ) ; if ( ( entry != null ) && ( entry . getSize ( ) == 0 ) && ! entry . isDirectory ( ) ) { JarEntry dirEntry = super . getJarEntry ( name + ' / ' ) ; if ( dirEntry != null ) { entry = dirEntry ; } } return entry ; } } </DOCUMENT>
<DOCUMENT_ID="seanzwx/tmp/tree/master/shop/android/imageloader/src/com/nostra13/universalimageloader/cache/memory/impl/LimitedAgeMemoryCache.java"> package com . nostra13 . universalimageloader . cache . memory . impl ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import com . nostra13 . universalimageloader . cache . memory . MemoryCacheAware ; /* *  STRNEWLINE ▁ * ▁ Decorator ▁ for ▁ { @ link ▁ MemoryCacheAware } . ▁ Provides ▁ special ▁ feature ▁ for ▁ cache : ▁ if ▁ some ▁ cached ▁ object ▁ age ▁ exceeds ▁ defined STRNEWLINE ▁ * ▁ value ▁ then ▁ this ▁ object ▁ will ▁ be ▁ removed ▁ from ▁ cache .  STRNEWLINE ▁ * ▁  STRNEWLINE ▁ * ▁ @ author ▁ Sergey ▁ Tarasevich ▁ ( nostra13 [ at ] gmail [ dot ] com )  STRNEWLINE ▁ * ▁ @ see ▁ MemoryCacheAware STRNEWLINE ▁ */ public class LimitedAgeMemoryCache < K , V > implements MemoryCacheAware < K , V > { private final MemoryCacheAware < K , V > cache ; private final long maxAge ; private final Map < K , Long > loadingDates = Collections . synchronizedMap ( new HashMap < K , Long > ( ) ) ; /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ param ▁ cache STRNEWLINE TABSYMBOL ▁ * ▁ Wrapped ▁ memory ▁ cache STRNEWLINE TABSYMBOL ▁ * ▁ @ param ▁ maxAge STRNEWLINE TABSYMBOL ▁ * ▁ Max ▁ object ▁ age ▁ < b > ( in ▁ seconds ) < / b > . ▁ If ▁ object ▁ age ▁ will ▁ exceed ▁ this ▁ value ▁ then ▁ it ' ll ▁ be ▁ removed ▁ from STRNEWLINE TABSYMBOL ▁ * ▁ cache ▁ on ▁ next ▁ treatment ▁ ( and ▁ therefore ▁ be ▁ reloaded ) .  STRNEWLINE TABSYMBOL ▁ */ public LimitedAgeMemoryCache ( MemoryCacheAware < K , V > cache , long maxAge ) { this . cache = cache ; this . maxAge = maxAge * 1000 ; // ▁ to ▁ milliseconds ENDCOM } @ Override public boolean put ( K key , V value ) { boolean putSuccesfully = cache . put ( key , value ) ; if ( putSuccesfully ) { loadingDates . put ( key , System . currentTimeMillis ( ) ) ; } return putSuccesfully ; } @ Override public V get ( K key ) { Long loadingDate = loadingDates . get ( key ) ; if ( loadingDate != null && System . currentTimeMillis ( ) - loadingDate > maxAge ) { cache . remove ( key ) ; loadingDates . remove ( key ) ; } return cache . get ( key ) ; } @ Override public void remove ( K key ) { cache . remove ( key ) ; loadingDates . remove ( key ) ; } @ Override public Collection < K > keys ( ) { return cache . keys ( ) ; } @ Override public void clear ( ) { cache . clear ( ) ; loadingDates . clear ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="forever342/dubbo/tree/master/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/BroadcastCluster.java"> /*  STRNEWLINE ▁ * ▁ Copyright ▁ 1999-2012 ▁ Alibaba ▁ Group .  STRNEWLINE ▁ * ▁  STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ;  STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License .  STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * ▁  STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * ▁  STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS ,  STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied .  STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License .  STRNEWLINE ▁ */ package com . alibaba . dubbo . rpc . cluster . support ; import com . alibaba . dubbo . rpc . Invoker ; import com . alibaba . dubbo . rpc . RpcException ; import com . alibaba . dubbo . rpc . cluster . Cluster ; import com . alibaba . dubbo . rpc . cluster . Directory ; /* *  STRNEWLINE ▁ * ▁ BroadcastCluster STRNEWLINE ▁ * ▁  STRNEWLINE ▁ * ▁ @ author ▁ william . liangf STRNEWLINE ▁ */ public class BroadcastCluster implements Cluster { public < T > Invoker < T > join ( Directory < T > directory ) throws RpcException { return new BroadcastClusterInvoker < T > ( directory ) ; } } </DOCUMENT>
<DOCUMENT_ID="popstr/undertow/tree/master/core/src/main/java/io/undertow/util/CanonicalPathUtils.java"> /* STRNEWLINE ▁ * ▁ JBoss , ▁ Home ▁ of ▁ Professional ▁ Open ▁ Source . STRNEWLINE ▁ * ▁ Copyright ▁ 2014 ▁ Red ▁ Hat , ▁ Inc . , ▁ and ▁ individual ▁ contributors STRNEWLINE ▁ * ▁ as ▁ indicated ▁ by ▁ the ▁ @ author ▁ tags . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package io . undertow . util ; import java . util . ArrayList ; import java . util . List ; /* * STRNEWLINE ▁ * ▁ @ author ▁ Stuart ▁ Douglas STRNEWLINE ▁ */ public class CanonicalPathUtils { public static String canonicalize ( final String path ) { int state = START ; for ( int i = path . length ( ) - 1 ; i >= 0 ; -- i ) { final char c = path . charAt ( i ) ; switch ( c ) { case ' / ' : if ( state == FIRST_SLASH ) { return realCanonicalize ( path , i + 1 , FIRST_SLASH ) ; } else if ( state == ONE_DOT ) { return realCanonicalize ( path , i + 2 , FIRST_SLASH ) ; } else if ( state == TWO_DOT ) { return realCanonicalize ( path , i + 3 , FIRST_SLASH ) ; } state = FIRST_SLASH ; break ; case ' . ' : if ( state == FIRST_SLASH || state == START ) { state = ONE_DOT ; } else if ( state == ONE_DOT ) { state = TWO_DOT ; } else { state = NORMAL ; } break ; default : state = NORMAL ; break ; } } return path ; } static final int START = - 1 ; static final int NORMAL = 0 ; static final int FIRST_SLASH = 1 ; static final int ONE_DOT = 2 ; static final int TWO_DOT = 3 ; private static String realCanonicalize ( final String path , final int lastDot , final int initialState ) { int state = initialState ; int eatCount = 0 ; int tokenEnd = path . length ( ) ; final List < String > parts = new ArrayList < > ( ) ; for ( int i = lastDot - 1 ; i >= 0 ; -- i ) { final char c = path . charAt ( i ) ; switch ( state ) { case NORMAL : { if ( c == ' / ' ) { state = FIRST_SLASH ; if ( eatCount > 0 ) { -- eatCount ; tokenEnd = i ; } } break ; } case FIRST_SLASH : { if ( c == ' . ' ) { state = ONE_DOT ; } else if ( c == ' / ' ) { if ( eatCount > 0 ) { -- eatCount ; tokenEnd = i ; } else { parts . add ( path . substring ( i + 1 , tokenEnd ) ) ; tokenEnd = i ; } } else { state = NORMAL ; } break ; } case ONE_DOT : { if ( c == ' . ' ) { state = TWO_DOT ; } else if ( c == ' / ' ) { if ( i + 2 != tokenEnd ) { parts . add ( path . substring ( i + 2 , tokenEnd ) ) ; } tokenEnd = i ; state = FIRST_SLASH ; } else { state = NORMAL ; } break ; } case TWO_DOT : { if ( c == ' / ' ) { if ( i + 3 != tokenEnd ) { parts . add ( path . substring ( i + 3 , tokenEnd ) ) ; } tokenEnd = i ; eatCount ++ ; state = FIRST_SLASH ; } else { state = NORMAL ; } } } } final StringBuilder result = new StringBuilder ( ) ; if ( tokenEnd != 0 ) { result . append ( path . substring ( 0 , tokenEnd ) ) ; } for ( int i = parts . size ( ) - 1 ; i >= 0 ; -- i ) { result . append ( parts . get ( i ) ) ; } if ( result . length ( ) == 0 ) { return " / " ; } return result . toString ( ) ; } private CanonicalPathUtils ( ) { } } </DOCUMENT>
<DOCUMENT_ID="idea4bsd/idea4bsd/tree/master/java/java-psi-api/src/com/intellij/psi/PsiVariable.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ 2000-2013 ▁ JetBrains ▁ s . r . o . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package com . intellij . psi ; import com . intellij . pom . PomRenameableTarget ; import com . intellij . util . IncorrectOperationException ; import org . jetbrains . annotations . NotNull ; import org . jetbrains . annotations . Nullable ; import org . jetbrains . annotations . NonNls ; /* * STRNEWLINE ▁ * ▁ Represents ▁ a ▁ Java ▁ local ▁ variable , ▁ method ▁ parameter ▁ or ▁ field . STRNEWLINE ▁ */ public interface PsiVariable extends PsiModifierListOwner , PsiNameIdentifierOwner , PsiTarget , PomRenameableTarget < PsiElement > { /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ type ▁ of ▁ the ▁ variable . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ the ▁ variable ▁ type . STRNEWLINE ▁ */ @ NotNull PsiType getType ( ) ; /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ type ▁ element ▁ declaring ▁ the ▁ type ▁ of ▁ the ▁ variable . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ the ▁ type ▁ element ▁ for ▁ the ▁ variable ▁ type . STRNEWLINE ▁ */ @ Nullable PsiTypeElement getTypeElement ( ) ; /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ initializer ▁ for ▁ the ▁ variable . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ the ▁ initializer ▁ expression , ▁ or ▁ null ▁ if ▁ it ▁ has ▁ no ▁ initializer . STRNEWLINE ▁ * ▁ @ see ▁ { @ link ▁ # hasInitializer ( ) } STRNEWLINE ▁ */ @ Nullable PsiExpression getInitializer ( ) ; /* * STRNEWLINE ▁ * ▁ < p > Checks ▁ if ▁ the ▁ variable ▁ has ▁ an ▁ initializer . < / p > STRNEWLINE ▁ * ▁ < p > Please ▁ note ▁ that ▁ even ▁ when ▁ { @ link ▁ # hasInitializer ( ) } ▁ returns ▁ true , ▁ { @ link ▁ # getInitializer ( ) } ▁ still ▁ can ▁ return ▁ null , STRNEWLINE ▁ * ▁ e . g . ▁ for ▁ implicit ▁ initializer ▁ in ▁ case ▁ of ▁ enum ▁ constant ▁ declaration . < / p > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ true ▁ if ▁ the ▁ variable ▁ has ▁ an ▁ initializer , ▁ false ▁ otherwise . STRNEWLINE ▁ */ boolean hasInitializer ( ) ; /* * STRNEWLINE ▁ * ▁ Ensures ▁ that ▁ the ▁ variable ▁ declaration ▁ is ▁ not ▁ combined ▁ in ▁ the ▁ same ▁ statement ▁ with STRNEWLINE ▁ * ▁ other ▁ declarations . ▁ Also , ▁ if ▁ the ▁ variable ▁ is ▁ an ▁ array , ▁ ensures ▁ that ▁ the ▁ array STRNEWLINE ▁ * ▁ brackets ▁ are ▁ used ▁ in ▁ Java ▁ style ▁ ( < code > int [ ] ▁ a < / code > ) STRNEWLINE ▁ * ▁ and ▁ not ▁ in ▁ C ▁ style ▁ ( < code > ▁ int ▁ a [ ] < / code > ) . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ throws ▁ IncorrectOperationException ▁ if ▁ the ▁ modification ▁ fails ▁ for ▁ some ▁ reason . STRNEWLINE ▁ */ void normalizeDeclaration ( ) throws IncorrectOperationException ; // ▁ Q : ▁ split ▁ into ▁ normalizeBrackets ▁ and ▁ splitting ▁ declarations ? ENDCOM /* * STRNEWLINE ▁ * ▁ Calculates ▁ and ▁ returns ▁ the ▁ constant ▁ value ▁ of ▁ the ▁ variable ▁ initializer . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ the ▁ calculated ▁ value , ▁ or ▁ null ▁ if ▁ the ▁ variable ▁ has ▁ no ▁ initializer ▁ or STRNEWLINE ▁ * ▁ the ▁ initializer ▁ does ▁ not ▁ evaluate ▁ to ▁ a ▁ constant . STRNEWLINE ▁ */ @ Nullable Object computeConstantValue ( ) ; /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ identifier ▁ declaring ▁ the ▁ name ▁ of ▁ the ▁ variable . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ the ▁ variable ▁ name ▁ identifier . STRNEWLINE ▁ */ @ Override @ Nullable PsiIdentifier getNameIdentifier ( ) ; @ Override PsiElement setName ( @ NonNls @ NotNull String name ) throws IncorrectOperationException ; } </DOCUMENT>
<DOCUMENT_ID="fitermay/intellij-community/tree/master/plugins/InspectionGadgets/test/com/siyeh/igtest/bugs/MisspelledToStringInsspection.java"> package com . siyeh . igtest . bugs ; public class MisspelledToStringInsspection { private int m_bar ; public MisspelledToStringInsspection ( ) { m_bar = 0 ; } public String tostring ( ) { return String . valueOf ( m_bar == 3 ) ; } } </DOCUMENT>
<DOCUMENT_ID="volyrique/FrameworkBenchmarks/tree/master/frameworks/Java/dropwizard/src/main/java/com/example/helloworld/HelloJDBIService.java"> package com . example . helloworld ; import com . example . helloworld . db . jdbi . FortuneRepository ; import io . dropwizard . Application ; import io . dropwizard . jdbi3 . JdbiFactory ; import io . dropwizard . jdbi3 . bundles . JdbiExceptionsBundle ; import io . dropwizard . setup . Bootstrap ; import io . dropwizard . setup . Environment ; import io . dropwizard . views . ViewBundle ; import org . jdbi . v3 . core . Jdbi ; import com . example . helloworld . config . HelloWorldConfiguration ; import com . example . helloworld . db . jdbi . WorldRepository ; import com . example . helloworld . resources . FortuneResource ; import com . example . helloworld . resources . WorldResource ; public class HelloJDBIService extends Application < HelloWorldConfiguration > { public static void main ( String [ ] args ) throws Exception { new HelloJDBIService ( ) . run ( args ) ; } @ Override public void initialize ( Bootstrap < HelloWorldConfiguration > bootstrap ) { bootstrap . addBundle ( new ViewBundle < > ( ) ) ; bootstrap . addBundle ( new JdbiExceptionsBundle ( ) ) ; // ▁ Provides ▁ automatic ▁ unwrapping ▁ of ▁ SQLException ▁ and ▁ DBIException ENDCOM } @ Override public void run ( HelloWorldConfiguration config , Environment environment ) { final JdbiFactory factory = new JdbiFactory ( ) ; final Jdbi jdbi = factory . build ( environment , config . getDatabaseConfiguration ( ) , " RDBMS " ) ; // ▁ Test ▁ type ▁ 1 : ▁ JSON ▁ serialization ▁ and ▁ Test ▁ type ▁ 6 : ▁ Plaintext ▁ are ▁ tested ▁ against ▁ HelloWorldService ▁ class ENDCOM environment . jersey ( ) . register ( new WorldResource ( new WorldRepository ( jdbi ) ) ) ; // ▁ Test ▁ types ▁ 2 , ▁ 3 ▁ & ▁ 5 : ▁ Single ▁ database ▁ query , ▁ Multiple ▁ database ▁ queries ▁ & ▁ Database ▁ updates ENDCOM environment . jersey ( ) . register ( new FortuneResource ( new FortuneRepository ( jdbi ) ) ) ; // ▁ Test ▁ type ▁ 4 : ▁ Fortunes ENDCOM } } </DOCUMENT>
<DOCUMENT_ID="WelcomeHUME/svn-caucho-com-resin/tree/master/modules/jca/src/javax/resource/cci/ResourceAdapterMetaData.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( c ) ▁ 1998-2012 ▁ Caucho ▁ Technology ▁ - - ▁ all ▁ rights ▁ reserved STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Resin ( R ) ▁ Open ▁ Source STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Each ▁ copy ▁ or ▁ derived ▁ work ▁ must ▁ preserve ▁ the ▁ copyright ▁ notice ▁ and ▁ this STRNEWLINE ▁ * ▁ notice ▁ unmodified . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Resin ▁ Open ▁ Source ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or STRNEWLINE ▁ * ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Resin ▁ Open ▁ Source ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE , ▁ or ▁ any ▁ warranty STRNEWLINE ▁ * ▁ of ▁ NON - INFRINGEMENT . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more STRNEWLINE ▁ * ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ Resin ▁ Open ▁ Source ; ▁ if ▁ not , ▁ write ▁ to ▁ the STRNEWLINE ▁ * ▁ Free ▁ SoftwareFoundation , ▁ Inc . STRNEWLINE ▁ * ▁ 59 ▁ Temple ▁ Place , ▁ Suite ▁ 330 STRNEWLINE ▁ * ▁ Boston , ▁ MA ▁ 02111-1307 ▁ USA STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ author ▁ Scott ▁ Ferguson STRNEWLINE ▁ */ package javax . resource . cci ; /* * STRNEWLINE ▁ * ▁ Returns ▁ meta - data ▁ for ▁ a ▁ resource ▁ adapter . STRNEWLINE ▁ */ public interface ResourceAdapterMetaData { /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ version ▁ of ▁ the ▁ resource ▁ adapter . STRNEWLINE ▁ */ public String getAdapterVersion ( ) ; /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ vendor ▁ name ▁ for ▁ the ▁ adapter . STRNEWLINE ▁ */ public String getAdapterVendorName ( ) ; /* * STRNEWLINE ▁ * ▁ Returns ▁ a ▁ tool ▁ name ▁ for ▁ the ▁ resource ▁ adapter . STRNEWLINE ▁ */ public String getAdapterName ( ) ; /* * STRNEWLINE ▁ * ▁ Returns ▁ a ▁ short ▁ description ▁ of ▁ the ▁ resource ▁ adapter . STRNEWLINE ▁ */ public String getAdapterShortDescription ( ) ; /* * STRNEWLINE ▁ * ▁ Returns ▁ a ▁ string ▁ representation ▁ of ▁ the ▁ version ▁ of ▁ the ▁ spec . STRNEWLINE ▁ */ public String getSpecVersion ( ) ; /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ interaction ▁ spec ▁ types . STRNEWLINE ▁ */ public String [ ] getInteractionSpecsSupported ( ) ; /* * STRNEWLINE ▁ * ▁ Returns ▁ true ▁ if ▁ the ▁ execute ▁ with ▁ the ▁ input ▁ and ▁ output ▁ records STRNEWLINE ▁ * ▁ are ▁ supported . STRNEWLINE ▁ */ public boolean supportsExecuteWithInputAndOutputRecord ( ) ; /* * STRNEWLINE ▁ * ▁ Returns ▁ true ▁ if ▁ the ▁ execute ▁ with ▁ the ▁ input ▁ records STRNEWLINE ▁ * ▁ are ▁ supported . STRNEWLINE ▁ */ public boolean supportsExecuteWithInputRecordOnly ( ) ; /* * STRNEWLINE ▁ * ▁ Returns ▁ true ▁ if ▁ local ▁ transactions ▁ are ▁ supported . STRNEWLINE ▁ */ public boolean supportsLocalTransactionDemarcation ( ) ; } </DOCUMENT>
<DOCUMENT_ID="34benma/openjdk/tree/master/nashorn/test/src/jdk/nashorn/internal/runtime/test/LexicalBindingTest.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( c ) ▁ 2014 , ▁ Oracle ▁ and / or ▁ its ▁ affiliates . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * ▁ DO ▁ NOT ▁ ALTER ▁ OR ▁ REMOVE ▁ COPYRIGHT ▁ NOTICES ▁ OR ▁ THIS ▁ FILE ▁ HEADER . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ code ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it STRNEWLINE ▁ * ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ version ▁ 2 ▁ only , ▁ as STRNEWLINE ▁ * ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation . ▁ Oracle ▁ designates ▁ this STRNEWLINE ▁ * ▁ particular ▁ file ▁ as ▁ subject ▁ to ▁ the ▁ " Classpath " ▁ exception ▁ as ▁ provided STRNEWLINE ▁ * ▁ by ▁ Oracle ▁ in ▁ the ▁ LICENSE ▁ file ▁ that ▁ accompanied ▁ this ▁ code . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ code ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT STRNEWLINE ▁ * ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or STRNEWLINE ▁ * ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ version ▁ 2 ▁ for ▁ more ▁ details ▁ ( a ▁ copy ▁ is ▁ included ▁ in ▁ the ▁ LICENSE ▁ file ▁ that STRNEWLINE ▁ * ▁ accompanied ▁ this ▁ code ) . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ version STRNEWLINE ▁ * ▁ 2 ▁ along ▁ with ▁ this ▁ work ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ▁ Foundation , STRNEWLINE ▁ * ▁ Inc . , ▁ 51 ▁ Franklin ▁ St , ▁ Fifth ▁ Floor , ▁ Boston , ▁ MA ▁ 02110-1301 ▁ USA . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Please ▁ contact ▁ Oracle , ▁ 500 ▁ Oracle ▁ Parkway , ▁ Redwood ▁ Shores , ▁ CA ▁ 94065 ▁ USA STRNEWLINE ▁ * ▁ or ▁ visit ▁ www . oracle . com ▁ if ▁ you ▁ need ▁ additional ▁ information ▁ or ▁ have ▁ any STRNEWLINE ▁ * ▁ questions . STRNEWLINE ▁ */ package jdk . nashorn . internal . runtime . test ; import jdk . nashorn . api . scripting . NashornScriptEngineFactory ; import org . testng . annotations . Test ; import javax . script . Bindings ; import javax . script . ScriptContext ; import javax . script . ScriptEngine ; import javax . script . ScriptException ; import javax . script . SimpleScriptContext ; import static org . testng . Assert . assertEquals ; /* * STRNEWLINE ▁ * ▁ Top - level ▁ lexical ▁ binding ▁ tests . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ test STRNEWLINE ▁ * ▁ @ run ▁ testng ▁ jdk . nashorn . internal . runtime . test . LexicalBindingTest STRNEWLINE ▁ */ @ SuppressWarnings ( " javadoc " ) public class LexicalBindingTest { final static String LANGUAGE_ES6 = " - - language = es6" ; final static int NUMBER_OF_CONTEXTS = 20 ; final static int MEGAMORPHIC_LOOP_COUNT = 20 ; /* * STRNEWLINE ▁ * ▁ Test ▁ access ▁ to ▁ global ▁ var - declared ▁ variables ▁ for ▁ shared ▁ script ▁ classes ▁ with ▁ multiple ▁ globals . STRNEWLINE ▁ */ @ Test public static void megamorphicVarTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( ) ; final ScriptContext [ ] contexts = new ScriptContext [ NUMBER_OF_CONTEXTS ] ; final String sharedScript = " foo " ; for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] = new SimpleScriptContext ( ) ; final Bindings b = e . createBindings ( ) ; context . setBindings ( b , ScriptContext . ENGINE_SCOPE ) ; assertEquals ( e . eval ( " var ▁ foo ▁ = ▁ ' " + i + " ' ; " , context ) , null ) ; } for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] ; assertEquals ( e . eval ( sharedScript , context ) , String . valueOf ( i ) ) ; } } /* * STRNEWLINE ▁ * ▁ Test ▁ access ▁ to ▁ global ▁ lexically ▁ declared ▁ variables ▁ for ▁ shared ▁ script ▁ classes ▁ with ▁ multiple ▁ globals . STRNEWLINE ▁ */ @ Test public static void megamorphicMultiGlobalLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final ScriptContext [ ] contexts = new ScriptContext [ NUMBER_OF_CONTEXTS ] ; final String sharedScript = " foo " ; for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] = new SimpleScriptContext ( ) ; final Bindings b = e . createBindings ( ) ; context . setBindings ( b , ScriptContext . ENGINE_SCOPE ) ; assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' " + i + " ' ; " , context ) , null ) ; } for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] ; assertEquals ( e . eval ( sharedScript , context ) , String . valueOf ( i ) ) ; } } /* * STRNEWLINE ▁ * ▁ Test ▁ access ▁ to ▁ global ▁ lexically ▁ declared ▁ variables ▁ for ▁ shared ▁ script ▁ classes ▁ with ▁ single ▁ global . STRNEWLINE ▁ */ @ Test public static void megamorphicSingleGlobalLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final String sharedGetterScript = " foo " ; final String sharedSetterScript = " foo ▁ = ▁ 1" ; for ( int i = 0 ; i < MEGAMORPHIC_LOOP_COUNT ; i ++ ) { assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " delete ▁ foo ; ▁ a " + i + " ▁ = ▁ 1 ; ▁ foo ▁ = ▁ " + i + " ; " ) , i ) ; assertEquals ( e . eval ( sharedGetterScript ) , i ) ; } assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' foo ' ; " ) , null ) ; assertEquals ( e . eval ( sharedGetterScript ) , " foo " ) ; assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " this . foo " ) , MEGAMORPHIC_LOOP_COUNT - 1 ) ; } /* * STRNEWLINE ▁ * ▁ Test ▁ access ▁ to ▁ global ▁ lexically ▁ declared ▁ variables ▁ for ▁ shared ▁ script ▁ classes ▁ with ▁ single ▁ global . STRNEWLINE ▁ */ @ Test public static void megamorphicInheritedGlobalLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final String sharedGetterScript = " foo " ; final String sharedSetterScript = " foo ▁ = ▁ 1" ; for ( int i = 0 ; i < MEGAMORPHIC_LOOP_COUNT ; i ++ ) { assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " delete ▁ foo ; ▁ a " + i + " ▁ = ▁ 1 ; ▁ Object . prototype . foo ▁ = ▁ " + i + " ; " ) , i ) ; assertEquals ( e . eval ( sharedGetterScript ) , i ) ; } assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' foo ' ; " ) , null ) ; assertEquals ( e . eval ( sharedGetterScript ) , " foo " ) ; assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " this . foo " ) , MEGAMORPHIC_LOOP_COUNT - 1 ) ; } /* * STRNEWLINE ▁ * ▁ Test ▁ multi - threaded ▁ access ▁ to ▁ global ▁ lexically ▁ declared ▁ variables ▁ for ▁ shared ▁ script ▁ classes ▁ with ▁ multiple ▁ globals . STRNEWLINE ▁ */ @ Test public static void multiThreadedLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final Bindings b = e . createBindings ( ) ; final ScriptContext origContext = e . getContext ( ) ; final ScriptContext newCtxt = new SimpleScriptContext ( ) ; newCtxt . setBindings ( b , ScriptContext . ENGINE_SCOPE ) ; final String sharedScript = " foo " ; assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' original ▁ context ' ; " , origContext ) , null ) ; assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' new ▁ context ' ; " , newCtxt ) , null ) ; final Thread t1 = new Thread ( new ScriptRunner ( e , origContext , sharedScript , " original ▁ context " , 1000 ) ) ; final Thread t2 = new Thread ( new ScriptRunner ( e , newCtxt , sharedScript , " new ▁ context " , 1000 ) ) ; t1 . start ( ) ; t2 . start ( ) ; t1 . join ( ) ; t2 . join ( ) ; assertEquals ( e . eval ( " foo ▁ = ▁ ' newer ▁ context ' ; " , newCtxt ) , " newer ▁ context " ) ; final Thread t3 = new Thread ( new ScriptRunner ( e , origContext , sharedScript , " original ▁ context " , 1000 ) ) ; final Thread t4 = new Thread ( new ScriptRunner ( e , newCtxt , sharedScript , " newer ▁ context " , 1000 ) ) ; t3 . start ( ) ; t4 . start ( ) ; t3 . join ( ) ; t4 . join ( ) ; assertEquals ( e . eval ( sharedScript ) , " original ▁ context " ) ; assertEquals ( e . eval ( sharedScript , newCtxt ) , " newer ▁ context " ) ; } private static class ScriptRunner implements Runnable { final ScriptEngine engine ; final ScriptContext context ; final String source ; final Object expected ; final int iterations ; ScriptRunner ( final ScriptEngine engine , final ScriptContext context , final String source , final Object expected , final int iterations ) { this . engine = engine ; this . context = context ; this . source = source ; this . expected = expected ; this . iterations = iterations ; } @ Override public void run ( ) { try { for ( int i = 0 ; i < iterations ; i ++ ) { assertEquals ( engine . eval ( source , context ) , expected ) ; } } catch ( final ScriptException se ) { throw new RuntimeException ( se ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="davidzchen/bazel/tree/master/third_party/java/proguard/proguard5.3.3/src/proguard/optimize/info/InstanceofClassMarker.java"> /* STRNEWLINE ▁ * ▁ ProGuard ▁ - - ▁ shrinking , ▁ optimization , ▁ obfuscation , ▁ and ▁ preverification STRNEWLINE ▁ * ▁ of ▁ Java ▁ bytecode . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Copyright ▁ ( c ) ▁ 2002-2017 ▁ Eric ▁ Lafortune ▁ @ ▁ GuardSquare STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it STRNEWLINE ▁ * ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free STRNEWLINE ▁ * ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) STRNEWLINE ▁ * ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT STRNEWLINE ▁ * ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or STRNEWLINE ▁ * ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for STRNEWLINE ▁ * ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along STRNEWLINE ▁ * ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , STRNEWLINE ▁ * ▁ 59 ▁ Temple ▁ Place , ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 ▁ USA STRNEWLINE ▁ */ package proguard . optimize . info ; import proguard . classfile . * ; import proguard . classfile . attribute . CodeAttribute ; import proguard . classfile . constant . ClassConstant ; import proguard . classfile . constant . visitor . ConstantVisitor ; import proguard . classfile . instruction . * ; import proguard . classfile . instruction . visitor . InstructionVisitor ; import proguard . classfile . util . SimplifiedVisitor ; import proguard . classfile . visitor . ClassVisitor ; /* * STRNEWLINE ▁ * ▁ This ▁ InstructionVisitor ▁ marks ▁ all ▁ classes ▁ that ▁ are ▁ used ▁ in ▁ an ▁ ' instanceof ' STRNEWLINE ▁ * ▁ test ▁ by ▁ any ▁ of ▁ the ▁ instructions ▁ that ▁ it ▁ visits . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ author ▁ Eric ▁ Lafortune STRNEWLINE ▁ */ public class InstanceofClassMarker extends SimplifiedVisitor implements InstructionVisitor , ConstantVisitor , ClassVisitor { // ▁ Implementations ▁ for ▁ InstructionVisitor . ENDCOM public void visitAnyInstruction ( Clazz clazz , Method method , CodeAttribute codeAttribute , int offset , Instruction instruction ) { } public void visitConstantInstruction ( Clazz clazz , Method method , CodeAttribute codeAttribute , int offset , ConstantInstruction constantInstruction ) { if ( constantInstruction . opcode == InstructionConstants . OP_INSTANCEOF ) { clazz . constantPoolEntryAccept ( constantInstruction . constantIndex , this ) ; } } // ▁ Implementations ▁ for ▁ ConstantVisitor . ENDCOM public void visitClassConstant ( Clazz clazz , ClassConstant classConstant ) { classConstant . referencedClassAccept ( this ) ; } // ▁ Implementations ▁ for ▁ ClassVisitor . ENDCOM public void visitLibraryClass ( LibraryClass libraryClass ) { } public void visitProgramClass ( ProgramClass programClass ) { setInstanceofed ( programClass ) ; } // ▁ Small ▁ utility ▁ methods . ENDCOM private static void setInstanceofed ( Clazz clazz ) { ClassOptimizationInfo info = ClassOptimizationInfo . getClassOptimizationInfo ( clazz ) ; if ( info != null ) { info . setInstanceofed ( ) ; } } public static boolean isInstanceofed ( Clazz clazz ) { ClassOptimizationInfo info = ClassOptimizationInfo . getClassOptimizationInfo ( clazz ) ; return info == null || info . isInstanceofed ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="jondong/crosswalk/tree/master/third_party/lzma_sdk/src/SevenZip/LzmaAlone.java"> package SevenZip ; public class LzmaAlone { static public class CommandLine { public static final int kEncode = 0 ; public static final int kDecode = 1 ; public static final int kBenchmak = 2 ; public int Command = - 1 ; public int NumBenchmarkPasses = 10 ; public int DictionarySize = 1 << 23 ; public boolean DictionarySizeIsDefined = false ; public int Lc = 3 ; public int Lp = 0 ; public int Pb = 2 ; public int Fb = 128 ; public boolean FbIsDefined = false ; public boolean Eos = false ; public int Algorithm = 2 ; public int MatchFinder = 1 ; public String InFile ; public String OutFile ; boolean ParseSwitch ( String s ) { if ( s . startsWith ( " d " ) ) { DictionarySize = 1 << Integer . parseInt ( s . substring ( 1 ) ) ; DictionarySizeIsDefined = true ; } else if ( s . startsWith ( " fb " ) ) { Fb = Integer . parseInt ( s . substring ( 2 ) ) ; FbIsDefined = true ; } else if ( s . startsWith ( " a " ) ) Algorithm = Integer . parseInt ( s . substring ( 1 ) ) ; else if ( s . startsWith ( " lc " ) ) Lc = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " lp " ) ) Lp = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " pb " ) ) Pb = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " eos " ) ) Eos = true ; else if ( s . startsWith ( " mf " ) ) { String mfs = s . substring ( 2 ) ; if ( mfs . equals ( " bt2" ) ) MatchFinder = 0 ; else if ( mfs . equals ( " bt4" ) ) MatchFinder = 1 ; else if ( mfs . equals ( " bt4b " ) ) MatchFinder = 2 ; else return false ; } else return false ; return true ; } public boolean Parse ( String [ ] args ) throws Exception { int pos = 0 ; boolean switchMode = true ; for ( int i = 0 ; i < args . length ; i ++ ) { String s = args [ i ] ; if ( s . length ( ) == 0 ) return false ; if ( switchMode ) { if ( s . compareTo ( " - - " ) == 0 ) { switchMode = false ; continue ; } if ( s . charAt ( 0 ) == ' - ' ) { String sw = s . substring ( 1 ) . toLowerCase ( ) ; if ( sw . length ( ) == 0 ) return false ; try { if ( ! ParseSwitch ( sw ) ) return false ; } catch ( NumberFormatException e ) { return false ; } continue ; } } if ( pos == 0 ) { if ( s . equalsIgnoreCase ( " e " ) ) Command = kEncode ; else if ( s . equalsIgnoreCase ( " d " ) ) Command = kDecode ; else if ( s . equalsIgnoreCase ( " b " ) ) Command = kBenchmak ; else return false ; } else if ( pos == 1 ) { if ( Command == kBenchmak ) { try { NumBenchmarkPasses = Integer . parseInt ( s ) ; if ( NumBenchmarkPasses < 1 ) return false ; } catch ( NumberFormatException e ) { return false ; } } else InFile = s ; } else if ( pos == 2 ) OutFile = s ; else return false ; pos ++ ; continue ; } return true ; } } static void PrintHelp ( ) { System . out . println ( " \n Usage : ▁ ▁ LZMA ▁ < e | d > ▁ [ < switches > . . . ] ▁ inputFile ▁ outputFile \n " + " ▁ ▁ e : ▁ encode ▁ file \n " + " ▁ ▁ d : ▁ decode ▁ file \n " + " ▁ ▁ b : ▁ Benchmark \n " + " < Switches > \n " + // ▁ " ▁ - a { N } : ▁ set ▁ compression ▁ mode ▁ - ▁ [ 0 , ▁ 1 ] , ▁ default : ▁ 1 ▁ ( max ) \n " ▁ + ENDCOM " ▁ ▁ - d { N } : ▁ ▁ set ▁ dictionary ▁ - ▁ [ 0,28 ] , ▁ default : ▁ 23 ▁ ( 8MB ) \n " + " ▁ ▁ - fb { N } : ▁ set ▁ number ▁ of ▁ fast ▁ bytes ▁ - ▁ [ 5 , ▁ 273 ] , ▁ default : ▁ 128 \n " + " ▁ ▁ - lc { N } : ▁ set ▁ number ▁ of ▁ literal ▁ context ▁ bits ▁ - ▁ [ 0 , ▁ 8 ] , ▁ default : ▁ 3 \n " + " ▁ ▁ - lp { N } : ▁ set ▁ number ▁ of ▁ literal ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 0 \n " + " ▁ ▁ - pb { N } : ▁ set ▁ number ▁ of ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 2 \n " + " ▁ ▁ - mf { MF _ ID } : ▁ set ▁ Match ▁ Finder : ▁ [ bt2 , ▁ bt4 ] , ▁ default : ▁ bt4 \n " + " ▁ ▁ - eos : ▁ ▁ ▁ write ▁ End ▁ Of ▁ Stream ▁ marker \n " ) ; } public static void main ( String [ ] args ) throws Exception { System . out . println ( " \n LZMA ▁ ( Java ) ▁ 4.61 ▁ ▁ 2008-11-23 \n " ) ; if ( args . length < 1 ) { PrintHelp ( ) ; return ; } CommandLine params = new CommandLine ( ) ; if ( ! params . Parse ( args ) ) { System . out . println ( " \n Incorrect ▁ command " ) ; return ; } if ( params . Command == CommandLine . kBenchmak ) { int dictionary = ( 1 << 21 ) ; if ( params . DictionarySizeIsDefined ) dictionary = params . DictionarySize ; if ( params . MatchFinder > 1 ) throw new Exception ( " Unsupported ▁ match ▁ finder " ) ; SevenZip . LzmaBench . LzmaBenchmark ( params . NumBenchmarkPasses , dictionary ) ; } else if ( params . Command == CommandLine . kEncode || params . Command == CommandLine . kDecode ) { java . io . File inFile = new java . io . File ( params . InFile ) ; java . io . File outFile = new java . io . File ( params . OutFile ) ; java . io . BufferedInputStream inStream = new java . io . BufferedInputStream ( new java . io . FileInputStream ( inFile ) ) ; java . io . BufferedOutputStream outStream = new java . io . BufferedOutputStream ( new java . io . FileOutputStream ( outFile ) ) ; boolean eos = false ; if ( params . Eos ) eos = true ; if ( params . Command == CommandLine . kEncode ) { SevenZip . Compression . LZMA . Encoder encoder = new SevenZip . Compression . LZMA . Encoder ( ) ; if ( ! encoder . SetAlgorithm ( params . Algorithm ) ) throw new Exception ( " Incorrect ▁ compression ▁ mode " ) ; if ( ! encoder . SetDictionarySize ( params . DictionarySize ) ) throw new Exception ( " Incorrect ▁ dictionary ▁ size " ) ; if ( ! encoder . SetNumFastBytes ( params . Fb ) ) throw new Exception ( " Incorrect ▁ - fb ▁ value " ) ; if ( ! encoder . SetMatchFinder ( params . MatchFinder ) ) throw new Exception ( " Incorrect ▁ - mf ▁ value " ) ; if ( ! encoder . SetLcLpPb ( params . Lc , params . Lp , params . Pb ) ) throw new Exception ( " Incorrect ▁ - lc ▁ or ▁ - lp ▁ or ▁ - pb ▁ value " ) ; encoder . SetEndMarkerMode ( eos ) ; encoder . WriteCoderProperties ( outStream ) ; long fileSize ; if ( eos ) fileSize = - 1 ; else fileSize = inFile . length ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) outStream . write ( ( int ) ( fileSize > > > ( 8 * i ) ) & 0xFF ) ; encoder . Code ( inStream , outStream , - 1 , - 1 , null ) ; } else { int propertiesSize = 5 ; byte [ ] properties = new byte [ propertiesSize ] ; if ( inStream . read ( properties , 0 , propertiesSize ) != propertiesSize ) throw new Exception ( " input ▁ . lzma ▁ file ▁ is ▁ too ▁ short " ) ; SevenZip . Compression . LZMA . Decoder decoder = new SevenZip . Compression . LZMA . Decoder ( ) ; if ( ! decoder . SetDecoderProperties ( properties ) ) throw new Exception ( " Incorrect ▁ stream ▁ properties " ) ; long outSize = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int v = inStream . read ( ) ; if ( v < 0 ) throw new Exception ( " Can ' t ▁ read ▁ stream ▁ size " ) ; outSize |= ( ( long ) v ) << ( 8 * i ) ; } if ( ! decoder . Code ( inStream , outStream , outSize ) ) throw new Exception ( " Error ▁ in ▁ data ▁ stream " ) ; } outStream . flush ( ) ; outStream . close ( ) ; inStream . close ( ) ; } else throw new Exception ( " Incorrect ▁ command " ) ; return ; } } </DOCUMENT>
<DOCUMENT_ID="pressgang-ccms/PressGangCCMSCommonUtilities/tree/master/src/main/java/org/jboss/pressgang/ccms/utils/common/ExceptionUtilities.java"> /* STRNEWLINE ▁ Copyright ▁ 2011-2014 ▁ Red ▁ Hat , ▁ Inc STRNEWLINE STRNEWLINE ▁ This ▁ file ▁ is ▁ part ▁ of ▁ PressGang ▁ CCMS . STRNEWLINE STRNEWLINE ▁ PressGang ▁ CCMS ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or STRNEWLINE ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE STRNEWLINE ▁ PressGang ▁ CCMS ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE STRNEWLINE ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License STRNEWLINE ▁ along ▁ with ▁ PressGang ▁ CCMS . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE */ package org . jboss . pressgang . ccms . utils . common ; import java . io . PrintWriter ; import java . io . StringWriter ; public class ExceptionUtilities { /* * STRNEWLINE ▁ * ▁ A ▁ standard ▁ function ▁ to ▁ get ▁ the ▁ stack ▁ trace ▁ from ▁ a STRNEWLINE ▁ * ▁ thrown ▁ Exception STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ ex ▁ The ▁ thrown ▁ exception STRNEWLINE ▁ * ▁ @ return ▁ The ▁ stack ▁ trace ▁ from ▁ the ▁ exception STRNEWLINE ▁ */ public static String getStackTrace ( final Throwable ex ) { final StringWriter sw = new StringWriter ( ) ; final PrintWriter pw = new PrintWriter ( sw , true ) ; ex . printStackTrace ( pw ) ; pw . flush ( ) ; sw . flush ( ) ; return sw . toString ( ) ; } /* * STRNEWLINE ▁ * ▁ Gets ▁ the ▁ root ▁ cause ▁ of ▁ an ▁ Exception / Error STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ throwable ▁ The ▁ exception / error ▁ to ▁ find ▁ the ▁ root ▁ cause ▁ of . STRNEWLINE ▁ * ▁ @ return ▁ The ▁ root ▁ cause ▁ of ▁ the ▁ exception , ▁ or ▁ throwable ▁ if ▁ it ▁ is ▁ the ▁ root ▁ cause . STRNEWLINE ▁ */ public static Throwable getRootCause ( Throwable throwable ) { if ( throwable . getCause ( ) != null ) return getRootCause ( throwable . getCause ( ) ) ; return throwable ; } } </DOCUMENT>
<DOCUMENT_ID="akshayabd/jenkins/tree/master/core/src/main/java/hudson/model/ListView.java"> /* STRNEWLINE ▁ * ▁ The ▁ MIT ▁ License STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ Copyright ▁ ( c ) ▁ 2004-2010 , ▁ Sun ▁ Microsystems , ▁ Inc . , ▁ Kohsuke ▁ Kawaguchi , STRNEWLINE ▁ * ▁ Erik ▁ Ramfelt , ▁ Seiji ▁ Sogabe , ▁ Martin ▁ Eigenbrodt , ▁ Alan ▁ Harder STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Permission ▁ is ▁ hereby ▁ granted , ▁ free ▁ of ▁ charge , ▁ to ▁ any ▁ person ▁ obtaining ▁ a ▁ copy STRNEWLINE ▁ * ▁ of ▁ this ▁ software ▁ and ▁ associated ▁ documentation ▁ files ▁ ( the ▁ " Software " ) , ▁ to ▁ deal STRNEWLINE ▁ * ▁ in ▁ the ▁ Software ▁ without ▁ restriction , ▁ including ▁ without ▁ limitation ▁ the ▁ rights STRNEWLINE ▁ * ▁ to ▁ use , ▁ copy , ▁ modify , ▁ merge , ▁ publish , ▁ distribute , ▁ sublicense , ▁ and / or ▁ sell STRNEWLINE ▁ * ▁ copies ▁ of ▁ the ▁ Software , ▁ and ▁ to ▁ permit ▁ persons ▁ to ▁ whom ▁ the ▁ Software ▁ is STRNEWLINE ▁ * ▁ furnished ▁ to ▁ do ▁ so , ▁ subject ▁ to ▁ the ▁ following ▁ conditions : STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ The ▁ above ▁ copyright ▁ notice ▁ and ▁ this ▁ permission ▁ notice ▁ shall ▁ be ▁ included ▁ in STRNEWLINE ▁ * ▁ all ▁ copies ▁ or ▁ substantial ▁ portions ▁ of ▁ the ▁ Software . STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ THE ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ " AS ▁ IS " , ▁ WITHOUT ▁ WARRANTY ▁ OF ▁ ANY ▁ KIND , ▁ EXPRESS ▁ OR STRNEWLINE ▁ * ▁ IMPLIED , ▁ INCLUDING ▁ BUT ▁ NOT ▁ LIMITED ▁ TO ▁ THE ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY , STRNEWLINE ▁ * ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE ▁ AND ▁ NONINFRINGEMENT . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE STRNEWLINE ▁ * ▁ AUTHORS ▁ OR ▁ COPYRIGHT ▁ HOLDERS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ CLAIM , ▁ DAMAGES ▁ OR ▁ OTHER STRNEWLINE ▁ * ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ AN ▁ ACTION ▁ OF ▁ CONTRACT , ▁ TORT ▁ OR ▁ OTHERWISE , ▁ ARISING ▁ FROM , STRNEWLINE ▁ * ▁ OUT ▁ OF ▁ OR ▁ IN ▁ CONNECTION ▁ WITH ▁ THE ▁ SOFTWARE ▁ OR ▁ THE ▁ USE ▁ OR ▁ OTHER ▁ DEALINGS ▁ IN STRNEWLINE ▁ * ▁ THE ▁ SOFTWARE . STRNEWLINE ▁ */ package hudson . model ; import hudson . Extension ; import hudson . Util ; import hudson . diagnosis . OldDataMonitor ; import hudson . model . Descriptor . FormException ; import hudson . model . listeners . ItemListener ; import hudson . security . ACL ; import hudson . util . CaseInsensitiveComparator ; import hudson . util . DescribableList ; import hudson . util . FormValidation ; import hudson . util . HttpResponses ; import hudson . views . ListViewColumn ; import hudson . views . ViewJobFilter ; import java . io . IOException ; import java . util . * ; import java . util . logging . Level ; import java . util . logging . Logger ; import java . util . regex . Pattern ; import java . util . regex . PatternSyntaxException ; import javax . annotation . concurrent . GuardedBy ; import javax . servlet . ServletException ; import jenkins . model . Jenkins ; import net . sf . json . JSONObject ; import org . kohsuke . accmod . Restricted ; import org . kohsuke . accmod . restrictions . NoExternalUse ; import org . kohsuke . stapler . DataBoundConstructor ; import org . kohsuke . stapler . HttpResponse ; import org . kohsuke . stapler . QueryParameter ; import org . kohsuke . stapler . StaplerRequest ; import org . kohsuke . stapler . StaplerResponse ; import org . kohsuke . stapler . interceptor . RequirePOST ; /* * STRNEWLINE ▁ * ▁ Displays ▁ { @ link ▁ Job } s ▁ in ▁ a ▁ flat ▁ list ▁ view . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ author ▁ Kohsuke ▁ Kawaguchi STRNEWLINE ▁ */ public class ListView extends View implements DirectlyModifiableView { /* * STRNEWLINE ▁ * ▁ List ▁ of ▁ job ▁ names . ▁ This ▁ is ▁ what ▁ gets ▁ serialized . STRNEWLINE ▁ */ @ GuardedBy ( " this " ) /* package */ /* almost - final */ SortedSet < String > jobNames = new TreeSet < String > ( CaseInsensitiveComparator . INSTANCE ) ; private DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > jobFilters ; private DescribableList < ListViewColumn , Descriptor < ListViewColumn > > columns ; /* * STRNEWLINE ▁ * ▁ Include ▁ regex ▁ string . STRNEWLINE ▁ */ private String includeRegex ; /* * STRNEWLINE ▁ * ▁ Whether ▁ to ▁ recurse ▁ in ▁ ItemGroups STRNEWLINE ▁ */ private boolean recurse ; /* * STRNEWLINE ▁ * ▁ Compiled ▁ include ▁ pattern ▁ from ▁ the ▁ includeRegex ▁ string . STRNEWLINE ▁ */ private transient Pattern includePattern ; /* * STRNEWLINE ▁ * ▁ Filter ▁ by ▁ enabled / disabled ▁ status ▁ of ▁ jobs . STRNEWLINE ▁ * ▁ Null ▁ for ▁ no ▁ filter , ▁ true ▁ for ▁ enabled - only , ▁ false ▁ for ▁ disabled - only . STRNEWLINE ▁ */ private Boolean statusFilter ; @ DataBoundConstructor public ListView ( String name ) { super ( name ) ; initColumns ( ) ; initJobFilters ( ) ; } public ListView ( String name , ViewGroup owner ) { this ( name ) ; this . owner = owner ; } private Object readResolve ( ) { if ( includeRegex != null ) { try { includePattern = Pattern . compile ( includeRegex ) ; } catch ( PatternSyntaxException x ) { includeRegex = null ; OldDataMonitor . report ( this , Collections . < Throwable > singleton ( x ) ) ; } } if ( jobNames == null ) { jobNames = new TreeSet < String > ( CaseInsensitiveComparator . INSTANCE ) ; } initColumns ( ) ; initJobFilters ( ) ; return this ; } protected void initColumns ( ) { if ( columns == null ) columns = new DescribableList < ListViewColumn , Descriptor < ListViewColumn > > ( this , ListViewColumn . createDefaultInitialColumnList ( ) ) ; } protected void initJobFilters ( ) { if ( jobFilters == null ) jobFilters = new DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > ( this ) ; } /* * STRNEWLINE ▁ * ▁ Used ▁ to ▁ determine ▁ if ▁ we ▁ want ▁ to ▁ display ▁ the ▁ Add ▁ button . STRNEWLINE ▁ */ public boolean hasJobFilterExtensions ( ) { return ! ViewJobFilter . all ( ) . isEmpty ( ) ; } public DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > getJobFilters ( ) { return jobFilters ; } @ Override public DescribableList < ListViewColumn , Descriptor < ListViewColumn > > getColumns ( ) { return columns ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ a ▁ read - only ▁ view ▁ of ▁ all ▁ { @ link ▁ Job } s ▁ in ▁ this ▁ view . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ < p > STRNEWLINE ▁ * ▁ This ▁ method ▁ returns ▁ a ▁ separate ▁ copy ▁ each ▁ time ▁ to ▁ avoid STRNEWLINE ▁ * ▁ concurrent ▁ modification ▁ issue . STRNEWLINE ▁ */ @ Override public List < TopLevelItem > getItems ( ) { SortedSet < String > names ; List < TopLevelItem > items = new ArrayList < TopLevelItem > ( ) ; synchronized ( this ) { names = new TreeSet < String > ( jobNames ) ; } ItemGroup < ? extends TopLevelItem > parent = getOwnerItemGroup ( ) ; List < TopLevelItem > parentItems = new ArrayList < TopLevelItem > ( parent . getItems ( ) ) ; includeItems ( parent , parentItems , names ) ; Boolean statusFilter = this . statusFilter ; // ▁ capture ▁ the ▁ value ▁ to ▁ isolate ▁ us ▁ from ▁ concurrent ▁ update ENDCOM Iterable < ? extends TopLevelItem > candidates ; if ( recurse ) { candidates = Items . getAllItems ( parent , TopLevelItem . class ) ; } else { candidates = parent . getItems ( ) ; } for ( TopLevelItem item : candidates ) { if ( ! names . contains ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ) continue ; // ▁ Add ▁ if ▁ no ▁ status ▁ filter ▁ or ▁ filter ▁ matches ▁ enabled / disabled ▁ status : ENDCOM if ( statusFilter == null || ! ( item instanceof AbstractProject ) || ( ( AbstractProject ) item ) . isDisabled ( ) ^ statusFilter ) items . add ( item ) ; } // ▁ check ▁ the ▁ filters ENDCOM Iterable < ViewJobFilter > jobFilters = getJobFilters ( ) ; List < TopLevelItem > allItems = new ArrayList < TopLevelItem > ( parentItems ) ; if ( recurse ) allItems = expand ( allItems , new ArrayList < TopLevelItem > ( ) ) ; for ( ViewJobFilter jobFilter : jobFilters ) { items = jobFilter . filter ( items , allItems , this ) ; } // ▁ for ▁ sanity , ▁ trim ▁ off ▁ duplicates ENDCOM items = new ArrayList < TopLevelItem > ( new LinkedHashSet < TopLevelItem > ( items ) ) ; return items ; } private List < TopLevelItem > expand ( Collection < TopLevelItem > items , List < TopLevelItem > allItems ) { for ( TopLevelItem item : items ) { if ( item instanceof ItemGroup ) { ItemGroup < ? extends Item > ig = ( ItemGroup < ? extends Item > ) item ; expand ( Util . filter ( ig . getItems ( ) , TopLevelItem . class ) , allItems ) ; } allItems . add ( item ) ; } return allItems ; } @ Override public boolean contains ( TopLevelItem item ) { return getItems ( ) . contains ( item ) ; } private void includeItems ( ItemGroup < ? extends TopLevelItem > root , Collection < ? extends Item > parentItems , SortedSet < String > names ) { if ( includePattern != null ) { for ( Item item : parentItems ) { if ( recurse && item instanceof ItemGroup ) { ItemGroup < ? > ig = ( ItemGroup < ? > ) item ; includeItems ( root , ig . getItems ( ) , names ) ; } if ( item instanceof TopLevelItem ) { String itemName = item . getRelativeNameFrom ( root ) ; if ( includePattern . matcher ( itemName ) . matches ( ) ) { names . add ( itemName ) ; } } } } } public synchronized boolean jobNamesContains ( TopLevelItem item ) { if ( item == null ) return false ; return jobNames . contains ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; } /* * STRNEWLINE ▁ * ▁ Adds ▁ the ▁ given ▁ item ▁ to ▁ this ▁ view . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ since ▁ 1.389 STRNEWLINE ▁ */ @ Override public void add ( TopLevelItem item ) throws IOException { synchronized ( this ) { jobNames . add ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; } save ( ) ; } /* * STRNEWLINE ▁ * ▁ Removes ▁ given ▁ item ▁ from ▁ this ▁ view . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ since ▁ 1.566 STRNEWLINE ▁ */ @ Override public boolean remove ( TopLevelItem item ) throws IOException { synchronized ( this ) { String name = item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ; if ( ! jobNames . remove ( name ) ) return false ; } save ( ) ; return true ; } public String getIncludeRegex ( ) { return includeRegex ; } public boolean isRecurse ( ) { return recurse ; } /* * STRNEWLINE ▁ * ▁ @ since ▁ 1.568 STRNEWLINE ▁ */ public void setRecurse ( boolean recurse ) { this . recurse = recurse ; } /* * STRNEWLINE ▁ * ▁ Filter ▁ by ▁ enabled / disabled ▁ status ▁ of ▁ jobs . STRNEWLINE ▁ * ▁ Null ▁ for ▁ no ▁ filter , ▁ true ▁ for ▁ enabled - only , ▁ false ▁ for ▁ disabled - only . STRNEWLINE ▁ */ public Boolean getStatusFilter ( ) { return statusFilter ; } @ Override @ RequirePOST public Item doCreateItem ( StaplerRequest req , StaplerResponse rsp ) throws IOException , ServletException { ItemGroup < ? extends TopLevelItem > ig = getOwnerItemGroup ( ) ; if ( ig instanceof ModifiableItemGroup ) { TopLevelItem item = ( ( ModifiableItemGroup < ? extends TopLevelItem > ) ig ) . doCreateItem ( req , rsp ) ; if ( item != null ) { synchronized ( this ) { jobNames . add ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; } owner . save ( ) ; } return item ; } return null ; } @ Override @ RequirePOST public HttpResponse doAddJobToView ( @ QueryParameter String name ) throws IOException , ServletException { checkPermission ( View . CONFIGURE ) ; if ( name == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ is ▁ required " ) ; TopLevelItem item = resolveName ( name ) ; if ( item == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ does ▁ not ▁ correspond ▁ to ▁ a ▁ known ▁ item " ) ; if ( contains ( item ) ) return HttpResponses . ok ( ) ; add ( item ) ; owner . save ( ) ; return HttpResponses . ok ( ) ; } @ Override @ RequirePOST public HttpResponse doRemoveJobFromView ( @ QueryParameter String name ) throws IOException , ServletException { checkPermission ( View . CONFIGURE ) ; if ( name == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ is ▁ required " ) ; TopLevelItem item = resolveName ( name ) ; if ( remove ( item ) ) owner . save ( ) ; return HttpResponses . ok ( ) ; } private TopLevelItem resolveName ( String name ) { TopLevelItem item = getOwnerItemGroup ( ) . getItem ( name ) ; if ( item == null ) { name = Items . getCanonicalName ( getOwnerItemGroup ( ) , name ) ; item = Jenkins . getInstance ( ) . getItemByFullName ( name , TopLevelItem . class ) ; } return item ; } /* * STRNEWLINE ▁ * ▁ Handles ▁ the ▁ configuration ▁ submission . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Load ▁ view - specific ▁ properties ▁ here . STRNEWLINE ▁ */ @ Override protected void submit ( StaplerRequest req ) throws ServletException , FormException , IOException { JSONObject json = req . getSubmittedForm ( ) ; synchronized ( this ) { recurse = json . optBoolean ( " recurse " , true ) ; jobNames . clear ( ) ; Iterable < ? extends TopLevelItem > items ; if ( recurse ) { items = Items . getAllItems ( getOwnerItemGroup ( ) , TopLevelItem . class ) ; } else { items = getOwnerItemGroup ( ) . getItems ( ) ; } for ( TopLevelItem item : items ) { String relativeNameFrom = item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ; if ( req . getParameter ( relativeNameFrom ) != null ) { jobNames . add ( relativeNameFrom ) ; } } } setIncludeRegex ( req . getParameter ( " useincluderegex " ) != null ? req . getParameter ( " includeRegex " ) : null ) ; if ( columns == null ) { columns = new DescribableList < ListViewColumn , Descriptor < ListViewColumn > > ( this ) ; } columns . rebuildHetero ( req , json , ListViewColumn . all ( ) , " columns " ) ; if ( jobFilters == null ) { jobFilters = new DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > ( this ) ; } jobFilters . rebuildHetero ( req , json , ViewJobFilter . all ( ) , " jobFilters " ) ; String filter = Util . fixEmpty ( req . getParameter ( " statusFilter " ) ) ; statusFilter = filter != null ? "1" . equals ( filter ) : null ; } /* * ▁ @ since ▁ 1.526 ▁ */ public void setIncludeRegex ( String includeRegex ) { this . includeRegex = Util . nullify ( includeRegex ) ; if ( this . includeRegex == null ) this . includePattern = null ; else this . includePattern = Pattern . compile ( includeRegex ) ; } @ Extension public static class DescriptorImpl extends ViewDescriptor { @ Override public String getDisplayName ( ) { return Messages . ListView_DisplayName ( ) ; } /* * STRNEWLINE ▁ * ▁ Checks ▁ if ▁ the ▁ include ▁ regular ▁ expression ▁ is ▁ valid . STRNEWLINE ▁ */ public FormValidation doCheckIncludeRegex ( @ QueryParameter String value ) throws IOException , ServletException , InterruptedException { String v = Util . fixEmpty ( value ) ; if ( v != null ) { try { Pattern . compile ( v ) ; } catch ( PatternSyntaxException pse ) { return FormValidation . error ( pse . getMessage ( ) ) ; } } return FormValidation . ok ( ) ; } } /* * STRNEWLINE ▁ * ▁ @ deprecated ▁ as ▁ of ▁ 1.391 STRNEWLINE ▁ * ▁ Use ▁ { @ link ▁ ListViewColumn # createDefaultInitialColumnList ( ) } STRNEWLINE ▁ */ @ Deprecated public static List < ListViewColumn > getDefaultColumns ( ) { return ListViewColumn . createDefaultInitialColumnList ( ) ; } @ Restricted ( NoExternalUse . class ) @ Extension public static final class Listener extends ItemListener { @ Override public void onLocationChanged ( final Item item , final String oldFullName , final String newFullName ) { ACL . impersonate ( ACL . SYSTEM , new Runnable ( ) { @ Override public void run ( ) { locationChanged ( item , oldFullName , newFullName ) ; } } ) ; } private void locationChanged ( Item item , String oldFullName , String newFullName ) { final Jenkins jenkins = Jenkins . getInstance ( ) ; for ( View view : jenkins . getViews ( ) ) { if ( view instanceof ListView ) { renameViewItem ( oldFullName , newFullName , jenkins , ( ListView ) view ) ; } } for ( Item g : jenkins . getAllItems ( ) ) { if ( g instanceof ViewGroup ) { ViewGroup vg = ( ViewGroup ) g ; for ( View v : vg . getViews ( ) ) { if ( v instanceof ListView ) { renameViewItem ( oldFullName , newFullName , vg , ( ListView ) v ) ; } } } } } private void renameViewItem ( String oldFullName , String newFullName , ViewGroup vg , ListView lv ) { boolean needsSave ; synchronized ( lv ) { Set < String > oldJobNames = new HashSet < String > ( lv . jobNames ) ; lv . jobNames . clear ( ) ; for ( String oldName : oldJobNames ) { lv . jobNames . add ( Items . computeRelativeNamesAfterRenaming ( oldFullName , newFullName , oldName , vg . getItemGroup ( ) ) ) ; } needsSave = ! oldJobNames . equals ( lv . jobNames ) ; } if ( needsSave ) { // ▁ do ▁ not ▁ hold ▁ ListView ▁ lock ▁ at ▁ the ▁ time ENDCOM try { lv . save ( ) ; } catch ( IOException x ) { Logger . getLogger ( ListView . class . getName ( ) ) . log ( Level . WARNING , null , x ) ; } } } @ Override public void onDeleted ( final Item item ) { ACL . impersonate ( ACL . SYSTEM , new Runnable ( ) { @ Override public void run ( ) { deleted ( item ) ; } } ) ; } private void deleted ( Item item ) { final Jenkins jenkins = Jenkins . getInstance ( ) ; for ( View view : jenkins . getViews ( ) ) { if ( view instanceof ListView ) { deleteViewItem ( item , jenkins , ( ListView ) view ) ; } } for ( Item g : jenkins . getAllItems ( ) ) { if ( g instanceof ViewGroup ) { ViewGroup vg = ( ViewGroup ) g ; for ( View v : vg . getViews ( ) ) { if ( v instanceof ListView ) { deleteViewItem ( item , vg , ( ListView ) v ) ; } } } } } private void deleteViewItem ( Item item , ViewGroup vg , ListView lv ) { boolean needsSave ; synchronized ( lv ) { needsSave = lv . jobNames . remove ( item . getRelativeNameFrom ( vg . getItemGroup ( ) ) ) ; } if ( needsSave ) { try { lv . save ( ) ; } catch ( IOException x ) { Logger . getLogger ( ListView . class . getName ( ) ) . log ( Level . WARNING , null , x ) ; } } } } } </DOCUMENT>
<DOCUMENT_ID="arunmk/CoreNLP/tree/master/test/src/edu/stanford/nlp/util/IterablesTest.java"> package edu . stanford . nlp . util ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; import java . util . Random ; import java . util . function . Function ; import junit . framework . Assert ; import junit . framework . TestCase ; /* * STRNEWLINE ▁ * ▁ Unit ▁ tests ▁ for ▁ Iterables ▁ utility ▁ class . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ author ▁ dramage STRNEWLINE ▁ */ public class IterablesTest extends TestCase { public void testZip ( ) { String [ ] s1 = new String [ ] { " a " , " b " , " c " } ; Integer [ ] s2 = new Integer [ ] { 1 , 2 , 3 , 4 } ; int count = 0 ; for ( Pair < String , Integer > pair : Iterables . zip ( s1 , s2 ) ) { assertEquals ( pair . first , s1 [ count ] ) ; assertEquals ( pair . second , s2 [ count ] ) ; count ++ ; } assertEquals ( s1 . length < s2 . length ? s1 . length : s2 . length , count ) ; } @ SuppressWarnings ( " unchecked " ) public void testChain ( ) { List < String > s1 = Arrays . asList ( new String [ ] { " hi " , " there " } ) ; List < String > s2 = Arrays . asList ( new String [ ] { } ) ; List < String > s3 = Arrays . asList ( new String [ ] { " yoo " } ) ; List < String > s4 = Arrays . asList ( new String [ ] { } ) ; List < String > answer = Arrays . asList ( new String [ ] { " yoo " , " hi " , " there " , " yoo " } ) ; List < String > chained = new ArrayList < String > ( ) ; for ( String s : Iterables . chain ( s3 , s1 , s2 , s3 , s4 ) ) { chained . add ( s ) ; } assertEquals ( answer , chained ) ; } public void testFilter ( ) { List < String > values = Arrays . asList ( " a " , " HI " , " tHere " , " YO " ) ; Iterator < String > iterator = Iterables . filter ( values , new Function < String , Boolean > ( ) { public Boolean apply ( String in ) { return in . equals ( in . toUpperCase ( ) ) ; } } ) . iterator ( ) ; assertTrue ( iterator . hasNext ( ) ) ; assertEquals ( iterator . next ( ) , " HI " ) ; assertEquals ( iterator . next ( ) , " YO " ) ; assertFalse ( iterator . hasNext ( ) ) ; } public void testTransform ( ) { List < Integer > values = Arrays . asList ( 1 , 2 , 3 , 4 ) ; List < Integer > squares = Arrays . asList ( 1 , 4 , 9 , 16 ) ; Function < Integer , Integer > squarer = new Function < Integer , Integer > ( ) { public Integer apply ( Integer in ) { return in * in ; } } ; for ( Pair < Integer , Integer > pair : Iterables . zip ( Iterables . transform ( values , squarer ) , squares ) ) { assertEquals ( pair . first , pair . second ) ; } } public void testMerge ( ) { List < String > a = Arrays . asList ( " a " , " b " , " d " , " e " ) ; List < String > b = Arrays . asList ( " b " , " c " , " d " , " e " ) ; Comparator < String > comparator = new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . compareTo ( o2 ) ; } } ; Iterator < Pair < String , String > > iter = Iterables . merge ( a , b , comparator ) . iterator ( ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " b " , " b " ) ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " d " , " d " ) ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " e " , " e " ) ) ; assertTrue ( ! iter . hasNext ( ) ) ; } public void testMerge3 ( ) { List < String > a = Arrays . asList ( " a " , " b " , " d " , " e " ) ; List < String > b = Arrays . asList ( " b " , " c " , " d " , " e " ) ; List < String > c = Arrays . asList ( " a " , " b " , " c " , " e " , " f " ) ; Comparator < String > comparator = new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . compareTo ( o2 ) ; } } ; Iterator < Triple < String , String , String > > iter = Iterables . merge ( a , b , c , comparator ) . iterator ( ) ; assertEquals ( iter . next ( ) , new Triple < String , String , String > ( " b " , " b " , " b " ) ) ; assertEquals ( iter . next ( ) , new Triple < String , String , String > ( " e " , " e " , " e " ) ) ; assertTrue ( ! iter . hasNext ( ) ) ; } public void testGroup ( ) { String [ ] input = new String [ ] { "0 ▁ ab " , "0 ▁ bb " , "0 ▁ cc " , "1 ▁ dd " , "2 ▁ dd " , "2 ▁ kj " , "3 ▁ kj " , "3 ▁ kk " } ; int [ ] counts = new int [ ] { 3 , 1 , 2 , 2 } ; Comparator < String > fieldOne = new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . split ( " ▁ " ) [ 0 ] . compareTo ( o2 . split ( " ▁ " ) [ 0 ] ) ; } } ; int index = 0 ; int group = 0 ; for ( Iterable < String > set : Iterables . group ( Arrays . asList ( input ) , fieldOne ) ) { String sharedKey = null ; int thisCount = 0 ; for ( String line : set ) { String thisKey = line . split ( " ▁ " ) [ 0 ] ; if ( sharedKey == null ) { sharedKey = thisKey ; } else { assertEquals ( " Wrong ▁ key " , sharedKey , thisKey ) ; } assertEquals ( " Wrong ▁ input ▁ line " , line , input [ index ++ ] ) ; thisCount ++ ; } assertEquals ( " Wrong ▁ number ▁ of ▁ items ▁ in ▁ this ▁ iterator " , counts [ group ++ ] , thisCount ) ; } assertEquals ( " Didn ' t ▁ get ▁ all ▁ inputs " , input . length , index ) ; assertEquals ( " Wrong ▁ number ▁ of ▁ groups " , counts . length , group ) ; } public void testSample ( ) { // ▁ make ▁ sure ▁ correct ▁ number ▁ of ▁ items ▁ is ▁ sampled ▁ and ▁ items ▁ are ▁ in ▁ range ENDCOM Iterable < Integer > items = Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ; int count = 0 ; for ( Integer item : Iterables . sample ( items , 5 , 2 , new Random ( ) ) ) { ++ count ; Assert . assertTrue ( item <= 5 ) ; Assert . assertTrue ( item >= 1 ) ; } Assert . assertEquals ( 2 , count ) ; } } </DOCUMENT>
<DOCUMENT_ID="sg26565/hott-transmitter-config/tree/master/lzma-sdk/src/main/java/SevenZip/LzmaAlone.java"> package SevenZip ; public class LzmaAlone { static public class CommandLine { public static final int kEncode = 0 ; public static final int kDecode = 1 ; public static final int kBenchmak = 2 ; public int Command = - 1 ; public int NumBenchmarkPasses = 10 ; public int DictionarySize = 1 << 23 ; public boolean DictionarySizeIsDefined = false ; public int Lc = 3 ; public int Lp = 0 ; public int Pb = 2 ; public int Fb = 128 ; public boolean FbIsDefined = false ; public boolean Eos = false ; public int Algorithm = 2 ; public int MatchFinder = 1 ; public String InFile ; public String OutFile ; boolean ParseSwitch ( String s ) { if ( s . startsWith ( " d " ) ) { DictionarySize = 1 << Integer . parseInt ( s . substring ( 1 ) ) ; DictionarySizeIsDefined = true ; } else if ( s . startsWith ( " fb " ) ) { Fb = Integer . parseInt ( s . substring ( 2 ) ) ; FbIsDefined = true ; } else if ( s . startsWith ( " a " ) ) Algorithm = Integer . parseInt ( s . substring ( 1 ) ) ; else if ( s . startsWith ( " lc " ) ) Lc = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " lp " ) ) Lp = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " pb " ) ) Pb = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " eos " ) ) Eos = true ; else if ( s . startsWith ( " mf " ) ) { String mfs = s . substring ( 2 ) ; if ( mfs . equals ( " bt2" ) ) MatchFinder = 0 ; else if ( mfs . equals ( " bt4" ) ) MatchFinder = 1 ; else if ( mfs . equals ( " bt4b " ) ) MatchFinder = 2 ; else return false ; } else return false ; return true ; } public boolean Parse ( String [ ] args ) throws Exception { int pos = 0 ; boolean switchMode = true ; for ( int i = 0 ; i < args . length ; i ++ ) { String s = args [ i ] ; if ( s . length ( ) == 0 ) return false ; if ( switchMode ) { if ( s . compareTo ( " - - " ) == 0 ) { switchMode = false ; continue ; } if ( s . charAt ( 0 ) == ' - ' ) { String sw = s . substring ( 1 ) . toLowerCase ( ) ; if ( sw . length ( ) == 0 ) return false ; try { if ( ! ParseSwitch ( sw ) ) return false ; } catch ( NumberFormatException e ) { return false ; } continue ; } } if ( pos == 0 ) { if ( s . equalsIgnoreCase ( " e " ) ) Command = kEncode ; else if ( s . equalsIgnoreCase ( " d " ) ) Command = kDecode ; else if ( s . equalsIgnoreCase ( " b " ) ) Command = kBenchmak ; else return false ; } else if ( pos == 1 ) { if ( Command == kBenchmak ) { try { NumBenchmarkPasses = Integer . parseInt ( s ) ; if ( NumBenchmarkPasses < 1 ) return false ; } catch ( NumberFormatException e ) { return false ; } } else InFile = s ; } else if ( pos == 2 ) OutFile = s ; else return false ; pos ++ ; continue ; } return true ; } } static void PrintHelp ( ) { System . out . println ( " \n Usage : ▁ ▁ LZMA ▁ < e | d > ▁ [ < switches > . . . ] ▁ inputFile ▁ outputFile \n " + " ▁ ▁ e : ▁ encode ▁ file \n " + " ▁ ▁ d : ▁ decode ▁ file \n " + " ▁ ▁ b : ▁ Benchmark \n " + " < Switches > \n " + // ▁ " ▁ - a { N } : ▁ set ▁ compression ▁ mode ▁ - ▁ [ 0 , ▁ 1 ] , ▁ default : ▁ 1 ▁ ( max ) \n " ▁ + ENDCOM " ▁ ▁ - d { N } : ▁ ▁ set ▁ dictionary ▁ - ▁ [ 0,28 ] , ▁ default : ▁ 23 ▁ ( 8MB ) \n " + " ▁ ▁ - fb { N } : ▁ set ▁ number ▁ of ▁ fast ▁ bytes ▁ - ▁ [ 5 , ▁ 273 ] , ▁ default : ▁ 128 \n " + " ▁ ▁ - lc { N } : ▁ set ▁ number ▁ of ▁ literal ▁ context ▁ bits ▁ - ▁ [ 0 , ▁ 8 ] , ▁ default : ▁ 3 \n " + " ▁ ▁ - lp { N } : ▁ set ▁ number ▁ of ▁ literal ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 0 \n " + " ▁ ▁ - pb { N } : ▁ set ▁ number ▁ of ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 2 \n " + " ▁ ▁ - mf { MF _ ID } : ▁ set ▁ Match ▁ Finder : ▁ [ bt2 , ▁ bt4 ] , ▁ default : ▁ bt4 \n " + " ▁ ▁ - eos : ▁ ▁ ▁ write ▁ End ▁ Of ▁ Stream ▁ marker \n " ) ; } public static void main ( String [ ] args ) throws Exception { System . out . println ( " \n LZMA ▁ ( Java ) ▁ 4.61 ▁ ▁ 2008-11-23 \n " ) ; if ( args . length < 1 ) { PrintHelp ( ) ; return ; } CommandLine params = new CommandLine ( ) ; if ( ! params . Parse ( args ) ) { System . out . println ( " \n Incorrect ▁ command " ) ; return ; } if ( params . Command == CommandLine . kBenchmak ) { int dictionary = ( 1 << 21 ) ; if ( params . DictionarySizeIsDefined ) dictionary = params . DictionarySize ; if ( params . MatchFinder > 1 ) throw new Exception ( " Unsupported ▁ match ▁ finder " ) ; SevenZip . LzmaBench . LzmaBenchmark ( params . NumBenchmarkPasses , dictionary ) ; } else if ( params . Command == CommandLine . kEncode || params . Command == CommandLine . kDecode ) { java . io . File inFile = new java . io . File ( params . InFile ) ; java . io . File outFile = new java . io . File ( params . OutFile ) ; java . io . BufferedInputStream inStream = new java . io . BufferedInputStream ( new java . io . FileInputStream ( inFile ) ) ; java . io . BufferedOutputStream outStream = new java . io . BufferedOutputStream ( new java . io . FileOutputStream ( outFile ) ) ; boolean eos = false ; if ( params . Eos ) eos = true ; if ( params . Command == CommandLine . kEncode ) { SevenZip . Compression . LZMA . Encoder encoder = new SevenZip . Compression . LZMA . Encoder ( ) ; if ( ! encoder . SetAlgorithm ( params . Algorithm ) ) throw new Exception ( " Incorrect ▁ compression ▁ mode " ) ; if ( ! encoder . SetDictionarySize ( params . DictionarySize ) ) throw new Exception ( " Incorrect ▁ dictionary ▁ size " ) ; if ( ! encoder . SetNumFastBytes ( params . Fb ) ) throw new Exception ( " Incorrect ▁ - fb ▁ value " ) ; if ( ! encoder . SetMatchFinder ( params . MatchFinder ) ) throw new Exception ( " Incorrect ▁ - mf ▁ value " ) ; if ( ! encoder . SetLcLpPb ( params . Lc , params . Lp , params . Pb ) ) throw new Exception ( " Incorrect ▁ - lc ▁ or ▁ - lp ▁ or ▁ - pb ▁ value " ) ; encoder . SetEndMarkerMode ( eos ) ; encoder . WriteCoderProperties ( outStream ) ; long fileSize ; if ( eos ) fileSize = - 1 ; else fileSize = inFile . length ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) outStream . write ( ( int ) ( fileSize > > > ( 8 * i ) ) & 0xFF ) ; encoder . Code ( inStream , outStream , - 1 , - 1 , null ) ; } else { int propertiesSize = 5 ; byte [ ] properties = new byte [ propertiesSize ] ; if ( inStream . read ( properties , 0 , propertiesSize ) != propertiesSize ) throw new Exception ( " input ▁ . lzma ▁ file ▁ is ▁ too ▁ short " ) ; SevenZip . Compression . LZMA . Decoder decoder = new SevenZip . Compression . LZMA . Decoder ( ) ; if ( ! decoder . SetDecoderProperties ( properties ) ) throw new Exception ( " Incorrect ▁ stream ▁ properties " ) ; long outSize = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int v = inStream . read ( ) ; if ( v < 0 ) throw new Exception ( " Can ' t ▁ read ▁ stream ▁ size " ) ; outSize |= ( ( long ) v ) << ( 8 * i ) ; } if ( ! decoder . Code ( inStream , outStream , outSize ) ) throw new Exception ( " Error ▁ in ▁ data ▁ stream " ) ; } outStream . flush ( ) ; outStream . close ( ) ; inStream . close ( ) ; } else throw new Exception ( " Incorrect ▁ command " ) ; return ; } } </DOCUMENT>
<DOCUMENT_ID="lucafavatella/intellij-community/tree/master/platform/platform-api/src/com/intellij/openapi/ide/KillRingTransferable.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ 2000-2011 ▁ JetBrains ▁ s . r . o . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package com . intellij . openapi . ide ; import com . intellij . openapi . editor . Document ; import org . jetbrains . annotations . NotNull ; import org . jetbrains . annotations . Nullable ; import java . awt . datatransfer . DataFlavor ; import java . awt . datatransfer . StringSelection ; import java . awt . datatransfer . Transferable ; import java . awt . datatransfer . UnsupportedFlavorException ; import java . io . IOException ; import java . lang . ref . WeakReference ; /* * STRNEWLINE ▁ * ▁ This ▁ class ▁ represents ▁ usual ▁ { @ link ▁ StringSelection ▁ transferable ▁ string } ▁ with ▁ additional ▁ meta - information ▁ that ▁ describes ▁ the ▁ place STRNEWLINE ▁ * ▁ of ▁ the ▁ document ▁ that ▁ from ▁ there ▁ it ▁ was ▁ retrieved . STRNEWLINE ▁ * ▁ < p / > STRNEWLINE ▁ * ▁ The ▁ main ▁ idea ▁ is ▁ that ▁ we ▁ want ▁ to ▁ be ▁ able ▁ to ▁ combine ▁ adjacent ▁ text ▁ into ▁ single ▁ unit ▁ like STRNEWLINE ▁ * ▁ < a ▁ href = " http : // www . gnu . org / software / emacs / manual / html _ node / emacs / Kill - Ring . html # Kill - Ring " > emacs ▁ kill ▁ ring < / a > ▁ does . STRNEWLINE ▁ * ▁ E . g . ▁ if ▁ the ▁ user ▁ invokes ▁ ' cut ▁ to ▁ the ▁ line ▁ end ' ▁ subsequently ▁ we ▁ may ▁ want ▁ to ▁ paste ▁ all ▁ of ▁ them , ▁ hence , ▁ we ▁ need ▁ to ▁ be ▁ able STRNEWLINE ▁ * ▁ to ▁ distinguish ▁ if ▁ particular ▁ copy - paste ▁ strings ▁ are ▁ adjacent . STRNEWLINE ▁ * ▁ < p / > STRNEWLINE ▁ * ▁ Thread - safe . STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ author ▁ Denis ▁ Zhdanov STRNEWLINE ▁ * ▁ @ since ▁ 4/15/11 ▁ 6:29 ▁ PM STRNEWLINE ▁ */ public class KillRingTransferable implements Transferable { private static final DataFlavor [ ] DATA_FLAVORS = { DataFlavor . stringFlavor } ; private final String myData ; private final WeakReference < Document > myDocument ; private final int myStartOffset ; private final int myEndOffset ; private final boolean myCut ; private volatile boolean myReadyToCombine = true ; /* * STRNEWLINE ▁ * ▁ Creates ▁ new ▁ < code > KillRingTransferable < / code > ▁ object . STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ param ▁ data ▁ target ▁ text ▁ to ▁ transfer STRNEWLINE ▁ * ▁ @ param ▁ document ▁ document ▁ that ▁ contained ▁ given ▁ text STRNEWLINE ▁ * ▁ @ param ▁ startOffset ▁ start ▁ offset ▁ of ▁ the ▁ given ▁ text ▁ at ▁ the ▁ given ▁ document STRNEWLINE ▁ * ▁ @ param ▁ endOffset ▁ end ▁ offset ▁ of ▁ the ▁ given ▁ text ▁ during ▁ current ▁ object ▁ construction STRNEWLINE ▁ * ▁ @ param ▁ cut ▁ flag ▁ that ▁ identifies ▁ whether ▁ target ▁ text ▁ was ▁ cut ▁ or ▁ copied ▁ from ▁ the ▁ document STRNEWLINE ▁ */ public KillRingTransferable ( @ NotNull String data , @ NotNull Document document , int startOffset , int endOffset , boolean cut ) { myData = data ; myDocument = new WeakReference < Document > ( document ) ; myStartOffset = startOffset ; myEndOffset = endOffset ; myCut = cut ; } @ Override public DataFlavor [ ] getTransferDataFlavors ( ) { return DATA_FLAVORS ; } @ Override public boolean isDataFlavorSupported ( DataFlavor flavor ) { return flavor == DataFlavor . stringFlavor ; } @ Nullable @ Override public Object getTransferData ( DataFlavor flavor ) throws UnsupportedFlavorException , IOException { return isDataFlavorSupported ( flavor ) ? myData : null ; } @ Nullable public Document getDocument ( ) { return myDocument . get ( ) ; } public int getStartOffset ( ) { return myStartOffset ; } /* * STRNEWLINE ▁ * ▁ @ return ▁ offset ▁ of ▁ the ▁ target ▁ text ▁ end ▁ on ▁ the ▁ moment ▁ of ▁ the ▁ current ▁ object ▁ construction STRNEWLINE ▁ */ public int getEndOffset ( ) { return myEndOffset ; } public boolean isCut ( ) { return myCut ; } /* * STRNEWLINE ▁ * ▁ @ return ▁ < code > true < / code > ▁ if ▁ current ▁ object ▁ can ▁ be ▁ combined ▁ with ▁ adjacent ▁ text ; ▁ < code > false < / code > ▁ otherwise . STRNEWLINE ▁ * ▁ Default ▁ value ▁ is ▁ < code > true < / code > STRNEWLINE ▁ */ public boolean isReadyToCombine ( ) { return myReadyToCombine ; } /* * STRNEWLINE ▁ * ▁ Allows ▁ to ▁ define ▁ if ▁ current ▁ object ▁ can ▁ be ▁ combined ▁ with ▁ adjacent ▁ text . ▁ STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ param ▁ readyToCombine ▁ < code > true < / code > ▁ if ▁ current ▁ object ▁ can ▁ be ▁ combined ▁ with ▁ adjacent ▁ text ; ▁ < code > false < / code > ▁ otherwise STRNEWLINE ▁ */ public void setReadyToCombine ( boolean readyToCombine ) { myReadyToCombine = readyToCombine ; } @ Override public String toString ( ) { return " data = ' " + myData + " ' , ▁ startOffset = " + myStartOffset + " , ▁ endOffset = " + myEndOffset + " , ▁ cut = " + myCut ; } } </DOCUMENT>
<DOCUMENT_ID="ajhalani/elasticsearch/tree/master/src/main/java/org/elasticsearch/common/logging/log4j/LogConfigurator.java"> /* STRNEWLINE ▁ * ▁ Licensed ▁ to ▁ Elasticsearch ▁ under ▁ one ▁ or ▁ more ▁ contributor STRNEWLINE ▁ * ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file ▁ distributed ▁ with STRNEWLINE ▁ * ▁ this ▁ work ▁ for ▁ additional ▁ information ▁ regarding ▁ copyright STRNEWLINE ▁ * ▁ ownership . ▁ Elasticsearch ▁ licenses ▁ this ▁ file ▁ to ▁ you ▁ under STRNEWLINE ▁ * ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ▁ you ▁ may STRNEWLINE ▁ * ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , STRNEWLINE ▁ * ▁ software ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an STRNEWLINE ▁ * ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY STRNEWLINE ▁ * ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ▁ See ▁ the ▁ License ▁ for ▁ the STRNEWLINE ▁ * ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations STRNEWLINE ▁ * ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . elasticsearch . common . logging . log4j ; import com . google . common . collect . ImmutableMap ; import org . apache . log4j . PropertyConfigurator ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . collect . MapBuilder ; import org . elasticsearch . common . settings . ImmutableSettings ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . env . FailedToResolveConfigException ; import java . io . IOException ; import java . net . MalformedURLException ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . EnumSet ; import java . util . Map ; import java . util . Properties ; import static org . elasticsearch . common . settings . ImmutableSettings . settingsBuilder ; public class LogConfigurator { private static boolean loaded ; private static ImmutableMap < String , String > replacements = new MapBuilder < String , String > ( ) . put ( " console " , " org . elasticsearch . common . logging . log4j . ConsoleAppender " ) . put ( " async " , " org . apache . log4j . AsyncAppender " ) . put ( " dailyRollingFile " , " org . apache . log4j . DailyRollingFileAppender " ) . put ( " externallyRolledFile " , " org . apache . log4j . ExternallyRolledFileAppender " ) . put ( " file " , " org . apache . log4j . FileAppender " ) . put ( " jdbc " , " org . apache . log4j . jdbc . JDBCAppender " ) . put ( " jms " , " org . apache . log4j . net . JMSAppender " ) . put ( " lf5" , " org . apache . log4j . lf5 . LF5Appender " ) . put ( " ntevent " , " org . apache . log4j . nt . NTEventLogAppender " ) . put ( " null " , " org . apache . log4j . NullAppender " ) . put ( " rollingFile " , " org . apache . log4j . RollingFileAppender " ) . put ( " smtp " , " org . apache . log4j . net . SMTPAppender " ) . put ( " socket " , " org . apache . log4j . net . SocketAppender " ) . put ( " socketHub " , " org . apache . log4j . net . SocketHubAppender " ) . put ( " syslog " , " org . apache . log4j . net . SyslogAppender " ) . put ( " telnet " , " org . apache . log4j . net . TelnetAppender " ) // ▁ layouts ENDCOM . put ( " simple " , " org . apache . log4j . SimpleLayout " ) . put ( " html " , " org . apache . log4j . HTMLLayout " ) . put ( " pattern " , " org . apache . log4j . PatternLayout " ) . put ( " consolePattern " , " org . apache . log4j . PatternLayout " ) . put ( " ttcc " , " org . apache . log4j . TTCCLayout " ) . put ( " xml " , " org . apache . log4j . XMLLayout " ) . immutableMap ( ) ; public static void configure ( Settings settings ) { if ( loaded ) { return ; } loaded = true ; Environment environment = new Environment ( settings ) ; ImmutableSettings . Builder settingsBuilder = settingsBuilder ( ) . put ( settings ) ; resolveConfig ( environment , settingsBuilder ) ; settingsBuilder . putProperties ( " elasticsearch . " , System . getProperties ( ) ) . putProperties ( " es . " , System . getProperties ( ) ) . replacePropertyPlaceholders ( ) ; Properties props = new Properties ( ) ; for ( Map . Entry < String , String > entry : settingsBuilder . build ( ) . getAsMap ( ) . entrySet ( ) ) { String key = " log4j . " + entry . getKey ( ) ; String value = entry . getValue ( ) ; if ( replacements . containsKey ( value ) ) { value = replacements . get ( value ) ; } if ( key . endsWith ( " . value " ) ) { props . setProperty ( key . substring ( 0 , key . length ( ) - " . value " . length ( ) ) , value ) ; } else if ( key . endsWith ( " . type " ) ) { props . setProperty ( key . substring ( 0 , key . length ( ) - " . type " . length ( ) ) , value ) ; } else { props . setProperty ( key , value ) ; } } PropertyConfigurator . configure ( props ) ; } public static void resolveConfig ( Environment env , final ImmutableSettings . Builder settingsBuilder ) { try { Files . walkFileTree ( env . configFile ( ) . toPath ( ) , EnumSet . of ( FileVisitOption . FOLLOW_LINKS ) , Integer . MAX_VALUE , new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { if ( file . getFileName ( ) . toString ( ) . startsWith ( " logging . " ) ) { loadConfig ( file , settingsBuilder ) ; } return FileVisitResult . CONTINUE ; } } ) ; } catch ( IOException ioe ) { throw new ElasticsearchException ( " Failed ▁ to ▁ load ▁ logging ▁ configuration " , ioe ) ; } } public static void loadConfig ( Path file , ImmutableSettings . Builder settingsBuilder ) { try { settingsBuilder . loadFromUrl ( file . toUri ( ) . toURL ( ) ) ; } catch ( FailedToResolveConfigException | NoClassDefFoundError | MalformedURLException e ) { // ▁ ignore ENDCOM } } } </DOCUMENT>
<DOCUMENT_ID="murador/ignite/tree/master/modules/core/src/main/java/org/apache/ignite/internal/GridJobSiblingsResponse.java"> /* STRNEWLINE ▁ * ▁ Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ ( ASF ) ▁ under ▁ one ▁ or ▁ more STRNEWLINE ▁ * ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file ▁ distributed ▁ with STRNEWLINE ▁ * ▁ this ▁ work ▁ for ▁ additional ▁ information ▁ regarding ▁ copyright ▁ ownership . STRNEWLINE ▁ * ▁ The ▁ ASF ▁ licenses ▁ this ▁ file ▁ to ▁ You ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 STRNEWLINE ▁ * ▁ ( the ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with STRNEWLINE ▁ * ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . apache . ignite . internal ; import java . io . Externalizable ; import java . nio . ByteBuffer ; import java . util . Collection ; import org . apache . ignite . IgniteCheckedException ; import org . apache . ignite . compute . ComputeJobSibling ; import org . apache . ignite . internal . util . typedef . internal . S ; import org . apache . ignite . marshaller . Marshaller ; import org . apache . ignite . plugin . extensions . communication . Message ; import org . apache . ignite . plugin . extensions . communication . MessageReader ; import org . apache . ignite . plugin . extensions . communication . MessageWriter ; import org . jetbrains . annotations . Nullable ; /* * STRNEWLINE ▁ * ▁ Job ▁ siblings ▁ response . STRNEWLINE ▁ */ public class GridJobSiblingsResponse implements Message { private static final long serialVersionUID = 0L ; @ GridDirectTransient private Collection < ComputeJobSibling > siblings ; private byte [ ] siblingsBytes ; /* * STRNEWLINE ▁ * ▁ Empty ▁ constructor ▁ required ▁ by ▁ { @ link ▁ Externalizable } . STRNEWLINE ▁ */ public GridJobSiblingsResponse ( ) { // ▁ No - op . ENDCOM } /* * STRNEWLINE ▁ * ▁ @ param ▁ siblings ▁ Siblings . STRNEWLINE ▁ * ▁ @ param ▁ siblingsBytes ▁ Serialized ▁ siblings . STRNEWLINE ▁ */ public GridJobSiblingsResponse ( @ Nullable Collection < ComputeJobSibling > siblings , @ Nullable byte [ ] siblingsBytes ) { this . siblings = siblings ; this . siblingsBytes = siblingsBytes ; } /* * STRNEWLINE ▁ * ▁ @ return ▁ Job ▁ siblings . STRNEWLINE ▁ */ public Collection < ComputeJobSibling > jobSiblings ( ) { return siblings ; } /* * STRNEWLINE ▁ * ▁ @ param ▁ marsh ▁ Marshaller . STRNEWLINE ▁ * ▁ @ throws ▁ IgniteCheckedException ▁ In ▁ case ▁ of ▁ error . STRNEWLINE ▁ */ public void unmarshalSiblings ( Marshaller marsh ) throws IgniteCheckedException { assert marsh != null ; if ( siblingsBytes != null ) siblings = marsh . unmarshal ( siblingsBytes , null ) ; } /* * ▁ { @ inheritDoc } ▁ */ @ Override public void onAckReceived ( ) { // ▁ No - op . ENDCOM } /* * ▁ { @ inheritDoc } ▁ */ @ Override public boolean writeTo ( ByteBuffer buf , MessageWriter writer ) { writer . setBuffer ( buf ) ; if ( ! writer . isHeaderWritten ( ) ) { if ( ! writer . writeHeader ( directType ( ) , fieldsCount ( ) ) ) return false ; writer . onHeaderWritten ( ) ; } switch ( writer . state ( ) ) { case 0 : if ( ! writer . writeByteArray ( " siblingsBytes " , siblingsBytes ) ) return false ; writer . incrementState ( ) ; } return true ; } /* * ▁ { @ inheritDoc } ▁ */ @ Override public boolean readFrom ( ByteBuffer buf , MessageReader reader ) { reader . setBuffer ( buf ) ; if ( ! reader . beforeMessageRead ( ) ) return false ; switch ( reader . state ( ) ) { case 0 : siblingsBytes = reader . readByteArray ( " siblingsBytes " ) ; if ( ! reader . isLastRead ( ) ) return false ; reader . incrementState ( ) ; } return reader . afterMessageRead ( GridJobSiblingsResponse . class ) ; } /* * ▁ { @ inheritDoc } ▁ */ @ Override public byte directType ( ) { return 4 ; } /* * ▁ { @ inheritDoc } ▁ */ @ Override public byte fieldsCount ( ) { return 1 ; } /* * ▁ { @ inheritDoc } ▁ */ @ Override public String toString ( ) { return S . toString ( GridJobSiblingsResponse . class , this ) ; } } </DOCUMENT>
<DOCUMENT_ID="beano/gocd/tree/master/plugin-infra/go-plugin-infra/test/com/thoughtworks/go/plugin/infra/MultipleExtensionPluginWithPluginManagerIntegrationTest.java"> /* * * * * GO - LICENSE - START * * * * * STRNEWLINE ▁ * ▁ Copyright ▁ 2015 ▁ ThoughtWorks , ▁ Inc . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ * * * * * GO - LICENSE - END * * * * */ package com . thoughtworks . go . plugin . infra ; import java . io . File ; import java . io . IOException ; import com . thoughtworks . go . util . SystemEnvironment ; import com . thoughtworks . go . plugin . activation . DefaultGoPluginActivator ; import com . thoughtworks . go . plugin . infra . listeners . DefaultPluginJarChangeListener ; import com . thoughtworks . go . plugin . infra . monitor . PluginFileDetails ; import com . thoughtworks . go . plugin . infra . plugininfo . GoPluginDescriptor ; import org . apache . commons . io . FileUtils ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . test . context . ContextConfiguration ; import org . springframework . test . context . junit4 . SpringJUnit4ClassRunner ; import static com . thoughtworks . go . util . SystemEnvironment . PLUGIN_ACTIVATOR_JAR_PATH ; import static com . thoughtworks . go . util . SystemEnvironment . PLUGIN_BUNDLE_PATH ; import static com . thoughtworks . go . util . SystemEnvironment . PLUGIN_FRAMEWORK_ENABLED ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . MatcherAssert . assertThat ; @ RunWith ( SpringJUnit4ClassRunner . class ) @ ContextConfiguration ( locations = { " classpath : / applicationContext - plugin - infra . xml " } ) public class MultipleExtensionPluginWithPluginManagerIntegrationTest { public static final String PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_1 = " testplugin . multiple . extension . DescriptorPlugin1 . setPluginDescriptor . invoked " ; public static final String PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_2 = " testplugin . multiple . extension . DescriptorPlugin2 . setPluginDescriptor . invoked " ; private static final String PLUGIN_DIR_NAME = " . / tmp - DefPlgnMgrIntTest " ; private static final String BUNDLE_DIR_NAME = " . / tmp - bundles - DefPlgnMgrIntTest " ; private static final File PLUGIN_DIR = new File ( PLUGIN_DIR_NAME ) ; private static final File BUNDLE_DIR = new File ( BUNDLE_DIR_NAME ) ; private static final String PLUGIN_ID = " testplugin . multiple . extension " ; @ Autowired DefaultPluginManager pluginManager ; @ Autowired DefaultPluginJarChangeListener jarChangeListener ; @ Autowired SystemEnvironment systemEnvironment ; static { System . setProperty ( PLUGIN_ACTIVATOR_JAR_PATH . propertyName ( ) , " defaultFiles / go - plugin - activator . jar " ) ; System . setProperty ( PLUGIN_BUNDLE_PATH . propertyName ( ) , BUNDLE_DIR_NAME ) ; System . setProperty ( PLUGIN_FRAMEWORK_ENABLED . propertyName ( ) , " Y " ) ; } private static File pathOfFileInDefaultFiles ( String filePath ) { return new File ( MultipleExtensionPluginWithPluginManagerIntegrationTest . class . getClassLoader ( ) . getResource ( " defaultFiles / " + filePath ) . getFile ( ) ) ; } @ Test public void shouldProvideDescriptorToMultipleExtensionsImplementingThePluginDescriptorAwareInterface ( ) throws Exception { GoPluginDescriptor plugin = pluginManager . getPluginDescriptorFor ( PLUGIN_ID ) ; assertThat ( plugin . id ( ) , is ( PLUGIN_ID ) ) ; assertThat ( plugin . bundleSymbolicName ( ) , is ( PLUGIN_ID ) ) ; assertThat ( plugin . bundleClassPath ( ) , is ( " lib / go - plugin - activator . jar , . " ) ) ; assertThat ( plugin . bundleActivator ( ) , is ( DefaultGoPluginActivator . class . getCanonicalName ( ) ) ) ; assertThat ( plugin . isInvalid ( ) , is ( false ) ) ; // property ▁ set ▁ by ▁ the ▁ plugin ▁ in ▁ the ▁ setPluginDescriptor ▁ method . ENDCOM assertThat ( System . getProperty ( PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_1 ) , is ( plugin . toString ( ) ) ) ; assertThat ( System . getProperty ( PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_2 ) , is ( plugin . toString ( ) ) ) ; } @ Before public void setUpPluginInfrastructure ( ) throws IOException { PLUGIN_DIR . mkdirs ( ) ; BUNDLE_DIR . mkdirs ( ) ; try { pluginManager . startInfrastructure ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } jarChangeListener . pluginJarAdded ( new PluginFileDetails ( pathOfFileInDefaultFiles ( " plugin - with - multiple - extensions . jar " ) , false ) ) ; } @ After public void tearDown ( ) throws Exception { System . clearProperty ( PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_1 ) ; System . clearProperty ( PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_2 ) ; FileUtils . deleteQuietly ( PLUGIN_DIR ) ; FileUtils . deleteQuietly ( BUNDLE_DIR ) ; pluginManager . stopInfrastructure ( ) ; FileUtils . deleteQuietly ( PLUGIN_DIR ) ; FileUtils . deleteQuietly ( BUNDLE_DIR ) ; } // TODO : ▁ Write ▁ Test ▁ to ▁ handle ▁ OSGIFWK ▁ and ▁ PLugin ▁ Manager ▁ Interaction . ENDCOM } </DOCUMENT>
<DOCUMENT_ID="clintjhill/saguaro/tree/master/src/com/stoneworks/BrickCanvasConverter.java"> package com . stoneworks ; import com . thoughtworks . xstream . converters . Converter ; import com . thoughtworks . xstream . converters . MarshallingContext ; import com . thoughtworks . xstream . converters . UnmarshallingContext ; import com . thoughtworks . xstream . io . HierarchicalStreamReader ; import com . thoughtworks . xstream . io . HierarchicalStreamWriter ; /* * STRNEWLINE ▁ * ▁ @ author ▁ clinthill STRNEWLINE ▁ * ▁ STRNEWLINE ▁ */ public class BrickCanvasConverter implements Converter { public BrickCanvasConverter ( ) { } /* STRNEWLINE TABSYMBOL ▁ * ▁ ( non - Javadoc ) STRNEWLINE TABSYMBOL ▁ * ▁ STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ com . thoughtworks . xstream . converters . Converter # canConvert ( java . lang . Class ) STRNEWLINE TABSYMBOL ▁ */ public boolean canConvert ( Class type ) { return ( type == BrickCanvas . class ) ; } /* STRNEWLINE TABSYMBOL ▁ * ▁ ( non - Javadoc ) STRNEWLINE TABSYMBOL ▁ * ▁ STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ com . thoughtworks . xstream . converters . Converter # marshal ( java . lang . Object , STRNEWLINE TABSYMBOL ▁ * ▁ com . thoughtworks . xstream . io . HierarchicalStreamWriter , STRNEWLINE TABSYMBOL ▁ * ▁ com . thoughtworks . xstream . converters . MarshallingContext ) STRNEWLINE TABSYMBOL ▁ */ public void marshal ( Object source , HierarchicalStreamWriter writer , MarshallingContext context ) { BrickCanvas canvas = ( BrickCanvas ) source ; writer . startNode ( " canvasBackgroundImage " ) ; context . convertAnother ( canvas . getBackgroundImage ( ) ) ; writer . endNode ( ) ; writer . startNode ( " bricksOnCanvas " ) ; for ( Object obj : canvas . getBricks ( ) ) { if ( obj instanceof Brick ) { writer . startNode ( obj . getClass ( ) . getName ( ) ) ; context . convertAnother ( obj ) ; writer . endNode ( ) ; } } writer . endNode ( ) ; } /* STRNEWLINE TABSYMBOL ▁ * ▁ ( non - Javadoc ) STRNEWLINE TABSYMBOL ▁ * ▁ STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ com . thoughtworks . xstream . converters . Converter # unmarshal ( com . thoughtworks . xstream . io . HierarchicalStreamReader , STRNEWLINE TABSYMBOL ▁ * ▁ com . thoughtworks . xstream . converters . UnmarshallingContext ) STRNEWLINE TABSYMBOL ▁ */ public Object unmarshal ( HierarchicalStreamReader reader , UnmarshallingContext context ) { BrickCanvas canvas = BrickCanvas . getInstance ( ) ; while ( reader . hasMoreChildren ( ) ) { reader . moveDown ( ) ; if ( reader . getNodeName ( ) . equals ( " canvasBackgroundImage " ) ) { canvas . setBackgroundImage ( ( BackgroundImage ) context . convertAnother ( reader , BackgroundImage . class ) ) ; } if ( reader . getNodeName ( ) . equals ( " bricksOnCanvas " ) ) { while ( reader . hasMoreChildren ( ) ) { reader . moveDown ( ) ; if ( reader . getNodeName ( ) . equals ( Brick . class . getName ( ) ) ) { canvas . getLayer ( ) . addChild ( ( Brick ) context . convertAnother ( reader , Brick . class ) ) ; } reader . moveUp ( ) ; } } reader . moveUp ( ) ; } return canvas ; } } </DOCUMENT>
<DOCUMENT_ID="HasanAliKaraca/Telegram/tree/master/TMessagesProj/src/main/java/org/telegram/ui/Adapters/MentionsAdapter.java"> /* STRNEWLINE ▁ * ▁ This ▁ is ▁ the ▁ source ▁ code ▁ of ▁ Telegram ▁ for ▁ Android ▁ v . ▁ 2 . x STRNEWLINE ▁ * ▁ It ▁ is ▁ licensed ▁ under ▁ GNU ▁ GPL ▁ v . ▁ 2 ▁ or ▁ later . STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ license ▁ in ▁ this ▁ archive ▁ ( see ▁ LICENSE ) . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Copyright ▁ Nikolai ▁ Kudashov , ▁ 2013-2015 . STRNEWLINE ▁ */ package org . telegram . ui . Adapters ; import android . content . Context ; import android . view . View ; import android . view . ViewGroup ; import org . telegram . android . MessageObject ; import org . telegram . android . MessagesController ; import org . telegram . android . UserObject ; import org . telegram . messenger . TLRPC ; import org . telegram . ui . Cells . MentionCell ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; public class MentionsAdapter extends BaseSearchAdapter { public interface MentionsAdapterDelegate { void needChangePanelVisibility ( boolean show ) ; } private Context mContext ; private TLRPC . ChatParticipants info ; private ArrayList < TLRPC . User > searchResultUsernames ; private ArrayList < String > searchResultHashtags ; private ArrayList < String > searchResultCommands ; private ArrayList < String > searchResultCommandsHelp ; private ArrayList < TLRPC . User > searchResultCommandsUsers ; private MentionsAdapterDelegate delegate ; private HashMap < Integer , TLRPC . BotInfo > botInfo ; private int resultStartPosition ; private int resultLength ; private String lastText ; private int lastPosition ; private ArrayList < MessageObject > messages ; private boolean needUsernames = true ; private boolean isDarkTheme ; private int botsCount ; public MentionsAdapter ( Context context , boolean isDarkTheme , MentionsAdapterDelegate delegate ) { mContext = context ; this . delegate = delegate ; this . isDarkTheme = isDarkTheme ; } public void setChatInfo ( TLRPC . ChatParticipants chatParticipants ) { info = chatParticipants ; if ( lastText != null ) { searchUsernameOrHashtag ( lastText , lastPosition , messages ) ; } } public void setNeedUsernames ( boolean value ) { needUsernames = value ; } public void setBotInfo ( HashMap < Integer , TLRPC . BotInfo > info ) { botInfo = info ; } public void setBotsCount ( int count ) { botsCount = count ; } @ Override public void clearRecentHashtags ( ) { super . clearRecentHashtags ( ) ; searchResultHashtags . clear ( ) ; notifyDataSetChanged ( ) ; if ( delegate != null ) { delegate . needChangePanelVisibility ( false ) ; } } @ Override protected void setHashtags ( ArrayList < HashtagObject > arrayList , HashMap < String , HashtagObject > hashMap ) { super . setHashtags ( arrayList , hashMap ) ; if ( lastText != null ) { searchUsernameOrHashtag ( lastText , lastPosition , messages ) ; } } public void searchUsernameOrHashtag ( String text , int position , ArrayList < MessageObject > messageObjects ) { if ( text == null || text . length ( ) == 0 ) { delegate . needChangePanelVisibility ( false ) ; lastText = null ; return ; } int searchPostion = position ; if ( text . length ( ) > 0 ) { searchPostion -- ; } lastText = null ; StringBuilder result = new StringBuilder ( ) ; int foundType = - 1 ; boolean hasIllegalUsernameCharacters = false ; for ( int a = searchPostion ; a >= 0 ; a -- ) { if ( a >= text . length ( ) ) { continue ; } char ch = text . charAt ( a ) ; if ( a == 0 || text . charAt ( a - 1 ) == ' ▁ ' || text . charAt ( a - 1 ) == ' \n ' ) { if ( needUsernames && ch == ' @ ' ) { if ( hasIllegalUsernameCharacters ) { delegate . needChangePanelVisibility ( false ) ; return ; } if ( info == null ) { lastText = text ; lastPosition = position ; messages = messageObjects ; delegate . needChangePanelVisibility ( false ) ; return ; } foundType = 0 ; resultStartPosition = a ; resultLength = result . length ( ) + 1 ; break ; } else if ( ch == ' # ' ) { if ( ! hashtagsLoadedFromDb ) { loadRecentHashtags ( ) ; lastText = text ; lastPosition = position ; messages = messageObjects ; delegate . needChangePanelVisibility ( false ) ; return ; } foundType = 1 ; resultStartPosition = a ; resultLength = result . length ( ) + 1 ; result . insert ( 0 , ch ) ; break ; } else if ( a == 0 && botInfo != null && ch == ' / ' ) { foundType = 2 ; resultStartPosition = a ; resultLength = result . length ( ) + 1 ; break ; } } if ( ! ( ch >= '0' && ch <= '9' || ch >= ' a ' && ch <= ' z ' || ch >= ' A ' && ch <= ' Z ' || ch == ' _ ' ) ) { hasIllegalUsernameCharacters = true ; } result . insert ( 0 , ch ) ; } if ( foundType == - 1 ) { delegate . needChangePanelVisibility ( false ) ; return ; } if ( foundType == 0 ) { final ArrayList < Integer > users = new ArrayList < > ( ) ; for ( int a = 0 ; a < Math . min ( 100 , messageObjects . size ( ) ) ; a ++ ) { int from_id = messageObjects . get ( a ) . messageOwner . from_id ; if ( ! users . contains ( from_id ) ) { users . add ( from_id ) ; } } String usernameString = result . toString ( ) . toLowerCase ( ) ; ArrayList < TLRPC . User > newResult = new ArrayList < > ( ) ; for ( TLRPC . TL_chatParticipant chatParticipant : info . participants ) { TLRPC . User user = MessagesController . getInstance ( ) . getUser ( chatParticipant . user_id ) ; if ( user == null || UserObject . isUserSelf ( user ) ) { continue ; } if ( user . username != null && user . username . length ( ) > 0 && ( usernameString . length ( ) > 0 && user . username . toLowerCase ( ) . startsWith ( usernameString ) || usernameString . length ( ) == 0 ) ) { newResult . add ( user ) ; } } searchResultHashtags = null ; searchResultCommands = null ; searchResultCommandsHelp = null ; searchResultCommandsUsers = null ; searchResultUsernames = newResult ; Collections . sort ( searchResultUsernames , new Comparator < TLRPC . User > ( ) { @ Override public int compare ( TLRPC . User lhs , TLRPC . User rhs ) { int lhsNum = users . indexOf ( lhs . id ) ; int rhsNum = users . indexOf ( rhs . id ) ; if ( lhsNum != - 1 && rhsNum != - 1 ) { return lhsNum < rhsNum ? - 1 : ( lhsNum == rhsNum ? 0 : 1 ) ; } else if ( lhsNum != - 1 && rhsNum == - 1 ) { return - 1 ; } else if ( lhsNum == - 1 && rhsNum != - 1 ) { return 1 ; } return 0 ; } } ) ; notifyDataSetChanged ( ) ; delegate . needChangePanelVisibility ( ! newResult . isEmpty ( ) ) ; } else if ( foundType == 1 ) { ArrayList < String > newResult = new ArrayList < > ( ) ; String hashtagString = result . toString ( ) . toLowerCase ( ) ; for ( HashtagObject hashtagObject : hashtags ) { if ( hashtagObject != null && hashtagObject . hashtag != null && hashtagObject . hashtag . startsWith ( hashtagString ) ) { newResult . add ( hashtagObject . hashtag ) ; } } searchResultHashtags = newResult ; searchResultUsernames = null ; searchResultCommands = null ; searchResultCommandsHelp = null ; searchResultCommandsUsers = null ; notifyDataSetChanged ( ) ; delegate . needChangePanelVisibility ( ! newResult . isEmpty ( ) ) ; } else if ( foundType == 2 ) { ArrayList < String > newResult = new ArrayList < > ( ) ; ArrayList < String > newResultHelp = new ArrayList < > ( ) ; ArrayList < TLRPC . User > newResultUsers = new ArrayList < > ( ) ; String command = result . toString ( ) . toLowerCase ( ) ; for ( HashMap . Entry < Integer , TLRPC . BotInfo > entry : botInfo . entrySet ( ) ) { for ( TLRPC . TL_botCommand botCommand : entry . getValue ( ) . commands ) { if ( botCommand != null && botCommand . command != null && botCommand . command . startsWith ( command ) ) { newResult . add ( " / " + botCommand . command ) ; newResultHelp . add ( botCommand . description ) ; newResultUsers . add ( MessagesController . getInstance ( ) . getUser ( entry . getValue ( ) . user_id ) ) ; } } } searchResultHashtags = null ; searchResultUsernames = null ; searchResultCommands = newResult ; searchResultCommandsHelp = newResultHelp ; searchResultCommandsUsers = newResultUsers ; notifyDataSetChanged ( ) ; delegate . needChangePanelVisibility ( ! newResult . isEmpty ( ) ) ; } } public int getResultStartPosition ( ) { return resultStartPosition ; } public int getResultLength ( ) { return resultLength ; } @ Override public int getViewTypeCount ( ) { return 1 ; } @ Override public int getCount ( ) { if ( searchResultUsernames != null ) { return searchResultUsernames . size ( ) ; } else if ( searchResultHashtags != null ) { return searchResultHashtags . size ( ) ; } else if ( searchResultCommands != null ) { return searchResultCommands . size ( ) ; } return 0 ; } @ Override public boolean isEmpty ( ) { if ( searchResultUsernames != null ) { return searchResultUsernames . isEmpty ( ) ; } else if ( searchResultHashtags != null ) { return searchResultHashtags . isEmpty ( ) ; } else if ( searchResultCommands != null ) { return searchResultCommands . isEmpty ( ) ; } return true ; } @ Override public int getItemViewType ( int position ) { return 0 ; } @ Override public boolean hasStableIds ( ) { return true ; } @ Override public boolean areAllItemsEnabled ( ) { return true ; } @ Override public boolean isEnabled ( int position ) { return true ; } @ Override public Object getItem ( int i ) { if ( searchResultUsernames != null ) { if ( i < 0 || i >= searchResultUsernames . size ( ) ) { return null ; } return searchResultUsernames . get ( i ) ; } else if ( searchResultHashtags != null ) { if ( i < 0 || i >= searchResultHashtags . size ( ) ) { return null ; } return searchResultHashtags . get ( i ) ; } else if ( searchResultCommands != null ) { if ( i < 0 || i >= searchResultCommands . size ( ) ) { return null ; } if ( searchResultCommandsUsers != null && botsCount != 1 ) { return String . format ( " % s @ % s " , searchResultCommands . get ( i ) , searchResultCommandsUsers . get ( i ) . username ) ; } return searchResultCommands . get ( i ) ; } return null ; } public boolean isLongClickEnabled ( ) { return searchResultHashtags != null ; } public boolean isBotCommands ( ) { return searchResultCommands != null ; } @ Override public View getView ( int i , View view , ViewGroup viewGroup ) { if ( view == null ) { view = new MentionCell ( mContext ) ; ( ( MentionCell ) view ) . setIsDarkTheme ( isDarkTheme ) ; } if ( searchResultUsernames != null ) { ( ( MentionCell ) view ) . setUser ( searchResultUsernames . get ( i ) ) ; } else if ( searchResultHashtags != null ) { ( ( MentionCell ) view ) . setText ( searchResultHashtags . get ( i ) ) ; } else if ( searchResultCommands != null ) { ( ( MentionCell ) view ) . setBotCommand ( searchResultCommands . get ( i ) , searchResultCommandsHelp . get ( i ) , searchResultCommandsUsers . get ( i ) ) ; } return view ; } } </DOCUMENT>
<DOCUMENT_ID="1and1/aesh/tree/master/src/main/java/org/jboss/aesh/cl/builder/OptionBuilder.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ 2012 ▁ Red ▁ Hat , ▁ Inc . ▁ and / or ▁ its ▁ affiliates . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Eclipse ▁ Public ▁ License ▁ version ▁ 1.0 , ▁ available ▁ at STRNEWLINE ▁ * ▁ http : // www . eclipse . org / legal / epl - v10 . html STRNEWLINE ▁ */ package org . jboss . aesh . cl . builder ; import org . jboss . aesh . cl . completer . OptionCompleter ; import org . jboss . aesh . cl . converter . CLConverter ; import org . jboss . aesh . cl . exception . OptionParserException ; import org . jboss . aesh . cl . internal . OptionInt ; import org . jboss . aesh . cl . internal . OptionType ; import java . util . ArrayList ; import java . util . List ; /* * STRNEWLINE ▁ * ▁ Build ▁ a ▁ { @ link ▁ OptionInt } ▁ object ▁ using ▁ the ▁ Builder ▁ pattern . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ author ▁ < a ▁ href = " mailto : stale . pedersen @ jboss . org " > Ståle ▁ W . ▁ Pedersen < / a > STRNEWLINE ▁ */ public class OptionBuilder { private char shortName ; private String name ; private String description ; private String argument ; private Class < ? > type ; private boolean hasValue = true ; private boolean required = false ; private boolean isProperty = false ; private boolean hasMultipleValues = false ; private char valueSeparator = ' , ' ; private OptionType optionType ; private Class < ? extends CLConverter > converter ; private String fieldName ; private OptionCompleter completer ; private List < String > defaultValues ; public OptionBuilder ( ) { defaultValues = new ArrayList < String > ( ) ; } /* * STRNEWLINE ▁ * ▁ The ▁ short ▁ option ▁ Name STRNEWLINE ▁ */ public OptionBuilder shortName ( char n ) { shortName = n ; return this ; } /* * STRNEWLINE ▁ * ▁ The ▁ name ▁ of ▁ the ▁ option ▁ param . STRNEWLINE ▁ * ▁ The ▁ first ▁ letter ▁ will ▁ be ▁ used ▁ as ▁ the ▁ short ▁ name . STRNEWLINE ▁ * ▁ If ▁ name ▁ is ▁ not ▁ defined , ▁ the ▁ variable ▁ name ▁ will ▁ be ▁ used . STRNEWLINE ▁ */ public OptionBuilder name ( String name ) { this . name = name ; return this ; } /* * STRNEWLINE ▁ * ▁ A ▁ description ▁ of ▁ the ▁ param . STRNEWLINE ▁ * ▁ This ▁ text ▁ will ▁ be ▁ printed ▁ out ▁ as ▁ part ▁ of ▁ a ▁ usage ▁ info . STRNEWLINE ▁ */ public OptionBuilder description ( String description ) { this . description = description ; return this ; } /* * STRNEWLINE ▁ * ▁ A ▁ description ▁ on ▁ what ▁ kind ▁ of ▁ value ▁ is ▁ used ▁ for ▁ this ▁ option . STRNEWLINE ▁ */ public OptionBuilder argument ( String argument ) { this . argument = argument ; return this ; } /* * STRNEWLINE ▁ * ▁ Define ▁ the ▁ Class ▁ type ▁ of ▁ this ▁ Option . STRNEWLINE ▁ * ▁ If ▁ this ▁ option ▁ is ▁ a ▁ multiple ▁ value ▁ option ▁ this ▁ Class ▁ must STRNEWLINE ▁ * ▁ be ▁ defined ▁ equal ▁ to ▁ the ▁ parameterized ▁ class ▁ type . STRNEWLINE ▁ * ▁ Note ▁ that ▁ the STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ If ▁ its ▁ a ▁ property ▁ option ▁ the STRNEWLINE ▁ * ▁ @ param ▁ type STRNEWLINE ▁ * ▁ @ return STRNEWLINE ▁ */ public OptionBuilder type ( Class < ? > type ) { this . type = type ; return this ; } /* * STRNEWLINE ▁ * ▁ Specify ▁ if ▁ this ▁ option ▁ is ▁ required STRNEWLINE ▁ */ public OptionBuilder required ( boolean required ) { this . required = required ; return this ; } public OptionBuilder fieldName ( String fieldName ) { this . fieldName = fieldName ; return this ; } public OptionBuilder hasValue ( boolean hasValue ) { this . hasValue = hasValue ; return this ; } public OptionBuilder isProperty ( boolean isProperty ) { this . isProperty = isProperty ; return this ; } public OptionBuilder hasMultipleValues ( boolean hasMultipleValues ) { this . hasMultipleValues = hasMultipleValues ; return this ; } public OptionBuilder addDefaultValue ( String defaultValue ) { this . defaultValues . add ( defaultValue ) ; return this ; } public OptionBuilder valueSeparator ( char valueSeparator ) { this . valueSeparator = valueSeparator ; return this ; } public OptionBuilder optionType ( OptionType optionType ) { this . optionType = optionType ; return this ; } public OptionBuilder converter ( Class < ? extends CLConverter > converter ) { this . converter = converter ; return this ; } public OptionBuilder completer ( OptionCompleter completer ) { this . completer = completer ; return this ; } public OptionInt create ( ) throws OptionParserException { if ( optionType == null ) { if ( ! hasValue ) optionType = OptionType . BOOLEAN ; else if ( isProperty ) optionType = OptionType . GROUP ; else if ( hasMultipleValues ) optionType = OptionType . LIST ; else optionType = OptionType . NORMAL ; } if ( name == null || ( name . length ( ) < 1 && optionType != OptionType . ARGUMENT ) ) { if ( fieldName == null || fieldName . length ( ) < 1 ) throw new OptionParserException ( " Name ▁ must ▁ be ▁ defined ▁ to ▁ create ▁ an ▁ Option " ) ; else name = fieldName ; } return new OptionInt ( shortName , name , description , argument , required , valueSeparator , defaultValues , type , fieldName , optionType , converter , completer ) ; } } </DOCUMENT>
<DOCUMENT_ID="nafae/developer/tree/master/modules/dfp_axis/src/main/java/com/google/api/ads/dfp/axis/v201308/ActivityGroupPage.java"> /* * STRNEWLINE ▁ * ▁ ActivityGroupPage . java STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ file ▁ was ▁ auto - generated ▁ from ▁ WSDL STRNEWLINE ▁ * ▁ by ▁ the ▁ Apache ▁ Axis ▁ 1.4 ▁ Mar ▁ 02 , ▁ 2009 ▁ ( 07:08:06 ▁ PST ) ▁ WSDL2Java ▁ emitter . STRNEWLINE ▁ */ package com . google . api . ads . dfp . axis . v201308 ; /* * STRNEWLINE ▁ * ▁ Captures ▁ a ▁ page ▁ of ▁ { @ link ▁ ActivityGroup } ▁ objects . STRNEWLINE ▁ */ public class ActivityGroupPage implements java . io . Serializable { /* ▁ The ▁ size ▁ of ▁ the ▁ total ▁ result ▁ set ▁ to ▁ which ▁ this ▁ page ▁ belongs . ▁ */ private java . lang . Integer totalResultSetSize ; /* ▁ The ▁ absolute ▁ index ▁ in ▁ the ▁ total ▁ result ▁ set ▁ on ▁ which ▁ this ▁ page STRNEWLINE ▁ * ▁ begins . ▁ */ private java . lang . Integer startIndex ; /* ▁ The ▁ collection ▁ of ▁ activity ▁ groups ▁ contained ▁ within ▁ this ▁ page . ▁ */ private com . google . api . ads . dfp . axis . v201308 . ActivityGroup [ ] results ; public ActivityGroupPage ( ) { } public ActivityGroupPage ( java . lang . Integer totalResultSetSize , java . lang . Integer startIndex , com . google . api . ads . dfp . axis . v201308 . ActivityGroup [ ] results ) { this . totalResultSetSize = totalResultSetSize ; this . startIndex = startIndex ; this . results = results ; } /* * STRNEWLINE ▁ * ▁ Gets ▁ the ▁ totalResultSetSize ▁ value ▁ for ▁ this ▁ ActivityGroupPage . STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ return ▁ totalResultSetSize ▁ * ▁ The ▁ size ▁ of ▁ the ▁ total ▁ result ▁ set ▁ to ▁ which ▁ this ▁ page ▁ belongs . STRNEWLINE ▁ */ public java . lang . Integer getTotalResultSetSize ( ) { return totalResultSetSize ; } /* * STRNEWLINE ▁ * ▁ Sets ▁ the ▁ totalResultSetSize ▁ value ▁ for ▁ this ▁ ActivityGroupPage . STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ param ▁ totalResultSetSize ▁ * ▁ The ▁ size ▁ of ▁ the ▁ total ▁ result ▁ set ▁ to ▁ which ▁ this ▁ page ▁ belongs . STRNEWLINE ▁ */ public void setTotalResultSetSize ( java . lang . Integer totalResultSetSize ) { this . totalResultSetSize = totalResultSetSize ; } /* * STRNEWLINE ▁ * ▁ Gets ▁ the ▁ startIndex ▁ value ▁ for ▁ this ▁ ActivityGroupPage . STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ return ▁ startIndex ▁ * ▁ The ▁ absolute ▁ index ▁ in ▁ the ▁ total ▁ result ▁ set ▁ on ▁ which ▁ this ▁ page STRNEWLINE ▁ * ▁ begins . STRNEWLINE ▁ */ public java . lang . Integer getStartIndex ( ) { return startIndex ; } /* * STRNEWLINE ▁ * ▁ Sets ▁ the ▁ startIndex ▁ value ▁ for ▁ this ▁ ActivityGroupPage . STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ param ▁ startIndex ▁ * ▁ The ▁ absolute ▁ index ▁ in ▁ the ▁ total ▁ result ▁ set ▁ on ▁ which ▁ this ▁ page STRNEWLINE ▁ * ▁ begins . STRNEWLINE ▁ */ public void setStartIndex ( java . lang . Integer startIndex ) { this . startIndex = startIndex ; } /* * STRNEWLINE ▁ * ▁ Gets ▁ the ▁ results ▁ value ▁ for ▁ this ▁ ActivityGroupPage . STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ return ▁ results ▁ * ▁ The ▁ collection ▁ of ▁ activity ▁ groups ▁ contained ▁ within ▁ this ▁ page . STRNEWLINE ▁ */ public com . google . api . ads . dfp . axis . v201308 . ActivityGroup [ ] getResults ( ) { return results ; } /* * STRNEWLINE ▁ * ▁ Sets ▁ the ▁ results ▁ value ▁ for ▁ this ▁ ActivityGroupPage . STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ param ▁ results ▁ * ▁ The ▁ collection ▁ of ▁ activity ▁ groups ▁ contained ▁ within ▁ this ▁ page . STRNEWLINE ▁ */ public void setResults ( com . google . api . ads . dfp . axis . v201308 . ActivityGroup [ ] results ) { this . results = results ; } public com . google . api . ads . dfp . axis . v201308 . ActivityGroup getResults ( int i ) { return this . results [ i ] ; } public void setResults ( int i , com . google . api . ads . dfp . axis . v201308 . ActivityGroup _value ) { this . results [ i ] = _value ; } private java . lang . Object __equalsCalc = null ; public synchronized boolean equals ( java . lang . Object obj ) { if ( ! ( obj instanceof ActivityGroupPage ) ) return false ; ActivityGroupPage other = ( ActivityGroupPage ) obj ; if ( obj == null ) return false ; if ( this == obj ) return true ; if ( __equalsCalc != null ) { return ( __equalsCalc == obj ) ; } __equalsCalc = obj ; boolean _equals ; _equals = true && ( ( this . totalResultSetSize == null && other . getTotalResultSetSize ( ) == null ) || ( this . totalResultSetSize != null && this . totalResultSetSize . equals ( other . getTotalResultSetSize ( ) ) ) ) && ( ( this . startIndex == null && other . getStartIndex ( ) == null ) || ( this . startIndex != null && this . startIndex . equals ( other . getStartIndex ( ) ) ) ) && ( ( this . results == null && other . getResults ( ) == null ) || ( this . results != null && java . util . Arrays . equals ( this . results , other . getResults ( ) ) ) ) ; __equalsCalc = null ; return _equals ; } private boolean __hashCodeCalc = false ; public synchronized int hashCode ( ) { if ( __hashCodeCalc ) { return 0 ; } __hashCodeCalc = true ; int _hashCode = 1 ; if ( getTotalResultSetSize ( ) != null ) { _hashCode += getTotalResultSetSize ( ) . hashCode ( ) ; } if ( getStartIndex ( ) != null ) { _hashCode += getStartIndex ( ) . hashCode ( ) ; } if ( getResults ( ) != null ) { for ( int i = 0 ; i < java . lang . reflect . Array . getLength ( getResults ( ) ) ; i ++ ) { java . lang . Object obj = java . lang . reflect . Array . get ( getResults ( ) , i ) ; if ( obj != null && ! obj . getClass ( ) . isArray ( ) ) { _hashCode += obj . hashCode ( ) ; } } } __hashCodeCalc = false ; return _hashCode ; } // ▁ Type ▁ metadata ENDCOM private static org . apache . axis . description . TypeDesc typeDesc = new org . apache . axis . description . TypeDesc ( ActivityGroupPage . class , true ) ; static { typeDesc . setXmlType ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " ActivityGroupPage " ) ) ; org . apache . axis . description . ElementDesc elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( " totalResultSetSize " ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " totalResultSetSize " ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( " http : // www . w3 . org / 2001 / XMLSchema " , " int " ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( false ) ; typeDesc . addFieldDesc ( elemField ) ; elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( " startIndex " ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " startIndex " ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( " http : // www . w3 . org / 2001 / XMLSchema " , " int " ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( false ) ; typeDesc . addFieldDesc ( elemField ) ; elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( " results " ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " results " ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " ActivityGroup " ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( false ) ; elemField . setMaxOccursUnbounded ( true ) ; typeDesc . addFieldDesc ( elemField ) ; } /* * STRNEWLINE ▁ * ▁ Return ▁ type ▁ metadata ▁ object STRNEWLINE ▁ */ public static org . apache . axis . description . TypeDesc getTypeDesc ( ) { return typeDesc ; } /* * STRNEWLINE ▁ * ▁ Get ▁ Custom ▁ Serializer STRNEWLINE ▁ */ public static org . apache . axis . encoding . Serializer getSerializer ( java . lang . String mechType , java . lang . Class _javaType , javax . xml . namespace . QName _xmlType ) { return new org . apache . axis . encoding . ser . BeanSerializer ( _javaType , _xmlType , typeDesc ) ; } /* * STRNEWLINE ▁ * ▁ Get ▁ Custom ▁ Deserializer STRNEWLINE ▁ */ public static org . apache . axis . encoding . Deserializer getDeserializer ( java . lang . String mechType , java . lang . Class _javaType , javax . xml . namespace . QName _xmlType ) { return new org . apache . axis . encoding . ser . BeanDeserializer ( _javaType , _xmlType , typeDesc ) ; } } </DOCUMENT>
<DOCUMENT_ID="scnakandala/derby/tree/master/java/engine/org/apache/derby/iapi/services/crypto/CipherProvider.java"> /* STRNEWLINE STRNEWLINE ▁ Derby ▁ - ▁ Class ▁ org . apache . derby . iapi . services . crypto . CipherProvider STRNEWLINE STRNEWLINE ▁ Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ ( ASF ) ▁ under ▁ one ▁ or ▁ more STRNEWLINE ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file ▁ distributed ▁ with STRNEWLINE ▁ this ▁ work ▁ for ▁ additional ▁ information ▁ regarding ▁ copyright ▁ ownership . STRNEWLINE ▁ The ▁ ASF ▁ licenses ▁ this ▁ file ▁ to ▁ you ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 STRNEWLINE ▁ ( the ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with STRNEWLINE ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE STRNEWLINE ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE STRNEWLINE ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE STRNEWLINE ▁ */ package org . apache . derby . iapi . services . crypto ; import java . security . Key ; import org . apache . derby . iapi . error . StandardException ; /* * STRNEWLINE TABSYMBOL A ▁ CipherProvider ▁ is ▁ a ▁ wrapper ▁ for ▁ a ▁ Cipher ▁ class ▁ in ▁ JCE . STRNEWLINE STRNEWLINE TABSYMBOL This ▁ service ▁ is ▁ only ▁ available ▁ when ▁ run ▁ on ▁ JDK1.2 ▁ or ▁ beyond . STRNEWLINE TABSYMBOL To ▁ use ▁ this ▁ service , ▁ either ▁ the ▁ SunJCE ▁ or ▁ an ▁ alternative ▁ clean ▁ room STRNEWLINE ▁ implementation ▁ of ▁ the ▁ JCE ▁ must ▁ be ▁ installed . STRNEWLINE STRNEWLINE TABSYMBOL To ▁ use ▁ a ▁ CipherProvider ▁ to ▁ encrypt ▁ or ▁ decrypt , ▁ it ▁ needs ▁ 3 ▁ things : STRNEWLINE TABSYMBOL 1 ) ▁ A ▁ CipherProvider ▁ that ▁ is ▁ initialized ▁ to ▁ ENCRYPT ▁ or ▁ DECRYPT STRNEWLINE TABSYMBOL 2 ) ▁ A ▁ secret ▁ Key ▁ for ▁ the ▁ encryption / decryption STRNEWLINE TABSYMBOL 3 ) ▁ An ▁ Initialization ▁ Vector ▁ ( IvParameterSpec ) ▁ that ▁ is ▁ used ▁ to ▁ create ▁ some STRNEWLINE TABSYMBOL TABSYMBOL randomness ▁ in ▁ the ▁ encryption STRNEWLINE STRNEWLINE ▁ See ▁ $ WS / docs / funcspec / mulan / configurableEncryption . html STRNEWLINE STRNEWLINE TABSYMBOL See ▁ http : // java . sun . com / products / JDK / 1.1 / docs / guide / security / CryptoSpec . html STRNEWLINE TABSYMBOL See ▁ http : // java . sun . com / products / JDK / 1.2 / docs / guide / security / CryptoSpec . html STRNEWLINE TABSYMBOL See ▁ http : // java . sun . com / products / jdk / 1.2 / jce / index . html STRNEWLINE ▁ */ public interface CipherProvider { /* * STRNEWLINE TABSYMBOL TABSYMBOL Encrypt ▁ data ▁ - ▁ use ▁ only ▁ with ▁ Cipher ▁ that ▁ has ▁ been ▁ initialized ▁ with STRNEWLINE TABSYMBOL TABSYMBOL CipherFactory . ENCRYPT . STRNEWLINE STRNEWLINE TABSYMBOL TABSYMBOL @ return ▁ The ▁ number ▁ of ▁ bytes ▁ stored ▁ in ▁ ciphertext . STRNEWLINE STRNEWLINE TABSYMBOL TABSYMBOL @ param ▁ cleartext ▁ the ▁ byte ▁ array ▁ containing ▁ the ▁ cleartext STRNEWLINE TABSYMBOL TABSYMBOL @ param ▁ offset ▁ encrypt ▁ from ▁ this ▁ byte ▁ offset ▁ in ▁ the ▁ cleartext STRNEWLINE TABSYMBOL TABSYMBOL @ param ▁ length ▁ encrypt ▁ this ▁ many ▁ bytes ▁ starting ▁ from ▁ offset STRNEWLINE TABSYMBOL TABSYMBOL @ param ▁ ciphertext ▁ the ▁ byte ▁ array ▁ to ▁ store ▁ the ▁ ciphertext STRNEWLINE TABSYMBOL TABSYMBOL @ param ▁ outputOffset ▁ the ▁ offset ▁ into ▁ the ▁ ciphertext ▁ array ▁ the ▁ output STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL should ▁ go STRNEWLINE STRNEWLINE TABSYMBOL TABSYMBOL If ▁ cleartext ▁ and ▁ ciphertext ▁ are ▁ the ▁ same ▁ array , ▁ caller ▁ must ▁ be ▁ careful STRNEWLINE TABSYMBOL TABSYMBOL to ▁ not ▁ overwrite ▁ the ▁ cleartext ▁ before ▁ it ▁ is ▁ scrambled . STRNEWLINE STRNEWLINE TABSYMBOL TABSYMBOL @ exception ▁ StandardException ▁ Standard ▁ Derby ▁ Error ▁ Policy STRNEWLINE TABSYMBOL ▁ */ int encrypt ( byte [ ] cleartext , int offset , int length , byte [ ] ciphertext , int outputOffset ) throws StandardException ; /* * STRNEWLINE TABSYMBOL TABSYMBOL Decrypt ▁ data ▁ - ▁ use ▁ only ▁ with ▁ Cipher ▁ that ▁ has ▁ been ▁ initialized ▁ with STRNEWLINE TABSYMBOL TABSYMBOL CipherFactory . DECRYPT . STRNEWLINE STRNEWLINE TABSYMBOL TABSYMBOL @ return ▁ The ▁ number ▁ of ▁ bytes ▁ stored ▁ in ▁ cleartext . STRNEWLINE STRNEWLINE TABSYMBOL TABSYMBOL @ param ▁ ciphertext ▁ the ▁ byte ▁ array ▁ containing ▁ the ▁ ciphertext STRNEWLINE TABSYMBOL TABSYMBOL @ param ▁ offset ▁ decrypt ▁ from ▁ this ▁ byte ▁ offset ▁ in ▁ the ▁ ciphertext STRNEWLINE TABSYMBOL TABSYMBOL @ param ▁ length ▁ decrypt ▁ this ▁ many ▁ bytes ▁ starting ▁ from ▁ offset STRNEWLINE TABSYMBOL TABSYMBOL @ param ▁ cleartext ▁ the ▁ byte ▁ array ▁ to ▁ store ▁ the ▁ cleartext STRNEWLINE TABSYMBOL TABSYMBOL @ param ▁ outputOffset ▁ the ▁ offset ▁ into ▁ the ▁ cleartext ▁ array ▁ the ▁ output STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL should ▁ go STRNEWLINE STRNEWLINE TABSYMBOL TABSYMBOL If ▁ cleartext ▁ and ▁ ciphertext ▁ are ▁ the ▁ same ▁ array , ▁ caller ▁ must ▁ be ▁ careful STRNEWLINE TABSYMBOL TABSYMBOL to ▁ not ▁ overwrite ▁ the ▁ ciphertext ▁ before ▁ it ▁ is ▁ un - scrambled . STRNEWLINE STRNEWLINE TABSYMBOL TABSYMBOL @ exception ▁ StandardException ▁ Standard ▁ Derby ▁ Error ▁ Policy STRNEWLINE TABSYMBOL ▁ */ int decrypt ( byte [ ] ciphertext , int offset , int length , byte [ ] cleartext , int outputOffset ) throws StandardException ; /* * STRNEWLINE TABSYMBOL ▁ TABSYMBOL Returns ▁ the ▁ encryption ▁ block ▁ size ▁ used ▁ during ▁ creation ▁ of ▁ the ▁ encrypted ▁ database STRNEWLINE TABSYMBOL ▁ */ public int getEncryptionBlockSize ( ) ; } </DOCUMENT>
<DOCUMENT_ID="victos/opencms-core/tree/master/src-gwt/org/opencms/gwt/client/ui/history/CmsResourceHistoryTable.java"> /* STRNEWLINE ▁ * ▁ This ▁ library ▁ is ▁ part ▁ of ▁ OpenCms ▁ - STRNEWLINE ▁ * ▁ the ▁ Open ▁ Source ▁ Content ▁ Management ▁ System STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Copyright ▁ ( c ) ▁ Alkacon ▁ Software ▁ GmbH ▁ ( http : // www . alkacon . com ) STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ library ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or STRNEWLINE ▁ * ▁ modify ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public STRNEWLINE ▁ * ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either STRNEWLINE ▁ * ▁ version ▁ 2.1 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ library ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU STRNEWLINE ▁ * ▁ Lesser ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ For ▁ further ▁ information ▁ about ▁ Alkacon ▁ Software , ▁ please ▁ see ▁ the STRNEWLINE ▁ * ▁ company ▁ website : ▁ http : // www . alkacon . com STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ For ▁ further ▁ information ▁ about ▁ OpenCms , ▁ please ▁ see ▁ the STRNEWLINE ▁ * ▁ project ▁ website : ▁ http : // www . opencms . org STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public STRNEWLINE ▁ * ▁ License ▁ along ▁ with ▁ this ▁ library ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software STRNEWLINE ▁ * ▁ Foundation , ▁ Inc . , ▁ 59 ▁ Temple ▁ Place , ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 ▁ USA STRNEWLINE ▁ */ package org . opencms . gwt . client . ui . history ; import org . opencms . gwt . client . CmsCoreProvider ; import org . opencms . gwt . client . ui . css . I_CmsCellTableResources ; import org . opencms . gwt . client . ui . css . I_CmsImageBundle ; import org . opencms . gwt . shared . CmsHistoryResourceBean ; import org . opencms . gwt . shared . CmsHistoryResourceCollection ; import com . google . common . base . Predicate ; import com . google . gwt . cell . client . AbstractCell ; import com . google . gwt . cell . client . ActionCell ; import com . google . gwt . core . client . GWT ; import com . google . gwt . dom . client . Style . Unit ; import com . google . gwt . safehtml . client . SafeHtmlTemplates ; import com . google . gwt . safehtml . shared . SafeHtml ; import com . google . gwt . user . cellview . client . CellTable ; import com . google . gwt . user . cellview . client . Column ; import com . google . gwt . user . cellview . client . IdentityColumn ; import com . google . gwt . user . cellview . client . TextColumn ; import com . google . gwt . view . client . ListDataProvider ; import com . google . gwt . view . client . ProvidesKey ; /* * STRNEWLINE ▁ * ▁ Cell ▁ table ▁ used ▁ to ▁ display ▁ historical ▁ versions ▁ of ▁ a ▁ content . < p > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Has ▁ buttons ▁ to ▁ preview ▁ or ▁ restore ▁ a ▁ previous ▁ version . < p > STRNEWLINE ▁ */ public class CmsResourceHistoryTable extends CellTable < CmsHistoryResourceBean > { /* * ▁ The ▁ templates ▁ used ▁ by ▁ this ▁ cell . ▁ */ static interface Templates extends SafeHtmlTemplates { /* * STRNEWLINE ▁ * ▁ Template ▁ for ▁ the ▁ button ▁ HTML . < p > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ title ▁ the ▁ button ▁ title STRNEWLINE ▁ * ▁ @ param ▁ cssClass ▁ the ▁ button ▁ CSS ▁ class STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ the ▁ HTML ▁ for ▁ the ▁ button STRNEWLINE ▁ */ @ Template ( " < span ▁ class = \ " {1 } \ " ▁ title = \ " {0 } \ " > < / span > " ) SafeHtml button ( String title , String cssClass ) ; /* * STRNEWLINE ▁ * ▁ Template ▁ for ▁ a ▁ span ▁ with ▁ a ▁ title . < p > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ text ▁ the ▁ span ▁ text STRNEWLINE ▁ * ▁ @ param ▁ title ▁ the ▁ span ▁ title STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ the ▁ HTML ▁ for ▁ the ▁ span STRNEWLINE ▁ */ @ Template ( " < span ▁ title = \ " {1 } \ " > { 0 } < / span > " ) SafeHtml textSpanWithTitle ( String text , String title ) ; } /* * ▁ The ▁ template ▁ instance . ▁ */ static Templates templates = GWT . create ( Templates . class ) ; /* * ▁ Handler ▁ instance ▁ for ▁ performing ▁ actions ▁ on ▁ the ▁ table ▁ entries . ▁ */ private I_CmsHistoryActionHandler m_handler ; /* * STRNEWLINE ▁ * ▁ Creates ▁ a ▁ new ▁ instance . < p > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ data ▁ the ▁ data ▁ to ▁ display ▁ in ▁ the ▁ table STRNEWLINE ▁ * ▁ @ param ▁ handler ▁ the ▁ handler ▁ instance ▁ used ▁ for ▁ performing ▁ actions ▁ on ▁ the ▁ table ▁ entries STRNEWLINE ▁ */ public CmsResourceHistoryTable ( CmsHistoryResourceCollection data , I_CmsHistoryActionHandler handler ) { super ( Integer . MAX_VALUE , ( CellTable . Resources ) GWT . create ( I_CmsCellTableResources . class ) , new ProvidesKey < CmsHistoryResourceBean > ( ) { public Object getKey ( CmsHistoryResourceBean item ) { return item . getStructureId ( ) + " _ " + item . getVersion ( ) ; } } ) ; m_handler = handler ; setWidth ( "100 % " , true ) ; setTableLayoutFixed ( true ) ; addVersionColumn ( ) ; addPreviewColumn ( ) ; addRevertColumn ( ) ; addPathColumn ( ) ; addSizeColumn ( ) ; addModificationDateColumn ( ) ; addUserLastModifiedColumn ( ) ; addPublishDateColumn ( ) ; ListDataProvider < CmsHistoryResourceBean > dataProvider = new ListDataProvider < CmsHistoryResourceBean > ( ) ; dataProvider . addDataDisplay ( this ) ; dataProvider . setList ( data . getResources ( ) ) ; } /* * STRNEWLINE ▁ * ▁ Helper ▁ method ▁ for ▁ adding ▁ a ▁ table ▁ column ▁ with ▁ a ▁ given ▁ width ▁ and ▁ label . < p > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ label ▁ the ▁ column ▁ label STRNEWLINE ▁ * ▁ @ param ▁ width ▁ the ▁ column ▁ width ▁ in ▁ pixels STRNEWLINE ▁ * ▁ @ param ▁ col ▁ the ▁ column ▁ to ▁ add STRNEWLINE ▁ */ private void addColumn ( String label , int width , Column < CmsHistoryResourceBean , ? > col ) { addColumn ( col , label ) ; setColumnWidth ( col , width , Unit . PX ) ; } /* * STRNEWLINE ▁ * ▁ Adds ▁ a ▁ table ▁ column . < p > STRNEWLINE ▁ */ private void addModificationDateColumn ( ) { addColumn ( CmsHistoryMessages . columnModificationDate ( ) , 190 , new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { return historyRes . getModificationDate ( ) . getDateText ( ) ; } } ) ; } /* * STRNEWLINE ▁ * ▁ Adds ▁ a ▁ table ▁ column . < p > STRNEWLINE ▁ */ private void addPathColumn ( ) { Column < CmsHistoryResourceBean , ? > col = new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { String path = historyRes . getRootPath ( ) ; String siteRoot = CmsCoreProvider . get ( ) . getSiteRoot ( ) ; if ( path . startsWith ( siteRoot ) ) { path = path . substring ( siteRoot . length ( ) ) ; if ( ! path . startsWith ( " / " ) ) { path = " / " + path ; } } return path ; } } ; addColumn ( col , CmsHistoryMessages . columnPath ( ) ) ; setColumnWidth ( col , 100 , Unit . PCT ) ; } /* * STRNEWLINE ▁ * ▁ Adds ▁ a ▁ table ▁ column . < p > STRNEWLINE ▁ */ private void addPreviewColumn ( ) { CmsButtonCell < CmsHistoryResourceBean > previewCell = new CmsButtonCell < CmsHistoryResourceBean > ( CmsHistoryMessages . titlePreview ( ) , I_CmsImageBundle . INSTANCE . style ( ) . tablePreviewIcon ( ) , new ActionCell . Delegate < CmsHistoryResourceBean > ( ) { @ SuppressWarnings ( " synthetic - access " ) public void execute ( CmsHistoryResourceBean historyRes ) { m_handler . showPreview ( historyRes ) ; } } , new Predicate < CmsHistoryResourceBean > ( ) { public boolean apply ( CmsHistoryResourceBean bean ) { return true ; } } ) ; addColumn ( CmsHistoryMessages . columnPreview ( ) , 30 , new IdentityColumn < CmsHistoryResourceBean > ( previewCell ) ) ; } /* * STRNEWLINE ▁ * ▁ Adds ▁ a ▁ table ▁ column . < p > STRNEWLINE ▁ */ private void addPublishDateColumn ( ) { addColumn ( CmsHistoryMessages . columnPublishDate ( ) , 190 , new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { if ( historyRes . getPublishDate ( ) != null ) { return historyRes . getPublishDate ( ) . getDateText ( ) ; } return " - " ; } } ) ; } /* * STRNEWLINE ▁ * ▁ Adds ▁ a ▁ table ▁ column . < p > STRNEWLINE ▁ */ private void addRevertColumn ( ) { CmsButtonCell < CmsHistoryResourceBean > replaceCell = new CmsButtonCell < CmsHistoryResourceBean > ( CmsHistoryMessages . titleRevert ( ) , I_CmsImageBundle . INSTANCE . style ( ) . tableReplaceIcon ( ) , new ActionCell . Delegate < CmsHistoryResourceBean > ( ) { @ SuppressWarnings ( " synthetic - access " ) public void execute ( CmsHistoryResourceBean historyRes ) { m_handler . revert ( historyRes ) ; } } , new Predicate < CmsHistoryResourceBean > ( ) { public boolean apply ( CmsHistoryResourceBean bean ) { return bean . getVersion ( ) . getVersionNumber ( ) != null ; } } ) ; addColumn ( CmsHistoryMessages . columnReplace ( ) , 30 , new IdentityColumn < CmsHistoryResourceBean > ( replaceCell ) ) ; } /* * STRNEWLINE ▁ * ▁ Adds ▁ a ▁ table ▁ column . < p > STRNEWLINE ▁ */ private void addSizeColumn ( ) { Column < CmsHistoryResourceBean , ? > col = new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { return " " + historyRes . getSize ( ) ; } } ; addColumn ( col , CmsHistoryMessages . columnSize ( ) ) ; setColumnWidth ( col , 100 , Unit . PX ) ; } /* * STRNEWLINE ▁ * ▁ Adds ▁ a ▁ table ▁ column . < p > STRNEWLINE ▁ */ private void addUserLastModifiedColumn ( ) { addColumn ( CmsHistoryMessages . columnUserLastModified ( ) , 120 , new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { return historyRes . getUserLastModified ( ) ; } } ) ; } /* * STRNEWLINE ▁ * ▁ Adds ▁ a ▁ table ▁ column . < p > STRNEWLINE ▁ */ private void addVersionColumn ( ) { AbstractCell < CmsHistoryResourceBean > cell = new CmsVersionCell ( ) ; addColumn ( CmsHistoryMessages . columnVersion ( ) , 40 , new IdentityColumn < CmsHistoryResourceBean > ( cell ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="maxammann/SimpleClans2/tree/master/SimpleClans2/src/main/java/com/p000ison/dev/simpleclans2/converter/Converter.java"> /* STRNEWLINE ▁ * ▁ This ▁ file ▁ is ▁ part ▁ of ▁ SimpleClans2 ▁ ( 2012 ) . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ SimpleClans2 ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or STRNEWLINE ▁ * ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ SimpleClans2 ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ SimpleClans2 . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Last ▁ modified : ▁ 05.11.12 ▁ 20:53 STRNEWLINE ▁ */ package com . p000ison . dev . simpleclans2 . converter ; import com . p000ison . dev . simpleclans2 . api . KillType ; import com . p000ison . dev . simpleclans2 . api . logging . Logging ; import com . p000ison . dev . sqlapi . jbdc . JBDCDatabase ; import org . json . simple . JSONArray ; import org . json . simple . JSONObject ; import org . json . simple . parser . JSONParser ; import org . json . simple . parser . ParseException ; import java . sql . * ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; /* * STRNEWLINE ▁ * ▁ Represents ▁ a ▁ converter . Converter STRNEWLINE ▁ */ @ SuppressWarnings ( " unchecked " ) public class Converter implements Runnable { private JBDCDatabase from ; private JBDCDatabase to ; private PreparedStatement insertClan , insertBB , updateClan , insertKill ; private PreparedStatement insertClanPlayer ; private Set < ConvertedClan > clans = new HashSet < ConvertedClan > ( ) ; private Set < ConvertedClanPlayer > players = new HashSet < ConvertedClanPlayer > ( ) ; public Converter ( JBDCDatabase from , JBDCDatabase to ) { this . from = from ; this . to = to ; insertBB = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ bb ` ▁ ( ` clan ` , ▁ ` text ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? ▁ ) ; " ) ; updateClan = to . prepare ( " UPDATE ▁ ` sc2 _ clans ` ▁ SET ▁ allies ▁ = ▁ ? , ▁ rivals ▁ = ▁ ? , ▁ warring ▁ = ▁ ? ▁ WHERE ▁ id ▁ = ▁ ? ; " ) ; insertKill = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ kills ` ▁ ( ▁ ` attacker ` , ▁ ` attacker _ clan ` , ▁ ` victim ` , ▁ ` victim _ clan ` , ▁ ` war ` , ▁ ` type ` , ▁ ` date ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) ; " ) ; prepareClan ( ) ; prepareClanPlayer ( ) ; } private void prepareClan ( ) { if ( insertClan != null ) { try { insertClan . close ( ) ; } catch ( SQLException e ) { Logging . debug ( e , false ) ; } } insertClan = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ clans ` ▁ ( ` name ` , ▁ ` tag ` , ▁ ` verified ` , ▁ ` founded ` , ▁ ` last _ action ` , ▁ ` flags ` , ▁ ` balance ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) ; " ) ; } private void prepareClanPlayer ( ) { if ( insertClanPlayer != null ) { try { insertClanPlayer . close ( ) ; } catch ( SQLException e ) { Logging . debug ( e , false ) ; } } insertClanPlayer = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ players ` ▁ ( ▁ ` name ` , ▁ ` leader ` , ▁ ` trusted ` , ▁ ` join _ date ` , ▁ ` last _ seen ` , ▁ ` clan ` , ▁ ` neutral _ kills ` , ▁ ` rival _ Kills ` , ▁ ` civilian _ Kills ` , ▁ ` deaths ` , ▁ ` flags ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) " ) ; } public void convertAll ( ) { try { convertClans ( ) ; convertPlayers ( ) ; convertKills ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } clans = null ; players = null ; } @ Override public void run ( ) { convertAll ( ) ; } public void convertPlayers ( ) throws SQLException { ResultSet result = from . query ( " SELECT ▁ * ▁ FROM ▁ ` sc _ players ` ; " ) ; while ( result . next ( ) ) { JSONObject flags = new JSONObject ( ) ; try { JSONParser parser = new JSONParser ( ) ; String flagsString = result . getString ( " flags " ) ; JSONObject object = ( JSONObject ) parser . parse ( flagsString ) ; boolean friendlyFire = result . getBoolean ( " friendly _ fire " ) ; boolean bb = ( Boolean ) object . get ( " bb - enabled " ) ; boolean cape = ( Boolean ) object . get ( " cape - enabled " ) ; if ( friendlyFire ) { flags . put ( " ff " , friendlyFire ) ; } if ( bb ) { flags . put ( " bb " , bb ) ; } if ( cape ) { flags . put ( " cape " , cape ) ; } } catch ( ParseException e ) { e . printStackTrace ( ) ; continue ; } String name = result . getString ( " name " ) ; insertPlayer ( name , result . getBoolean ( " leader " ) , result . getBoolean ( " trusted " ) , result . getLong ( " join _ date " ) , result . getLong ( " last _ seen " ) , getIDByTag ( result . getString ( " tag " ) ) , result . getInt ( " neutral _ kills " ) , result . getInt ( " rival _ kills " ) , result . getInt ( " civilian _ kills " ) , result . getInt ( " deaths " ) , flags . toJSONString ( ) ) ; ResultSet idResult = to . query ( " SELECT ▁ id ▁ FROM ▁ ` sc2 _ players ` ▁ WHERE ▁ name ▁ = ▁ ' " + name + " ' ; " ) ; idResult . next ( ) ; players . add ( new ConvertedClanPlayer ( idResult . getLong ( " id " ) , name ) ) ; } } public void insertPlayer ( String name , boolean leader , boolean trusted , long joinDate , long lastSeen , long clan , int neutralKills , int rivalKills , int civilianKills , int deaths , String flags ) throws SQLException { insertClanPlayer . setString ( 1 , name ) ; insertClanPlayer . setBoolean ( 2 , leader ) ; insertClanPlayer . setBoolean ( 3 , trusted ) ; insertClanPlayer . setTimestamp ( 4 , new Timestamp ( joinDate ) ) ; insertClanPlayer . setTimestamp ( 5 , new Timestamp ( lastSeen ) ) ; insertClanPlayer . setLong ( 6 , clan ) ; insertClanPlayer . setInt ( 7 , neutralKills ) ; insertClanPlayer . setInt ( 8 , rivalKills ) ; insertClanPlayer . setInt ( 9 , civilianKills ) ; insertClanPlayer . setInt ( 10 , deaths ) ; if ( flags != null ) { insertClanPlayer . setString ( 11 , flags ) ; } else { insertClanPlayer . setNull ( 11 , Types . VARCHAR ) ; } try { insertClanPlayer . executeUpdate ( ) ; } catch ( SQLException e ) { if ( e . getMessage ( ) . startsWith ( " Duplicate ▁ entry " ) || e . getMessage ( ) . contains ( " Abort ▁ due ▁ to ▁ constraint ▁ violation " ) ) { Logging . debug ( " Found ▁ duplicate ▁ clanPlayer ▁ % s ! ▁ Skipping ! " , name ) ; } else { Logging . debug ( e , " Error " , false ) ; } prepareClanPlayer ( ) ; } } public long getClanPlayerIDbyName ( String tag ) { for ( ConvertedClanPlayer cp : players ) { if ( cp . getName ( ) . equals ( tag ) ) { return cp . getId ( ) ; } } return - 1 ; } public void convertClans ( ) throws SQLException { ResultSet result = from . query ( " SELECT ▁ * ▁ FROM ▁ ` sc _ clans ` ; " ) ; while ( result . next ( ) ) { JSONObject flags = new JSONObject ( ) ; String name = result . getString ( " name " ) ; String tag = result . getString ( " tag " ) ; boolean verified = result . getBoolean ( " verified " ) ; boolean friendly_fire = result . getBoolean ( " friendly _ fire " ) ; long founded = result . getLong ( " founded " ) ; long last_used = result . getLong ( " last _ used " ) ; String flagsString = result . getString ( " flags " ) ; String cape = result . getString ( " cape _ url " ) ; ConvertedClan clan = new ConvertedClan ( tag ) ; clan . setPackedAllies ( result . getString ( " packed _ allies " ) ) ; clan . serPackedRivals ( result . getString ( " packed _ rivals " ) ) ; if ( friendly_fire ) { flags . put ( " ff " , friendly_fire ) ; } if ( cape != null && ! cape . isEmpty ( ) ) { flags . put ( " cape - url " , cape ) ; } JSONParser parser = new JSONParser ( ) ; try { JSONObject object = ( JSONObject ) parser . parse ( flagsString ) ; String world = object . get ( " homeWorld " ) . toString ( ) ; if ( ! world . isEmpty ( ) ) { int x = ( ( Long ) object . get ( " homeX " ) ) . intValue ( ) ; int y = ( ( Long ) object . get ( " homeY " ) ) . intValue ( ) ; int z = ( ( Long ) object . get ( " homeZ " ) ) . intValue ( ) ; flags . put ( " home " , x + " : " + y + " : " + z + " : " + world + " : 0:0" ) ; } clan . setRawWarring ( ( JSONArray ) object . get ( " warring " ) ) ; } catch ( ParseException e ) { Logging . debug ( e , true ) ; continue ; } insertClan ( name , tag , verified , founded , last_used , flags . isEmpty ( ) ? null : flags . toJSONString ( ) , result . getDouble ( " balance " ) ) ; String selectLastQuery = " SELECT ▁ ` id ` ▁ FROM ▁ ` sc2 _ clans ` ▁ ORDER ▁ BY ▁ ID ▁ DESC ▁ LIMIT ▁ 1 ; " ; ResultSet selectLast = to . query ( selectLastQuery ) ; selectLast . next ( ) ; clan . setId ( selectLast . getLong ( " id " ) ) ; selectLast . close ( ) ; insertBB ( Arrays . asList ( result . getString ( " packed _ bb " ) . split ( " \\s * ( \\ | | $ ) " ) ) , clan . getId ( ) ) ; clans . add ( clan ) ; } for ( ConvertedClan clan : clans ) { JSONArray allies = new JSONArray ( ) ; JSONArray rivals = new JSONArray ( ) ; JSONArray warring = new JSONArray ( ) ; for ( String allyTag : clan . getRawAllies ( ) ) { long allyID = getIDByTag ( allyTag ) ; if ( allyID != - 1 ) { allies . add ( allyID ) ; } } for ( String rivalTag : clan . getRawAllies ( ) ) { long rivalID = getIDByTag ( rivalTag ) ; if ( rivalID != - 1 ) { rivals . add ( rivalID ) ; } } for ( String warringTag : clan . getRawWarring ( ) ) { long warringID = getIDByTag ( warringTag ) ; if ( warringID != - 1 ) { warring . add ( warringID ) ; } } if ( ! allies . isEmpty ( ) ) { updateClan . setString ( 1 , allies . toJSONString ( ) ) ; } else { updateClan . setNull ( 1 , Types . VARCHAR ) ; } if ( ! rivals . isEmpty ( ) ) { updateClan . setString ( 2 , rivals . toJSONString ( ) ) ; } else { updateClan . setNull ( 2 , Types . VARCHAR ) ; } if ( ! warring . isEmpty ( ) ) { updateClan . setString ( 3 , warring . toJSONString ( ) ) ; } else { updateClan . setNull ( 3 , Types . VARCHAR ) ; } updateClan . setLong ( 4 , clan . getId ( ) ) ; updateClan . executeUpdate ( ) ; } } public long getIDByTag ( String tag ) { for ( ConvertedClan clan : clans ) { if ( clan . getTag ( ) . equals ( tag ) ) { return clan . getId ( ) ; } } return - 1 ; } public void insertBB ( List < String > bb , long clan ) throws SQLException { for ( String text : bb ) { insertBB . setLong ( 1 , clan ) ; insertBB . setString ( 2 , text ) ; insertBB . executeUpdate ( ) ; } } public void insertClan ( String name , String tag , boolean verified , long founded , long last_action , String flags , double balance ) throws SQLException { insertClan . setString ( 1 , name ) ; insertClan . setString ( 2 , tag ) ; insertClan . setBoolean ( 3 , verified ) ; insertClan . setTimestamp ( 4 , new Timestamp ( founded ) ) ; insertClan . setTimestamp ( 5 , new Timestamp ( last_action ) ) ; if ( flags != null ) { insertClan . setString ( 6 , flags ) ; } else { insertClan . setNull ( 6 , Types . VARCHAR ) ; } insertClan . setDouble ( 7 , balance ) ; try { insertClan . executeUpdate ( ) ; } catch ( SQLException e ) { if ( e . getMessage ( ) . startsWith ( " Duplicate ▁ entry " ) || e . getMessage ( ) . contains ( " Abort ▁ due ▁ to ▁ constraint ▁ violation " ) ) { Logging . debug ( " Found ▁ duplicate ▁ clan ▁ % s ! ▁ Skipping ! " , name ) ; } else { Logging . debug ( e , " Error " , false ) ; } prepareClan ( ) ; } } public void convertKills ( ) throws SQLException { ResultSet result = from . query ( " SELECT ▁ * ▁ FROM ▁ ` sc _ kills ` ; " ) ; while ( result . next ( ) ) { Timestamp date ; try { date = result . getTimestamp ( " date " ) ; } catch ( Exception e ) { date = new Timestamp ( System . currentTimeMillis ( ) ) ; } insertKill ( result . getString ( " attacker " ) , result . getString ( " attacker _ tag " ) , result . getString ( " victim " ) , result . getString ( " victim _ tag " ) , result . getString ( " kill _ type " ) , result . getBoolean ( " war " ) , date ) ; } } public void insertKill ( String attacker , String attacker_clan , String victim , String victim_clan , String type , boolean war , Timestamp date ) throws SQLException { long attackerID = getClanPlayerIDbyName ( attacker ) ; if ( attackerID == - 1 ) { return ; } long victimID = getClanPlayerIDbyName ( victim ) ; if ( victimID == - 1 ) { return ; } insertKill . setLong ( 1 , attackerID ) ; insertKill . setLong ( 2 , getIDByTag ( attacker_clan ) ) ; insertKill . setLong ( 3 , victimID ) ; insertKill . setLong ( 4 , getIDByTag ( victim_clan ) ) ; KillType realType ; switch ( type . charAt ( 0 ) ) { case ' c ' : realType = KillType . CIVILIAN ; break ; case ' n ' : realType = KillType . NEUTRAL ; break ; case ' r ' : realType = KillType . RIVAL ; break ; default : throw new UnsupportedOperationException ( " Failed ▁ at ▁ inserting ▁ kill ! ▁ Type ▁ not ▁ found : ▁ " + type ) ; } insertKill . setByte ( 5 , realType . getType ( ) ) ; insertKill . setBoolean ( 6 , war ) ; insertKill . setTimestamp ( 7 , date ) ; insertKill . executeUpdate ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="iLoop2/openmrs-core/tree/master/api/src/test/java/org/openmrs/PersonAttributeTest.java"> /* * STRNEWLINE ▁ * ▁ This ▁ Source ▁ Code ▁ Form ▁ is ▁ subject ▁ to ▁ the ▁ terms ▁ of ▁ the ▁ Mozilla ▁ Public ▁ License , STRNEWLINE ▁ * ▁ v . ▁ 2.0 . ▁ If ▁ a ▁ copy ▁ of ▁ the ▁ MPL ▁ was ▁ not ▁ distributed ▁ with ▁ this ▁ file , ▁ You ▁ can STRNEWLINE ▁ * ▁ obtain ▁ one ▁ at ▁ http : // mozilla . org / MPL / 2.0 / . ▁ OpenMRS ▁ is ▁ also ▁ distributed ▁ under STRNEWLINE ▁ * ▁ the ▁ terms ▁ of ▁ the ▁ Healthcare ▁ Disclaimer ▁ located ▁ at ▁ http : // openmrs . org / license . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ OpenMRS ▁ Inc . ▁ OpenMRS ▁ is ▁ a ▁ registered ▁ trademark ▁ and ▁ the ▁ OpenMRS STRNEWLINE ▁ * ▁ graphic ▁ logo ▁ is ▁ a ▁ trademark ▁ of ▁ OpenMRS ▁ Inc . STRNEWLINE ▁ */ package org . openmrs ; import java . util . Date ; import org . junit . Assert ; import org . junit . Test ; import org . openmrs . api . context . Context ; import org . openmrs . test . BaseContextSensitiveTest ; import org . openmrs . test . Verifies ; /* * STRNEWLINE ▁ * ▁ Tests ▁ methods ▁ on ▁ the ▁ PersonAttribute ▁ class STRNEWLINE ▁ */ public class PersonAttributeTest extends BaseContextSensitiveTest { /* * STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ PersonAttribute # toString ( ) STRNEWLINE TABSYMBOL ▁ */ @ Test @ Verifies ( value = " should ▁ return ▁ toString ▁ of ▁ hydrated ▁ value " , method = " toString ( ) " ) public void toString_shouldReturnToStringOfHydratedValue ( ) throws Exception { // ▁ type ▁ = ▁ CIVIL ▁ STATUS , ▁ concept ▁ = ▁ MARRIED ENDCOM PersonAttributeType type = Context . getPersonService ( ) . getPersonAttributeType ( 8 ) ; PersonAttribute attr = new PersonAttribute ( type , "6" ) ; Assert . assertEquals ( " MARRIED " , attr . toString ( ) ) ; } /* * STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ PersonAttribute # compareTo ( PersonAttribute ) STRNEWLINE TABSYMBOL ▁ */ @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ other ▁ attribute ▁ is ▁ voided " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfOtherAttributeIsVoided ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; PersonAttribute other = new PersonAttribute ( ) ; other . setVoided ( true ) ; Assert . assertTrue ( pa . compareTo ( other ) < 0 ) ; } /* * STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ PersonAttribute # compareTo ( PersonAttribute ) STRNEWLINE TABSYMBOL ▁ */ @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ other ▁ attribute ▁ has ▁ earlier ▁ date ▁ created " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfOtherAttributeHasEarlierDateCreated ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; pa . setDateCreated ( new Date ( ) ) ; PersonAttribute other = new PersonAttribute ( ) ; pa . setDateCreated ( new Date ( pa . getDateCreated ( ) . getTime ( ) - 1000 ) ) ; Assert . assertTrue ( pa . compareTo ( other ) < 0 ) ; } /* * STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ PersonAttribute # compareTo ( PersonAttribute ) STRNEWLINE TABSYMBOL ▁ */ @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ this ▁ attribute ▁ has ▁ lower ▁ attribute ▁ type ▁ than ▁ argument " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfThisAttributeHasLowerAttributeTypeThanArgument ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; PersonAttribute other = new PersonAttribute ( ) ; other . setAttributeType ( new PersonAttributeType ( 2 ) ) ; Assert . assertTrue ( pa . compareTo ( other ) < 0 ) ; } /* * STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ PersonAttribute # compareTo ( PersonAttribute ) STRNEWLINE TABSYMBOL ▁ */ @ Test @ Verifies ( value = " should ▁ not ▁ throw ▁ exception ▁ if ▁ attribute ▁ type ▁ is ▁ null " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldNotThrowExceptionIfAttributeTypeIdIsNull ( ) throws Exception { Assert . assertTrue ( new PersonAttribute ( 1 ) . compareTo ( new PersonAttribute ( 1 ) ) == 0 ) ; } /* * STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ PersonAttribute # compareTo ( PersonAttribute ) STRNEWLINE TABSYMBOL ▁ */ @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ other ▁ attribute ▁ has ▁ lower ▁ value " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfOtherAttributeHasLowerValue ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; pa . setValue ( "2" ) ; PersonAttribute other = new PersonAttribute ( ) ; other . setAttributeType ( new PersonAttributeType ( 1 ) ) ; other . setValue ( "1" ) ; Assert . assertTrue ( pa . compareTo ( other ) > 0 ) ; } /* * STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ PersonAttribute # compareTo ( PersonAttribute ) STRNEWLINE TABSYMBOL ▁ */ @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ this ▁ attribute ▁ has ▁ lower ▁ attribute ▁ id ▁ than ▁ argument " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfThisAttributeHasLowerAttributeIdThanArgument ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( 1 ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; PersonAttribute other = new PersonAttribute ( 2 ) ; other . setAttributeType ( new PersonAttributeType ( 1 ) ) ; Assert . assertTrue ( pa . compareTo ( other ) < 0 ) ; } /* * STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ PersonAttribute # equalsContent ( PersonAttribute ) STRNEWLINE TABSYMBOL ▁ */ @ Test @ Verifies ( value = " should ▁ return ▁ true ▁ if ▁ attributeType ▁ value ▁ and ▁ void ▁ status ▁ are ▁ the ▁ same " , method = " equalsContent ( PersonAttribute ) " ) public void equalsContent_shouldReturnTrueIfAttributeTypeValueAndVoidStatusAreTheSame ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( 2 ) ; // ▁ a ▁ different ▁ personAttributeid ▁ than ▁ below ENDCOM pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; pa . setValue ( "1" ) ; pa . setVoided ( false ) ; PersonAttribute other = new PersonAttribute ( 1 ) ; // ▁ a ▁ different ▁ personAttributeid ▁ than ▁ above ENDCOM pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; pa . setValue ( "1" ) ; pa . setVoided ( false ) ; Assert . assertTrue ( pa . equalsContent ( other ) ) ; } /* * STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ PersonAttribute # getHydratedObject ( ) STRNEWLINE TABSYMBOL ▁ */ @ Test @ Verifies ( value = " should ▁ load ▁ class ▁ in ▁ format ▁ property " , method = " getHydratedObject ( ) " ) public void getHydratedObject_shouldLoadClassInFormatProperty ( ) throws Exception { PersonAttributeType type = new PersonAttributeType ( ) ; type . setFormat ( " org . openmrs . Concept " ) ; PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setAttributeType ( type ) ; pa . setValue ( "5089" ) ; Concept concept = ( Concept ) pa . getHydratedObject ( ) ; Assert . assertEquals ( 5089 , concept . getConceptId ( ) . intValue ( ) ) ; } /* * STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ PersonAttribute # getHydratedObject ( ) STRNEWLINE TABSYMBOL ▁ */ @ Test @ Verifies ( value = " should ▁ load ▁ user ▁ class ▁ in ▁ format ▁ property " , method = " getHydratedObject ( ) " ) public void getHydratedObject_shouldLoadUserClassInFormatProperty ( ) throws Exception { PersonAttributeType type = new PersonAttributeType ( ) ; type . setFormat ( " org . openmrs . User " ) ; PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setAttributeType ( type ) ; pa . setValue ( "1" ) ; Object value = pa . getHydratedObject ( ) ; Assert . assertTrue ( " should ▁ load ▁ user ▁ class ▁ in ▁ format ▁ property " , ( value instanceof User ) ) ; } /* * STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ PersonAttribute # getHydratedObject ( ) STRNEWLINE TABSYMBOL ▁ */ @ Test @ Verifies ( value = " should ▁ still ▁ load ▁ class ▁ in ▁ format ▁ property ▁ if ▁ not ▁ Attributable " , method = " getHydratedObject ( ) " ) public void getHydratedObject_shouldStillLoadClassInFormatPropertyIfNotAttributable ( ) throws Exception { PersonAttributeType type = new PersonAttributeType ( ) ; type . setFormat ( " java . lang . String " ) ; PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setAttributeType ( type ) ; pa . setValue ( " lalapalooza " ) ; String value = ( String ) pa . getHydratedObject ( ) ; Assert . assertEquals ( " lalapalooza " , value ) ; } /* * STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ PersonAttribute # voidAttribute ( String ) STRNEWLINE TABSYMBOL ▁ */ @ Test @ Verifies ( value = " should ▁ set ▁ voided ▁ bit ▁ to ▁ true " , method = " voidAttribute ( String ) " ) public void voidAttribute_shouldSetVoidedBitToTrue ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setVoided ( false ) ; pa . voidAttribute ( " Because " ) ; Assert . assertTrue ( pa . isVoided ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="sklintyg/infra/tree/master/sjukfall/engine/src/test/java/se/inera/intyg/infra/sjukfall/engine/SjukfallIntygEnhetCreatorTest.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2019 ▁ Inera ▁ AB ▁ ( http : // www . inera . se ) STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ file ▁ is ▁ part ▁ of ▁ sklintyg ▁ ( https : // github . com / sklintyg ) . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ sklintyg ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or STRNEWLINE ▁ * ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ sklintyg ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ */ package se . inera . intyg . infra . sjukfall . engine ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertTrue ; import java . io . IOException ; import java . time . LocalDate ; import java . util . List ; import java . util . Map ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . mockito . junit . MockitoJUnitRunner ; import se . inera . intyg . infra . sjukfall . dto . IntygData ; import se . inera . intyg . infra . sjukfall . dto . IntygParametrar ; import se . inera . intyg . infra . sjukfall . dto . SjukfallIntyg ; import se . inera . intyg . infra . sjukfall . testdata . SjukfallIntygGenerator ; /* * STRNEWLINE ▁ * ▁ Created ▁ by ▁ Magnus ▁ Ekstrand ▁ on ▁ 2016-02-16 . STRNEWLINE ▁ */ @ RunWith ( MockitoJUnitRunner . class ) public class SjukfallIntygEnhetCreatorTest { private static final String LOCATION_INTYGSDATA = " classpath : Sjukfall / Enhet / intygsdata - creator . csv " ; private static List < IntygData > intygDataList ; private SjukfallIntygEnhetCreator creator ; private IntygParametrar parameters ; @ BeforeClass public static void initTestData ( ) throws IOException { SjukfallIntygGenerator generator = new SjukfallIntygGenerator ( LOCATION_INTYGSDATA ) ; intygDataList = generator . generate ( ) . get ( ) ; assertTrue ( " Expected ▁ 16 ▁ but ▁ was ▁ " + intygDataList . size ( ) , intygDataList . size ( ) == 16 ) ; } @ Before public void setup ( ) { creator = new SjukfallIntygEnhetCreator ( ) ; parameters = new IntygParametrar ( 5 , LocalDate . parse ( "2016-02-16" ) ) ; } @ Test public void testCreatingMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; assertTrue ( " Expected ▁ 7 ▁ but ▁ was ▁ " + map . size ( ) , map . size ( ) == 7 ) ; } @ Test public void testReducedMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > reducedMap = creator . reduceMap ( map ) ; // ▁ Map ▁ should ▁ be ▁ reduced ▁ with ▁ one ▁ entry ENDCOM assertTrue ( " Expected ▁ 6 ▁ but ▁ was ▁ " + reducedMap . size ( ) , reducedMap . size ( ) == 6 ) ; } @ Test public void testSortedMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > sortedMap = creator . sortValues ( map ) ; for ( Map . Entry < String , List < SjukfallIntyg > > entry : sortedMap . entrySet ( ) ) { if ( entry . getValue ( ) . size ( ) > 1 ) { SjukfallIntyg [ ] arr = entry . getValue ( ) . toArray ( new SjukfallIntyg [ entry . getValue ( ) . size ( ) ] ) ; // ▁ Check ▁ sort ▁ order ▁ when ▁ list ▁ size ▁ is ▁ greater ▁ than ▁ one ENDCOM for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { assertTrue ( arr [ i ] . getSlutDatum ( ) . isBefore ( arr [ i + 1 ] . getSlutDatum ( ) ) ) ; } } } } @ Test public void testSetActiveCertificate ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > activeMap = creator . setActive ( map ) ; // ▁ It ▁ can ▁ only ▁ be ▁ zero ▁ or ▁ one ▁ active ▁ object ENDCOM assertTrue ( activeMap . entrySet ( ) . stream ( ) . allMatch ( e -> e . getValue ( ) . stream ( ) . filter ( o -> o . isAktivtIntyg ( ) ) . count ( ) < 2 ) ) ; } /* STRNEWLINE ▁ * ▁ Test ▁ methods ▁ below ▁ refers ▁ to ▁ specified ▁ cases ▁ in ▁ SjukfallEnhet . xlsx . STRNEWLINE ▁ * ▁ https : // inera - certificate . atlassian . net / wiki / pages / viewpage . action ? pageId = 39747618 & preview = / 39747618/39747617 / Sjukfall . xlsx STRNEWLINE ▁ */ @ Test public void testFall1 ( ) { String key = "19791110-9291" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-20" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall2 ( ) { String key = "19791123-9262" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-20" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall3 ( ) { String key = "19791212-9280" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 3 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 2 ) , "2016-02-25" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall4 ( ) { String key = "19800113-9297" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 3 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 2 ) , "2016-02-25" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall5 ( ) { String key = "19800124-9286" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-12" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-25" ) ; assertTrue ( list . get ( 0 ) . isAktivtIntyg ( ) ) ; assertFalse ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall6 ( ) { String key = "19800207-9294" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-12" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-25" ) ; assertFalse ( list . get ( 0 ) . isAktivtIntyg ( ) ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall7 ( ) { String key = "19800228-9224" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; assertNull ( map . get ( key ) ) ; } private static void assertStartDate ( SjukfallIntyg intygsData , String datum ) { assertTrue ( intygsData . getStartDatum ( ) . equals ( LocalDate . parse ( datum ) ) ) ; } private static void assertEndDate ( SjukfallIntyg intygsData , String datum ) { assertTrue ( intygsData . getSlutDatum ( ) . equals ( LocalDate . parse ( datum ) ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="pentaho/pentaho-kettle/tree/master/core/src/main/java/org/pentaho/di/core/Props.java"> /* ! ▁ * * * * * STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Pentaho ▁ Data ▁ Integration STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2002-2018 ▁ by ▁ Hitachi ▁ Vantara ▁ : ▁ http : // www . pentaho . com STRNEWLINE ▁ * STRNEWLINE ▁ * * * * * STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with STRNEWLINE ▁ * ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ * STRNEWLINE ▁ * * * * */ package org . pentaho . di . core ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . List ; import java . util . Properties ; import org . pentaho . di . core . exception . KettleValueException ; import org . pentaho . di . core . logging . LogChannel ; import org . pentaho . di . core . logging . LogChannelInterface ; import org . pentaho . di . core . row . ValueMetaInterface ; import org . pentaho . di . core . util . SortedFileOutputStream ; import org . pentaho . di . i18n . BaseMessages ; /* * STRNEWLINE ▁ * ▁ We ▁ use ▁ Props ▁ to ▁ store ▁ all ▁ kinds ▁ of ▁ user ▁ interactive ▁ information ▁ such ▁ as ▁ the ▁ selected ▁ colors , ▁ fonts , ▁ positions ▁ of STRNEWLINE ▁ * ▁ windows , ▁ etc . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ author ▁ Matt STRNEWLINE ▁ * ▁ @ since ▁ 15-12-2003 STRNEWLINE ▁ * STRNEWLINE ▁ */ public class Props implements Cloneable { private static Class < ? > PKG = Const . class ; // ▁ for ▁ i18n ▁ purposes , ▁ needed ▁ by ▁ Translator2 ! ! ENDCOM private static final String STRING_USER_PREFERENCES = " User ▁ preferences " ; protected static Props props ; public static final String STRING_FONT_FIXED_NAME = " FontFixedName " ; public static final String STRING_FONT_FIXED_SIZE = " FontFixedSize " ; public static final String STRING_FONT_FIXED_STYLE = " FontFixedStyle " ; public static final String STRING_FONT_DEFAULT_NAME = " FontDefaultName " ; public static final String STRING_FONT_DEFAULT_SIZE = " FontDefaultSize " ; public static final String STRING_FONT_DEFAULT_STYLE = " FontDefaultStyle " ; public static final String STRING_FONT_GRAPH_NAME = " FontGraphName " ; public static final String STRING_FONT_GRAPH_SIZE = " FontGraphSize " ; public static final String STRING_FONT_GRAPH_STYLE = " FontGraphStyle " ; public static final String STRING_FONT_GRID_NAME = " FontGridName " ; public static final String STRING_FONT_GRID_SIZE = " FontGridSize " ; public static final String STRING_FONT_GRID_STYLE = " FontGridStyle " ; public static final String STRING_FONT_NOTE_NAME = " FontNoteName " ; public static final String STRING_FONT_NOTE_SIZE = " FontNoteSize " ; public static final String STRING_FONT_NOTE_STYLE = " FontNoteStyle " ; public static final String STRING_BACKGROUND_COLOR_R = " BackgroundColorR " ; public static final String STRING_BACKGROUND_COLOR_G = " BackgroundColorG " ; public static final String STRING_BACKGROUND_COLOR_B = " BackgroundColorB " ; public static final String STRING_GRAPH_COLOR_R = " GraphColorR " ; public static final String STRING_GRAPH_COLOR_G = " GraphColorG " ; public static final String STRING_GRAPH_COLOR_B = " GraphColorB " ; public static final String STRING_TAB_COLOR_R = " TabColorR54" ; public static final String STRING_TAB_COLOR_G = " TabColorG54" ; public static final String STRING_TAB_COLOR_B = " TabColorB54" ; public static final String STRING_SVG_ENABLED = " EnableSVG " ; public static final String STRING_ICON_SIZE = " IconSize " ; public static final String STRING_LINE_WIDTH = " LineWidth " ; public static final String STRING_SHADOW_SIZE = " ShadowSize54" ; public static final String STRING_LOG_LEVEL = " LogLevel " ; public static final String STRING_LOG_FILTER = " LogFilter " ; public static final String STRING_MIDDLE_PCT = " MiddlePct " ; public static final String STRING_INDICATE_SLOW_TRANS_STEPS = " IndicateSlowTransSteps " ; public static final String STRING_LAST_PREVIEW_TRANS = " LastPreviewTrans " ; public static final String STRING_LAST_PREVIEW_STEP = " LastPreviewStep " ; public static final String STRING_LAST_PREVIEW_SIZE = " LastPreviewSize " ; public static final String STRING_MAX_UNDO = " MaxUndo " ; public static final String STRING_SIZE_MAX = " SizeMax " ; public static final String STRING_SIZE_X = " SizeX " ; public static final String STRING_SIZE_Y = " SizeY " ; public static final String STRING_SIZE_W = " SizeW " ; public static final String STRING_SIZE_H = " SizeH " ; public static final String STRING_SASH_W1 = " SashWeight1" ; public static final String STRING_SASH_W2 = " SashWeight2" ; public static final String STRING_AUTO_SAVE = " AutoSave " ; public static final String STRING_SAVE_CONF = " SaveConfirmation " ; public static final String STRING_AUTO_SPLIT = " AutoSplit " ; public static final String STRING_AUTO_COLLAPSE_CORE_TREE = " AutoCollapseCoreObjectsTree " ; public static final String STRING_USE_DB_CACHE = " UseDBCache " ; public static final String STRING_OPEN_LAST_FILE = " OpenLastFile " ; public static final String STRING_LAST_REPOSITORY_LOGIN = " RepositoryLastLogin " ; public static final String STRING_LAST_REPOSITORY = " RepositoryLast " ; public static final String STRING_ONLY_ACTIVE_STEPS = " OnlyActiveSteps " ; public static final String STRING_START_SHOW_REPOSITORIES = " ShowRepositoriesAtStartup " ; public static final String STRING_ANTI_ALIASING = " EnableAntiAliasing54" ; public static final String STRING_SHOW_CANVAS_GRID = " ShowCanvasGrid " ; public static final String STRING_SHOW_EXIT_WARNING = " ShowExitWarning " ; public static final String STRING_SHOW_OS_LOOK = " ShowOSLook54" ; public static final String STRING_LAST_ARGUMENT = " LastArgument " ; public static final String STRING_ARGUMENT_NAME_PREFIX = " Argument ▁ " ; public static final String STRING_CUSTOM_PARAMETER = " CustomParameter " ; public static final String STRING_PLUGIN_HISTORY = " PluginHistory " ; public static final String STRING_DEFAULT_PREVIEW_SIZE = " DefaultPreviewSize " ; public static final String STRING_ONLY_USED_DB_TO_XML = " SaveOnlyUsedConnectionsToXML " ; public static final String STRING_ASK_ABOUT_REPLACING_DATABASES = " AskAboutReplacingDatabases " ; public static final String STRING_REPLACE_DATABASES = " ReplaceDatabases " ; private static final String STRING_MAX_NR_LINES_IN_LOG = " MaxNrOfLinesInLog " ; private static final String STRING_MAX_NR_LINES_IN_HISTORY = " MaxNrOfLinesInHistory " ; private static final String STRING_LINES_IN_HISTORY_FETCH_SIZE = " LinesInHistoryFetchSize " ; public static final String STRING_DISABLE_INITIAL_EXECUTION_HISTORY = " DisableInitialExecutionHistory " ; private static final String STRING_MAX_LOG_LINE_TIMEOUT_MINUTES = " MaxLogLineTimeOutMinutes " ; public static final String STRING_RECENT_SEARCHES = " RecentSearches " ; public static final String STRING_SHOW_NEW_SUBTRANS_POPUP = " ShowNewSubtransPopup " ; protected LogChannelInterface log ; protected Properties properties ; protected ArrayList < ObjectUsageCount > pluginHistory ; protected int type ; protected String filename ; public static final int TYPE_PROPERTIES_EMPTY = 0 ; public static final int TYPE_PROPERTIES_SPOON = 1 ; public static final int TYPE_PROPERTIES_PAN = 2 ; public static final int TYPE_PROPERTIES_CHEF = 3 ; public static final int TYPE_PROPERTIES_KITCHEN = 4 ; public static final int TYPE_PROPERTIES_MENU = 5 ; public static final int TYPE_PROPERTIES_PLATE = 6 ; public static final int WIDGET_STYLE_DEFAULT = 0 ; public static final int WIDGET_STYLE_FIXED = 1 ; public static final int WIDGET_STYLE_TABLE = 2 ; public static final int WIDGET_STYLE_NOTEPAD = 3 ; public static final int WIDGET_STYLE_GRAPH = 4 ; public static final int WIDGET_STYLE_TAB = 5 ; public static final int WIDGET_STYLE_TOOLBAR = 6 ; /* * STRNEWLINE ▁ * ▁ Initialize ▁ the ▁ properties : ▁ load ▁ from ▁ disk . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ display STRNEWLINE ▁ * ▁ The ▁ Display STRNEWLINE ▁ * ▁ @ param ▁ t STRNEWLINE ▁ * ▁ The ▁ type ▁ of ▁ properties ▁ file . STRNEWLINE ▁ */ public static final void init ( int t ) { if ( props == null ) { props = new Props ( t ) ; } else { throw new RuntimeException ( " The ▁ Properties ▁ systems ▁ settings ▁ are ▁ already ▁ initialised ! " ) ; } } /* * STRNEWLINE ▁ * ▁ Initialize ▁ the ▁ properties : ▁ load ▁ from ▁ disk . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ display STRNEWLINE ▁ * ▁ The ▁ Display STRNEWLINE ▁ * ▁ @ param ▁ filename STRNEWLINE ▁ * ▁ the ▁ filename ▁ to ▁ use STRNEWLINE ▁ */ public static final void init ( String filename ) { if ( props == null ) { props = new Props ( filename ) ; } else { throw new RuntimeException ( " The ▁ properties ▁ systems ▁ settings ▁ are ▁ already ▁ initialised ! " ) ; } } /* * STRNEWLINE ▁ * ▁ Check ▁ to ▁ see ▁ whether ▁ the ▁ Kettle ▁ properties ▁ where ▁ loaded . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ true ▁ if ▁ the ▁ Kettle ▁ properties ▁ where ▁ loaded . STRNEWLINE ▁ */ public static boolean isInitialized ( ) { return props != null ; } public static Props getInstance ( ) { if ( props != null ) { return props ; } throw new RuntimeException ( " Properties , ▁ Kettle ▁ systems ▁ settings , ▁ not ▁ initialised ! " ) ; } protected Props ( ) { init ( ) ; } protected Props ( int t ) { type = t ; filename = getFilename ( ) ; init ( ) ; } protected void init ( ) { createLogChannel ( ) ; properties = new Properties ( ) ; pluginHistory = new ArrayList < ObjectUsageCount > ( ) ; loadProps ( ) ; addDefaultEntries ( ) ; loadPluginHistory ( ) ; } protected Props ( String filename ) { properties = new Properties ( ) ; this . type = TYPE_PROPERTIES_EMPTY ; this . filename = filename ; init ( ) ; } @ Override public String toString ( ) { return STRING_USER_PREFERENCES ; } protected void createLogChannel ( ) { log = new LogChannel ( STRING_USER_PREFERENCES ) ; } public String getFilename ( ) { String filename = " " ; String directory = Const . getKettleDirectory ( ) ; switch ( type ) { case TYPE_PROPERTIES_SPOON : case TYPE_PROPERTIES_PAN : filename = directory + Const . FILE_SEPARATOR + " . spoonrc " ; break ; case TYPE_PROPERTIES_CHEF : case TYPE_PROPERTIES_KITCHEN : filename = directory + Const . FILE_SEPARATOR + " . chefrc " ; break ; case TYPE_PROPERTIES_MENU : filename = directory + Const . FILE_SEPARATOR + " . menurc " ; break ; case TYPE_PROPERTIES_PLATE : filename = directory + Const . FILE_SEPARATOR + " . platerc " ; break ; default : break ; } return filename ; } public String getLicenseFilename ( ) { String directory = Const . getKettleDirectory ( ) ; String filename = directory + Const . FILE_SEPARATOR + " . licence " ; // ▁ Try ▁ to ▁ create ▁ the ▁ directory . . . ENDCOM File dir = new File ( directory ) ; if ( ! dir . exists ( ) ) { try { dir . mkdirs ( ) ; } catch ( Exception e ) { // ▁ ignore ▁ - ▁ should ▁ likely ▁ report ▁ failure ▁ to ▁ create ▁ directory ENDCOM } } return filename ; } public boolean fileExists ( ) { File f = new File ( filename ) ; return f . exists ( ) ; } public void setType ( int t ) { type = t ; } public int getType ( ) { return type ; } public boolean loadProps ( ) { try { FileInputStream fis = new FileInputStream ( filename ) ; try { properties . load ( fis ) ; } finally { try { fis . close ( ) ; } catch ( IOException ignored ) { // ▁ Ignore ▁ close ▁ exception ENDCOM } } } catch ( Exception e ) { return false ; } return true ; } protected void addDefaultEntries ( ) { if ( ! properties . containsKey ( " JobDialogStyle " ) ) { properties . setProperty ( " JobDialogStyle " , " RESIZE , MAX , MIN " ) ; } } public void saveProps ( ) { File spoonRc = new File ( filename ) ; try { // ▁ FileOutputStream ▁ fos ▁ = ▁ new ▁ FileOutputStream ( spoonRc ) ; ENDCOM SortedFileOutputStream fos = new SortedFileOutputStream ( spoonRc ) ; fos . setLogger ( log ) ; properties . store ( fos , " Kettle ▁ Properties ▁ file " ) ; fos . close ( ) ; log . logDetailed ( BaseMessages . getString ( PKG , " Spoon . Log . SaveProperties " ) ) ; } catch ( IOException e ) { // ▁ If ▁ saving ▁ fails ▁ this ▁ could ▁ be ▁ a ▁ known ▁ Java ▁ bug : ▁ If ▁ running ▁ Spoon ▁ on ▁ windows ▁ the ▁ spoon ENDCOM // ▁ config ▁ file ▁ gets ▁ created ▁ with ▁ the ▁ ' hidden ' ▁ attribute ▁ set . ▁ Some ▁ Java ▁ JREs ▁ cannot ▁ open ENDCOM // ▁ FileOutputStreams ▁ on ▁ files ▁ with ▁ that ▁ attribute ▁ set . ▁ The ▁ user ▁ has ▁ to ▁ unset ▁ that ▁ attribute ENDCOM // ▁ manually . ENDCOM // ▁ Note ▁ that ▁ we ▁ don ' t ▁ really ▁ want ▁ to ▁ throw ▁ an ▁ exception ▁ here , ▁ that ▁ would ▁ prevent ▁ usage ▁ of ▁ Kettle ▁ on ▁ read - only ENDCOM // ▁ systems . ENDCOM if ( spoonRc . isHidden ( ) && filename . indexOf ( ' \\ ' ) != - 1 ) { // ▁ If ▁ filename ▁ contains ▁ a ▁ backslash ▁ we ▁ consider ▁ Spoon ▁ as ▁ running ▁ on ▁ Windows ENDCOM log . logError ( BaseMessages . getString ( PKG , " Spoon . Log . SavePropertiesFailedWindowsBugAttr " , filename ) ) ; } else { // ▁ Another ▁ reason ▁ why ▁ the ▁ save ▁ failed ENDCOM log . logError ( BaseMessages . getString ( PKG , " Spoon . Log . SavePropertiesFailed " ) + e . getMessage ( ) ) ; } } } public void setLogLevel ( String level ) { properties . setProperty ( STRING_LOG_LEVEL , level ) ; } public String getLogLevel ( ) { String level = properties . getProperty ( STRING_LOG_LEVEL , " Basic " ) ; return level ; } public void setLogFilter ( String filter ) { properties . setProperty ( STRING_LOG_FILTER , Const . NVL ( filter , " " ) ) ; } public String getLogFilter ( ) { String level = properties . getProperty ( STRING_LOG_FILTER , " " ) ; return level ; } public void setUseDBCache ( boolean use ) { properties . setProperty ( STRING_USE_DB_CACHE , use ? " Y " : " N " ) ; } public boolean useDBCache ( ) { String use = properties . getProperty ( STRING_USE_DB_CACHE ) ; return ! " N " . equalsIgnoreCase ( use ) ; } public void setLastRepository ( String repname ) { properties . setProperty ( STRING_LAST_REPOSITORY , repname ) ; } public String getLastRepository ( ) { return properties . getProperty ( STRING_LAST_REPOSITORY ) ; } public void setLastRepositoryLogin ( String login ) { properties . setProperty ( STRING_LAST_REPOSITORY_LOGIN , login ) ; } public String getLastRepositoryLogin ( ) { return properties . getProperty ( STRING_LAST_REPOSITORY_LOGIN ) ; } public void setOnlyActiveSteps ( boolean only ) { properties . setProperty ( STRING_ONLY_ACTIVE_STEPS , only ? " Y " : " N " ) ; } public boolean getOnlyActiveSteps ( ) { String only = properties . getProperty ( STRING_ONLY_ACTIVE_STEPS , " N " ) ; return " Y " . equalsIgnoreCase ( only ) ; // ▁ Default : ▁ show ▁ active ▁ steps . ENDCOM } public boolean askAboutReplacingDatabaseConnections ( ) { String ask = properties . getProperty ( STRING_ASK_ABOUT_REPLACING_DATABASES , " N " ) ; return " Y " . equalsIgnoreCase ( ask ) ; } public void setProperty ( String propertyName , String value ) { properties . setProperty ( propertyName , value ) ; } public String getProperty ( String propertyName ) { return properties . getProperty ( propertyName ) ; } public void setAskAboutReplacingDatabaseConnections ( boolean ask ) { properties . setProperty ( STRING_ASK_ABOUT_REPLACING_DATABASES , ask ? " Y " : " N " ) ; } /* * STRNEWLINE ▁ * ▁ @ param ▁ parameterName STRNEWLINE ▁ * ▁ The ▁ parameter ▁ name STRNEWLINE ▁ * ▁ @ param ▁ defaultValue STRNEWLINE ▁ * ▁ The ▁ default ▁ value ▁ in ▁ case ▁ the ▁ parameter ▁ doesn ' t ▁ exist ▁ yet . STRNEWLINE ▁ * ▁ @ return ▁ The ▁ custom ▁ parameter STRNEWLINE ▁ */ public String getCustomParameter ( String parameterName , String defaultValue ) { return properties . getProperty ( STRING_CUSTOM_PARAMETER + parameterName , defaultValue ) ; } /* * STRNEWLINE ▁ * ▁ Set ▁ the ▁ custom ▁ parameter STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ parameterName STRNEWLINE ▁ * ▁ The ▁ name ▁ of ▁ the ▁ parameter STRNEWLINE ▁ * ▁ @ param ▁ value STRNEWLINE ▁ * ▁ The ▁ value ▁ to ▁ be ▁ stored ▁ in ▁ the ▁ properties ▁ file . STRNEWLINE ▁ */ public void setCustomParameter ( String parameterName , String value ) { properties . setProperty ( STRING_CUSTOM_PARAMETER + parameterName , value ) ; } public void clearCustomParameters ( ) { Enumeration < Object > keys = properties . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String key = ( String ) keys . nextElement ( ) ; if ( key . startsWith ( STRING_CUSTOM_PARAMETER ) ) { // ▁ Clear ▁ this ▁ one ENDCOM properties . remove ( key ) ; } } } /* * STRNEWLINE ▁ * ▁ Convert ▁ " argument ▁ 1 " ▁ to ▁ 1 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ value STRNEWLINE ▁ * ▁ The ▁ value ▁ to ▁ determine ▁ the ▁ argument ▁ number ▁ for STRNEWLINE ▁ * ▁ @ return ▁ The ▁ argument ▁ number STRNEWLINE ▁ */ public static final int getArgumentNumber ( ValueMetaInterface value ) { if ( value != null && value . getName ( ) . startsWith ( Props . STRING_ARGUMENT_NAME_PREFIX ) ) { return Const . toInt ( value . getName ( ) . substring ( Props . STRING_ARGUMENT_NAME_PREFIX . length ( ) ) , - 1 ) ; } return - 1 ; } public static final String [ ] convertArguments ( RowMetaAndData row ) { String [ ] args = new String [ 10 ] ; for ( int i = 0 ; i < row . size ( ) ; i ++ ) { ValueMetaInterface valueMeta = row . getValueMeta ( i ) ; int argNr = getArgumentNumber ( valueMeta ) ; if ( argNr >= 0 && argNr < 10 ) { try { args [ argNr ] = row . getString ( i , " " ) ; } catch ( KettleValueException e ) { args [ argNr ] = " " ; // ▁ Should ▁ never ▁ happen ENDCOM } } } return args ; } /* * STRNEWLINE ▁ * ▁ Set ▁ the ▁ last ▁ arguments ▁ so ▁ that ▁ we ▁ can ▁ recall ▁ it ▁ the ▁ next ▁ time . . . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ args STRNEWLINE ▁ * ▁ the ▁ arguments ▁ to ▁ save STRNEWLINE ▁ */ public void setLastArguments ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { if ( args [ i ] != null ) { properties . setProperty ( STRING_LAST_ARGUMENT + " _ " + i , args [ i ] ) ; } } } /* * STRNEWLINE ▁ * ▁ Get ▁ the ▁ last ▁ entered ▁ arguments . . . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ the ▁ last ▁ entered ▁ arguments . . . STRNEWLINE ▁ */ public String [ ] getLastArguments ( ) { String [ ] args = new String [ 10 ] ; for ( int i = 0 ; i < args . length ; i ++ ) { args [ i ] = properties . getProperty ( STRING_LAST_ARGUMENT + " _ " + i ) ; } return args ; } /* * STRNEWLINE ▁ * ▁ Get ▁ the ▁ list ▁ of ▁ recently ▁ used ▁ step STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ a ▁ list ▁ of ▁ strings : ▁ the ▁ plug - in ▁ IDs STRNEWLINE ▁ */ public List < ObjectUsageCount > getPluginHistory ( ) { return pluginHistory ; } public int increasePluginHistory ( String pluginID ) { for ( int i = 0 ; i < pluginHistory . size ( ) ; i ++ ) { ObjectUsageCount usage = pluginHistory . get ( i ) ; if ( usage . getObjectName ( ) . equalsIgnoreCase ( pluginID ) ) { int uses = usage . increment ( ) ; Collections . sort ( pluginHistory ) ; savePluginHistory ( ) ; return uses ; } } addPluginHistory ( pluginID , 1 ) ; Collections . sort ( pluginHistory ) ; savePluginHistory ( ) ; return 1 ; } /* STRNEWLINE ▁ * ▁ /* * ▁ Set ▁ the ▁ last ▁ plugin ▁ used ▁ in ▁ the ▁ plugin ▁ history STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ pluginID ▁ The ▁ last ▁ plugin ▁ ID STRNEWLINE ▁ */ public void addPluginHistory ( String pluginID , int uses ) { // ▁ Add ▁ at ▁ the ▁ front ENDCOM pluginHistory . add ( new ObjectUsageCount ( pluginID , uses ) ) ; } /* * STRNEWLINE ▁ * ▁ Load ▁ the ▁ plugin ▁ history ▁ from ▁ the ▁ properties ▁ file STRNEWLINE ▁ * STRNEWLINE ▁ */ protected void loadPluginHistory ( ) { pluginHistory = new ArrayList < ObjectUsageCount > ( ) ; int i = 0 ; String string = properties . getProperty ( STRING_PLUGIN_HISTORY + " _ " + i ) ; while ( string != null ) { pluginHistory . add ( ObjectUsageCount . fromString ( string ) ) ; i ++ ; string = properties . getProperty ( STRING_PLUGIN_HISTORY + " _ " + i ) ; } Collections . sort ( pluginHistory ) ; } private void savePluginHistory ( ) { for ( int i = 0 ; i < pluginHistory . size ( ) ; i ++ ) { ObjectUsageCount usage = pluginHistory . get ( i ) ; properties . setProperty ( STRING_PLUGIN_HISTORY + " _ " + i , usage . toString ( ) ) ; } } public boolean areOnlyUsedConnectionsSavedToXML ( ) { String show = properties . getProperty ( STRING_ONLY_USED_DB_TO_XML , " Y " ) ; return " Y " . equalsIgnoreCase ( show ) ; // ▁ Default : ▁ save ▁ all ▁ connections ENDCOM } public void setOnlyUsedConnectionsSavedToXML ( boolean onlyUsedConnections ) { properties . setProperty ( STRING_ONLY_USED_DB_TO_XML , onlyUsedConnections ? " Y " : " N " ) ; } public boolean replaceExistingDatabaseConnections ( ) { String replace = properties . getProperty ( STRING_REPLACE_DATABASES , " Y " ) ; return " Y " . equalsIgnoreCase ( replace ) ; } public void setReplaceDatabaseConnections ( boolean replace ) { properties . setProperty ( STRING_REPLACE_DATABASES , replace ? " Y " : " N " ) ; } public boolean showNewSubtransPopup ( ) { String show = properties . getProperty ( STRING_SHOW_NEW_SUBTRANS_POPUP , " Y " ) ; return " Y " . equalsIgnoreCase ( show ) ; } public void setShowNewSubtransPopup ( boolean show ) { properties . setProperty ( STRING_SHOW_NEW_SUBTRANS_POPUP , show ? " Y " : " N " ) ; } public int getMaxNrLinesInLog ( ) { String lines = properties . getProperty ( STRING_MAX_NR_LINES_IN_LOG ) ; return Const . toInt ( lines , Const . MAX_NR_LOG_LINES ) ; } public void setMaxNrLinesInLog ( int maxNrLinesInLog ) { properties . setProperty ( STRING_MAX_NR_LINES_IN_LOG , Integer . toString ( maxNrLinesInLog ) ) ; } public int getMaxNrLinesInHistory ( ) { String lines = properties . getProperty ( STRING_MAX_NR_LINES_IN_HISTORY ) ; return Const . toInt ( lines , Const . MAX_NR_HISTORY_LINES ) ; } public int getLinesInHistoryFetchSize ( ) { String fetchSize = properties . getProperty ( STRING_LINES_IN_HISTORY_FETCH_SIZE ) ; return Const . toInt ( fetchSize , Const . HISTORY_LINES_FETCH_SIZE ) ; } public boolean disableInitialExecutionHistory ( ) { String disable = properties . getProperty ( STRING_DISABLE_INITIAL_EXECUTION_HISTORY , " N " ) ; return " Y " . equalsIgnoreCase ( disable ) ; } public void setMaxNrLinesInHistory ( int maxNrLinesInHistory ) { properties . setProperty ( STRING_MAX_NR_LINES_IN_HISTORY , Integer . toString ( maxNrLinesInHistory ) ) ; } public void setLinesInHistoryFetchSize ( int linesInHistoryFetchSize ) { properties . setProperty ( STRING_LINES_IN_HISTORY_FETCH_SIZE , Integer . toString ( linesInHistoryFetchSize ) ) ; } public void setDisableInitialExecutionHistory ( boolean disable ) { properties . setProperty ( STRING_DISABLE_INITIAL_EXECUTION_HISTORY , disable ? " Y " : " N " ) ; } public int getMaxLogLineTimeoutMinutes ( ) { String minutes = properties . getProperty ( STRING_MAX_LOG_LINE_TIMEOUT_MINUTES ) ; return Const . toInt ( minutes , Const . MAX_LOG_LINE_TIMEOUT_MINUTES ) ; } public void setMaxLogLineTimeoutMinutes ( int maxLogLineTimeoutMinutes ) { properties . setProperty ( STRING_MAX_LOG_LINE_TIMEOUT_MINUTES , Integer . toString ( maxLogLineTimeoutMinutes ) ) ; } public void reset ( ) { props = null ; properties . clear ( ) ; pluginHistory . clear ( ) ; } } </DOCUMENT>