<DOCUMENT_ID="signed/intellij-community/tree/master/java/java-tests/testData/psi/parser-full/declarationParsing/class/NoType.java"> class ClassName { new X ( ) ; } </DOCUMENT>
<DOCUMENT_ID="crockpotveggies/deeplearning4j/tree/master/deeplearning4j-ui-parent/deeplearning4j-ui/src/test/java/org/deeplearning4j/ui/weights/HistogramBinTest.java"> package org . deeplearning4j . ui . weights ; import org . junit . Before ; import org . junit . Test ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . Nd4j ; import java . math . BigDecimal ; import static org . junit . Assert . assertEquals ; /* * STRNEWLINE ▁ * ▁ @ author ▁ raver119 @ gmail . com STRNEWLINE ▁ */ public class HistogramBinTest { @ Before public void setUp ( ) throws Exception { } @ Test public void testGetBins ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { 0.1 , 0.2 , 0.3 , 0.4 , 0.5 , 0.6 , 0.7 , 0.8 , 0.9 , 1.0 , 1.0 } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 10 ) . build ( ) ; assertEquals ( 0.1 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getBins ( ) ) ; assertEquals ( 2 , histogram . getBins ( ) . getDouble ( 9 ) , 0.001 ) ; } @ Test public void testGetData1 ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { 0.1 , 0.2 , 0.3 , 0.4 , 0.5 , 0.6 , 0.7 , 0.8 , 0.9 , 1.0 , 1.0 } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 10 ) . build ( ) ; assertEquals ( 0.1 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getData ( ) ) ; assertEquals ( 10 , histogram . getData ( ) . size ( ) ) ; } @ Test public void testGetData2 ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f , - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 10 ) . build ( ) ; assertEquals ( - 1.0 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getData ( ) ) ; assertEquals ( 10 , histogram . getData ( ) . size ( ) ) ; assertEquals ( 2 , histogram . getData ( ) . get ( new BigDecimal ( "1.00" ) ) . get ( ) ) ; } @ Test public void testGetData4 ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f , - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 50 ) . build ( ) ; assertEquals ( - 1.0 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getData ( ) ) ; assertEquals ( 50 , histogram . getData ( ) . size ( ) ) ; assertEquals ( 2 , histogram . getData ( ) . get ( new BigDecimal ( "1.00" ) ) . get ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="poiru/uni-spiffer/tree/master/spiffer/src/test/java/com/mohanathas/spiffer/algorithm/NodeTest.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2013 ▁ Birunthan ▁ Mohanathas STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ MIT ▁ license ▁ < http : // opensource . org / licenses / MIT > . ▁ This STRNEWLINE ▁ * ▁ file ▁ may ▁ not ▁ be ▁ copied , ▁ modified , ▁ or ▁ distributed ▁ except ▁ according ▁ to ▁ those STRNEWLINE ▁ * ▁ terms . STRNEWLINE ▁ */ package com . mohanathas . spiffer . algorithm ; import com . mohanathas . spiffer . util . Point ; import org . junit . Test ; import static org . junit . Assert . * ; /* * STRNEWLINE ▁ * ▁ Tests ▁ the ▁ Node ▁ class . STRNEWLINE ▁ */ public class NodeTest { public NodeTest ( ) { } @ Test public void testConstructor ( ) { final Node node = new Node ( 1 , 2 ) ; assertEquals ( 1 , node . getX ( ) ) ; assertEquals ( 2 , node . getY ( ) ) ; assertEquals ( new Point ( 1 , 2 ) , node . getPoint ( ) ) ; assertEquals ( Float . MAX_VALUE , node . getStartDistance ( ) , 0.001f ) ; assertEquals ( 0.0f , node . getGoalDistance ( ) , 0.001f ) ; } @ Test public void testCompareTo ( ) { final Node node1 = new Node ( 0 , 0 ) ; final Node node2 = new Node ( 0 , 0 ) ; node1 . setStartDistance ( 1.0f ) ; node1 . setGoalDistance ( 2.0f ) ; node2 . setStartDistance ( 2.0f ) ; node2 . setGoalDistance ( 1.0f ) ; assertEquals ( 0 , node1 . compareTo ( node2 ) ) ; node2 . setGoalDistance ( 3.0f ) ; assertEquals ( - 1 , node1 . compareTo ( node2 ) ) ; } @ Test public void testToString ( ) { final Node node = new Node ( 1 , 2 ) ; assertEquals ( " ( 1 , ▁ 2 ) " , node . toString ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="avasilevskiy/presto/tree/master/presto-raptor/src/main/java/com/facebook/presto/raptor/metadata/ShardNodes.java"> /* STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package com . facebook . presto . raptor . metadata ; import com . google . common . collect . ImmutableSet ; import java . util . Objects ; import java . util . Set ; import java . util . UUID ; import static com . google . common . base . MoreObjects . toStringHelper ; import static com . google . common . base . Preconditions . checkNotNull ; public class ShardNodes { private final UUID shardUuid ; private final Set < String > nodeIdentifiers ; public ShardNodes ( UUID shardUuid , Set < String > nodeIdentifiers ) { this . shardUuid = checkNotNull ( shardUuid , " shardUuid ▁ is ▁ null " ) ; this . nodeIdentifiers = ImmutableSet . copyOf ( checkNotNull ( nodeIdentifiers , " nodeIdentifiers ▁ is ▁ null " ) ) ; } public UUID getShardUuid ( ) { return shardUuid ; } public Set < String > getNodeIdentifiers ( ) { return nodeIdentifiers ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } ShardNodes other = ( ShardNodes ) obj ; return Objects . equals ( this . shardUuid , other . shardUuid ) && Objects . equals ( this . nodeIdentifiers , other . nodeIdentifiers ) ; } @ Override public int hashCode ( ) { return Objects . hash ( shardUuid , nodeIdentifiers ) ; } @ Override public String toString ( ) { return toStringHelper ( this ) . add ( " shardUuid " , shardUuid ) . add ( " nodeIdentifiers " , nodeIdentifiers ) . toString ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="da1z/intellij-community/tree/master/java/java-tests/testData/inspection/deadCode/junitAbstractClassWithInheritor/src/ChildTest.java"> public class ChildTest extends AbstractTest { } </DOCUMENT>
<DOCUMENT_ID="elijah513/ice/tree/master/java/test/src/main/java/test/Ice/location/ServerLocatorRegistry.java"> // ▁ Copyright ▁ ( c ) ▁ 2003-2015 ▁ ZeroC , ▁ Inc . ▁ All ▁ rights ▁ reserved . ENDCOM // ▁ This ▁ copy ▁ of ▁ Ice ▁ is ▁ licensed ▁ to ▁ you ▁ under ▁ the ▁ terms ▁ described ▁ in ▁ the ENDCOM // ▁ ICE _ LICENSE ▁ file ▁ included ▁ in ▁ this ▁ distribution . ENDCOM package test . Ice . location ; import test . Ice . location . Test . _TestLocatorRegistryDisp ; public class ServerLocatorRegistry extends _TestLocatorRegistryDisp { @ Override public void setAdapterDirectProxy_async ( Ice . AMD_LocatorRegistry_setAdapterDirectProxy cb , String adapter , Ice . ObjectPrx object , Ice . Current current ) { if ( object != null ) { _adapters . put ( adapter , object ) ; } else { _adapters . remove ( adapter ) ; } cb . ice_response ( ) ; } @ Override public void setReplicatedAdapterDirectProxy_async ( Ice . AMD_LocatorRegistry_setReplicatedAdapterDirectProxy cb , String adapter , String replica , Ice . ObjectPrx object , Ice . Current current ) { if ( object != null ) { _adapters . put ( adapter , object ) ; _adapters . put ( replica , object ) ; } else { _adapters . remove ( adapter ) ; _adapters . remove ( replica ) ; } cb . ice_response ( ) ; } @ Override public void setServerProcessProxy_async ( Ice . AMD_LocatorRegistry_setServerProcessProxy cb , String id , Ice . ProcessPrx proxy , Ice . Current current ) { } @ Override public void addObject ( Ice . ObjectPrx object , Ice . Current current ) { _objects . put ( object . ice_getIdentity ( ) , object ) ; } public Ice . ObjectPrx getAdapter ( String adapter ) throws Ice . AdapterNotFoundException { Ice . ObjectPrx obj = _adapters . get ( adapter ) ; if ( obj == null ) { throw new Ice . AdapterNotFoundException ( ) ; } return obj ; } public Ice . ObjectPrx getObject ( Ice . Identity id ) throws Ice . ObjectNotFoundException { Ice . ObjectPrx obj = _objects . get ( id ) ; if ( obj == null ) { throw new Ice . ObjectNotFoundException ( ) ; } return obj ; } private java . util . HashMap < String , Ice . ObjectPrx > _adapters = new java . util . HashMap < String , Ice . ObjectPrx > ( ) ; private java . util . HashMap < Ice . Identity , Ice . ObjectPrx > _objects = new java . util . HashMap < Ice . Identity , Ice . ObjectPrx > ( ) ; } </DOCUMENT>
<DOCUMENT_ID="tuchida/rhino/tree/master/testsrc/org/mozilla/javascript/tests/Bug688021Test.java"> /* ▁ This ▁ Source ▁ Code ▁ Form ▁ is ▁ subject ▁ to ▁ the ▁ terms ▁ of ▁ the ▁ Mozilla ▁ Public STRNEWLINE ▁ * ▁ License , ▁ v . ▁ 2.0 . ▁ If ▁ a ▁ copy ▁ of ▁ the ▁ MPL ▁ was ▁ not ▁ distributed ▁ with ▁ this STRNEWLINE ▁ * ▁ file , ▁ You ▁ can ▁ obtain ▁ one ▁ at ▁ http : // mozilla . org / MPL / 2.0 / . ▁ */ package org . mozilla . javascript . tests ; import static org . junit . Assert . assertEquals ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . mozilla . javascript . CompilerEnvirons ; import org . mozilla . javascript . Context ; import org . mozilla . javascript . ErrorReporter ; import org . mozilla . javascript . Parser ; import org . mozilla . javascript . ast . AstRoot ; /* * STRNEWLINE ▁ * ▁ @ author ▁ André ▁ Bargull STRNEWLINE ▁ * ▁ STRNEWLINE ▁ */ public class Bug688021Test { private Context cx ; @ Before public void setUp ( ) { cx = Context . enter ( ) ; cx . setLanguageVersion ( Context . VERSION_1_8 ) ; } @ After public void tearDown ( ) { Context . exit ( ) ; } private AstRoot parse ( CharSequence cs ) { CompilerEnvirons compilerEnv = new CompilerEnvirons ( ) ; compilerEnv . initFromContext ( cx ) ; ErrorReporter compilationErrorReporter = compilerEnv . getErrorReporter ( ) ; Parser p = new Parser ( compilerEnv , compilationErrorReporter ) ; return p . parse ( cs . toString ( ) , " < eval > " , 1 ) ; } private String toSource ( CharSequence cs ) { return parse ( cs ) . toSource ( ) ; } @ Test public void testToSource ( ) { assertEquals ( " debugger ; \n " , toSource ( " debugger " ) ) ; assertEquals ( " debugger ; \n " , toSource ( " debugger ; " ) ) ; assertEquals ( " debugger ; \n " , toSource ( " debugger ; \n " ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="qqming113/hadoop/tree/master/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/webapp/dao/TaskAttemptsInfo.java"> /* * STRNEWLINE ▁ * ▁ Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ ( ASF ) ▁ under ▁ one STRNEWLINE ▁ * ▁ or ▁ more ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file STRNEWLINE ▁ * ▁ distributed ▁ with ▁ this ▁ work ▁ for ▁ additional ▁ information STRNEWLINE ▁ * ▁ regarding ▁ copyright ▁ ownership . ▁ The ▁ ASF ▁ licenses ▁ this ▁ file STRNEWLINE ▁ * ▁ to ▁ you ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the STRNEWLINE ▁ * ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance STRNEWLINE ▁ * ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ taskattemptlicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . apache . hadoop . mapreduce . v2 . app . webapp . dao ; import java . util . ArrayList ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = " taskAttempts " ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TaskAttemptsInfo { protected ArrayList < TaskAttemptInfo > taskAttempt = new ArrayList < TaskAttemptInfo > ( ) ; public TaskAttemptsInfo ( ) { } // ▁ JAXB ▁ needs ▁ this ENDCOM public void add ( TaskAttemptInfo taskattemptInfo ) { taskAttempt . add ( taskattemptInfo ) ; } public ArrayList < TaskAttemptInfo > getTaskAttempts ( ) { return taskAttempt ; } } </DOCUMENT>
<DOCUMENT_ID="christer155/IntegratingFacebookTutorial/tree/master/IntegratingFacebookTutorial-Unity/Assets/Plugins/Android/facebook/src/com/facebook/internal/ImageResponseCache.java"> /* * STRNEWLINE ▁ * ▁ Copyright ▁ 2010 - present ▁ Facebook . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package com . facebook . internal ; import android . content . Context ; import android . util . Log ; import com . facebook . LoggingBehavior ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . HttpURLConnection ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; class ImageResponseCache { static final String TAG = ImageResponseCache . class . getSimpleName ( ) ; private volatile static FileLruCache imageCache ; synchronized static FileLruCache getCache ( Context context ) throws IOException { if ( imageCache == null ) { imageCache = new FileLruCache ( context . getApplicationContext ( ) , TAG , new FileLruCache . Limits ( ) ) ; } return imageCache ; } // ▁ Get ▁ stream ▁ from ▁ cache , ▁ or ▁ return ▁ null ▁ if ▁ the ▁ image ▁ is ▁ not ▁ cached . ENDCOM // ▁ Does ▁ not ▁ throw ▁ if ▁ there ▁ was ▁ an ▁ error . ENDCOM static InputStream getCachedImageStream ( URI url , Context context ) { InputStream imageStream = null ; if ( url != null ) { if ( isCDNURL ( url ) ) { try { FileLruCache cache = getCache ( context ) ; imageStream = cache . get ( url . toString ( ) ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , e . toString ( ) ) ; } } } return imageStream ; } static InputStream interceptAndCacheImageStream ( Context context , HttpURLConnection connection ) throws IOException { InputStream stream = null ; if ( connection . getResponseCode ( ) == HttpURLConnection . HTTP_OK ) { URL url = connection . getURL ( ) ; stream = connection . getInputStream ( ) ; // ▁ Default ▁ stream ▁ in ▁ case ▁ caching ▁ fails ENDCOM try { if ( isCDNURL ( url . toURI ( ) ) ) { FileLruCache cache = getCache ( context ) ; // ▁ Wrap ▁ stream ▁ with ▁ a ▁ caching ▁ stream ENDCOM stream = cache . interceptAndPut ( url . toString ( ) , new BufferedHttpInputStream ( stream , connection ) ) ; } } catch ( IOException e ) { // ▁ Caching ▁ is ▁ best ▁ effort ENDCOM } catch ( URISyntaxException e ) { // ▁ Caching ▁ is ▁ best ▁ effort ENDCOM } } return stream ; } private static boolean isCDNURL ( URI url ) { if ( url != null ) { String uriHost = url . getHost ( ) ; if ( uriHost . endsWith ( " fbcdn . net " ) ) { return true ; } if ( uriHost . startsWith ( " fbcdn " ) && uriHost . endsWith ( " akamaihd . net " ) ) { return true ; } } return false ; } static void clearCache ( Context context ) { try { getCache ( context ) . clearCache ( ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , " clearCache ▁ failed ▁ " + e . getMessage ( ) ) ; } } private static class BufferedHttpInputStream extends BufferedInputStream { HttpURLConnection connection ; BufferedHttpInputStream ( InputStream stream , HttpURLConnection connection ) { super ( stream , Utility . DEFAULT_STREAM_BUFFER_SIZE ) ; this . connection = connection ; } @ Override public void close ( ) throws IOException { super . close ( ) ; Utility . disconnectQuietly ( connection ) ; } } } </DOCUMENT>
<DOCUMENT_ID="13366348079/Dubbo/tree/master/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/BroadcastCluster.java"> /*  STRNEWLINE ▁ * ▁ Copyright ▁ 1999-2012 ▁ Alibaba ▁ Group .  STRNEWLINE ▁ * ▁  STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ;  STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License .  STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * ▁  STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * ▁  STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS ,  STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied .  STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License .  STRNEWLINE ▁ */ package com . alibaba . dubbo . rpc . cluster . support ; import com . alibaba . dubbo . rpc . Invoker ; import com . alibaba . dubbo . rpc . RpcException ; import com . alibaba . dubbo . rpc . cluster . Cluster ; import com . alibaba . dubbo . rpc . cluster . Directory ; /* *  STRNEWLINE ▁ * ▁ BroadcastCluster STRNEWLINE ▁ * ▁  STRNEWLINE ▁ * ▁ @ author ▁ william . liangf STRNEWLINE ▁ */ public class BroadcastCluster implements Cluster { public < T > Invoker < T > join ( Directory < T > directory ) throws RpcException { return new BroadcastClusterInvoker < T > ( directory ) ; } } </DOCUMENT>
<DOCUMENT_ID="karianna/jdk8_tl/tree/master/hotspot/test/compiler/5091921/Test6850611.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( c ) ▁ 2011 , ▁ Oracle ▁ and / or ▁ its ▁ affiliates . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * ▁ DO ▁ NOT ▁ ALTER ▁ OR ▁ REMOVE ▁ COPYRIGHT ▁ NOTICES ▁ OR ▁ THIS ▁ FILE ▁ HEADER . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ code ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it STRNEWLINE ▁ * ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ version ▁ 2 ▁ only , ▁ as STRNEWLINE ▁ * ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ code ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT STRNEWLINE ▁ * ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or STRNEWLINE ▁ * ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ version ▁ 2 ▁ for ▁ more ▁ details ▁ ( a ▁ copy ▁ is ▁ included ▁ in ▁ the ▁ LICENSE ▁ file ▁ that STRNEWLINE ▁ * ▁ accompanied ▁ this ▁ code ) . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ version STRNEWLINE ▁ * ▁ 2 ▁ along ▁ with ▁ this ▁ work ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ▁ Foundation , STRNEWLINE ▁ * ▁ Inc . , ▁ 51 ▁ Franklin ▁ St , ▁ Fifth ▁ Floor , ▁ Boston , ▁ MA ▁ 02110-1301 ▁ USA . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Please ▁ contact ▁ Oracle , ▁ 500 ▁ Oracle ▁ Parkway , ▁ Redwood ▁ Shores , ▁ CA ▁ 94065 ▁ USA STRNEWLINE ▁ * ▁ or ▁ visit ▁ www . oracle . com ▁ if ▁ you ▁ need ▁ additional ▁ information ▁ or ▁ have ▁ any STRNEWLINE ▁ * ▁ questions . STRNEWLINE ▁ * STRNEWLINE ▁ */ /* * STRNEWLINE ▁ * ▁ @ test STRNEWLINE ▁ * ▁ @ bug ▁ 6850611 STRNEWLINE ▁ * ▁ @ summary ▁ int ▁ / ▁ long ▁ arithmetic ▁ seems ▁ to ▁ be ▁ broken ▁ in ▁ 1.6.0_14 ▁ HotSpot ▁ Server ▁ VM ▁ ( Win ▁ XP ) STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ run ▁ main ▁ Test6850611 STRNEWLINE ▁ */ public class Test6850611 { public static void main ( String [ ] args ) { test ( ) ; } private static void test ( ) { for ( int j = 0 ; j < 5 ; ++ j ) { long x = 0 ; for ( int i = Integer . MIN_VALUE ; i < Integer . MAX_VALUE ; ++ i ) { x += i ; } System . out . println ( " sum : ▁ " + x ) ; if ( x != - 4294967295l ) { System . out . println ( " FAILED " ) ; System . exit ( 97 ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="Rachels-Courses/Course-Common-Files/tree/master/STUDENT_REFERENCE/EXAMPLE_CODE/File IO/Java/OutputCSV/FileOutputter.java"> import java . io . * ; public class FileOutputter { private BufferedWriter m_writer ; private String m_filename ; public static void print ( String filename , String text ) { try { File file = new File ( filename ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( file . getAbsoluteFile ( ) , true ) ) ; bw . write ( text ) ; bw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void println ( String filename , String text ) { print ( filename , text + " \n " ) ; } public FileOutputter ( ) { m_filename = " default . txt " ; } public FileOutputter ( String filename ) { m_filename = filename ; } public void print ( String text ) { openFile ( m_filename ) ; try { m_writer . write ( text ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } closeFile ( ) ; } public void println ( String text ) { print ( text + " \n " ) ; } private void openFile ( String filename ) { try { File file = new File ( filename ) ; m_writer = new BufferedWriter ( new FileWriter ( file . getAbsoluteFile ( ) , true ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } private void closeFile ( ) { try { m_writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } </DOCUMENT>
<DOCUMENT_ID="mayonghui2112/helloWorld/tree/master/sourceCode/OnJava8-Examples-master/patterns/trash/Paper.java"> // ▁ patterns / trash / Paper . java ENDCOM // ▁ ( c ) 2017 ▁ MindView ▁ LLC : ▁ see ▁ Copyright . txt ENDCOM // ▁ We ▁ make ▁ no ▁ guarantees ▁ that ▁ this ▁ code ▁ is ▁ fit ▁ for ▁ any ▁ purpose . ENDCOM // ▁ Visit ▁ http : // OnJava8 . com ▁ for ▁ more ▁ book ▁ information . ENDCOM package patterns . trash ; public class Paper extends Trash { private static double val = 0.10f ; public Paper ( double wt ) { super ( wt ) ; } @ Override public double value ( ) { return val ; } public static void value ( double newVal ) { val = newVal ; } } </DOCUMENT>
<DOCUMENT_ID="yuanke/hadoop-hbase/tree/master/src/test/org/apache/hadoop/mapred/TestKillCompletedJob.java"> /* * STRNEWLINE ▁ * ▁ Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ ( ASF ) ▁ under ▁ one STRNEWLINE ▁ * ▁ or ▁ more ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file STRNEWLINE ▁ * ▁ distributed ▁ with ▁ this ▁ work ▁ for ▁ additional ▁ information STRNEWLINE ▁ * ▁ regarding ▁ copyright ▁ ownership . ▁ The ▁ ASF ▁ licenses ▁ this ▁ file STRNEWLINE ▁ * ▁ to ▁ you ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the STRNEWLINE ▁ * ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance STRNEWLINE ▁ * ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . apache . hadoop . mapred ; import java . io . * ; import java . net . * ; import junit . framework . TestCase ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . hdfs . MiniDFSCluster ; import org . apache . hadoop . fs . FileSystem ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . IntWritable ; import org . apache . hadoop . io . Text ; /* * STRNEWLINE ▁ * ▁ A ▁ JUnit ▁ test ▁ to ▁ test ▁ that ▁ killing ▁ completed ▁ jobs ▁ does ▁ not ▁ move ▁ them STRNEWLINE ▁ * ▁ to ▁ the ▁ failed ▁ sate ▁ - ▁ See ▁ JIRA ▁ HADOOP - 2132 STRNEWLINE ▁ */ public class TestKillCompletedJob extends TestCase { static Boolean launchWordCount ( String fileSys , String jobTracker , JobConf conf , String input , int numMaps , int numReduces ) throws IOException { final Path inDir = new Path ( " / testing / wc / input " ) ; final Path outDir = new Path ( " / testing / wc / output " ) ; FileSystem fs = FileSystem . get ( URI . create ( fileSys ) , conf ) ; fs . delete ( outDir , true ) ; if ( ! fs . mkdirs ( inDir ) ) { throw new IOException ( " Mkdirs ▁ failed ▁ to ▁ create ▁ " + inDir . toString ( ) ) ; } { DataOutputStream file = fs . create ( new Path ( inDir , " part - 0" ) ) ; file . writeBytes ( input ) ; file . close ( ) ; } FileSystem . setDefaultUri ( conf , fileSys ) ; conf . set ( " mapred . job . tracker " , jobTracker ) ; conf . setJobName ( " wordcount " ) ; conf . setInputFormat ( TextInputFormat . class ) ; // ▁ the ▁ keys ▁ are ▁ words ▁ ( strings ) ENDCOM conf . setOutputKeyClass ( Text . class ) ; // ▁ the ▁ values ▁ are ▁ counts ▁ ( ints ) ENDCOM conf . setOutputValueClass ( IntWritable . class ) ; conf . setMapperClass ( WordCount . MapClass . class ) ; conf . setCombinerClass ( WordCount . Reduce . class ) ; conf . setReducerClass ( WordCount . Reduce . class ) ; FileInputFormat . setInputPaths ( conf , inDir ) ; FileOutputFormat . setOutputPath ( conf , outDir ) ; conf . setNumMapTasks ( numMaps ) ; conf . setNumReduceTasks ( numReduces ) ; RunningJob rj = JobClient . runJob ( conf ) ; JobID jobId = rj . getID ( ) ; // ▁ Kill ▁ the ▁ job ▁ after ▁ it ▁ is ▁ successful ENDCOM if ( rj . isSuccessful ( ) ) { System . out . println ( " Job ▁ Id : " + jobId + " ▁ completed ▁ successfully . ▁ Killing ▁ it ▁ now " ) ; rj . killJob ( ) ; } return rj . isSuccessful ( ) ; } public void testKillCompJob ( ) throws IOException { String namenode = null ; MiniDFSCluster dfs = null ; MiniMRCluster mr = null ; FileSystem fileSys = null ; try { final int taskTrackers = 1 ; Configuration conf = new Configuration ( ) ; dfs = new MiniDFSCluster ( conf , 1 , true , null ) ; fileSys = dfs . getFileSystem ( ) ; namenode = fileSys . getUri ( ) . toString ( ) ; mr = new MiniMRCluster ( taskTrackers , namenode , 3 ) ; JobConf jobConf = new JobConf ( ) ; Boolean result ; final String jobTrackerName = " localhost : " + mr . getJobTrackerPort ( ) ; result = launchWordCount ( namenode , jobTrackerName , jobConf , " Small ▁ text \n " , 1 , 0 ) ; assertTrue ( result ) ; } finally { if ( dfs != null ) { dfs . shutdown ( ) ; } if ( mr != null ) { mr . shutdown ( ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="weebl2000/modeshape/tree/master/modeshape-jcr/src/main/java/org/modeshape/jcr/ModeShape.java"> /* STRNEWLINE ▁ * ▁ ModeShape ▁ ( http : // www . modeshape . org ) STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . modeshape . jcr ; import java . io . IOException ; import java . io . InputStream ; import java . util . Properties ; import org . modeshape . common . collection . UnmodifiableProperties ; import org . modeshape . common . logging . Logger ; /* * STRNEWLINE ▁ * ▁ Information ▁ about ▁ ModeShape . STRNEWLINE ▁ */ public final class ModeShape { private static final Properties bundleProperties = loadBundleProperties ( ) ; private static Properties loadBundleProperties ( ) { // ▁ This ▁ is ▁ idempotent , ▁ so ▁ we ▁ don ' t ▁ need ▁ to ▁ lock ▁ . . . ENDCOM InputStream stream = null ; try { stream = JcrRepository . class . getClassLoader ( ) . getResourceAsStream ( " org / modeshape / jcr / repository . properties " ) ; assert stream != null ; Properties props = new Properties ( ) ; props . load ( stream ) ; return new UnmodifiableProperties ( props ) ; } catch ( IOException e ) { throw new IllegalStateException ( JcrI18n . failedToReadPropertiesFromManifest . text ( e . getLocalizedMessage ( ) ) , e ) ; } finally { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { } finally { stream = null ; } } } } static { Logger . getLogger ( JcrRepository . class ) . info ( JcrI18n . initializing , getName ( ) , getVersion ( ) ) ; } /* * STRNEWLINE ▁ * ▁ Get ▁ the ▁ name ▁ suitable ▁ for ▁ public ▁ display . STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ return ▁ the ▁ name ; ▁ never ▁ null STRNEWLINE ▁ */ public static final String getName ( ) { return bundleProperties . getProperty ( " name " ) ; } /* * STRNEWLINE ▁ * ▁ Get ▁ the ▁ vendor ▁ name ▁ suitable ▁ for ▁ public ▁ display . STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ return ▁ the ▁ name ; ▁ never ▁ null STRNEWLINE ▁ */ public static final String getVendor ( ) { return bundleProperties . getProperty ( " vendor " ) ; } /* * STRNEWLINE ▁ * ▁ Get ▁ the ▁ project ▁ URL ▁ suitable ▁ for ▁ public ▁ display . STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ return ▁ the ▁ name ; ▁ never ▁ null STRNEWLINE ▁ */ public static final String getUrl ( ) { return bundleProperties . getProperty ( " url " ) ; } /* * STRNEWLINE ▁ * ▁ Get ▁ the ▁ version ▁ suitable ▁ for ▁ public ▁ display . STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ return ▁ the ▁ name ; ▁ never ▁ null STRNEWLINE ▁ */ public static final String getVersion ( ) { return bundleProperties . getProperty ( " version " ) ; } } </DOCUMENT>
<DOCUMENT_ID="fengyouchao/sockslib/tree/master/src/main/java/sockslib/client/CommandReplyMessage.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ 2015-2025 ▁ the ▁ original ▁ author ▁ or ▁ authors . STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except STRNEWLINE ▁ * ▁ in ▁ compliance ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ▁ distributed ▁ under ▁ the ▁ License STRNEWLINE ▁ * ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express STRNEWLINE ▁ * ▁ or ▁ implied . ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations ▁ under STRNEWLINE ▁ * ▁ the ▁ License . STRNEWLINE ▁ */ package sockslib . client ; import sockslib . common . AddressType ; import sockslib . utils . SocksUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . net . UnknownHostException ; /* * STRNEWLINE ▁ * ▁ The ▁ class ▁ < code > RequestCmdReplyMessage < / code > ▁ represents ▁ the ▁ message ▁ that STRNEWLINE ▁ * ▁ sent ▁ by ▁ SOCKS ▁ server ▁ when ▁ client ▁ sends ▁ a ▁ command ▁ request . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ author ▁ Youchao ▁ Feng STRNEWLINE ▁ * ▁ @ version ▁ 1.0 STRNEWLINE ▁ * ▁ @ date ▁ Mar ▁ 23 , ▁ 2015 ▁ 5:55:06 ▁ PM STRNEWLINE ▁ */ public class CommandReplyMessage implements SocksMessage { /* * STRNEWLINE ▁ * ▁ Logger ▁ that ▁ subclasses ▁ also ▁ can ▁ use . STRNEWLINE ▁ */ protected Logger logger = LoggerFactory . getLogger ( CommandReplyMessage . class ) ; /* * STRNEWLINE ▁ * ▁ The ▁ bytes ▁ that ▁ received ▁ from ▁ SOCKS ▁ server . STRNEWLINE ▁ */ private byte [ ] replyBytes ; /* * STRNEWLINE ▁ * ▁ Constructs ▁ an ▁ instance ▁ of ▁ { @ link ▁ CommandReplyMessage } ▁ with ▁ an ▁ array ▁ of STRNEWLINE ▁ * ▁ bytes ▁ that ▁ received ▁ from ▁ SOCKS ▁ server . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ replyBytes ▁ The ▁ bytes ▁ that ▁ received ▁ from ▁ SOCKS ▁ server . STRNEWLINE ▁ */ public CommandReplyMessage ( byte [ ] replyBytes ) { this . replyBytes = replyBytes ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ < code > true < / code > ▁ if ▁ the ▁ command ▁ request ▁ is ▁ success . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ If ▁ the ▁ command ▁ request ▁ is ▁ success , ▁ it ▁ will ▁ return STRNEWLINE ▁ * ▁ < code > true < / code > . STRNEWLINE ▁ */ public boolean isSuccess ( ) { if ( replyBytes . length < 10 ) { return false ; } return replyBytes [ 1 ] == 0 ; } /* * STRNEWLINE ▁ * ▁ Gets ▁ IP ▁ address ▁ from ▁ the ▁ bytes ▁ that ▁ sent ▁ by ▁ SOCKS ▁ server . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ IP ▁ address . STRNEWLINE ▁ * ▁ @ throws ▁ UnknownHostException ▁ If ▁ the ▁ host ▁ is ▁ unknown . STRNEWLINE ▁ */ public InetAddress getIp ( ) throws UnknownHostException { byte [ ] addressBytes = null ; if ( replyBytes [ 3 ] == AddressType . IPV4 ) { addressBytes = new byte [ 4 ] ; } else if ( replyBytes [ 3 ] == AddressType . IPV6 ) { addressBytes = new byte [ 16 ] ; } System . arraycopy ( replyBytes , 4 , addressBytes , 0 , addressBytes . length ) ; return InetAddress . getByAddress ( addressBytes ) ; } /* * STRNEWLINE ▁ * ▁ Gets ▁ port ▁ from ▁ bytes ▁ that ▁ sent ▁ by ▁ SOCKS ▁ server . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ port . STRNEWLINE ▁ */ public int getPort ( ) { return SocksUtil . bytesToInt ( replyBytes [ replyBytes . length - 2 ] , replyBytes [ replyBytes . length - 1 ] ) ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ bytes ▁ that ▁ sent ▁ by ▁ SOCKS ▁ server . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ The ▁ bytes ▁ that ▁ sent ▁ by ▁ SOCKS ▁ server . STRNEWLINE ▁ */ public byte [ ] getReplyBytes ( ) { return replyBytes ; } /* * STRNEWLINE ▁ * ▁ Sets ▁ reply ▁ bytes . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ replyBytes ▁ The ▁ bytes ▁ that ▁ sent ▁ by ▁ SOCKS ▁ server . STRNEWLINE ▁ */ public void setReplyBytes ( byte [ ] replyBytes ) { this . replyBytes = replyBytes ; } /* * STRNEWLINE ▁ * ▁ Gets ▁ the ▁ socket ▁ address . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ Socket ▁ address . STRNEWLINE ▁ */ public SocketAddress getSocketAddress ( ) { try { return new InetSocketAddress ( getIp ( ) , getPort ( ) ) ; } catch ( UnknownHostException e ) { logger . error ( e . getMessage ( ) , e ) ; } return null ; } } </DOCUMENT>
<DOCUMENT_ID="kingargyle/adt-leanback-support/tree/master/leanback-v17/src/main/java/android/support/v17/leanback/app/HeadersFragment.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2014 ▁ The ▁ Android ▁ Open ▁ Source ▁ Project STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except STRNEWLINE ▁ * ▁ in ▁ compliance ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ▁ distributed ▁ under ▁ the ▁ License STRNEWLINE ▁ * ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express STRNEWLINE ▁ * ▁ or ▁ implied . ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations ▁ under STRNEWLINE ▁ * ▁ the ▁ License . STRNEWLINE ▁ */ package android . support . v17 . leanback . app ; import android . content . Context ; import android . graphics . Color ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Bundle ; import android . support . v17 . leanback . R ; import android . support . v17 . leanback . widget . FocusHighlightHelper ; import android . support . v17 . leanback . widget . ItemBridgeAdapter ; import android . support . v17 . leanback . widget . PresenterSelector ; import android . support . v17 . leanback . widget . OnItemSelectedListener ; import android . support . v17 . leanback . widget . Row ; import android . support . v17 . leanback . widget . RowHeaderPresenter ; import android . support . v17 . leanback . widget . SinglePresenterSelector ; import android . support . v17 . leanback . widget . VerticalGridView ; import android . util . TypedValue ; import android . view . View ; import android . view . ViewGroup ; import android . view . View . OnLayoutChangeListener ; import android . widget . FrameLayout ; /* * STRNEWLINE ▁ * ▁ An ▁ internal ▁ fragment ▁ containing ▁ a ▁ list ▁ of ▁ row ▁ headers . STRNEWLINE ▁ */ public class HeadersFragment extends BaseRowFragment { interface OnHeaderClickedListener { void onHeaderClicked ( ) ; } private OnItemSelectedListener mOnItemSelectedListener ; private OnHeaderClickedListener mOnHeaderClickedListener ; private boolean mHeadersEnabled = true ; private boolean mHeadersGone = false ; private int mBackgroundColor ; private boolean mBackgroundColorSet ; private static final PresenterSelector sHeaderPresenter = new SinglePresenterSelector ( new RowHeaderPresenter ( R . layout . lb_header ) ) ; public HeadersFragment ( ) { setPresenterSelector ( sHeaderPresenter ) ; } public void setOnHeaderClickedListener ( OnHeaderClickedListener listener ) { mOnHeaderClickedListener = listener ; } public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelectedListener = listener ; } @ Override protected VerticalGridView findGridViewFromRoot ( View view ) { return ( VerticalGridView ) view . findViewById ( R . id . browse_headers ) ; } @ Override protected void onRowSelected ( ViewGroup parent , View view , int position , long id ) { if ( mOnItemSelectedListener != null ) { if ( position >= 0 ) { Row row = ( Row ) getAdapter ( ) . get ( position ) ; mOnItemSelectedListener . onItemSelected ( null , row ) ; } else { mOnItemSelectedListener . onItemSelected ( null , null ) ; } } } private final ItemBridgeAdapter . AdapterListener mAdapterListener = new ItemBridgeAdapter . AdapterListener ( ) { @ Override public void onCreate ( ItemBridgeAdapter . ViewHolder viewHolder ) { View headerView = viewHolder . getViewHolder ( ) . view ; headerView . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { if ( mOnHeaderClickedListener != null ) { mOnHeaderClickedListener . onHeaderClicked ( ) ; } } } ) ; headerView . setFocusable ( true ) ; headerView . setFocusableInTouchMode ( true ) ; if ( mWrapper != null ) { viewHolder . itemView . addOnLayoutChangeListener ( sLayoutChangeListener ) ; } else { headerView . addOnLayoutChangeListener ( sLayoutChangeListener ) ; } } } ; private static OnLayoutChangeListener sLayoutChangeListener = new OnLayoutChangeListener ( ) { @ Override public void onLayoutChange ( View v , int left , int top , int right , int bottom , int oldLeft , int oldTop , int oldRight , int oldBottom ) { v . setPivotX ( 0 ) ; v . setPivotY ( v . getMeasuredHeight ( ) / 2 ) ; } } ; @ Override protected int getLayoutResourceId ( ) { return R . layout . lb_headers_fragment ; } @ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; final VerticalGridView listView = getVerticalGridView ( ) ; if ( listView == null ) { return ; } if ( getBridgeAdapter ( ) != null ) { FocusHighlightHelper . setupHeaderItemFocusHighlight ( listView ) ; } view . setBackgroundColor ( getBackgroundColor ( ) ) ; updateFadingEdgeToBrandColor ( getBackgroundColor ( ) ) ; updateListViewVisibility ( ) ; } private void updateListViewVisibility ( ) { final VerticalGridView listView = getVerticalGridView ( ) ; if ( listView != null ) { getView ( ) . setVisibility ( mHeadersGone ? View . GONE : View . VISIBLE ) ; if ( ! mHeadersGone ) { if ( mHeadersEnabled ) { listView . setChildrenVisibility ( View . VISIBLE ) ; } else { listView . setChildrenVisibility ( View . INVISIBLE ) ; } } } } void setHeadersEnabled ( boolean enabled ) { mHeadersEnabled = enabled ; updateListViewVisibility ( ) ; } void setHeadersGone ( boolean gone ) { mHeadersGone = gone ; updateListViewVisibility ( ) ; } static class NoOverlappingFrameLayout extends FrameLayout { public NoOverlappingFrameLayout ( Context context ) { super ( context ) ; } /* * STRNEWLINE ▁ * ▁ Avoid ▁ creating ▁ hardware ▁ layer ▁ for ▁ header ▁ dock . STRNEWLINE ▁ */ @ Override public boolean hasOverlappingRendering ( ) { return false ; } } // ▁ Wrapper ▁ needed ▁ because ▁ of ▁ conflict ▁ between ▁ RecyclerView ' s ▁ use ▁ of ▁ alpha ENDCOM // ▁ for ▁ ADD ▁ animations , ▁ and ▁ RowHeaderPresnter ' s ▁ use ▁ of ▁ alpha ▁ for ▁ selected ▁ level . ENDCOM private final ItemBridgeAdapter . Wrapper mWrapper = new ItemBridgeAdapter . Wrapper ( ) { @ Override public void wrap ( View wrapper , View wrapped ) { ( ( FrameLayout ) wrapper ) . addView ( wrapped ) ; } @ Override public View createWrapper ( View root ) { return new NoOverlappingFrameLayout ( root . getContext ( ) ) ; } } ; @ Override protected void updateAdapter ( ) { super . updateAdapter ( ) ; ItemBridgeAdapter adapter = getBridgeAdapter ( ) ; if ( adapter != null ) { adapter . setAdapterListener ( mAdapterListener ) ; adapter . setWrapper ( mWrapper ) ; } if ( adapter != null && getVerticalGridView ( ) != null ) { FocusHighlightHelper . setupHeaderItemFocusHighlight ( getVerticalGridView ( ) ) ; } } void setBackgroundColor ( int color ) { mBackgroundColor = color ; mBackgroundColorSet = true ; if ( getView ( ) != null ) { getView ( ) . setBackgroundColor ( mBackgroundColor ) ; updateFadingEdgeToBrandColor ( mBackgroundColor ) ; } } private void updateFadingEdgeToBrandColor ( int backgroundColor ) { View fadingView = getView ( ) . findViewById ( R . id . fade_out_edge ) ; Drawable background = fadingView . getBackground ( ) ; if ( background instanceof GradientDrawable ) { background . mutate ( ) ; ( ( GradientDrawable ) background ) . setColors ( new int [ ] { Color . TRANSPARENT , backgroundColor } ) ; } } int getBackgroundColor ( ) { if ( getActivity ( ) == null ) { throw new IllegalStateException ( " Activity ▁ must ▁ be ▁ attached " ) ; } if ( mBackgroundColorSet ) { return mBackgroundColor ; } TypedValue outValue = new TypedValue ( ) ; getActivity ( ) . getTheme ( ) . resolveAttribute ( R . attr . defaultBrandColor , outValue , true ) ; return getResources ( ) . getColor ( outValue . resourceId ) ; } @ Override void onTransitionStart ( ) { super . onTransitionStart ( ) ; if ( ! mHeadersEnabled ) { // ▁ When ▁ enabling ▁ headers ▁ fragment , ▁ the ▁ RowHeaderView ▁ gets ▁ a ▁ focus ▁ but ENDCOM // ▁ isShown ( ) ▁ is ▁ still ▁ false ▁ because ▁ its ▁ parent ▁ is ▁ INVSIBILE , ▁ accessibility ENDCOM // ▁ event ▁ is ▁ not ▁ sent . ENDCOM // ▁ Workaround ▁ is : ▁ prevent ▁ focus ▁ to ▁ a ▁ child ▁ view ▁ during ▁ transition ▁ and ▁ put ENDCOM // ▁ focus ▁ on ▁ it ▁ after ▁ transition ▁ is ▁ done . ENDCOM final VerticalGridView listView = getVerticalGridView ( ) ; if ( listView != null ) { listView . setDescendantFocusability ( ViewGroup . FOCUS_BEFORE_DESCENDANTS ) ; if ( listView . hasFocus ( ) ) { listView . requestFocus ( ) ; } } } } @ Override void onTransitionEnd ( ) { if ( mHeadersEnabled ) { final VerticalGridView listView = getVerticalGridView ( ) ; if ( listView != null ) { listView . setDescendantFocusability ( ViewGroup . FOCUS_AFTER_DESCENDANTS ) ; if ( listView . hasFocus ( ) ) { listView . requestFocus ( ) ; } } } super . onTransitionEnd ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="MeetMe/selenium/tree/master/java/server/src/org/openqa/grid/internal/listeners/Prioritizer.java"> // ▁ Licensed ▁ to ▁ the ▁ Software ▁ Freedom ▁ Conservancy ▁ ( SFC ) ▁ under ▁ one ENDCOM // ▁ or ▁ more ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file ENDCOM // ▁ distributed ▁ with ▁ this ▁ work ▁ for ▁ additional ▁ information ENDCOM // ▁ regarding ▁ copyright ▁ ownership . ▁ The ▁ SFC ▁ licenses ▁ this ▁ file ENDCOM // ▁ to ▁ you ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ENDCOM // ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ENDCOM // ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at ENDCOM // ▁ http : // www . apache . org / licenses / LICENSE - 2.0 ENDCOM // ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ENDCOM // ▁ software ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ENDCOM // ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ENDCOM // ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ▁ See ▁ the ▁ License ▁ for ▁ the ENDCOM // ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations ENDCOM // ▁ under ▁ the ▁ License . ENDCOM package org . openqa . grid . internal . listeners ; import java . util . Map ; public interface Prioritizer { /* * STRNEWLINE ▁ * ▁ priority ▁ of ▁ a ▁ is ▁ lower ▁ than ▁ b ▁ : ▁ compare ( a , b ) ▁ > ▁ 0 STRNEWLINE ▁ * ▁ < p / > STRNEWLINE ▁ * ▁ priority ▁ of ▁ b ▁ is ▁ lower ▁ than ▁ a ▁ : ▁ compare ( a , b ) ▁ < ▁ 0 STRNEWLINE ▁ * ▁ < p / > STRNEWLINE ▁ * ▁ a ▁ and ▁ b ▁ have ▁ the ▁ same ▁ priority ▁ : ▁ compare ( a , b ) ▁ = ▁ 0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ a STRNEWLINE ▁ * ▁ @ param ▁ b STRNEWLINE ▁ * ▁ @ return ▁ a ▁ negative ▁ number ▁ is ▁ a ▁ is ▁ less ▁ important ▁ than ▁ b , ▁ a ▁ positive ▁ number ▁ is ▁ a ▁ is ▁ more STRNEWLINE ▁ * ▁ important ▁ than ▁ b , ▁ 0 ▁ if ▁ a ▁ and ▁ b ▁ are ▁ equally ▁ as ▁ important . STRNEWLINE ▁ */ public int compareTo ( Map < String , Object > a , Map < String , Object > b ) ; } </DOCUMENT>
<DOCUMENT_ID="Authorlove/hadoop/tree/master/hadoop-tools/hadoop-rumen/src/main/java/org/apache/hadoop/tools/rumen/DefaultInputDemuxer.java"> /* * STRNEWLINE ▁ * ▁ Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ ( ASF ) ▁ under ▁ one STRNEWLINE ▁ * ▁ or ▁ more ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file STRNEWLINE ▁ * ▁ distributed ▁ with ▁ this ▁ work ▁ for ▁ additional ▁ information STRNEWLINE ▁ * ▁ regarding ▁ copyright ▁ ownership . ▁ The ▁ ASF ▁ licenses ▁ this ▁ file STRNEWLINE ▁ * ▁ to ▁ you ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the STRNEWLINE ▁ * ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance STRNEWLINE ▁ * ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . apache . hadoop . tools . rumen ; import java . io . IOException ; import java . io . InputStream ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . Path ; /* * STRNEWLINE ▁ * ▁ { @ link ▁ DefaultInputDemuxer } ▁ acts ▁ as ▁ a ▁ pass - through ▁ demuxer . ▁ It ▁ just ▁ opens STRNEWLINE ▁ * ▁ each ▁ file ▁ and ▁ returns ▁ back ▁ the ▁ input ▁ stream . ▁ If ▁ the ▁ input ▁ is ▁ compressed , ▁ it STRNEWLINE ▁ * ▁ would ▁ return ▁ a ▁ decompression ▁ stream . STRNEWLINE ▁ */ public class DefaultInputDemuxer implements InputDemuxer { String name ; InputStream input ; @ Override public void bindTo ( Path path , Configuration conf ) throws IOException { if ( name != null ) { // ▁ re - binding ▁ before ▁ the ▁ previous ▁ one ▁ was ▁ consumed . ENDCOM close ( ) ; } name = path . getName ( ) ; input = new PossiblyDecompressedInputStream ( path , conf ) ; return ; } @ Override public Pair < String , InputStream > getNext ( ) throws IOException { if ( name != null ) { Pair < String , InputStream > ret = new Pair < String , InputStream > ( name , input ) ; name = null ; input = null ; return ret ; } return null ; } @ Override public void close ( ) throws IOException { try { if ( input != null ) { input . close ( ) ; } } finally { name = null ; input = null ; } } } </DOCUMENT>
<DOCUMENT_ID="davidfestal/che/tree/master/plugins/plugin-java/che-plugin-java-ext-lang-server/src/test/resources/RenamePackage/testFail10/in/r/A.java"> package r ; class C { } </DOCUMENT>
<DOCUMENT_ID="GeorgeMe/realm-java/tree/master/realm/src/main/java/io/realm/internal/SharedGroupWithReplication.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ 2014 ▁ Realm ▁ Inc . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ /* package ▁ io . realm . internal ; STRNEWLINE STRNEWLINE public ▁ class ▁ SharedGroupWithReplication ▁ extends ▁ SharedGroup ▁ { STRNEWLINE STRNEWLINE ▁ public ▁ SharedGroupWithReplication ( ) STRNEWLINE ▁ { STRNEWLINE ▁ super ( " " , ▁ true ) ; STRNEWLINE ▁ } STRNEWLINE STRNEWLINE ▁ public ▁ SharedGroupWithReplication ( String ▁ databaseFile ) STRNEWLINE ▁ { STRNEWLINE ▁ super ( databaseFile , ▁ true ) ; STRNEWLINE ▁ } STRNEWLINE STRNEWLINE ▁ public ▁ static ▁ String ▁ getDefaultDatabaseFileName ( ) STRNEWLINE ▁ { STRNEWLINE ▁ return ▁ nativeGetDefaultReplicationDatabaseFileName ( ) ; STRNEWLINE ▁ } STRNEWLINE } ▁ */ </DOCUMENT>
<DOCUMENT_ID="dslomov/intellij-community/tree/master/java/compiler/impl/src/com/intellij/compiler/impl/javaCompiler/javac/JavacCompiler.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ 2000-2012 ▁ JetBrains ▁ s . r . o . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package com . intellij . compiler . impl . javaCompiler . javac ; import com . intellij . compiler . impl . javaCompiler . BackendCompiler ; import com . intellij . openapi . compiler . CompilerBundle ; import com . intellij . openapi . fileTypes . FileType ; import com . intellij . openapi . fileTypes . StdFileTypes ; import com . intellij . openapi . options . Configurable ; import com . intellij . openapi . project . Project ; import org . jetbrains . annotations . NonNls ; import org . jetbrains . annotations . NotNull ; import org . jetbrains . jps . model . java . compiler . JavaCompilers ; import java . util . Collections ; import java . util . Set ; public class JavacCompiler implements BackendCompiler { private final Project myProject ; public JavacCompiler ( Project project ) { myProject = project ; } @ NotNull @ NonNls public String getId ( ) { // ▁ used ▁ for ▁ externalization ENDCOM return JavaCompilers . JAVAC_ID ; } @ NotNull public String getPresentableName ( ) { return CompilerBundle . message ( " compiler . javac . name " ) ; } @ NotNull public Configurable createConfigurable ( ) { return new JavacConfigurable ( JavacConfiguration . getOptions ( myProject , JavacConfiguration . class ) ) ; } @ NotNull public Set < FileType > getCompilableFileTypes ( ) { return Collections . < FileType > singleton ( StdFileTypes . JAVA ) ; } } </DOCUMENT>
<DOCUMENT_ID="iweiss/activemq-artemis/tree/master/tests/activemq5-unit-tests/src/test/java/org/apache/activemq/spring/SpringConsumer.java"> /* * STRNEWLINE ▁ * ▁ Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ ( ASF ) ▁ under ▁ one ▁ or ▁ more STRNEWLINE ▁ * ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file ▁ distributed ▁ with STRNEWLINE ▁ * ▁ this ▁ work ▁ for ▁ additional ▁ information ▁ regarding ▁ copyright ▁ ownership . STRNEWLINE ▁ * ▁ The ▁ ASF ▁ licenses ▁ this ▁ file ▁ to ▁ You ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 STRNEWLINE ▁ * ▁ ( the ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with STRNEWLINE ▁ * ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . apache . activemq . spring ; import javax . jms . Connection ; import javax . jms . ConnectionFactory ; import javax . jms . Destination ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . MessageConsumer ; import javax . jms . MessageListener ; import javax . jms . Session ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . jms . core . JmsTemplate ; public class SpringConsumer extends ConsumerBean implements MessageListener { private static final Logger LOG = LoggerFactory . getLogger ( SpringConsumer . class ) ; private JmsTemplate template ; private String myId = " foo " ; private Destination destination ; private Connection connection ; private Session session ; private MessageConsumer consumer ; public void start ( ) throws JMSException { String selector = " next ▁ = ▁ ' " + myId + " ' " ; try { ConnectionFactory factory = template . getConnectionFactory ( ) ; final Connection c = connection = factory . createConnection ( ) ; // ▁ we ▁ might ▁ be ▁ a ▁ reusable ▁ connection ▁ in ▁ spring ENDCOM // ▁ so ▁ lets ▁ only ▁ set ▁ the ▁ client ▁ ID ▁ once ▁ if ▁ its ▁ not ▁ set ENDCOM synchronized ( c ) { if ( c . getClientID ( ) == null ) { c . setClientID ( myId ) ; } } connection . start ( ) ; session = connection . createSession ( true , Session . CLIENT_ACKNOWLEDGE ) ; consumer = session . createConsumer ( destination , selector , false ) ; consumer . setMessageListener ( this ) ; } catch ( JMSException ex ) { LOG . error ( " " , ex ) ; throw ex ; } } public void stop ( ) throws JMSException { if ( consumer != null ) { consumer . close ( ) ; } if ( session != null ) { session . close ( ) ; } if ( connection != null ) { connection . close ( ) ; } } @ Override public void onMessage ( Message message ) { super . onMessage ( message ) ; try { message . acknowledge ( ) ; } catch ( JMSException e ) { LOG . error ( " Failed ▁ to ▁ acknowledge : ▁ " + e , e ) ; } } // ▁ Properties ENDCOM public Destination getDestination ( ) { return destination ; } public void setDestination ( Destination destination ) { this . destination = destination ; } public String getMyId ( ) { return myId ; } public void setMyId ( String myId ) { this . myId = myId ; } public JmsTemplate getTemplate ( ) { return template ; } public void setTemplate ( JmsTemplate template ) { this . template = template ; } } </DOCUMENT>
<DOCUMENT_ID="irwinai/zxing/tree/master/android/src/com/google/zxing/client/android/result/AddressBookResultHandler.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2008 ▁ ZXing ▁ authors STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package com . google . zxing . client . android . result ; import com . google . zxing . client . android . R ; import com . google . zxing . client . result . AddressBookParsedResult ; import com . google . zxing . client . result . ParsedResult ; import android . app . Activity ; import android . telephony . PhoneNumberUtils ; import android . text . Spannable ; import android . text . SpannableString ; import android . text . style . StyleSpan ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; /* * STRNEWLINE ▁ * ▁ Handles ▁ address ▁ book ▁ entries . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ author ▁ dswitkin @ google . com ▁ ( Daniel ▁ Switkin ) STRNEWLINE ▁ */ public final class AddressBookResultHandler extends ResultHandler { private static final DateFormat [ ] DATE_FORMATS = { new SimpleDateFormat ( " yyyyMMdd " , Locale . ENGLISH ) , new SimpleDateFormat ( " yyyyMMdd ' T ' HHmmss " , Locale . ENGLISH ) , new SimpleDateFormat ( " yyyy - MM - dd " , Locale . ENGLISH ) , new SimpleDateFormat ( " yyyy - MM - dd ' T ' HH : mm : ss " , Locale . ENGLISH ) , } ; static { for ( DateFormat format : DATE_FORMATS ) { format . setLenient ( false ) ; } } private static final int [ ] BUTTON_TEXTS = { R . string . button_add_contact , R . string . button_show_map , R . string . button_dial , R . string . button_email , } ; private final boolean [ ] fields ; private int buttonCount ; // ▁ This ▁ takes ▁ all ▁ the ▁ work ▁ out ▁ of ▁ figuring ▁ out ▁ which ▁ buttons / actions ▁ should ▁ be ▁ in ▁ which ENDCOM // ▁ positions , ▁ based ▁ on ▁ which ▁ fields ▁ are ▁ present ▁ in ▁ this ▁ barcode . ENDCOM private int mapIndexToAction ( int index ) { if ( index < buttonCount ) { int count = - 1 ; for ( int x = 0 ; x < MAX_BUTTON_COUNT ; x ++ ) { if ( fields [ x ] ) { count ++ ; } if ( count == index ) { return x ; } } } return - 1 ; } public AddressBookResultHandler ( Activity activity , ParsedResult result ) { super ( activity , result ) ; AddressBookParsedResult addressResult = ( AddressBookParsedResult ) result ; String [ ] addresses = addressResult . getAddresses ( ) ; boolean hasAddress = addresses != null && addresses . length > 0 && addresses [ 0 ] != null && ! addresses [ 0 ] . isEmpty ( ) ; String [ ] phoneNumbers = addressResult . getPhoneNumbers ( ) ; boolean hasPhoneNumber = phoneNumbers != null && phoneNumbers . length > 0 ; String [ ] emails = addressResult . getEmails ( ) ; boolean hasEmailAddress = emails != null && emails . length > 0 ; fields = new boolean [ MAX_BUTTON_COUNT ] ; fields [ 0 ] = true ; // ▁ Add ▁ contact ▁ is ▁ always ▁ available ENDCOM fields [ 1 ] = hasAddress ; fields [ 2 ] = hasPhoneNumber ; fields [ 3 ] = hasEmailAddress ; buttonCount = 0 ; for ( int x = 0 ; x < MAX_BUTTON_COUNT ; x ++ ) { if ( fields [ x ] ) { buttonCount ++ ; } } } @ Override public int getButtonCount ( ) { return buttonCount ; } @ Override public int getButtonText ( int index ) { return BUTTON_TEXTS [ mapIndexToAction ( index ) ] ; } @ Override public void handleButtonPress ( int index ) { AddressBookParsedResult addressResult = ( AddressBookParsedResult ) getResult ( ) ; String [ ] addresses = addressResult . getAddresses ( ) ; String address1 = addresses == null || addresses . length < 1 ? null : addresses [ 0 ] ; String [ ] addressTypes = addressResult . getAddressTypes ( ) ; String address1Type = addressTypes == null || addressTypes . length < 1 ? null : addressTypes [ 0 ] ; int action = mapIndexToAction ( index ) ; switch ( action ) { case 0 : addContact ( addressResult . getNames ( ) , addressResult . getNicknames ( ) , addressResult . getPronunciation ( ) , addressResult . getPhoneNumbers ( ) , addressResult . getPhoneTypes ( ) , addressResult . getEmails ( ) , addressResult . getEmailTypes ( ) , addressResult . getNote ( ) , addressResult . getInstantMessenger ( ) , address1 , address1Type , addressResult . getOrg ( ) , addressResult . getTitle ( ) , addressResult . getURLs ( ) , addressResult . getBirthday ( ) , addressResult . getGeo ( ) ) ; break ; case 1 : searchMap ( address1 ) ; break ; case 2 : dialPhone ( addressResult . getPhoneNumbers ( ) [ 0 ] ) ; break ; case 3 : sendEmail ( addressResult . getEmails ( ) , null , null , null , null ) ; break ; default : break ; } } private static Date parseDate ( String s ) { for ( DateFormat currentFormat : DATE_FORMATS ) { try { return currentFormat . parse ( s ) ; } catch ( ParseException e ) { // ▁ continue ENDCOM } } return null ; } // ▁ Overriden ▁ so ▁ we ▁ can ▁ hyphenate ▁ phone ▁ numbers , ▁ format ▁ birthdays , ▁ and ▁ bold ▁ the ▁ name . ENDCOM @ Override public CharSequence getDisplayContents ( ) { AddressBookParsedResult result = ( AddressBookParsedResult ) getResult ( ) ; StringBuilder contents = new StringBuilder ( 100 ) ; ParsedResult . maybeAppend ( result . getNames ( ) , contents ) ; int namesLength = contents . length ( ) ; String pronunciation = result . getPronunciation ( ) ; if ( pronunciation != null && ! pronunciation . isEmpty ( ) ) { contents . append ( " \n ( " ) ; contents . append ( pronunciation ) ; contents . append ( ' ) ' ) ; } ParsedResult . maybeAppend ( result . getTitle ( ) , contents ) ; ParsedResult . maybeAppend ( result . getOrg ( ) , contents ) ; ParsedResult . maybeAppend ( result . getAddresses ( ) , contents ) ; String [ ] numbers = result . getPhoneNumbers ( ) ; if ( numbers != null ) { for ( String number : numbers ) { if ( number != null ) { ParsedResult . maybeAppend ( PhoneNumberUtils . formatNumber ( number ) , contents ) ; } } } ParsedResult . maybeAppend ( result . getEmails ( ) , contents ) ; ParsedResult . maybeAppend ( result . getURLs ( ) , contents ) ; String birthday = result . getBirthday ( ) ; if ( birthday != null && ! birthday . isEmpty ( ) ) { Date date = parseDate ( birthday ) ; if ( date != null ) { ParsedResult . maybeAppend ( DateFormat . getDateInstance ( DateFormat . MEDIUM ) . format ( date . getTime ( ) ) , contents ) ; } } ParsedResult . maybeAppend ( result . getNote ( ) , contents ) ; if ( namesLength > 0 ) { // ▁ Bold ▁ the ▁ full ▁ name ▁ to ▁ make ▁ it ▁ stand ▁ out ▁ a ▁ bit . ENDCOM Spannable styled = new SpannableString ( contents . toString ( ) ) ; styled . setSpan ( new StyleSpan ( android . graphics . Typeface . BOLD ) , 0 , namesLength , 0 ) ; return styled ; } else { return contents . toString ( ) ; } } @ Override public int getDisplayTitle ( ) { return R . string . result_address_book ; } } </DOCUMENT>
<DOCUMENT_ID="rsf/RSFUtil/tree/master/src/uk/org/ponder/rsf/flow/jsfnav/support/NavigationRule.java"> /*  STRNEWLINE ▁ * ▁ Created ▁ on ▁ 10 - Feb - 2006 STRNEWLINE ▁ */ package uk . org . ponder . rsf . flow . jsfnav . support ; import java . util . List ; import uk . org . ponder . rsf . viewstate . ViewParameters ; public class NavigationRule { public ViewParameters fromViewId ; public List navigationCases ; } </DOCUMENT>
<DOCUMENT_ID="shlee89/athena/tree/master/web/gui/src/main/java/org/onosproject/ui/impl/TunnelViewMessageHandler.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ 2015 - present ▁ Open ▁ Networking ▁ Laboratory STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . onosproject . ui . impl ; import com . fasterxml . jackson . databind . node . ObjectNode ; import com . google . common . collect . ImmutableSet ; import org . onosproject . incubator . net . tunnel . Tunnel ; import org . onosproject . incubator . net . tunnel . TunnelEndPointFormatter ; import org . onosproject . incubator . net . tunnel . TunnelService ; import org . onosproject . ui . RequestHandler ; import org . onosproject . ui . UiMessageHandler ; import org . onosproject . ui . table . TableModel ; import org . onosproject . ui . table . TableRequestHandler ; import org . onosproject . ui . table . cell . EnumFormatter ; import java . util . Collection ; public class TunnelViewMessageHandler extends UiMessageHandler { private static final String TUNNEL_DATA_REQ = " tunnelDataRequest " ; private static final String TUNNEL_DATA_RESP = " tunnelDataResponse " ; private static final String TUNNELS = " tunnels " ; private static final String ID = " id " ; private static final String NAME = " name " ; private static final String ONE = " one " ; private static final String TWO = " two " ; private static final String TYPE = " type " ; private static final String GROUP_ID = " group _ id " ; private static final String BANDWIDTH = " bandwidth " ; private static final String PATH = " path " ; private static final String [ ] COL_IDS = { ID , NAME , ONE , TWO , TYPE , GROUP_ID , BANDWIDTH , PATH } ; @ Override protected Collection < RequestHandler > createRequestHandlers ( ) { return ImmutableSet . of ( new TunnelDataRequestHandler ( ) ) ; } private final class TunnelDataRequestHandler extends TableRequestHandler { private static final String NO_ROWS_MESSAGE = " No ▁ tunnels ▁ found " ; public TunnelDataRequestHandler ( ) { super ( TUNNEL_DATA_REQ , TUNNEL_DATA_RESP , TUNNELS ) ; } @ Override protected String [ ] getColumnIds ( ) { return COL_IDS ; } @ Override protected String noRowsMessage ( ObjectNode payload ) { return NO_ROWS_MESSAGE ; } @ Override protected TableModel createTableModel ( ) { TableModel tm = super . createTableModel ( ) ; // TODO ▁ add ▁ more ▁ formater ▁ class ▁ so ▁ that ▁ we ▁ can ▁ get ▁ a ▁ more ▁ readable ▁ table ENDCOM tm . setFormatter ( ONE , TunnelEndPointFormatter . INSTANCE ) ; tm . setFormatter ( TWO , TunnelEndPointFormatter . INSTANCE ) ; tm . setFormatter ( TYPE , EnumFormatter . INSTANCE ) ; return tm ; } @ Override protected void populateTable ( TableModel tm , ObjectNode payload ) { TunnelService ts = get ( TunnelService . class ) ; ts . queryAllTunnels ( ) . forEach ( tunnel -> populateRow ( tm . addRow ( ) , tunnel ) ) ; } } private void populateRow ( TableModel . Row row , Tunnel tunnel ) { row . cell ( ID , tunnel . tunnelId ( ) . id ( ) ) . cell ( NAME , tunnel . tunnelName ( ) . value ( ) ) . cell ( ONE , tunnel . src ( ) ) . cell ( TWO , tunnel . dst ( ) ) . cell ( TYPE , tunnel . type ( ) ) . cell ( GROUP_ID , tunnel . groupId ( ) . id ( ) ) . cell ( BANDWIDTH , tunnel . annotations ( ) . value ( BANDWIDTH ) ) . cell ( PATH , tunnel . path ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="AtwooTM/cassandra/tree/master/src/java/org/apache/cassandra/cql3/UTName.java"> /* STRNEWLINE ▁ * ▁ Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ ( ASF ) ▁ under ▁ one STRNEWLINE ▁ * ▁ or ▁ more ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file STRNEWLINE ▁ * ▁ distributed ▁ with ▁ this ▁ work ▁ for ▁ additional ▁ information STRNEWLINE ▁ * ▁ regarding ▁ copyright ▁ ownership . ▁ The ▁ ASF ▁ licenses ▁ this ▁ file STRNEWLINE ▁ * ▁ to ▁ you ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the STRNEWLINE ▁ * ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance STRNEWLINE ▁ * ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . apache . cassandra . cql3 ; import java . nio . ByteBuffer ; public class UTName { private String ksName ; private final ColumnIdentifier utName ; public UTName ( ColumnIdentifier ksName , ColumnIdentifier utName ) { this . ksName = ksName == null ? null : ksName . toString ( ) ; this . utName = utName ; } public boolean hasKeyspace ( ) { return ksName != null ; } public void setKeyspace ( String keyspace ) { this . ksName = keyspace ; } public String getKeyspace ( ) { return ksName ; } public ByteBuffer getUserTypeName ( ) { return utName . bytes ; } public String getStringTypeName ( ) { return utName . toString ( ) ; } @ Override public String toString ( ) { return ( hasKeyspace ( ) ? ( ksName + " . " ) : " " ) + utName ; } } </DOCUMENT>
<DOCUMENT_ID="bogeo/simsamples/tree/master/src/de/hsbo/geo/simsamples/applications/PubExample.java"> package de . hsbo . geo . simsamples . applications ; import de . hsbo . geo . simsamples . common . RandomValueGenerator ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . Customer ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . CustomerQueue ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . Server ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . ServerQueue ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . SimpleServerCustomerSimulator ; /* * STRNEWLINE ▁ * ▁ Simple ▁ system ▁ consisting ▁ of ▁ a ▁ single ▁ serving ▁ unit ▁ and ▁ multiple ▁ clients ▁ STRNEWLINE ▁ * ▁ processing ▁ discrete ▁ events . ▁ The ▁ concrete ▁ example ▁ simulates ▁ a ▁ bar ▁ situation STRNEWLINE ▁ * ▁ with ▁ three ▁ customers ▁ and ▁ a ▁ barmaid . ▁ A ▁ customer ▁ entity ▁ can ▁ take ▁ one ▁ of ▁ STRNEWLINE ▁ * ▁ the ▁ following ▁ states : ▁ WAITING , ▁ IN _ SERVICE , ▁ SATISFIED . ▁ For ▁ the ▁ serving ▁ STRNEWLINE ▁ * ▁ units ▁ there ▁ are ▁ the ▁ states ▁ FREE ▁ and ▁ BUSY . ▁ Typical ▁ events ▁ are ▁ requesting ▁ a ▁ STRNEWLINE ▁ * ▁ drink , ▁ finishing ▁ a ▁ service ▁ etc . ▁ The ▁ implementation ▁ uses ▁ the ▁ STRNEWLINE ▁ * ▁ { @ link ▁ SimpleServerCustomerSimulator } ▁ which ▁ operates ▁ on ▁ { @ link ▁ Server } ▁ STRNEWLINE ▁ * ▁ and ▁ { @ link ▁ Customer } ▁ entities . ▁ STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ author ▁ Benno ▁ Schmidt STRNEWLINE ▁ */ public class PubExample { public static void main ( String [ ] args ) throws Exception { new PubExample ( ) . run ( ) ; } private void run ( ) throws Exception { Drinker peter = new Drinker ( " Peter " , 15. /* average ▁ drinking ▁ time */ ) , paul = new Drinker ( " Paul " , 20. ) , harry = new Drinker ( " Harry " , 30. ) ; Barmaid elke = new Barmaid ( " Elke " , 2. /* average ▁ serving ▁ time */ ) ; CustomerQueue drinking = new CustomerQueue ( " . " ) ; // ▁ initially ▁ empty ENDCOM CustomerQueue thursty = new CustomerQueue ( " ? " ) ; thursty . enqueue ( peter , paul , harry ) ; ServerQueue tapping = new ServerQueue ( " X " ) ; // ▁ initially ▁ empty ENDCOM ServerQueue free = new ServerQueue ( " . " ) ; free . enqueue ( elke ) ; SimpleServerCustomerSimulator sim = new SimpleServerCustomerSimulator ( free , // ▁ " free ▁ servers " ENDCOM tapping , // ▁ " busy ▁ servers " ENDCOM thursty , // ▁ " waiting ▁ customers " ENDCOM drinking ) ; // ▁ " satisfied ▁ customers " ENDCOM sim . setConsoleDump ( false ) ; // ▁ Simulate ▁ M ▁ minutes : ENDCOM double M = 120. ; sim . execute ( M ) ; } protected class Drinker extends Customer { private double dt ; protected Drinker ( String name , double drinkingTime ) { super ( name ) ; this . dt = drinkingTime ; } @ Override public double getDuration ( ) { double var = RandomValueGenerator . number ( - 2. , + 2. , 0. , 1. ) ; // ▁ = ▁ normal - distributed ▁ variation ▁ ( mean ▁ 0 , ▁ standard ▁ deviation ▁ 1 ) ENDCOM return dt + var ; } } protected class Barmaid extends Server { private double dt ; protected Barmaid ( String name , double serviceTime ) { super ( name ) ; this . dt = serviceTime ; } public double getDuration ( ) { return dt + RandomValueGenerator . number ( - 1. , + 1. , 0. , 1. ) ; } } } </DOCUMENT>
<DOCUMENT_ID="lowiki-org/localwiki-backend-server/tree/master/sapling-daisydiff/src/java/org/eclipse/compare/rangedifferencer/DifferencesIterator.java"> /* * * * * STRNEWLINE ▁ * ▁ Copyright ▁ ( c ) ▁ 2000 , ▁ 2006 ▁ IBM ▁ Corporation ▁ and ▁ others . STRNEWLINE ▁ * ▁ All ▁ rights ▁ reserved . ▁ This ▁ program ▁ and ▁ the ▁ accompanying ▁ materials STRNEWLINE ▁ * ▁ are ▁ made ▁ available ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ Eclipse ▁ Public ▁ License ▁ v1.0 STRNEWLINE ▁ * ▁ which ▁ accompanies ▁ this ▁ distribution , ▁ and ▁ is ▁ available ▁ at STRNEWLINE ▁ * ▁ http : // www . eclipse . org / legal / epl - v10 . html STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Contributors : STRNEWLINE ▁ * ▁ IBM ▁ Corporation ▁ - ▁ initial ▁ API ▁ and ▁ implementation STRNEWLINE ▁ * * * * */ package org . eclipse . compare . rangedifferencer ; import java . util . ArrayList ; import java . util . List ; /* * STRNEWLINE ▁ * ▁ A ▁ custom ▁ iterator ▁ to ▁ iterate ▁ over ▁ a ▁ List ▁ of ▁ < code > RangeDifferences < / code > . ▁ It STRNEWLINE ▁ * ▁ is ▁ used ▁ internally ▁ by ▁ the ▁ < code > RangeDifferencer < / code > . STRNEWLINE ▁ */ /* ▁ package ▁ */ class DifferencesIterator { List fRange ; int fIndex ; RangeDifference [ ] fArray ; RangeDifference fDifference ; /* STRNEWLINE TABSYMBOL ▁ * ▁ Creates ▁ a ▁ differences ▁ iterator ▁ on ▁ an ▁ array ▁ of STRNEWLINE TABSYMBOL ▁ * ▁ < code > RangeDifference < / code > s . STRNEWLINE TABSYMBOL ▁ */ DifferencesIterator ( RangeDifference [ ] differenceRanges ) { fArray = differenceRanges ; fIndex = 0 ; fRange = new ArrayList ( ) ; if ( fIndex < fArray . length ) fDifference = fArray [ fIndex ++ ] ; else fDifference = null ; } /* STRNEWLINE TABSYMBOL ▁ * ▁ Returns ▁ the ▁ number ▁ of ▁ RangeDifferences STRNEWLINE TABSYMBOL ▁ */ int getCount ( ) { return fRange . size ( ) ; } /* STRNEWLINE TABSYMBOL ▁ * ▁ Appends ▁ the ▁ edit ▁ to ▁ its ▁ list ▁ and ▁ moves ▁ to ▁ the ▁ next STRNEWLINE TABSYMBOL ▁ * ▁ < code > RangeDifference < / code > . STRNEWLINE TABSYMBOL ▁ */ void next ( ) { fRange . add ( fDifference ) ; if ( fDifference != null ) { if ( fIndex < fArray . length ) fDifference = fArray [ fIndex ++ ] ; else fDifference = null ; } } /* STRNEWLINE TABSYMBOL ▁ * ▁ Difference ▁ iterators ▁ are ▁ used ▁ in ▁ pairs . ▁ This ▁ method ▁ returns ▁ the ▁ other STRNEWLINE TABSYMBOL ▁ * ▁ iterator . STRNEWLINE TABSYMBOL ▁ */ DifferencesIterator other ( DifferencesIterator right , DifferencesIterator left ) { if ( this == right ) return left ; return right ; } /* STRNEWLINE TABSYMBOL ▁ * ▁ Removes ▁ all ▁ < code > RangeDifference < / code > s STRNEWLINE TABSYMBOL ▁ */ void removeAll ( ) { fRange . clear ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="iliat/gatk-tools-java/tree/master/src/main/java/com/google/cloud/genomics/gatk/common/GenomicsConverterBase.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2014 ▁ Google ▁ Inc . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ▁ you ▁ may ▁ not STRNEWLINE ▁ * ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of STRNEWLINE ▁ * ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT STRNEWLINE ▁ * ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ▁ See ▁ the STRNEWLINE ▁ * ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations ▁ under STRNEWLINE ▁ * ▁ the ▁ License . STRNEWLINE ▁ */ // ▁ This ▁ file ▁ differs ▁ from ▁ GenomicsConverter ▁ in ▁ the ▁ utils - java ▁ package ▁ ENDCOM // ▁ ( ▁ com . google . cloud . genomics . utils ) ▁ and ▁ it ▁ depends ▁ on ▁ HTSJDK ▁ 1.118 . ENDCOM // ▁ utils - java ▁ can ▁ not ▁ yet ▁ be ▁ moved ▁ to ▁ depend ▁ on ▁ HTSJDK ▁ due ▁ to ▁ pending ENDCOM // ▁ work ▁ ( https : // github . com / samtools / htsjdk / pull / 55 ) . ENDCOM // ▁ Once ▁ this ▁ completes ▁ and ▁ utils - java ▁ is ▁ updated ▁ this ▁ file ▁ can ▁ be ▁ removed . ▁ ENDCOM package com . google . cloud . genomics . gatk . common ; import htsjdk . samtools . SAMFileHeader ; import htsjdk . samtools . SAMRecord ; import java . util . List ; /* * STRNEWLINE ▁ * ▁ Base ▁ class ▁ for ▁ conversion . STRNEWLINE ▁ * ▁ Concrete ▁ classes ▁ utilize ▁ ReadUtils ▁ from ▁ genomics - utils ▁ package STRNEWLINE ▁ * ▁ to ▁ do ▁ the ▁ actual ▁ work ▁ and ▁ provides ▁ a ▁ thin ▁ wrapper ▁ on ▁ top ▁ of ▁ that STRNEWLINE ▁ * ▁ to ▁ deal ▁ with ▁ REST ▁ vs . ▁ GRPC ▁ implementations . STRNEWLINE ▁ */ public abstract class GenomicsConverterBase < Read , ReadGroupSet , Reference > implements GenomicsConverter < Read , ReadGroupSet , Reference > { @ Override public SAMRecord makeSAMRecord ( Read read , ReadGroupSet readGroupSet , List < Reference > references , boolean forceSetMatePositionToThisPosition ) { return makeSAMRecord ( read , makeSAMFileHeader ( readGroupSet , references ) ) ; } @ Override public SAMRecord makeSAMRecord ( Read read , boolean forceSetMatePositionToThisPosition ) { return makeSAMRecord ( read , new SAMFileHeader ( ) ) ; } @ Override public abstract SAMFileHeader makeSAMFileHeader ( ReadGroupSet readGroupSet , List < Reference > references ) ; @ Override public abstract SAMRecord makeSAMRecord ( Read read , SAMFileHeader header ) ; } </DOCUMENT>
<DOCUMENT_ID="didoupimpon/CC152/tree/master/src/main/java/net/minecraft/server/ItemReed.java"> package net . minecraft . server ; // ▁ CraftBukkit ▁ start ENDCOM import org . bukkit . block . BlockState ; import org . bukkit . craftbukkit . block . CraftBlockState ; import org . bukkit . craftbukkit . event . CraftEventFactory ; import org . bukkit . event . block . BlockPlaceEvent ; // ▁ CraftBukkit ▁ end ENDCOM public class ItemReed extends Item { private int id ; public ItemReed ( int i , Block block ) { super ( i ) ; this . id = block . id ; } public boolean a ( ItemStack itemstack , EntityHuman entityhuman , World world , int i , int j , int k , int l ) { int clickedX = i , clickedY = j , clickedZ = k ; // ▁ CraftBukkit ENDCOM if ( world . getTypeId ( i , j , k ) == Block . SNOW . id ) { l = 0 ; } else { if ( l == 0 ) { -- j ; } if ( l == 1 ) { ++ j ; } if ( l == 2 ) { -- k ; } if ( l == 3 ) { ++ k ; } if ( l == 4 ) { -- i ; } if ( l == 5 ) { ++ i ; } } if ( itemstack . count == 0 ) { return false ; } else { if ( world . a ( this . id , i , j , k , false ) ) { Block block = Block . byId [ this . id ] ; // ▁ CraftBukkit ▁ start ▁ - ▁ This ▁ executes ▁ the ▁ placement ▁ of ▁ the ▁ block ENDCOM BlockState replacedBlockState = CraftBlockState . getBlockState ( world , i , j , k ) ; // ▁ CraftBukkit ENDCOM /* * STRNEWLINE ▁ * ▁ @ see ▁ net . minecraft . server . World # setTypeId ( int ▁ i , ▁ int ▁ j , ▁ int ▁ k , ▁ int ▁ l ) STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ replaces ▁ world . setTypeId ( IIII ) , ▁ we ' re ▁ doing ▁ this ▁ because ▁ we ▁ need ▁ to STRNEWLINE ▁ * ▁ hook ▁ between ▁ the ▁ ' placement ' ▁ and ▁ the ▁ informing ▁ to ▁ ' world ' ▁ so ▁ we ▁ can STRNEWLINE ▁ * ▁ sanely ▁ undo ▁ this . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Whenever ▁ the ▁ call ▁ to ▁ ' world . setTypeId ' ▁ changes ▁ we ▁ need ▁ to ▁ figure ▁ out ▁ again ▁ what ▁ to STRNEWLINE ▁ * ▁ replace ▁ this ▁ with . STRNEWLINE ▁ */ if ( world . setRawTypeId ( i , j , k , this . id ) ) { // ▁ < - - ▁ world . e ▁ does ▁ this ▁ to ▁ place ▁ the ▁ block ENDCOM BlockPlaceEvent event = CraftEventFactory . callBlockPlaceEvent ( world , entityhuman , replacedBlockState , clickedX , clickedY , clickedZ , block ) ; if ( event . isCancelled ( ) || ! event . canBuild ( ) ) { // ▁ CraftBukkit ▁ - ▁ undo ; ▁ this ▁ only ▁ has ▁ reed , ▁ repeater ▁ and ▁ pie ▁ blocks ENDCOM world . setTypeIdAndData ( i , j , k , replacedBlockState . getTypeId ( ) , replacedBlockState . getRawData ( ) ) ; } else { world . update ( i , j , k , this . id ) ; // ▁ < - - ▁ world . setTypeId ▁ does ▁ this ▁ on ▁ success ▁ ( tell ▁ the ▁ world ) ENDCOM Block . byId [ this . id ] . postPlace ( world , i , j , k , l ) ; Block . byId [ this . id ] . postPlace ( world , i , j , k , entityhuman ) ; world . makeSound ( ( double ) ( ( float ) i + 0.5F ) , ( double ) ( ( float ) j + 0.5F ) , ( double ) ( ( float ) k + 0.5F ) , block . stepSound . getName ( ) , ( block . stepSound . getVolume1 ( ) + 1.0F ) / 2.0F , block . stepSound . getVolume2 ( ) * 0.8F ) ; -- itemstack . count ; } // ▁ CraftBukkit ▁ end ENDCOM } } return true ; } } } </DOCUMENT>
<DOCUMENT_ID="slburson/fast-serialization/tree/master/src/main/java/org/nustaq/serialization/serializers/FSTCPEnumSetSerializer.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ 2014 ▁ Ruediger ▁ Moeller . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . nustaq . serialization . serializers ; import org . nustaq . serialization . FSTBasicObjectSerializer ; import org . nustaq . serialization . FSTClazzInfo ; import org . nustaq . serialization . FSTObjectInput ; import org . nustaq . serialization . FSTObjectOutput ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . EnumSet ; /* * STRNEWLINE ▁ * ▁ Created ▁ with ▁ IntelliJ ▁ IDEA . STRNEWLINE ▁ * ▁ User : ▁ ruedi STRNEWLINE ▁ * ▁ Date : ▁ 11.11.12 STRNEWLINE ▁ * ▁ Time : ▁ 04:09 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ EnumSet ▁ Serializer ▁ for ▁ Cross ▁ Platform ▁ serialization . ▁ Writes ▁ full ▁ Strings ▁ instead ▁ of ▁ ordinals STRNEWLINE ▁ * STRNEWLINE ▁ */ public class FSTCPEnumSetSerializer extends FSTBasicObjectSerializer { Field elemType ; @ Override public void writeObject ( FSTObjectOutput out , Object toWrite , FSTClazzInfo clzInfo , FSTClazzInfo . FSTFieldInfo referencedBy , int streamPosition ) throws IOException { EnumSet enset = ( EnumSet ) toWrite ; int count = 0 ; out . writeInt ( enset . size ( ) ) ; if ( enset . isEmpty ( ) ) { // WTF ▁ only ▁ way ▁ to ▁ determine ▁ enumtype ▁ . . ENDCOM EnumSet compl = EnumSet . complementOf ( enset ) ; out . writeClassTag ( compl . iterator ( ) . next ( ) . getClass ( ) ) ; } else { for ( Object element : enset ) { if ( count == 0 ) { out . writeStringUTF ( element . getClass ( ) . getName ( ) ) ; } out . writeStringUTF ( element . toString ( ) ) ; count ++ ; } } } /* * STRNEWLINE ▁ * ▁ @ return ▁ true ▁ if ▁ FST ▁ can ▁ skip ▁ a ▁ search ▁ for ▁ same ▁ instances ▁ in ▁ the ▁ serialized ▁ ObjectGraph . ▁ This ▁ speeds ▁ up ▁ reading ▁ and ▁ writing ▁ and ▁ makes STRNEWLINE ▁ * ▁ sense ▁ for ▁ short ▁ immutable ▁ such ▁ as ▁ Integer , ▁ Short , ▁ Character , ▁ Date , ▁ . . ▁ . ▁ For ▁ those ▁ classes ▁ it ▁ is ▁ more ▁ expensive ▁ ( CPU , ▁ size ) ▁ to ▁ do ▁ a ▁ lookup ▁ than ▁ to ▁ just STRNEWLINE ▁ * ▁ write ▁ the ▁ Object ▁ twice ▁ in ▁ case . STRNEWLINE ▁ */ @ Override public boolean alwaysCopy ( ) { return false ; } @ Override public Object instantiate ( Class objectClass , FSTObjectInput in , FSTClazzInfo serializationInfo , FSTClazzInfo . FSTFieldInfo referencee , int streamPosition ) throws Exception { int len = in . readInt ( ) ; Class elemCl = in . getClassForName ( in . readStringUTF ( ) ) ; EnumSet enSet = EnumSet . noneOf ( elemCl ) ; in . registerObject ( enSet , streamPosition , serializationInfo , referencee ) ; // ▁ IMPORTANT , ▁ else ▁ tracking ▁ double ▁ objects ▁ will ▁ fail ENDCOM for ( int i = 0 ; i < len ; i ++ ) { String val = in . readStringUTF ( ) ; enSet . add ( Enum . valueOf ( elemCl , val ) ) ; } return enSet ; } } </DOCUMENT>
<DOCUMENT_ID="esi-mineset/spark/tree/master/sql/core/src/test/java/test/org/apache/spark/sql/JavaStringLength.java"> /* STRNEWLINE ▁ * ▁ Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ ( ASF ) ▁ under ▁ one ▁ or ▁ more STRNEWLINE ▁ * ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file ▁ distributed ▁ with STRNEWLINE ▁ * ▁ this ▁ work ▁ for ▁ additional ▁ information ▁ regarding ▁ copyright ▁ ownership . STRNEWLINE ▁ * ▁ The ▁ ASF ▁ licenses ▁ this ▁ file ▁ to ▁ You ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 STRNEWLINE ▁ * ▁ ( the ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with STRNEWLINE ▁ * ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package test . org . apache . spark . sql ; import org . apache . spark . sql . api . java . UDF1 ; /* * STRNEWLINE ▁ * ▁ It ▁ is ▁ used ▁ for ▁ register ▁ Java ▁ UDF ▁ from ▁ PySpark STRNEWLINE ▁ */ public class JavaStringLength implements UDF1 < String , Integer > { @ Override public Integer call ( String str ) throws Exception { return new Integer ( str . length ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="borcsokj/camel/tree/master/components/camel-apns/src/test/java/org/apache/camel/component/apns/ApnsProducerTest.java"> /* * STRNEWLINE ▁ * ▁ Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ ( ASF ) ▁ under ▁ one ▁ or ▁ more STRNEWLINE ▁ * ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file ▁ distributed ▁ with STRNEWLINE ▁ * ▁ this ▁ work ▁ for ▁ additional ▁ information ▁ regarding ▁ copyright ▁ ownership . STRNEWLINE ▁ * ▁ The ▁ ASF ▁ licenses ▁ this ▁ file ▁ to ▁ You ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 STRNEWLINE ▁ * ▁ ( the ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with STRNEWLINE ▁ * ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . apache . camel . component . apns ; import com . notnoop . apns . APNS ; import com . notnoop . apns . ApnsService ; import com . notnoop . apns . EnhancedApnsNotification ; import com . notnoop . apns . utils . ApnsServerStub ; import org . apache . camel . CamelContext ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . component . apns . factory . ApnsServiceFactory ; import org . apache . camel . component . apns . model . ApnsConstants ; import org . apache . camel . component . apns . model . MessageType ; import org . apache . camel . component . apns . util . ApnsUtils ; import org . apache . camel . component . apns . util . TestConstants ; import org . apache . camel . test . junit4 . CamelTestSupport ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; /* * STRNEWLINE ▁ * ▁ Unit ▁ test ▁ that ▁ we ▁ can ▁ produce ▁ JMS ▁ message ▁ from ▁ files STRNEWLINE ▁ */ public class ApnsProducerTest extends CamelTestSupport { private static final String FAKE_TOKEN = "19308314834701ACD8313AEBD92AEFDE192120371FE13982392831701318B943" ; private ApnsServerStub server ; @ Before public void startup ( ) { server = ApnsUtils . prepareAndStartServer ( TestConstants . TEST_GATEWAY_PORT , TestConstants . TEST_FEEDBACK_PORT ) ; } @ After public void stop ( ) { server . stop ( ) ; } @ Test ( timeout = 5000 ) public void testProducer ( ) throws Exception { String message = " Hello ▁ World " ; String messagePayload = APNS . newPayload ( ) . alertBody ( message ) . build ( ) ; EnhancedApnsNotification apnsNotification = new EnhancedApnsNotification ( 1 , EnhancedApnsNotification . MAXIMUM_EXPIRY , FAKE_TOKEN , messagePayload ) ; server . stopAt ( apnsNotification . length ( ) ) ; template . sendBody ( " direct : test " , message ) ; server . getMessages ( ) . acquire ( ) ; assertArrayEquals ( apnsNotification . marshall ( ) , server . getReceived ( ) . toByteArray ( ) ) ; } @ Test ( timeout = 5000 ) public void testProducerWithApnsNotification ( ) throws InterruptedException { String message = " Hello ▁ World " ; String messagePayload = APNS . newPayload ( ) . alertBody ( message ) . build ( ) ; final EnhancedApnsNotification apnsNotification = new EnhancedApnsNotification ( 14 , EnhancedApnsNotification . MAXIMUM_EXPIRY , FAKE_TOKEN , messagePayload ) ; server . stopAt ( apnsNotification . length ( ) ) ; template . sendBody ( " direct : testWithApnsNotification " , apnsNotification ) ; server . getMessages ( ) . acquire ( ) ; assertArrayEquals ( apnsNotification . marshall ( ) , server . getReceived ( ) . toByteArray ( ) ) ; } protected CamelContext createCamelContext ( ) throws Exception { CamelContext camelContext = super . createCamelContext ( ) ; ApnsServiceFactory apnsServiceFactory = ApnsUtils . createDefaultTestConfiguration ( camelContext ) ; ApnsService apnsService = apnsServiceFactory . getApnsService ( ) ; ApnsComponent apnsComponent = new ApnsComponent ( apnsService ) ; camelContext . addComponent ( " apns " , apnsComponent ) ; return camelContext ; } protected RouteBuilder createRouteBuilder ( ) throws Exception { return new RouteBuilder ( ) { public void configure ( ) throws Exception { from ( " direct : test " ) . setHeader ( ApnsConstants . HEADER_TOKENS , constant ( FAKE_TOKEN ) ) . to ( " apns : notify " ) ; from ( " direct : testWithApnsNotification " ) . setHeader ( ApnsConstants . HEADER_MESSAGE_TYPE , constant ( MessageType . APNS_NOTIFICATION . name ( ) ) ) . to ( " apns : notify " ) ; } } ; } } </DOCUMENT>
<DOCUMENT_ID="elastic-grid/Elastic-Grid/tree/master/modules/replicated-storage/src/main/java/com/elasticgrid/storage/replicated/ReplicatedContainer.java"> /* *  STRNEWLINE ▁ * ▁ Elastic ▁ Grid STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2008-2010 ▁ Elastic ▁ Grid , ▁ LLC .  STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ▁ as STRNEWLINE ▁ * ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the STRNEWLINE ▁ * ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version .  STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful ,  STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details .  STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > .  STRNEWLINE ▁ */ package com . elasticgrid . storage . replicated ; import com . elasticgrid . storage . Container ; import com . elasticgrid . storage . Storable ; import com . elasticgrid . storage . StorageException ; import com . elasticgrid . storage . StorableNotFoundException ; import java . util . Arrays ; import java . util . List ; import java . util . logging . Logger ; import java . io . File ; import java . io . InputStream ; /* *  STRNEWLINE ▁ * ▁ Replicated ▁ { @ link ▁ Container } ▁ ensuring ▁ that ▁ many ▁ { @ link ▁ Container } s ▁ are ▁ kept ▁ in ▁ sync ▁ each ▁ time STRNEWLINE ▁ * ▁ a ▁ write ▁ operation ▁ is ▁ done . ▁ All ▁ read ▁ operations ▁ are ▁ done ▁ against ▁ a ▁ preferred ▁ { @ link ▁ Container }  STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ @ author ▁ Jerome ▁ Bernard STRNEWLINE ▁ */ public class ReplicatedContainer implements Container { private final Container preferred ; private final List < Container > otherContainers ; private static final Logger logger = Logger . getLogger ( ReplicatedContainer . class . getName ( ) ) ; public ReplicatedContainer ( Container preferred , List < Container > otherContainers ) { this . preferred = preferred ; this . otherContainers = otherContainers ; } public String getName ( ) { return null ; // To ▁ change ▁ body ▁ of ▁ implemented ▁ methods ▁ use ▁ File ▁ | ▁ Settings ▁ | ▁ File ▁ Templates .  ENDCOM } public List < Storable > listStorables ( ) throws StorageException { return null ; // To ▁ change ▁ body ▁ of ▁ implemented ▁ methods ▁ use ▁ File ▁ | ▁ Settings ▁ | ▁ File ▁ Templates .  ENDCOM } public Storable findStorableByName ( String name ) throws StorableNotFoundException , StorageException { return null ; // To ▁ change ▁ body ▁ of ▁ implemented ▁ methods ▁ use ▁ File ▁ | ▁ Settings ▁ | ▁ File ▁ Templates .  ENDCOM } public Storable uploadStorable ( File file ) throws StorageException { return null ; // To ▁ change ▁ body ▁ of ▁ implemented ▁ methods ▁ use ▁ File ▁ | ▁ Settings ▁ | ▁ File ▁ Templates .  ENDCOM } public Storable uploadStorable ( String name , File file ) throws StorageException { return null ; // To ▁ change ▁ body ▁ of ▁ implemented ▁ methods ▁ use ▁ File ▁ | ▁ Settings ▁ | ▁ File ▁ Templates .  ENDCOM } public Storable uploadStorable ( String name , InputStream stream , String mimeType ) throws StorageException { return null ; // To ▁ change ▁ body ▁ of ▁ implemented ▁ methods ▁ use ▁ File ▁ | ▁ Settings ▁ | ▁ File ▁ Templates .  ENDCOM } public void deleteStorable ( String name ) throws StorageException { // To ▁ change ▁ body ▁ of ▁ implemented ▁ methods ▁ use ▁ File ▁ | ▁ Settings ▁ | ▁ File ▁ Templates .  ENDCOM } } </DOCUMENT>
<DOCUMENT_ID="medsob/Tanaguru/tree/master/web-app/tgol-web-app/src/main/java/org/tanaguru/webapp/command/helper/UploadAuditSetUpCommandHelper.java"> /* STRNEWLINE ▁ * ▁ Tanaguru ▁ - ▁ Automated ▁ webpage ▁ assessment STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2008-2015 ▁ Tanaguru . org STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Tanaguru . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Tanaguru ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ▁ as STRNEWLINE ▁ * ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the STRNEWLINE ▁ * ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Contact ▁ us ▁ by ▁ mail : ▁ tanaguru ▁ AT ▁ tanaguru ▁ DOT ▁ org STRNEWLINE ▁ */ package org . tanaguru . webapp . command . helper ; import java . io . IOException ; import java . util . HashMap ; import java . util . LinkedHashMap ; import java . util . Map ; import org . tanaguru . crawler . util . CrawlUtils ; import org . springframework . web . multipart . commons . CommonsMultipartFile ; /* * STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ author ▁ jkowalczyk STRNEWLINE ▁ */ public final class UploadAuditSetUpCommandHelper { /* * STRNEWLINE ▁ * ▁ Local ▁ Map ▁ to ▁ deal ▁ with ▁ uploaded ▁ files ▁ with ▁ the ▁ same ▁ name STRNEWLINE ▁ */ private static Map < String , Integer > fileNameCounterMap = new HashMap < String , Integer > ( ) ; /* * STRNEWLINE ▁ * ▁ This ▁ method ▁ converts ▁ the ▁ uploaded ▁ files ▁ into ▁ a ▁ map ▁ where ▁ the ▁ key ▁ is ▁ the STRNEWLINE ▁ * ▁ file ▁ name ▁ and ▁ the ▁ value ▁ is ▁ the ▁ file ▁ content . STRNEWLINE ▁ */ public synchronized static Map < String , String > convertFilesToMap ( CommonsMultipartFile [ ] fileInputList ) { Map < String , String > fileMap = new LinkedHashMap < String , String > ( ) ; CommonsMultipartFile tmpMultiFile ; String tmpCharset ; fileNameCounterMap . clear ( ) ; for ( int i = 0 ; i < fileInputList . length ; i ++ ) { tmpMultiFile = fileInputList [ i ] ; try { if ( tmpMultiFile != null && ! tmpMultiFile . isEmpty ( ) && tmpMultiFile . getInputStream ( ) != null ) { tmpCharset = CrawlUtils . extractCharset ( tmpMultiFile . getInputStream ( ) ) ; fileMap . put ( getFileName ( tmpMultiFile . getOriginalFilename ( ) ) , tmpMultiFile . getFileItem ( ) . getString ( tmpCharset ) ) ; } } catch ( IOException e ) { } } return fileMap ; } /* * STRNEWLINE ▁ * ▁ This ▁ method ▁ formats ▁ the ▁ file ▁ name ▁ of ▁ the ▁ uploaded ▁ file ▁ ( prefix ▁ by ▁ " / " ) STRNEWLINE ▁ * ▁ and ▁ suffix ▁ files ▁ with ▁ the ▁ same ▁ name ▁ with ▁ an ▁ index . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ originalFileName STRNEWLINE ▁ * ▁ @ return STRNEWLINE ▁ */ private static String getFileName ( String originalFileName ) { StringBuilder fileName = new StringBuilder ( ) ; fileName . append ( ' / ' ) ; if ( fileNameCounterMap . containsKey ( originalFileName ) ) { fileNameCounterMap . put ( originalFileName , Integer . valueOf ( fileNameCounterMap . get ( originalFileName ) + 1 ) ) ; fileName . append ( originalFileName ) ; fileName . append ( ' _ ' ) ; fileName . append ( fileNameCounterMap . get ( originalFileName ) ) ; return fileName . toString ( ) ; } else { fileNameCounterMap . put ( originalFileName , Integer . valueOf ( 1 ) ) ; fileName . append ( originalFileName ) ; return fileName . toString ( ) ; } } } </DOCUMENT>
<DOCUMENT_ID="iamjakob/elasticsearch/tree/master/core/src/test/java/org/elasticsearch/benchmark/search/aggregations/GlobalOrdinalsBenchmark.java"> /* STRNEWLINE ▁ * ▁ Licensed ▁ to ▁ Elasticsearch ▁ under ▁ one ▁ or ▁ more ▁ contributor STRNEWLINE ▁ * ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file ▁ distributed ▁ with STRNEWLINE ▁ * ▁ this ▁ work ▁ for ▁ additional ▁ information ▁ regarding ▁ copyright STRNEWLINE ▁ * ▁ ownership . ▁ Elasticsearch ▁ licenses ▁ this ▁ file ▁ to ▁ you ▁ under STRNEWLINE ▁ * ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ▁ you ▁ may STRNEWLINE ▁ * ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , STRNEWLINE ▁ * ▁ software ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an STRNEWLINE ▁ * ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY STRNEWLINE ▁ * ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ▁ See ▁ the ▁ License ▁ for ▁ the STRNEWLINE ▁ * ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations STRNEWLINE ▁ * ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . elasticsearch . benchmark . search . aggregations ; import com . carrotsearch . hppc . IntIntHashMap ; import com . carrotsearch . hppc . ObjectHashSet ; import com . carrotsearch . randomizedtesting . generators . RandomStrings ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . action . admin . cluster . stats . ClusterStatsResponse ; import org . elasticsearch . action . bulk . BulkRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . benchmark . search . aggregations . TermsAggregationSearchBenchmark . StatsResult ; import org . elasticsearch . bootstrap . BootstrapForTesting ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . SizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . discovery . Discovery ; import org . elasticsearch . indices . IndexAlreadyExistsException ; import org . elasticsearch . node . Node ; import org . elasticsearch . search . aggregations . AggregationBuilders ; import org . elasticsearch . transport . TransportModule ; import java . util . * ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . node . NodeBuilder . nodeBuilder ; public class GlobalOrdinalsBenchmark { private static final String INDEX_NAME = " index " ; private static final String TYPE_NAME = " type " ; private static final int QUERY_WARMUP = 25 ; private static final int QUERY_COUNT = 100 ; private static final int FIELD_START = 1 ; private static final int FIELD_LIMIT = 1 << 22 ; private static final boolean USE_DOC_VALUES = false ; static long COUNT = SizeValue . parseSizeValue ( "5m " ) . singles ( ) ; static Node node ; static Client client ; public static void main ( String [ ] args ) throws Exception { System . setProperty ( " es . logger . prefix " , " " ) ; BootstrapForTesting . ensureInitialized ( ) ; Random random = new Random ( ) ; Settings settings = settingsBuilder ( ) . put ( " index . refresh _ interval " , " - 1" ) . put ( SETTING_NUMBER_OF_SHARDS , 1 ) . put ( SETTING_NUMBER_OF_REPLICAS , 0 ) . put ( TransportModule . TRANSPORT_TYPE_KEY , " local " ) . build ( ) ; String clusterName = GlobalOrdinalsBenchmark . class . getSimpleName ( ) ; node = nodeBuilder ( ) . clusterName ( clusterName ) . settings ( settingsBuilder ( ) . put ( settings ) ) . node ( ) ; client = node . client ( ) ; try { client . admin ( ) . indices ( ) . prepareCreate ( INDEX_NAME ) . addMapping ( TYPE_NAME , jsonBuilder ( ) . startObject ( ) . startObject ( TYPE_NAME ) . startArray ( " dynamic _ templates " ) . startObject ( ) . startObject ( " default " ) . field ( " match " , " * " ) . field ( " match _ mapping _ type " , " string " ) . startObject ( " mapping " ) . field ( " type " , " string " ) . field ( " index " , " not _ analyzed " ) . startObject ( " fields " ) . startObject ( " doc _ values " ) . field ( " type " , " string " ) . field ( " index " , " no " ) . startObject ( " fielddata " ) . field ( " format " , " doc _ values " ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) ) . get ( ) ; ObjectHashSet < String > uniqueTerms = new ObjectHashSet < > ( ) ; for ( int i = 0 ; i < FIELD_LIMIT ; i ++ ) { boolean added ; do { added = uniqueTerms . add ( RandomStrings . randomAsciiOfLength ( random , 16 ) ) ; } while ( ! added ) ; } String [ ] sValues = uniqueTerms . toArray ( String . class ) ; uniqueTerms = null ; BulkRequestBuilder builder = client . prepareBulk ( ) ; IntIntHashMap tracker = new IntIntHashMap ( ) ; for ( int i = 0 ; i < COUNT ; i ++ ) { Map < String , Object > fieldValues = new HashMap < > ( ) ; for ( int fieldSuffix = 1 ; fieldSuffix <= FIELD_LIMIT ; fieldSuffix <<= 1 ) { int index = tracker . putOrAdd ( fieldSuffix , 0 , 0 ) ; if ( index >= fieldSuffix ) { index = random . nextInt ( fieldSuffix ) ; fieldValues . put ( " field _ " + fieldSuffix , sValues [ index ] ) ; } else { fieldValues . put ( " field _ " + fieldSuffix , sValues [ index ] ) ; tracker . put ( fieldSuffix , ++ index ) ; } } builder . add ( client . prepareIndex ( INDEX_NAME , TYPE_NAME , String . valueOf ( i ) ) . setSource ( fieldValues ) ) ; if ( builder . numberOfActions ( ) >= 1000 ) { builder . get ( ) ; builder = client . prepareBulk ( ) ; } } if ( builder . numberOfActions ( ) > 0 ) { builder . get ( ) ; } } catch ( IndexAlreadyExistsException e ) { System . out . println ( " - - > ▁ Index ▁ already ▁ exists , ▁ ignoring ▁ indexing ▁ phase , ▁ waiting ▁ for ▁ green " ) ; ClusterHealthResponse clusterHealthResponse = client . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForGreenStatus ( ) . setTimeout ( "10m " ) . execute ( ) . actionGet ( ) ; if ( clusterHealthResponse . isTimedOut ( ) ) { System . err . println ( " - - > ▁ Timed ▁ out ▁ waiting ▁ for ▁ cluster ▁ health " ) ; } } client . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . builder ( ) . put ( " logger . index . fielddata . ordinals " , " DEBUG " ) ) . get ( ) ; client . admin ( ) . indices ( ) . prepareRefresh ( INDEX_NAME ) . execute ( ) . actionGet ( ) ; COUNT = client . prepareCount ( INDEX_NAME ) . setQuery ( matchAllQuery ( ) ) . execute ( ) . actionGet ( ) . getCount ( ) ; System . out . println ( " - - > ▁ Number ▁ of ▁ docs ▁ in ▁ index : ▁ " + COUNT ) ; List < StatsResult > stats = new ArrayList < > ( ) ; for ( int fieldSuffix = FIELD_START ; fieldSuffix <= FIELD_LIMIT ; fieldSuffix <<= 1 ) { String fieldName = " field _ " + fieldSuffix ; String name = " global _ ordinals - " + fieldName ; if ( USE_DOC_VALUES ) { fieldName = fieldName + " . doc _ values " ; name = name + " _ doc _ values " ; // ▁ can ' t ▁ have ▁ . ▁ in ▁ agg ▁ name ENDCOM } stats . add ( terms ( name , fieldName , " global _ ordinals _ low _ cardinality " ) ) ; } for ( int fieldSuffix = FIELD_START ; fieldSuffix <= FIELD_LIMIT ; fieldSuffix <<= 1 ) { String fieldName = " field _ " + fieldSuffix ; String name = " ordinals - " + fieldName ; if ( USE_DOC_VALUES ) { fieldName = fieldName + " . doc _ values " ; name = name + " _ doc _ values " ; // ▁ can ' t ▁ have ▁ . ▁ in ▁ agg ▁ name ENDCOM } stats . add ( terms ( name , fieldName , " ordinals " ) ) ; } System . out . println ( " - - - - - - - - - - - - - - - - - - ▁ SUMMARY ▁ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " ) ; System . out . format ( Locale . ENGLISH , " % 30s % 10s % 10s % 15s \n " , " name " , " took " , " millis " , " fieldata ▁ size " ) ; for ( StatsResult stat : stats ) { System . out . format ( Locale . ENGLISH , " % 30s % 10s % 10d % 15s \n " , stat . name , TimeValue . timeValueMillis ( stat . took ) , ( stat . took / QUERY_COUNT ) , stat . fieldDataMemoryUsed ) ; } System . out . println ( " - - - - - - - - - - - - - - - - - - ▁ SUMMARY ▁ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " ) ; client . close ( ) ; node . close ( ) ; } private static StatsResult terms ( String name , String field , String executionHint ) { long totalQueryTime ; // ▁ LM ▁ VALUE ENDCOM client . admin ( ) . indices ( ) . prepareClearCache ( ) . setFieldDataCache ( true ) . execute ( ) . actionGet ( ) ; System . gc ( ) ; System . out . println ( " - - > ▁ Warmup ▁ ( " + name + " ) . . . " ) ; // ▁ run ▁ just ▁ the ▁ child ▁ query , ▁ warm ▁ up ▁ first ENDCOM for ( int j = 0 ; j < QUERY_WARMUP ; j ++ ) { SearchResponse searchResponse = client . prepareSearch ( INDEX_NAME ) . setSize ( 0 ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( AggregationBuilders . terms ( name ) . field ( field ) . executionHint ( executionHint ) ) . get ( ) ; if ( j == 0 ) { System . out . println ( " - - > ▁ Loading ▁ ( " + field + " ) : ▁ took : ▁ " + searchResponse . getTook ( ) ) ; } if ( searchResponse . getHits ( ) . totalHits ( ) != COUNT ) { System . err . println ( " - - > ▁ mismatch ▁ on ▁ hits " ) ; } } System . out . println ( " - - > ▁ Warmup ▁ ( " + name + " ) ▁ DONE " ) ; System . out . println ( " - - > ▁ Running ▁ ( " + name + " ) . . . " ) ; totalQueryTime = 0 ; for ( int j = 0 ; j < QUERY_COUNT ; j ++ ) { SearchResponse searchResponse = client . prepareSearch ( INDEX_NAME ) . setSize ( 0 ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( AggregationBuilders . terms ( name ) . field ( field ) . executionHint ( executionHint ) ) . get ( ) ; if ( searchResponse . getHits ( ) . totalHits ( ) != COUNT ) { System . err . println ( " - - > ▁ mismatch ▁ on ▁ hits " ) ; } totalQueryTime += searchResponse . getTookInMillis ( ) ; } System . out . println ( " - - > ▁ Terms ▁ Agg ▁ ( " + name + " ) : ▁ " + ( totalQueryTime / QUERY_COUNT ) + " ms " ) ; String nodeId = node . injector ( ) . getInstance ( Discovery . class ) . localNode ( ) . getId ( ) ; ClusterStatsResponse clusterStateResponse = client . admin ( ) . cluster ( ) . prepareClusterStats ( ) . setNodesIds ( nodeId ) . get ( ) ; System . out . println ( " - - > ▁ Heap ▁ used : ▁ " + clusterStateResponse . getNodesStats ( ) . getJvm ( ) . getHeapUsed ( ) ) ; ByteSizeValue fieldDataMemoryUsed = clusterStateResponse . getIndicesStats ( ) . getFieldData ( ) . getMemorySize ( ) ; System . out . println ( " - - > ▁ Fielddata ▁ memory ▁ size : ▁ " + fieldDataMemoryUsed ) ; return new StatsResult ( name , totalQueryTime , fieldDataMemoryUsed ) ; } } </DOCUMENT>
<DOCUMENT_ID="tharindum/opennms_dashboard/tree/master/opennms-webapp/src/main/java/org/opennms/web/report/database/ReportParametersValidator.java"> /* * * * * STRNEWLINE ▁ * ▁ This ▁ file ▁ is ▁ part ▁ of ▁ OpenNMS ( R ) . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2010-2011 ▁ The ▁ OpenNMS ▁ Group , ▁ Inc . STRNEWLINE ▁ * ▁ OpenNMS ( R ) ▁ is ▁ Copyright ▁ ( C ) ▁ 1999-2011 ▁ The ▁ OpenNMS ▁ Group , ▁ Inc . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ OpenNMS ( R ) ▁ is ▁ a ▁ registered ▁ trademark ▁ of ▁ The ▁ OpenNMS ▁ Group , ▁ Inc . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ OpenNMS ( R ) ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published STRNEWLINE ▁ * ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , STRNEWLINE ▁ * ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ OpenNMS ( R ) ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ OpenNMS ( R ) . ▁ If ▁ not , ▁ see : STRNEWLINE ▁ * ▁ http : // www . gnu . org / licenses / STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ For ▁ more ▁ information ▁ contact : STRNEWLINE ▁ * ▁ OpenNMS ( R ) ▁ Licensing ▁ < license @ opennms . org > STRNEWLINE ▁ * ▁ http : // www . opennms . org / STRNEWLINE ▁ * ▁ http : // www . opennms . com / STRNEWLINE ▁ * * * * */ package org . opennms . web . report . database ; import java . util . Iterator ; import java . util . List ; import org . opennms . api . reporting . parameter . ReportDoubleParm ; import org . opennms . api . reporting . parameter . ReportFloatParm ; import org . opennms . api . reporting . parameter . ReportParameters ; import org . opennms . api . reporting . parameter . ReportDateParm ; import org . opennms . api . reporting . parameter . ReportIntParm ; import org . opennms . api . reporting . parameter . ReportStringParm ; import org . springframework . binding . message . MessageBuilder ; import org . springframework . binding . message . MessageContext ; import org . springframework . binding . validation . ValidationContext ; /* * STRNEWLINE ▁ * ▁ < p > ReportParametersValidator ▁ class . < / p > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ author ▁ ranger STRNEWLINE ▁ * ▁ @ version ▁ $ Id : ▁ $ STRNEWLINE ▁ * ▁ @ since ▁ 1.8.1 STRNEWLINE ▁ */ public class ReportParametersValidator { /* * STRNEWLINE ▁ * ▁ < p > validateReportParameters < / p > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ reportCriteria ▁ a ▁ { @ link ▁ org . opennms . api . reporting . parameter . ReportParameters } ▁ object . STRNEWLINE ▁ * ▁ @ param ▁ context ▁ a ▁ { @ link ▁ org . springframework . binding . validation . ValidationContext } ▁ object . STRNEWLINE ▁ */ public void validateReportParameters ( ReportParameters reportCriteria , ValidationContext context ) { MessageContext messages = context . getMessageContext ( ) ; List < ReportDateParm > dateParms = reportCriteria . getDateParms ( ) ; for ( Iterator < ReportDateParm > dateParmIter = dateParms . iterator ( ) ; dateParmIter . hasNext ( ) ; ) { ReportDateParm dateParm = dateParmIter . next ( ) ; if ( dateParm . getDate ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " date ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ date ▁ field " + dateParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportStringParm > stringParms = reportCriteria . getStringParms ( ) ; for ( Iterator < ReportStringParm > stringParmIter = stringParms . iterator ( ) ; stringParmIter . hasNext ( ) ; ) { ReportStringParm stringParm = stringParmIter . next ( ) ; if ( stringParm . getValue ( ) == " " ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " string ▁ parms " ) . defaultText ( " cannot ▁ have ▁ empty ▁ string ▁ field " + stringParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportIntParm > intParms = reportCriteria . getIntParms ( ) ; for ( Iterator < ReportIntParm > intParmIter = intParms . iterator ( ) ; intParmIter . hasNext ( ) ; ) { ReportIntParm intParm = intParmIter . next ( ) ; // ▁ TODO ▁ add ▁ a ▁ more ▁ sensible ▁ check ▁ here ▁ - ▁ I ▁ think ▁ we ▁ probably ▁ can ▁ have ▁ zero ▁ int ▁ parm ENDCOM if ( intParm . getValue ( ) == 0 ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " int ▁ parms " ) . defaultText ( " cannot ▁ have ▁ zero ▁ integer ▁ field " + intParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportFloatParm > floatParms = reportCriteria . getFloatParms ( ) ; for ( Iterator < ReportFloatParm > floatParmIter = floatParms . iterator ( ) ; floatParmIter . hasNext ( ) ; ) { ReportFloatParm floatParm = floatParmIter . next ( ) ; if ( floatParm . getValue ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " float ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ float ▁ field " + floatParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportDoubleParm > doubleParms = reportCriteria . getDoubleParms ( ) ; for ( Iterator < ReportDoubleParm > doubleParmIter = doubleParms . iterator ( ) ; doubleParmIter . hasNext ( ) ; ) { ReportDoubleParm doubleParm = doubleParmIter . next ( ) ; if ( doubleParm . getValue ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " double ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ double ▁ field " + doubleParm . getDisplayName ( ) ) . build ( ) ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="huangbop/takeout/tree/master/app/src/main/java/com/huangbop/takeout/IndexActivity.java"> package com . huangbop . takeout ; import android . app . Activity ; import android . app . AlertDialog ; import android . content . DialogInterface ; import android . content . Intent ; import android . os . Bundle ; import android . view . KeyEvent ; import android . view . View ; import android . widget . Button ; import android . widget . Toast ; /* * STRNEWLINE ▁ * ▁ Created ▁ by ▁ Administrator ▁ on ▁ 2015/3/2 . STRNEWLINE ▁ */ public class IndexActivity extends Activity { private Button btnIndex0 ; private Button btnIndex1 ; private Button btnIndex2 ; private ButtonListener listener ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_index ) ; listener = new ButtonListener ( ) ; findButtons ( ) ; setClickListener ( ) ; } private long exitTime = 0 ; @ Override public boolean onKeyDown ( int keyCode , KeyEvent event ) { // ▁ if ▁ ( keyCode ▁ = = ▁ KeyEvent . KEYCODE _ BACK ) ▁ { ENDCOM // ▁ AlertDialog . Builder ▁ builder ▁ = ▁ new ▁ AlertDialog . Builder ( this ) ; ENDCOM // ▁ builder . setTitle ( " Exit " ) ; ENDCOM // ▁ builder . setMessage ( " Are ▁ you ▁ sure ▁ to ▁ exit ? " ) ; ENDCOM // ▁ builder . setPositiveButton ( " OK " , ▁ new ▁ DialogInterface . OnClickListener ( ) ▁ { ENDCOM // ▁ @ Override ENDCOM // ▁ public ▁ void ▁ onClick ( DialogInterface ▁ dialog , ▁ int ▁ which ) ▁ { ENDCOM // ▁ finish ( ) ; ENDCOM // ▁ builder . setNegativeButton ( " Cancel " , ▁ new ▁ DialogInterface . OnClickListener ( ) ▁ { ENDCOM // ▁ @ Override ENDCOM // ▁ public ▁ void ▁ onClick ( DialogInterface ▁ dialog , ▁ int ▁ which ) ▁ { ENDCOM // ▁ return ; ENDCOM // ▁ builder . show ( ) ; ENDCOM if ( keyCode == KeyEvent . KEYCODE_BACK && event . getAction ( ) == KeyEvent . ACTION_DOWN ) { if ( ( System . currentTimeMillis ( ) - exitTime ) > 2000 ) { Toast . makeText ( this , " Press ▁ again ▁ to ▁ exit . " , Toast . LENGTH_SHORT ) . show ( ) ; exitTime = System . currentTimeMillis ( ) ; } else { finish ( ) ; System . exit ( 0 ) ; } return true ; } return super . onKeyDown ( keyCode , event ) ; } private void setClickListener ( ) { btnIndex0 . setOnClickListener ( listener ) ; btnIndex1 . setOnClickListener ( listener ) ; btnIndex2 . setOnClickListener ( listener ) ; } private void findButtons ( ) { btnIndex0 = ( Button ) findViewById ( R . id . btnIndex0 ) ; btnIndex1 = ( Button ) findViewById ( R . id . btnIndex1 ) ; btnIndex2 = ( Button ) findViewById ( R . id . btnIndex2 ) ; } private class ButtonListener implements View . OnClickListener { @ Override public void onClick ( View v ) { switch ( v . getId ( ) ) { case R . id . btnIndex0 : Intent intent0 = new Intent ( IndexActivity . this , MainActivity . class ) ; startActivity ( intent0 ) ; break ; case R . id . btnIndex1 : Intent intent1 = new Intent ( IndexActivity . this , SecondActivity . class ) ; startActivity ( intent1 ) ; break ; case R . id . btnIndex2 : Intent intent2 = new Intent ( IndexActivity . this , LifeCycle . class ) ; startActivity ( intent2 ) ; break ; } } } } </DOCUMENT>
<DOCUMENT_ID="moosbusch/xbLIDO/tree/master/src/net/opengis/gml/GridCoverageDocument.java"> /* ▁  STRNEWLINE ▁ * ▁ Copyright ▁ 2013 ▁ Gunnar ▁ Kappei .  STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ;  STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License .  STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS ,  STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied .  STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License .  STRNEWLINE ▁ */ package net . opengis . gml ; /* * STRNEWLINE ▁ * ▁ A ▁ document ▁ containing ▁ one ▁ GridCoverage ( @ http : // www . opengis . net / gml ) ▁ element . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ is ▁ a ▁ complex ▁ type . STRNEWLINE ▁ */ public interface GridCoverageDocument extends net . opengis . gml . DiscreteCoverageDocument { public static final org . apache . xmlbeans . SchemaType type = ( org . apache . xmlbeans . SchemaType ) org . apache . xmlbeans . XmlBeans . typeSystemForClassLoader ( GridCoverageDocument . class . getClassLoader ( ) , " schemaorg _ apache _ xmlbeans . system . s6E28D279B6C224D74769DB8B98AF1665" ) . resolveHandle ( " gridcoveragea6fddoctype " ) ; /* * STRNEWLINE ▁ * ▁ Gets ▁ the ▁ " GridCoverage " ▁ element STRNEWLINE ▁ */ net . opengis . gml . GridCoverageType getGridCoverage ( ) ; /* * STRNEWLINE ▁ * ▁ Sets ▁ the ▁ " GridCoverage " ▁ element STRNEWLINE ▁ */ void setGridCoverage ( net . opengis . gml . GridCoverageType gridCoverage ) ; /* * STRNEWLINE ▁ * ▁ Appends ▁ and ▁ returns ▁ a ▁ new ▁ empty ▁ " GridCoverage " ▁ element STRNEWLINE ▁ */ net . opengis . gml . GridCoverageType addNewGridCoverage ( ) ; /* * STRNEWLINE ▁ * ▁ A ▁ factory ▁ class ▁ with ▁ static ▁ methods ▁ for ▁ creating ▁ instances STRNEWLINE ▁ * ▁ of ▁ this ▁ type . STRNEWLINE ▁ */ public static final class Factory { public static net . opengis . gml . GridCoverageDocument newInstance ( ) { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newInstance ( type , null ) ; } public static net . opengis . gml . GridCoverageDocument newInstance ( org . apache . xmlbeans . XmlOptions options ) { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newInstance ( type , options ) ; } /* * ▁ @ param ▁ xmlAsString ▁ the ▁ string ▁ value ▁ to ▁ parse ▁ */ public static net . opengis . gml . GridCoverageDocument parse ( java . lang . String xmlAsString ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xmlAsString , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . lang . String xmlAsString , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xmlAsString , type , options ) ; } /* * ▁ @ param ▁ file ▁ the ▁ file ▁ from ▁ which ▁ to ▁ load ▁ an ▁ xml ▁ document ▁ */ public static net . opengis . gml . GridCoverageDocument parse ( java . io . File file ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( file , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . File file , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( file , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . net . URL u ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( u , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . net . URL u , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( u , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . InputStream is ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( is , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . InputStream is , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( is , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . Reader r ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( r , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . Reader r , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( r , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( javax . xml . stream . XMLStreamReader sr ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( sr , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( javax . xml . stream . XMLStreamReader sr , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( sr , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( org . w3c . dom . Node node ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( node , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( org . w3c . dom . Node node , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( node , type , options ) ; } /* * ▁ @ deprecated ▁ { @ link ▁ org . apache . xmlbeans . xml . stream . XMLInputStream } ▁ */ @ Deprecated public static net . opengis . gml . GridCoverageDocument parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , null ) ; } /* * ▁ @ deprecated ▁ { @ link ▁ org . apache . xmlbeans . xml . stream . XMLInputStream } ▁ */ @ Deprecated public static net . opengis . gml . GridCoverageDocument parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , options ) ; } /* * ▁ @ deprecated ▁ { @ link ▁ org . apache . xmlbeans . xml . stream . XMLInputStream } ▁ */ @ Deprecated public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , null ) ; } /* * ▁ @ deprecated ▁ { @ link ▁ org . apache . xmlbeans . xml . stream . XMLInputStream } ▁ */ @ Deprecated public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , options ) ; } private Factory ( ) { } // ▁ No ▁ instance ▁ of ▁ this ▁ class ▁ allowed ENDCOM } } </DOCUMENT>
<DOCUMENT_ID="farkas-arpad/KROKI-mockup-tool/tree/master/GraphEdit/src/graphedit/state/SelectionState.java"> package graphedit . state ; import graphedit . actions . popup . LinkPopupMenu ; import graphedit . app . MainFrame ; import graphedit . command . ChangeAssociationPropertiesCommand ; import graphedit . command . ChangeElementPropertiesCommand ; import graphedit . command . ChangeLinkTypeCommand ; import graphedit . command . Command ; import graphedit . gui . dialog . AssociationLinkDialog ; import graphedit . gui . dialog . ClassElementDialog ; import graphedit . model . components . AggregationLink ; import graphedit . model . components . AssociationLink ; import graphedit . model . components . Class ; import graphedit . model . components . CompositionLink ; import graphedit . model . components . GraphElement ; import graphedit . model . components . Link ; import graphedit . model . components . LinkNode ; import graphedit . model . components . Package ; import graphedit . model . properties . PropertyEnums . GraphElementProperties ; import graphedit . view . AggregationLinkPainter ; import graphedit . view . AssociationLinkPainter ; import graphedit . view . CompositionLinkPainter ; import graphedit . view . ElementPainter ; import graphedit . view . LinkPainter ; import java . awt . Cursor ; import java . awt . event . KeyEvent ; import java . awt . event . MouseEvent ; import java . awt . geom . Dimension2D ; import java . awt . geom . Point2D ; import java . util . ArrayList ; import java . util . List ; import javax . swing . SwingUtilities ; public class SelectionState extends State { private Point2D popupPoint ; public SelectionState ( ) { super ( ) ; } @ Override public void mouseReleased ( MouseEvent e ) { GraphElement hitElement = controller . getCurrentElement ( ) ; Link hitLink = controller . getCurrentLink ( ) ; LinkNode hitNode = controller . getCurrentLinkNode ( ) ; if ( SwingUtilities . isRightMouseButton ( e ) ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; if ( hitElement != null ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; showGraphElementPopup ( e ) ; } else if ( hitLink != null || hitNode != null ) { showLinkElementPopup ( e ) ; } else showGraphElementPopup ( e ) ; view . repaint ( ) ; } } @ Override public void mousePressed ( MouseEvent e ) { Link hitLink = controller . getCurrentLink ( ) ; view . getSelectionModel ( ) . setSelectedNode ( null ) ; GraphElement hitElement = controller . getCurrentElement ( ) ; LinkNode hitNode = controller . getCurrentLinkNode ( ) ; if ( SwingUtilities . isLeftMouseButton ( e ) ) { if ( hitNode != null ) // provera ▁ mora ▁ pre ▁ nego ▁ sto ▁ se ▁ gleda ▁ da ▁ li ▁ je ▁ pogodjen ▁ element , ▁ zbog ▁ konektora ▁ koji ▁ je ▁ na ▁ elementu ENDCOM view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; else { view . getSelectionModel ( ) . setSelectedLink ( null ) ; // ▁ vrsi ▁ se ▁ provera ▁ da ▁ li ▁ je ▁ pritom ▁ pogodjen ▁ element ENDCOM if ( hitElement != null ) { // ▁ vrsi ▁ se ▁ provera ▁ da ▁ li ▁ je ▁ pritisnut ▁ ctrl ENDCOM if ( e . isControlDown ( ) ) { // ▁ da ▁ li ▁ je ▁ pogodjeni ▁ element ▁ prethodno ▁ bio ▁ selektovan ENDCOM if ( view . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { view . getSelectionModel ( ) . removeSelectedElement ( hitElement ) ; } else { view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; } } else { if ( ! view . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; } } } else if ( hitLink != null ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . setSelectedLink ( hitLink ) ; hitNode = view . getSelectedLinkNode ( hitLink , e . getPoint ( ) ) ; // kako ▁ bi ▁ pomeranje ▁ moglo ▁ odmah ▁ poctu ▁ u ▁ slucaju ▁ da ▁ se ▁ kliknulo ▁ direktno ▁ na ▁ konektor ENDCOM view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; } else { if ( ! e . isControlDown ( ) ) view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; } } } else if ( SwingUtilities . isRightMouseButton ( e ) ) { if ( hitElement != null ) { view . getSelectionModel ( ) . setSelectedLink ( null ) ; view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; } else if ( hitNode != null ) { view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; } else if ( hitLink != null ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . setSelectedLink ( hitLink ) ; hitNode = view . getSelectedLinkNode ( hitLink , e . getPoint ( ) ) ; view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; } else { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . setSelectedNode ( null ) ; view . getSelectionModel ( ) . setSelectedNode ( null ) ; } } // ▁ azuriraj ▁ promene ENDCOM view . repaint ( ) ; } @ Override public void mouseDragged ( MouseEvent e ) { GraphElement hitElement = controller . getCurrentElement ( ) ; Link hitLink = controller . getCurrentLink ( ) ; LinkNode hitNode = view . getSelectionModel ( ) . getSelectedNode ( ) ; if ( SwingUtilities . isLeftMouseButton ( e ) ) { if ( hitNode != null || ( hitLink != null && hitElement == null ) ) { // predji ▁ u ▁ move ▁ state ENDCOM State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getMoveElementState ( ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; state . mousePressed ( e ) ; } else if ( hitElement != null ) { if ( MainFrame . getInstance ( ) . getCurrentView ( ) . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { if ( e . isControlDown ( ) ) { // ▁ kopiraj ▁ element ENDCOM // ▁ selektuj ▁ kopirani ▁ element ENDCOM } if ( view . getCursor ( ) . getName ( ) . equals ( Cursor . getDefaultCursor ( ) . getName ( ) ) ) { // ▁ predji ▁ u ▁ MoveState ENDCOM State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getMoveElementState ( ) ; state . mousePressed ( e ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ) ; ( ( MoveElementState ) state ) . setElements ( view . getSelectionModel ( ) . getSelectedElements ( ) ) ; ( ( MoveElementState ) state ) . setRightMove ( false ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } else { // ▁ predji ▁ u ▁ ResizeState ENDCOM State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getResizeState ( ) ; state . setView ( view ) ; state . setController ( controller ) ; state . mousePressed ( e ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; // ne ▁ treba ▁ da ▁ se ▁ menja ▁ cursor ENDCOM } } } else { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getLassoSelectionState ( ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } } else if ( SwingUtilities . isRightMouseButton ( e ) && hitElement != null ) { if ( view . getCursor ( ) . getName ( ) . equals ( Cursor . getDefaultCursor ( ) . getName ( ) ) ) { // ▁ predji ▁ u ▁ MoveState ENDCOM State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getMoveElementState ( ) ; state . mousePressed ( e ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ) ; List < GraphElement > shadowElements = new ArrayList < GraphElement > ( ) ; List < ElementPainter > shadowPainters = new ArrayList < ElementPainter > ( ) ; for ( GraphElement element : view . getSelectionModel ( ) . getSelectedElements ( ) ) { try { GraphElement clone = ( GraphElement ) element . clone ( ) ; clone . setShadowElement ( true ) ; ElementPainter clonePainter = ( ElementPainter ) view . getElementPainter ( element ) . clone ( ) ; clonePainter . setElement ( clone ) ; shadowElements . add ( clone ) ; shadowPainters . add ( clonePainter ) ; } catch ( CloneNotSupportedException e1 ) { e1 . printStackTrace ( ) ; } } view . setShadowPainters ( shadowPainters ) ; ( ( MoveElementState ) state ) . setElements ( shadowElements ) ; ( ( MoveElementState ) state ) . setRightMove ( true ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } } else { if ( hitElement != null ) { if ( view . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { // ▁ kopiraj ▁ element ENDCOM // ▁ selektuj ▁ kopirani ▁ element ENDCOM // ▁ predji ▁ u ▁ MoveState ENDCOM } } } } @ Override public void mouseMoved ( MouseEvent e ) { int xPos = e . getX ( ) ; int yPos = e . getY ( ) ; // ▁ azuriranje ▁ koordinata ENDCOM MainFrame . getInstance ( ) . setPositionTrack ( xPos , yPos ) ; if ( view . getSelectionModel ( ) . getSelectedElements ( ) . size ( ) == 1 ) { GraphElement selectedElement = view . getSelectionModel ( ) . getSelectedElements ( ) . get ( 0 ) ; Dimension2D size = ( Dimension2D ) selectedElement . getProperty ( GraphElementProperties . SIZE ) ; Point2D position = new Point2D . Double ( ( ( Point2D ) selectedElement . getProperty ( GraphElementProperties . POSITION ) ) . getX ( ) - size . getWidth ( ) / 2 , ( ( Point2D ) selectedElement . getProperty ( GraphElementProperties . POSITION ) ) . getY ( ) - size . getHeight ( ) / 2 ) ; // levo ▁ ( polje ▁ sirine ▁ 5 ▁ piksela ▁ : ▁ po ▁ 2 ▁ piksela ▁ sa ▁ obe ▁ strane ▁ linije ▁ + ▁ linija )  ENDCOM if ( position . getX ( ) <= xPos && xPos <= position . getX ( ) + 4 ) { // levo - gore ENDCOM if ( position . getY ( ) <= yPos && yPos <= position . getY ( ) + 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . NW_RESIZE_CURSOR ) ) ; } // levo - sredina ENDCOM else if ( position . getY ( ) + 4 < yPos && yPos < position . getY ( ) + size . getHeight ( ) - 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . W_RESIZE_CURSOR ) ) ; } // levo - dole ENDCOM else if ( position . getY ( ) + size . getHeight ( ) - 4 <= yPos && yPos <= position . getY ( ) + size . getHeight ( ) ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . SW_RESIZE_CURSOR ) ) ; } // ostalo ENDCOM else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } // sredina ENDCOM else if ( position . getX ( ) + 4 < xPos && xPos < position . getX ( ) + size . getWidth ( ) - 4 ) { // sredina - gore ENDCOM if ( position . getY ( ) <= yPos && yPos <= position . getY ( ) + 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . N_RESIZE_CURSOR ) ) ; } // sredina - dole ENDCOM else if ( position . getY ( ) + size . getHeight ( ) - 4 <= yPos && yPos <= position . getY ( ) + size . getHeight ( ) ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . S_RESIZE_CURSOR ) ) ; } // ostalo ENDCOM else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } // desno ENDCOM else if ( position . getX ( ) + size . getWidth ( ) - 4 <= xPos && xPos <= position . getX ( ) + size . getWidth ( ) ) { // desno - gore ENDCOM if ( position . getY ( ) <= yPos && yPos <= position . getY ( ) + 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . NE_RESIZE_CURSOR ) ) ; } // desno - sredina ENDCOM else if ( position . getY ( ) + 4 < yPos && yPos < position . getY ( ) + size . getHeight ( ) - 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . E_RESIZE_CURSOR ) ) ; } // desno - dole ENDCOM else if ( position . getY ( ) + size . getHeight ( ) - 4 <= yPos && yPos <= position . getY ( ) + size . getHeight ( ) ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . SE_RESIZE_CURSOR ) ) ; } // ostalo ENDCOM else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } // ostalo ENDCOM else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } @ Override public void keyPressed ( KeyEvent e ) { if ( e . isControlDown ( ) && e . getKeyCode ( ) == KeyEvent . VK_ENTER ) { if ( view . getSelectionModel ( ) . getSelectedElements ( ) . size ( ) > 0 ) { // ▁ otvori ▁ properties ▁ window ▁ za ▁ pojedinacni ▁ ili ▁ grupu ▁ elemenata ENDCOM } } } @ Override public void mouseClicked ( MouseEvent e ) { if ( SwingUtilities . isLeftMouseButton ( e ) ) if ( e . getClickCount ( ) == 2 ) { Link hitLink = controller . getCurrentLink ( ) ; if ( hitLink != null ) { if ( hitLink instanceof AssociationLink ) { AssociationLinkDialog d = new AssociationLinkDialog ( ( AssociationLink ) hitLink ) ; d . setVisible ( true ) ; if ( d . isSomethingChanged ( ) ) { if ( d . isCreateNewLink ( ) ) { AssociationLink newLink ; LinkPainter painter = null ; if ( d . isAssociation ( ) ) { newLink = new AssociationLink ( hitLink . getNodes ( ) , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , " AssociationLink " + ( ( AssociationLink ) hitLink ) . getCurrentCount ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , MainFrame . getInstance ( ) . incrementLinkCounter ( ) ) ; painter = new AssociationLinkPainter ( newLink ) ; } else if ( d . isAggregation ( ) ) { newLink = new AggregationLink ( hitLink . getNodes ( ) , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , " AggregationLink " + ( ( AssociationLink ) hitLink ) . getCurrentCount ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , MainFrame . getInstance ( ) . incrementLinkCounter ( ) ) ; painter = new AggregationLinkPainter ( newLink ) ; } else { // if ▁ ( d . isComposition ( ) ) {  ENDCOM newLink = new CompositionLink ( hitLink . getNodes ( ) , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , " CompositionLink " + ( ( AssociationLink ) hitLink ) . getCurrentCount ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , MainFrame . getInstance ( ) . incrementLinkCounter ( ) ) ; painter = new CompositionLinkPainter ( newLink ) ; } Command command = new ChangeLinkTypeCommand ( view , hitLink , newLink , painter ) ; view . getModel ( ) . getCommandManager ( ) . executeCommand ( command ) ; newLink . getSourceConnector ( ) . setLink ( newLink ) ; newLink . getDestinationConnector ( ) . setLink ( newLink ) ; } else { Command command = new ChangeAssociationPropertiesCommand ( view , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , ( AssociationLink ) hitLink ) ; view . getModel ( ) . getCommandManager ( ) . executeCommand ( command ) ; } view . repaint ( ) ; } } } else { GraphElement element = controller . getCurrentElement ( ) ; if ( element instanceof Package ) MainFrame . getInstance ( ) . showDiagram ( ( ( Package ) element ) . getHierarchyPackage ( ) . getDiagram ( ) ) ; else if ( element instanceof graphedit . model . components . Class ) { ClassElementDialog dialog = new ClassElementDialog ( ( Class ) element ) ; dialog . setVisible ( true ) ; if ( dialog . isOk ( ) ) { Command command = new ChangeElementPropertiesCommand ( view , dialog . getName ( ) , dialog . getStereotype ( ) , element ) ; view . getModel ( ) . getCommandManager ( ) . executeCommand ( command ) ; view . repaint ( ) ; } } } } } public void showGraphElementPopup ( MouseEvent e ) { MainFrame . getInstance ( ) . getViewPopupMenu ( ) . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } public void showLinkElementPopup ( MouseEvent e ) { LinkPopupMenu popup = MainFrame . getInstance ( ) . getLinkPopupMenu ( ) ; popup . preparePopup ( ) ; popup . setActionPoint ( e . getPoint ( ) ) ; popup . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } @ Override public boolean isAutoScrollOnDragEnabled ( ) { return false ; } @ Override public boolean isAutoScrollOnMoveEnabled ( ) { return false ; } public Point2D getPopupPoint ( ) { return popupPoint ; } public void setPopupPoint ( Point2D popupPoint ) { this . popupPoint = popupPoint ; } } </DOCUMENT>
<DOCUMENT_ID="sourcepit/osgifier/tree/master/org.sourcepit.osgifier.core/gen/main/emf/org/sourcepit/osgifier/core/model/java/Named.java"> /* STRNEWLINE ▁ * ▁ Copyright ▁ 2014 ▁ Bernd ▁ Vogt ▁ and ▁ others . STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . sourcepit . osgifier . core . model . java ; import org . eclipse . emf . ecore . EObject ; /* * STRNEWLINE ▁ * ▁ < ! - - ▁ begin - user - doc ▁ - - > STRNEWLINE ▁ * ▁ A ▁ representation ▁ of ▁ the ▁ model ▁ object ▁ ' < em > < b > Named < / b > < / em > ' . STRNEWLINE ▁ * ▁ < ! - - ▁ end - user - doc ▁ - - > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ < p > STRNEWLINE ▁ * ▁ The ▁ following ▁ features ▁ are ▁ supported : STRNEWLINE ▁ * ▁ < ul > STRNEWLINE ▁ * ▁ < li > { @ link ▁ org . sourcepit . osgifier . core . model . java . Named # getName ▁ < em > Name < / em > } < / li > STRNEWLINE ▁ * ▁ < / ul > STRNEWLINE ▁ * ▁ < / p > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ see ▁ org . sourcepit . osgifier . core . model . java . JavaModelPackage # getNamed ( ) STRNEWLINE ▁ * ▁ @ model ▁ interface = " true " ▁ abstract = " true " STRNEWLINE ▁ * ▁ @ generated STRNEWLINE ▁ */ public interface Named extends EObject { /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ value ▁ of ▁ the ▁ ' < em > < b > Name < / b > < / em > ' ▁ attribute . STRNEWLINE ▁ * ▁ < ! - - ▁ begin - user - doc ▁ - - > STRNEWLINE ▁ * ▁ < p > STRNEWLINE ▁ * ▁ If ▁ the ▁ meaning ▁ of ▁ the ▁ ' < em > Name < / em > ' ▁ attribute ▁ isn ' t ▁ clear , ▁ there ▁ really ▁ should ▁ be ▁ more ▁ of ▁ a ▁ description ▁ here . . . STRNEWLINE ▁ * ▁ < / p > STRNEWLINE ▁ * ▁ < ! - - ▁ end - user - doc ▁ - - > STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ return ▁ the ▁ value ▁ of ▁ the ▁ ' < em > Name < / em > ' ▁ attribute . STRNEWLINE ▁ * ▁ @ see ▁ # setName ( String ) STRNEWLINE ▁ * ▁ @ see ▁ org . sourcepit . osgifier . core . model . java . JavaModelPackage # getNamed _ Name ( ) STRNEWLINE ▁ * ▁ @ model ▁ required = " true " STRNEWLINE ▁ * ▁ @ generated STRNEWLINE ▁ */ String getName ( ) ; /* * STRNEWLINE ▁ * ▁ Sets ▁ the ▁ value ▁ of ▁ the ▁ ' { @ link ▁ org . sourcepit . osgifier . core . model . java . Named # getName ▁ < em > Name < / em > } ' ▁ attribute . STRNEWLINE ▁ * ▁ < ! - - ▁ begin - user - doc ▁ - - > STRNEWLINE ▁ * ▁ < ! - - ▁ end - user - doc ▁ - - > STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ @ param ▁ value ▁ the ▁ new ▁ value ▁ of ▁ the ▁ ' < em > Name < / em > ' ▁ attribute . STRNEWLINE ▁ * ▁ @ see ▁ # getName ( ) STRNEWLINE ▁ * ▁ @ generated STRNEWLINE ▁ */ void setName ( String value ) ; } // ▁ Named ENDCOM </DOCUMENT>
<DOCUMENT_ID="ptupitsyn/ignite/tree/master/modules/core/src/test/java/org/apache/ignite/internal/IgniteClientRejoinTest.java"> /* STRNEWLINE ▁ * ▁ Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ ( ASF ) ▁ under ▁ one ▁ or ▁ more STRNEWLINE ▁ * ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file ▁ distributed ▁ with STRNEWLINE ▁ * ▁ this ▁ work ▁ for ▁ additional ▁ information ▁ regarding ▁ copyright ▁ ownership . STRNEWLINE ▁ * ▁ The ▁ ASF ▁ licenses ▁ this ▁ file ▁ to ▁ You ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 STRNEWLINE ▁ * ▁ ( the ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with STRNEWLINE ▁ * ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . apache . ignite . internal ; import java . io . IOException ; import java . io . OutputStream ; import java . net . InetSocketAddress ; import java . net . Socket ; import java . net . SocketException ; import java . util . ArrayList ; import java . util . List ; import java . util . Random ; import java . util . concurrent . Callable ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import org . apache . ignite . Ignite ; import org . apache . ignite . IgniteCache ; import org . apache . ignite . IgniteCheckedException ; import org . apache . ignite . IgniteClientDisconnectedException ; import org . apache . ignite . IgniteException ; import org . apache . ignite . Ignition ; import org . apache . ignite . cluster . ClusterNode ; import org . apache . ignite . configuration . IgniteConfiguration ; import org . apache . ignite . failure . AbstractFailureHandler ; import org . apache . ignite . failure . FailureContext ; import org . apache . ignite . failure . TestFailureHandler ; import org . apache . ignite . internal . util . typedef . internal . U ; import org . apache . ignite . lang . IgniteInClosure ; import org . apache . ignite . plugin . extensions . communication . Message ; import org . apache . ignite . spi . IgniteSpiException ; import org . apache . ignite . spi . IgniteSpiOperationTimeoutException ; import org . apache . ignite . spi . IgniteSpiOperationTimeoutHelper ; import org . apache . ignite . spi . discovery . tcp . TcpDiscoverySpi ; import org . apache . ignite . spi . discovery . tcp . messages . TcpDiscoveryAbstractMessage ; import org . apache . ignite . testframework . GridTestUtils ; import org . apache . ignite . testframework . junits . common . GridCommonAbstractTest ; import org . junit . Test ; /* * STRNEWLINE ▁ * ▁ Tests ▁ client ▁ to ▁ be ▁ able ▁ restore ▁ connection ▁ to ▁ cluster ▁ if ▁ coordination ▁ is ▁ not ▁ available . STRNEWLINE ▁ */ public class IgniteClientRejoinTest extends GridCommonAbstractTest { /* * ▁ Block . ▁ */ private volatile boolean block ; /* * ▁ Block ▁ all . ▁ */ private volatile boolean blockAll ; /* * ▁ Coordinator . ▁ */ private volatile ClusterNode crd ; /* * ▁ Client ▁ reconnect ▁ disabled . ▁ */ private boolean clientReconnectDisabled ; /* * ▁ { @ inheritDoc } ▁ */ @ Override protected void beforeTestsStarted ( ) throws Exception { System . setProperty ( " IGNITE _ SKIP _ CONFIGURATION _ CONSISTENCY _ CHECK " , " true " ) ; } /* * ▁ { @ inheritDoc } ▁ */ @ Override protected void afterTestsStopped ( ) throws Exception { System . clearProperty ( " IGNITE _ SKIP _ CONFIGURATION _ CONSISTENCY _ CHECK " ) ; } /* * ▁ { @ inheritDoc } ▁ */ @ Override protected void afterTest ( ) throws Exception { stopAllGrids ( ) ; } /* * ▁ { @ inheritDoc } ▁ */ @ Override protected void beforeTest ( ) throws Exception { clientReconnectDisabled = false ; } /* * ▁ { @ inheritDoc } ▁ */ @ Override protected IgniteConfiguration getConfiguration ( String gridName ) throws Exception { IgniteConfiguration cfg = super . getConfiguration ( gridName ) ; if ( gridName . contains ( " client " ) ) { cfg . setCommunicationSpi ( new TcpCommunicationSpi ( ) ) ; TcpDiscoverySpi spi = ( TcpDiscoverySpi ) cfg . getDiscoverySpi ( ) ; DiscoverySpi dspi = new DiscoverySpi ( ) ; dspi . setIpFinder ( spi . getIpFinder ( ) ) ; cfg . setDiscoverySpi ( dspi ) ; dspi . setJoinTimeout ( 60_000 ) ; dspi . setClientReconnectDisabled ( clientReconnectDisabled ) ; cfg . setClientMode ( true ) ; } // ▁ TODO : ▁ IGNITE - 4833 ENDCOM cfg . setPeerClassLoadingEnabled ( false ) ; return cfg ; } /* * STRNEWLINE ▁ * ▁ @ throws ▁ Exception ▁ If ▁ failed . STRNEWLINE ▁ */ @ Test public void testClientsReconnectAfterStart ( ) throws Exception { Ignite srv1 = startGrid ( " server1" ) ; crd = ( ( IgniteKernal ) srv1 ) . localNode ( ) ; Ignite srv2 = startGrid ( " server2" ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; List < Ignite > clientNodes = new ArrayList < > ( ) ; final int CLIENTS_NUM = 5 ; for ( int i = 0 ; i < CLIENTS_NUM ; i ++ ) clientNodes . add ( startGrid ( " client " + i ) ) ; blockAll = true ; GridTestUtils . runAsync ( new Callable < Object > ( ) { @ Override public Object call ( ) throws Exception { U . sleep ( 5_000 ) ; block = true ; blockAll = false ; System . out . println ( " > > > ▁ Allow ▁ with ▁ blocked ▁ coordinator . " ) ; latch . countDown ( ) ; return null ; } } ) ; IgniteInternalFuture < Object > fut = GridTestUtils . runAsync ( new Callable < Object > ( ) { @ Override public Object call ( ) throws Exception { latch . await ( ) ; U . sleep ( ( new Random ( ) . nextInt ( 15 ) + 30 ) * 1000 ) ; block = false ; System . out . println ( " > > > ▁ Allow ▁ coordinator . " ) ; return null ; } } ) ; fut . get ( ) ; for ( Ignite client : clientNodes ) { while ( true ) { try { IgniteCache < Integer , Integer > cache = client . getOrCreateCache ( " some " ) ; for ( int i = 0 ; i < 100 ; i ++ ) cache . put ( i , i ) ; for ( int i = 0 ; i < 100 ; i ++ ) assertEquals ( ( Integer ) i , cache . get ( i ) ) ; cache . clear ( ) ; break ; } catch ( IgniteClientDisconnectedException e ) { e . reconnectFuture ( ) . get ( ) ; } } } assertEquals ( CLIENTS_NUM , srv1 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; assertEquals ( CLIENTS_NUM , srv2 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; } /* * STRNEWLINE ▁ * ▁ @ throws ▁ Exception ▁ If ▁ failed . STRNEWLINE ▁ */ @ Test public void testClientsReconnect ( ) throws Exception { Ignite srv1 = startGrid ( " server1" ) ; crd = ( ( IgniteKernal ) srv1 ) . localNode ( ) ; Ignite srv2 = startGrid ( " server2" ) ; block = true ; List < IgniteInternalFuture < Ignite > > futs = new ArrayList < > ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final int CLIENTS_NUM = 5 ; for ( int i = 0 ; i < CLIENTS_NUM ; i ++ ) { final int idx = i ; IgniteInternalFuture < Ignite > fut = GridTestUtils . runAsync ( new Callable < Ignite > ( ) { @ Override public Ignite call ( ) throws Exception { latch . await ( ) ; String nodeName = " client " + idx ; IgniteConfiguration cfg = getConfiguration ( nodeName ) . setFailureHandler ( new AbstractFailureHandler ( ) { @ Override protected boolean handle ( Ignite ignite , FailureContext failureCtx ) { // ▁ This ▁ should ▁ _ not _ ▁ fire ▁ when ▁ exchange - worker ▁ terminates ▁ before ▁ reconnect . ENDCOM Runtime . getRuntime ( ) . halt ( Ignition . KILL_EXIT_CODE ) ; return false ; } } ) ; return startGrid ( nodeName , optimize ( cfg ) , null ) ; } } ) ; futs . add ( fut ) ; } GridTestUtils . runAsync ( new Callable < Boolean > ( ) { @ Override public Boolean call ( ) throws Exception { latch . countDown ( ) ; Random rnd = new Random ( ) ; U . sleep ( ( rnd . nextInt ( 15 ) + 15 ) * 1000 ) ; block = false ; System . out . println ( " > > > ▁ ALLOW ▁ connection ▁ to ▁ coordinator . " ) ; return true ; } } ) ; for ( IgniteInternalFuture < Ignite > clientFut : futs ) { Ignite client = clientFut . get ( ) ; IgniteCache < Integer , Integer > cache = client . getOrCreateCache ( client . name ( ) ) ; for ( int i = 0 ; i < 100 ; i ++ ) cache . put ( i , i ) ; for ( int i = 0 ; i < 100 ; i ++ ) assert i == cache . get ( i ) ; } assertEquals ( CLIENTS_NUM , srv1 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; assertEquals ( CLIENTS_NUM , srv2 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; } /* * STRNEWLINE ▁ * ▁ @ throws ▁ Exception ▁ If ▁ failed . STRNEWLINE ▁ */ @ Test public void testClientsReconnectDisabled ( ) throws Exception { clientReconnectDisabled = true ; Ignite srv1 = startGrid ( " server1" ) ; if ( ! tcpDiscovery ( ) ) return ; crd = ( ( IgniteKernal ) srv1 ) . localNode ( ) ; Ignite srv2 = startGrid ( " server2" ) ; block = true ; List < IgniteInternalFuture < Ignite > > futs = new ArrayList < > ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final int CLIENTS_NUM = 5 ; final CountDownLatch failureHndLatch = new CountDownLatch ( CLIENTS_NUM ) ; for ( int i = 0 ; i < CLIENTS_NUM ; i ++ ) { final int idx = i ; IgniteInternalFuture < Ignite > fut = GridTestUtils . runAsync ( new Callable < Ignite > ( ) { @ Override public Ignite call ( ) throws Exception { latch . await ( ) ; String igniteInstanceName = " client " + idx ; return startGrid ( igniteInstanceName , getConfiguration ( igniteInstanceName ) . setFailureHandler ( new TestFailureHandler ( true , failureHndLatch ) ) ) ; } } ) ; futs . add ( fut ) ; } latch . countDown ( ) ; for ( final IgniteInternalFuture < Ignite > clientFut : futs ) { // noinspection ▁ ThrowableNotThrown ENDCOM GridTestUtils . assertThrows ( log , new Callable < Object > ( ) { @ Override public Object call ( ) throws Exception { clientFut . get ( ) ; return null ; } } , IgniteCheckedException . class , null ) ; } assertTrue ( failureHndLatch . await ( 1000 , TimeUnit . MILLISECONDS ) ) ; assertEquals ( 0 , srv1 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; assertEquals ( 0 , srv2 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; } /* * ▁ { @ inheritDoc } ▁ */ @ Override protected long getTestTimeout ( ) { return 3 * 60_000 ; } private class TcpCommunicationSpi extends org . apache . ignite . spi . communication . tcp . TcpCommunicationSpi { /* * ▁ { @ inheritDoc } ▁ */ @ Override public void sendMessage ( ClusterNode node , Message msg ) throws IgniteSpiException { if ( blockAll || block && node . id ( ) . equals ( crd . id ( ) ) ) throw new IgniteSpiException ( new SocketException ( " Test ▁ communication ▁ exception " ) ) ; super . sendMessage ( node , msg ) ; } /* * ▁ { @ inheritDoc } ▁ */ @ Override public void sendMessage ( ClusterNode node , Message msg , IgniteInClosure < IgniteException > ackC ) throws IgniteSpiException { if ( blockAll || block && node . id ( ) . equals ( crd . id ( ) ) ) throw new IgniteSpiException ( new SocketException ( " Test ▁ communication ▁ exception " ) ) ; super . sendMessage ( node , msg , ackC ) ; } } private class DiscoverySpi extends TcpDiscoverySpi { /* * ▁ { @ inheritDoc } ▁ */ @ Override protected void writeToSocket ( Socket sock , TcpDiscoveryAbstractMessage msg , byte [ ] data , long timeout ) throws IOException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; super . writeToSocket ( sock , msg , data , timeout ) ; } /* * ▁ { @ inheritDoc } ▁ */ @ Override protected void writeToSocket ( Socket sock , TcpDiscoveryAbstractMessage msg , long timeout ) throws IOException , IgniteCheckedException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; super . writeToSocket ( sock , msg , timeout ) ; } /* * ▁ { @ inheritDoc } ▁ */ @ Override protected void writeToSocket ( Socket sock , OutputStream out , TcpDiscoveryAbstractMessage msg , long timeout ) throws IOException , IgniteCheckedException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; super . writeToSocket ( sock , out , msg , timeout ) ; } /* * ▁ { @ inheritDoc } ▁ */ @ Override protected void writeToSocket ( TcpDiscoveryAbstractMessage msg , Socket sock , int res , long timeout ) throws IOException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; super . writeToSocket ( msg , sock , res , timeout ) ; } /* * ▁ { @ inheritDoc } ▁ */ @ Override protected Socket openSocket ( Socket sock , InetSocketAddress remAddr , IgniteSpiOperationTimeoutHelper timeoutHelper ) throws IOException , IgniteSpiOperationTimeoutException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; return super . openSocket ( sock , remAddr , timeoutHelper ) ; } } } </DOCUMENT>
<DOCUMENT_ID="lumenrobot/relex-id/tree/master/core/src/main/java/id/ac/itb/ee/lskk/relexid/core/PartOfSpeech.java"> package id . ac . itb . ee . lskk . relexid . core ; import java . util . Locale ; import java . util . Map ; import javax . xml . namespace . QName ; import org . eclipse . emf . ecore . EObject ; /* * STRNEWLINE ▁ * ▁ < ! - - ▁ begin - user - doc ▁ - - > STRNEWLINE ▁ * ▁ A ▁ representation ▁ of ▁ the ▁ model ▁ object ▁ ' < em > < b > Part ▁ Of ▁ Speech < / b > < / em > ' . STRNEWLINE ▁ * ▁ < ! - - ▁ end - user - doc ▁ - - > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ < p > STRNEWLINE ▁ * ▁ The ▁ following ▁ features ▁ are ▁ supported : STRNEWLINE ▁ * ▁ < ul > STRNEWLINE ▁ * ▁ < li > { @ link ▁ id . ac . itb . ee . lskk . relexid . core . PartOfSpeech # getLiteral ▁ < em > Literal < / em > } < / li > STRNEWLINE ▁ * ▁ < li > { @ link ▁ id . ac . itb . ee . lskk . relexid . core . PartOfSpeech # getResource ▁ < em > Resource < / em > } < / li > STRNEWLINE ▁ * ▁ < li > { @ link ▁ id . ac . itb . ee . lskk . relexid . core . PartOfSpeech # getWord ▁ < em > Word < / em > } < / li > STRNEWLINE ▁ * ▁ < li > { @ link ▁ id . ac . itb . ee . lskk . relexid . core . PartOfSpeech # getName ▁ < em > Name < / em > } < / li > STRNEWLINE ▁ * ▁ < / ul > STRNEWLINE ▁ * ▁ < / p > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ see ▁ id . ac . itb . ee . lskk . relexid . core . RelexidPackage # getPartOfSpeech ( ) STRNEWLINE ▁ * ▁ @ model ▁ interface = " true " ▁ abstract = " true " STRNEWLINE ▁ * ▁ @ generated STRNEWLINE ▁ */ public interface PartOfSpeech extends EObject { /* * STRNEWLINE TABSYMBOL ▁ * ▁ Returns ▁ the ▁ value ▁ of ▁ the ▁ ' < em > < b > Literal < / b > < / em > ' ▁ attribute . STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ begin - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ end - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ begin - model - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ Literal ▁ part ▁ text ▁ without ▁ preprocessing . STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ end - model - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ @ return ▁ the ▁ value ▁ of ▁ the ▁ ' < em > Literal < / em > ' ▁ attribute . STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ # setLiteral ( String ) STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ id . ac . itb . ee . lskk . relexid . core . RelexidPackage # getPartOfSpeech _ Literal ( ) STRNEWLINE TABSYMBOL ▁ * ▁ @ model ▁ required = " true " STRNEWLINE TABSYMBOL ▁ * ▁ @ generated STRNEWLINE TABSYMBOL ▁ */ String getLiteral ( ) ; /* * STRNEWLINE TABSYMBOL ▁ * ▁ Sets ▁ the ▁ value ▁ of ▁ the ▁ ' { @ link ▁ id . ac . itb . ee . lskk . relexid . core . PartOfSpeech # getLiteral ▁ < em > Literal < / em > } ' ▁ attribute . STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ begin - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ end - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ @ param ▁ value ▁ the ▁ new ▁ value ▁ of ▁ the ▁ ' < em > Literal < / em > ' ▁ attribute . STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ # getLiteral ( ) STRNEWLINE TABSYMBOL ▁ * ▁ @ generated STRNEWLINE TABSYMBOL ▁ */ void setLiteral ( String value ) ; /* * STRNEWLINE TABSYMBOL ▁ * ▁ Returns ▁ the ▁ value ▁ of ▁ the ▁ ' < em > < b > Resource < / b > < / em > ' ▁ attribute . STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ begin - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ end - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ begin - model - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ Semantic ▁ resource ▁ ( if ▁ known ) . STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ end - model - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ @ return ▁ the ▁ value ▁ of ▁ the ▁ ' < em > Resource < / em > ' ▁ attribute . STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ # setResource ( QName ) STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ id . ac . itb . ee . lskk . relexid . core . RelexidPackage # getPartOfSpeech _ Resource ( ) STRNEWLINE TABSYMBOL ▁ * ▁ @ model ▁ dataType = " id . ac . itb . ee . lskk . relexid . core . QName " STRNEWLINE TABSYMBOL ▁ * ▁ @ generated STRNEWLINE TABSYMBOL ▁ */ QName getResource ( ) ; /* * STRNEWLINE TABSYMBOL ▁ * ▁ Sets ▁ the ▁ value ▁ of ▁ the ▁ ' { @ link ▁ id . ac . itb . ee . lskk . relexid . core . PartOfSpeech # getResource ▁ < em > Resource < / em > } ' ▁ attribute . STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ begin - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ end - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ @ param ▁ value ▁ the ▁ new ▁ value ▁ of ▁ the ▁ ' < em > Resource < / em > ' ▁ attribute . STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ # getResource ( ) STRNEWLINE TABSYMBOL ▁ * ▁ @ generated STRNEWLINE TABSYMBOL ▁ */ void setResource ( QName value ) ; /* * STRNEWLINE TABSYMBOL ▁ * ▁ Returns ▁ the ▁ value ▁ of ▁ the ▁ ' < em > < b > Word < / b > < / em > ' ▁ attribute . STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ begin - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ end - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ begin - model - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ Exact ▁ word ▁ resource ▁ ( if ▁ known ) . ▁ Available ▁ word ▁ namespaces ▁ are : STRNEWLINE TABSYMBOL ▁ * ▁ STRNEWLINE TABSYMBOL ▁ * ▁ < ul > STRNEWLINE TABSYMBOL ▁ * ▁ < li > wn30 : ▁ http : // purl . org / vocabularies / princeton / wn30 / < / li > STRNEWLINE TABSYMBOL ▁ * ▁ < li > wn30 - msa : ▁ http : // wn - msa . sourceforge . net / wn30 - msa / ▁ from ▁ < a ▁ href = " http : // wn - msa . sourceforge . net / " > WordNet ▁ Bahasa < / a > < / li > STRNEWLINE TABSYMBOL ▁ * ▁ < / ul > STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ end - model - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ @ return ▁ the ▁ value ▁ of ▁ the ▁ ' < em > Word < / em > ' ▁ attribute . STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ # setWord ( QName ) STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ id . ac . itb . ee . lskk . relexid . core . RelexidPackage # getPartOfSpeech _ Word ( ) STRNEWLINE TABSYMBOL ▁ * ▁ @ model ▁ dataType = " id . ac . itb . ee . lskk . relexid . core . QName " STRNEWLINE TABSYMBOL ▁ * ▁ @ generated STRNEWLINE TABSYMBOL ▁ */ QName getWord ( ) ; /* * STRNEWLINE TABSYMBOL ▁ * ▁ Sets ▁ the ▁ value ▁ of ▁ the ▁ ' { @ link ▁ id . ac . itb . ee . lskk . relexid . core . PartOfSpeech # getWord ▁ < em > Word < / em > } ' ▁ attribute . STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ begin - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ end - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ @ param ▁ value ▁ the ▁ new ▁ value ▁ of ▁ the ▁ ' < em > Word < / em > ' ▁ attribute . STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ # getWord ( ) STRNEWLINE TABSYMBOL ▁ * ▁ @ generated STRNEWLINE TABSYMBOL ▁ */ void setWord ( QName value ) ; /* * STRNEWLINE TABSYMBOL ▁ * ▁ Returns ▁ the ▁ value ▁ of ▁ the ▁ ' < em > < b > Name < / b > < / em > ' ▁ attribute . STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ begin - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ end - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ begin - model - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ { @ code ▁ rdfs : label } ▁ for ▁ the ▁ { @ link ▁ # resource } . ▁ Usually ▁ retrieved ▁ from ▁ a ▁ { @ link ▁ LabelProvider } . STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ end - model - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ @ return ▁ the ▁ value ▁ of ▁ the ▁ ' < em > Name < / em > ' ▁ attribute . STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ # setName ( String ) STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ id . ac . itb . ee . lskk . relexid . core . RelexidPackage # getPartOfSpeech _ Name ( ) STRNEWLINE TABSYMBOL ▁ * ▁ @ model ▁ required = " true " STRNEWLINE TABSYMBOL ▁ * ▁ @ generated STRNEWLINE TABSYMBOL ▁ */ String getName ( ) ; /* * STRNEWLINE TABSYMBOL ▁ * ▁ Sets ▁ the ▁ value ▁ of ▁ the ▁ ' { @ link ▁ id . ac . itb . ee . lskk . relexid . core . PartOfSpeech # getName ▁ < em > Name < / em > } ' ▁ attribute . STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ begin - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ end - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ @ param ▁ value ▁ the ▁ new ▁ value ▁ of ▁ the ▁ ' < em > Name < / em > ' ▁ attribute . STRNEWLINE TABSYMBOL ▁ * ▁ @ see ▁ # getName ( ) STRNEWLINE TABSYMBOL ▁ * ▁ @ generated STRNEWLINE TABSYMBOL ▁ */ void setName ( String value ) ; /* * STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ begin - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ end - user - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ begin - model - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ Generate ▁ a ▁ readable ▁ { @ link ▁ GeneratedLiteral } ▁ in ▁ the ▁ specified ▁ locale . STRNEWLINE TABSYMBOL ▁ * ▁ STRNEWLINE TABSYMBOL ▁ * ▁ @ param ▁ The ▁ translations ▁ of ▁ resources ▁ in ▁ this ▁ locale ' s ▁ language . ▁ Note ▁ that ▁ informal ▁ dictionaries ▁ ( i . e . ▁ bahasa ▁ gaul / alay ) ▁ is ▁ a ▁ valid ▁ use ▁ case . ▁ Key ▁ is ▁ resource ▁ URI ▁ and ▁ value ▁ is ▁ literal . STRNEWLINE TABSYMBOL ▁ * ▁ < ! - - ▁ end - model - doc ▁ - - > STRNEWLINE TABSYMBOL ▁ * ▁ @ model ▁ required = " true " ▁ localeDataType = " id . ac . itb . ee . lskk . relexid . core . Locale " ▁ translatorDataType = " id . ac . itb . ee . lskk . relexid . core . Translator " STRNEWLINE TABSYMBOL ▁ * ▁ @ generated STRNEWLINE TABSYMBOL ▁ */ GeneratedLiteral generate ( Locale locale , Map < String , String > dict , Translator translator ) ; } // ▁ PartOfSpeech ENDCOM </DOCUMENT>
<DOCUMENT_ID="charlesvinette/react-native/tree/master/ReactAndroid/src/main/java/com/facebook/react/views/modal/ReactModalHostView.java"> /* * STRNEWLINE ▁ * ▁ Copyright ▁ ( c ) ▁ 2015 - present , ▁ Facebook , ▁ Inc . STRNEWLINE ▁ * ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ source ▁ code ▁ is ▁ licensed ▁ under ▁ the ▁ BSD - style ▁ license ▁ found ▁ in ▁ the STRNEWLINE ▁ * ▁ LICENSE ▁ file ▁ in ▁ the ▁ root ▁ directory ▁ of ▁ this ▁ source ▁ tree . ▁ An ▁ additional ▁ grant STRNEWLINE ▁ * ▁ of ▁ patent ▁ rights ▁ can ▁ be ▁ found ▁ in ▁ the ▁ PATENTS ▁ file ▁ in ▁ the ▁ same ▁ directory . STRNEWLINE ▁ */ package com . facebook . react . views . modal ; import javax . annotation . Nullable ; import java . util . ArrayList ; import android . app . Activity ; import android . app . Dialog ; import android . content . Context ; import android . content . DialogInterface ; import android . view . KeyEvent ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . view . accessibility . AccessibilityEvent ; import android . widget . FrameLayout ; import com . facebook . infer . annotation . Assertions ; import com . facebook . react . R ; import com . facebook . react . bridge . LifecycleEventListener ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . common . annotations . VisibleForTesting ; import com . facebook . react . uimanager . JSTouchDispatcher ; import com . facebook . react . uimanager . RootView ; import com . facebook . react . uimanager . UIManagerModule ; import com . facebook . react . uimanager . events . EventDispatcher ; import com . facebook . react . views . view . ReactViewGroup ; /* * STRNEWLINE ▁ * ▁ ReactModalHostView ▁ is ▁ a ▁ view ▁ that ▁ sits ▁ in ▁ the ▁ view ▁ hierarchy ▁ representing ▁ a ▁ Modal ▁ view . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ It ▁ does ▁ a ▁ number ▁ of ▁ things : STRNEWLINE ▁ * ▁ 1 . ▁ It ▁ creates ▁ a ▁ Dialog . ▁ We ▁ use ▁ this ▁ Dialog ▁ to ▁ actually ▁ display ▁ the ▁ Modal ▁ in ▁ the ▁ window . STRNEWLINE ▁ * ▁ 2 . ▁ It ▁ creates ▁ a ▁ DialogRootViewGroup . ▁ This ▁ view ▁ is ▁ the ▁ view ▁ that ▁ is ▁ displayed ▁ by ▁ the ▁ Dialog . ▁ To STRNEWLINE ▁ * ▁ display ▁ a ▁ view ▁ within ▁ a ▁ Dialog , ▁ that ▁ view ▁ must ▁ have ▁ its ▁ parent ▁ set ▁ to ▁ the ▁ window ▁ the ▁ Dialog STRNEWLINE ▁ * ▁ creates . ▁ Because ▁ of ▁ this , ▁ we ▁ can ▁ not ▁ use ▁ the ▁ ReactModalHostView ▁ since ▁ it ▁ sits ▁ in ▁ the STRNEWLINE ▁ * ▁ normal ▁ React ▁ view ▁ hierarchy . ▁ We ▁ do ▁ however ▁ want ▁ all ▁ of ▁ the ▁ layout ▁ magic ▁ to ▁ happen ▁ as ▁ if ▁ the STRNEWLINE ▁ * ▁ DialogRootViewGroup ▁ were ▁ part ▁ of ▁ the ▁ hierarchy . ▁ Therefore , ▁ we ▁ forward ▁ all ▁ view ▁ changes STRNEWLINE ▁ * ▁ around ▁ addition ▁ and ▁ removal ▁ of ▁ views ▁ to ▁ the ▁ DialogRootViewGroup . STRNEWLINE ▁ */ public class ReactModalHostView extends ViewGroup implements LifecycleEventListener { // ▁ This ▁ listener ▁ is ▁ called ▁ when ▁ the ▁ user ▁ presses ▁ KeyEvent . KEYCODE _ BACK ENDCOM // ▁ An ▁ event ▁ is ▁ then ▁ passed ▁ to ▁ JS ▁ which ▁ can ▁ either ▁ close ▁ or ▁ not ▁ close ▁ the ▁ Modal ▁ by ▁ setting ▁ the ENDCOM // ▁ visible ▁ property ENDCOM public interface OnRequestCloseListener { void onRequestClose ( DialogInterface dialog ) ; } private DialogRootViewGroup mHostView ; private @ Nullable Dialog mDialog ; private boolean mTransparent ; private String mAnimationType ; // ▁ Set ▁ this ▁ flag ▁ to ▁ true ▁ if ▁ changing ▁ a ▁ particular ▁ property ▁ on ▁ the ▁ view ▁ requires ▁ a ▁ new ▁ Dialog ▁ to ENDCOM // ▁ be ▁ created . ▁ For ▁ instance , ▁ animation ▁ does ▁ since ▁ it ▁ affects ▁ Dialog ▁ creation ▁ through ▁ the ▁ theme ENDCOM // ▁ but ▁ transparency ▁ does ▁ not ▁ since ▁ we ▁ can ▁ access ▁ the ▁ window ▁ to ▁ update ▁ the ▁ property . ENDCOM private boolean mPropertyRequiresNewDialog ; private @ Nullable DialogInterface . OnShowListener mOnShowListener ; private @ Nullable OnRequestCloseListener mOnRequestCloseListener ; public ReactModalHostView ( Context context ) { super ( context ) ; ( ( ReactContext ) context ) . addLifecycleEventListener ( this ) ; mHostView = new DialogRootViewGroup ( context ) ; } @ Override protected void onLayout ( boolean changed , int l , int t , int r , int b ) { // ▁ Do ▁ nothing ▁ as ▁ we ▁ are ▁ laid ▁ out ▁ by ▁ UIManager ENDCOM } @ Override public void addView ( View child , int index ) { mHostView . addView ( child , index ) ; } @ Override public int getChildCount ( ) { return mHostView . getChildCount ( ) ; } @ Override public View getChildAt ( int index ) { return mHostView . getChildAt ( index ) ; } @ Override public void removeView ( View child ) { mHostView . removeView ( child ) ; } @ Override public void removeViewAt ( int index ) { View child = getChildAt ( index ) ; mHostView . removeView ( child ) ; } @ Override public void addChildrenForAccessibility ( ArrayList < View > outChildren ) { // ▁ Explicitly ▁ override ▁ this ▁ to ▁ prevent ▁ accessibility ▁ events ▁ being ▁ passed ▁ down ▁ to ▁ children ENDCOM // ▁ Those ▁ will ▁ be ▁ handled ▁ by ▁ the ▁ mHostView ▁ which ▁ lives ▁ in ▁ the ▁ dialog ENDCOM } @ Override public boolean dispatchPopulateAccessibilityEvent ( AccessibilityEvent event ) { // ▁ Explicitly ▁ override ▁ this ▁ to ▁ prevent ▁ accessibility ▁ events ▁ being ▁ passed ▁ down ▁ to ▁ children ENDCOM // ▁ Those ▁ will ▁ be ▁ handled ▁ by ▁ the ▁ mHostView ▁ which ▁ lives ▁ in ▁ the ▁ dialog ENDCOM return false ; } public void onDropInstance ( ) { ( ( ReactContext ) getContext ( ) ) . removeLifecycleEventListener ( this ) ; dismiss ( ) ; } private void dismiss ( ) { if ( mDialog != null ) { mDialog . dismiss ( ) ; mDialog = null ; // ▁ We ▁ need ▁ to ▁ remove ▁ the ▁ mHostView ▁ from ▁ the ▁ parent ENDCOM // ▁ It ▁ is ▁ possible ▁ we ▁ are ▁ dismissing ▁ this ▁ dialog ▁ and ▁ reattaching ▁ the ▁ hostView ▁ to ▁ another ENDCOM ViewGroup parent = ( ViewGroup ) mHostView . getParent ( ) ; parent . removeViewAt ( 0 ) ; } } protected void setOnRequestCloseListener ( OnRequestCloseListener listener ) { mOnRequestCloseListener = listener ; } protected void setOnShowListener ( DialogInterface . OnShowListener listener ) { mOnShowListener = listener ; } protected void setTransparent ( boolean transparent ) { mTransparent = transparent ; } protected void setAnimationType ( String animationType ) { mAnimationType = animationType ; mPropertyRequiresNewDialog = true ; } @ Override public void onHostResume ( ) { // ▁ We ▁ show ▁ the ▁ dialog ▁ again ▁ when ▁ the ▁ host ▁ resumes ENDCOM showOrUpdate ( ) ; } @ Override public void onHostPause ( ) { // ▁ We ▁ dismiss ▁ the ▁ dialog ▁ and ▁ reconstitute ▁ it ▁ onHostResume ENDCOM dismiss ( ) ; } @ Override public void onHostDestroy ( ) { // ▁ Drop ▁ the ▁ instance ▁ if ▁ the ▁ host ▁ is ▁ destroyed ▁ which ▁ will ▁ dismiss ▁ the ▁ dialog ENDCOM onDropInstance ( ) ; } @ VisibleForTesting public @ Nullable Dialog getDialog ( ) { return mDialog ; } /* * STRNEWLINE ▁ * ▁ showOrUpdate ▁ will ▁ display ▁ the ▁ Dialog . ▁ It ▁ is ▁ called ▁ by ▁ the ▁ manager ▁ once ▁ all ▁ properties ▁ are ▁ set STRNEWLINE ▁ * ▁ because ▁ we ▁ need ▁ to ▁ know ▁ all ▁ of ▁ them ▁ before ▁ creating ▁ the ▁ Dialog . ▁ It ▁ is ▁ also ▁ smart ▁ during STRNEWLINE ▁ * ▁ updates ▁ if ▁ the ▁ changed ▁ properties ▁ can ▁ be ▁ applied ▁ directly ▁ to ▁ the ▁ Dialog ▁ or ▁ require ▁ the STRNEWLINE ▁ * ▁ recreation ▁ of ▁ a ▁ new ▁ Dialog . STRNEWLINE ▁ */ protected void showOrUpdate ( ) { // ▁ If ▁ the ▁ existing ▁ Dialog ▁ is ▁ currently ▁ up , ▁ we ▁ may ▁ need ▁ to ▁ redraw ▁ it ▁ or ▁ we ▁ may ▁ be ▁ able ▁ to ▁ update ENDCOM // ▁ the ▁ property ▁ without ▁ having ▁ to ▁ recreate ▁ the ▁ dialog ENDCOM if ( mDialog != null ) { if ( mPropertyRequiresNewDialog ) { dismiss ( ) ; } else { updateProperties ( ) ; return ; } } // ▁ Reset ▁ the ▁ flag ▁ since ▁ we ▁ are ▁ going ▁ to ▁ create ▁ a ▁ new ▁ dialog ENDCOM mPropertyRequiresNewDialog = false ; int theme = R . style . Theme_FullScreenDialog ; if ( mAnimationType . equals ( " fade " ) ) { theme = R . style . Theme_FullScreenDialogAnimatedFade ; } else if ( mAnimationType . equals ( " slide " ) ) { theme = R . style . Theme_FullScreenDialogAnimatedSlide ; } mDialog = new Dialog ( getContext ( ) , theme ) ; mDialog . setContentView ( getContentView ( ) ) ; updateProperties ( ) ; mDialog . setOnShowListener ( mOnShowListener ) ; mDialog . setOnKeyListener ( new DialogInterface . OnKeyListener ( ) { @ Override public boolean onKey ( DialogInterface dialog , int keyCode , KeyEvent event ) { if ( event . getAction ( ) == KeyEvent . ACTION_UP ) { // ▁ We ▁ need ▁ to ▁ stop ▁ the ▁ BACK ▁ button ▁ from ▁ closing ▁ the ▁ dialog ▁ by ▁ default ▁ so ▁ we ▁ capture ▁ that ENDCOM // ▁ event ▁ and ▁ instead ▁ inform ▁ JS ▁ so ▁ that ▁ it ▁ can ▁ make ▁ the ▁ decision ▁ as ▁ to ▁ whether ▁ or ▁ not ▁ to ENDCOM // ▁ allow ▁ the ▁ back ▁ button ▁ to ▁ close ▁ the ▁ dialog . ▁ If ▁ it ▁ chooses ▁ to , ▁ it ▁ can ▁ just ▁ set ▁ visible ENDCOM // ▁ to ▁ false ▁ on ▁ the ▁ Modal ▁ and ▁ the ▁ Modal ▁ will ▁ go ▁ away ENDCOM if ( keyCode == KeyEvent . KEYCODE_BACK ) { Assertions . assertNotNull ( mOnRequestCloseListener , " setOnRequestCloseListener ▁ must ▁ be ▁ called ▁ by ▁ the ▁ manager " ) ; mOnRequestCloseListener . onRequestClose ( dialog ) ; return true ; } else { // ▁ We ▁ redirect ▁ the ▁ rest ▁ of ▁ the ▁ key ▁ events ▁ to ▁ the ▁ current ▁ activity , ▁ since ▁ the ▁ activity ENDCOM // ▁ expects ▁ to ▁ receive ▁ those ▁ events ▁ and ▁ react ▁ to ▁ them , ▁ ie . ▁ in ▁ the ▁ case ▁ of ▁ the ▁ dev ▁ menu ENDCOM Activity currentActivity = ( ( ReactContext ) getContext ( ) ) . getCurrentActivity ( ) ; if ( currentActivity != null ) { return currentActivity . onKeyUp ( keyCode , event ) ; } } } return false ; } } ) ; mDialog . getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; mDialog . show ( ) ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ view ▁ that ▁ will ▁ be ▁ the ▁ root ▁ view ▁ of ▁ the ▁ dialog . ▁ We ▁ are ▁ wrapping ▁ this ▁ in ▁ a STRNEWLINE ▁ * ▁ FrameLayout ▁ because ▁ this ▁ is ▁ the ▁ system ' s ▁ way ▁ of ▁ notifying ▁ us ▁ that ▁ the ▁ dialog ▁ size ▁ has ▁ changed . STRNEWLINE ▁ * ▁ This ▁ has ▁ the ▁ pleasant ▁ side - effect ▁ of ▁ us ▁ not ▁ having ▁ to ▁ preface ▁ all ▁ Modals ▁ with STRNEWLINE ▁ * ▁ " top : ▁ statusBarHeight " , ▁ since ▁ that ▁ margin ▁ will ▁ be ▁ included ▁ in ▁ the ▁ FrameLayout . STRNEWLINE ▁ */ private View getContentView ( ) { FrameLayout frameLayout = new FrameLayout ( getContext ( ) ) ; frameLayout . addView ( mHostView ) ; frameLayout . setFitsSystemWindows ( true ) ; return frameLayout ; } /* * STRNEWLINE ▁ * ▁ updateProperties ▁ will ▁ update ▁ the ▁ properties ▁ that ▁ do ▁ not ▁ require ▁ us ▁ to ▁ recreate ▁ the ▁ dialog STRNEWLINE ▁ * ▁ Properties ▁ that ▁ do ▁ require ▁ us ▁ to ▁ recreate ▁ the ▁ dialog ▁ should ▁ set ▁ mPropertyRequiresNewDialog ▁ to STRNEWLINE ▁ * ▁ true ▁ when ▁ the ▁ property ▁ changes STRNEWLINE ▁ */ private void updateProperties ( ) { Assertions . assertNotNull ( mDialog , " mDialog ▁ must ▁ exist ▁ when ▁ we ▁ call ▁ updateProperties " ) ; if ( mTransparent ) { mDialog . getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_DIM_BEHIND ) ; } else { mDialog . getWindow ( ) . setDimAmount ( 0.5f ) ; mDialog . getWindow ( ) . setFlags ( WindowManager . LayoutParams . FLAG_DIM_BEHIND , WindowManager . LayoutParams . FLAG_DIM_BEHIND ) ; } } /* * STRNEWLINE ▁ * ▁ DialogRootViewGroup ▁ is ▁ the ▁ ViewGroup ▁ which ▁ contains ▁ all ▁ the ▁ children ▁ of ▁ a ▁ Modal . ▁ It ▁ gets ▁ all STRNEWLINE ▁ * ▁ child ▁ information ▁ forwarded ▁ from ▁ ReactModalHostView ▁ and ▁ uses ▁ that ▁ to ▁ create ▁ children . ▁ It ▁ is STRNEWLINE ▁ * ▁ also ▁ responsible ▁ for ▁ acting ▁ as ▁ a ▁ RootView ▁ and ▁ handling ▁ touch ▁ events . ▁ It ▁ does ▁ this ▁ the ▁ same STRNEWLINE ▁ * ▁ way ▁ as ▁ ReactRootView . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ To ▁ get ▁ layout ▁ to ▁ work ▁ properly , ▁ we ▁ need ▁ to ▁ layout ▁ all ▁ the ▁ elements ▁ within ▁ the ▁ Modal ▁ as ▁ if ▁ they STRNEWLINE ▁ * ▁ can ▁ fill ▁ the ▁ entire ▁ window . ▁ To ▁ do ▁ that , ▁ we ▁ need ▁ to ▁ explicitly ▁ set ▁ the ▁ styleWidth ▁ and STRNEWLINE ▁ * ▁ styleHeight ▁ on ▁ the ▁ LayoutShadowNode ▁ to ▁ be ▁ the ▁ window ▁ size . ▁ This ▁ is ▁ done ▁ through ▁ the STRNEWLINE ▁ * ▁ UIManagerModule , ▁ and ▁ will ▁ then ▁ cause ▁ the ▁ children ▁ to ▁ layout ▁ as ▁ if ▁ they ▁ can ▁ fill ▁ the ▁ window . STRNEWLINE ▁ */ static class DialogRootViewGroup extends ReactViewGroup implements RootView { private final JSTouchDispatcher mJSTouchDispatcher = new JSTouchDispatcher ( this ) ; public DialogRootViewGroup ( Context context ) { super ( context ) ; } @ Override protected void onSizeChanged ( final int w , final int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; if ( getChildCount ( ) > 0 ) { ( ( ReactContext ) getContext ( ) ) . runOnNativeModulesQueueThread ( new Runnable ( ) { @ Override public void run ( ) { ( ( ReactContext ) getContext ( ) ) . getNativeModule ( UIManagerModule . class ) . updateNodeSize ( getChildAt ( 0 ) . getId ( ) , w , h ) ; } } ) ; } } @ Override public boolean onInterceptTouchEvent ( MotionEvent event ) { mJSTouchDispatcher . handleTouchEvent ( event , getEventDispatcher ( ) ) ; return super . onInterceptTouchEvent ( event ) ; } @ Override public boolean onTouchEvent ( MotionEvent event ) { mJSTouchDispatcher . handleTouchEvent ( event , getEventDispatcher ( ) ) ; super . onTouchEvent ( event ) ; // ▁ In ▁ case ▁ when ▁ there ▁ is ▁ no ▁ children ▁ interested ▁ in ▁ handling ▁ touch ▁ event , ▁ we ▁ return ▁ true ▁ from ENDCOM // ▁ the ▁ root ▁ view ▁ in ▁ order ▁ to ▁ receive ▁ subsequent ▁ events ▁ related ▁ to ▁ that ▁ gesture ENDCOM return true ; } @ Override public void onChildStartedNativeGesture ( MotionEvent androidEvent ) { mJSTouchDispatcher . onChildStartedNativeGesture ( androidEvent , getEventDispatcher ( ) ) ; } @ Override public void requestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { // ▁ No - op ▁ - ▁ override ▁ in ▁ order ▁ to ▁ still ▁ receive ▁ events ▁ to ▁ onInterceptTouchEvent ENDCOM // ▁ even ▁ when ▁ some ▁ other ▁ view ▁ disallow ▁ that ENDCOM } private EventDispatcher getEventDispatcher ( ) { ReactContext reactContext = ( ReactContext ) getContext ( ) ; return reactContext . getNativeModule ( UIManagerModule . class ) . getEventDispatcher ( ) ; } } } </DOCUMENT>
<DOCUMENT_ID="tuxillo/aarch64-dragonfly-gcc/tree/master/libjava/classpath/gnu/java/net/protocol/jar/Handler.java"> /* ▁ gnu . java . net . protocol . jar . Handler ▁ - ▁ jar ▁ protocol ▁ handler ▁ for ▁ java . net STRNEWLINE ▁ Copyright ▁ ( C ) ▁ 1999 , ▁ 2002 , ▁ 2003 , ▁ 2005 , ▁ 2006 ▁ Free ▁ Software ▁ Foundation , ▁ Inc . STRNEWLINE STRNEWLINE This ▁ file ▁ is ▁ part ▁ of ▁ GNU ▁ Classpath . STRNEWLINE STRNEWLINE GNU ▁ Classpath ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 , ▁ or ▁ ( at ▁ your ▁ option ) STRNEWLINE any ▁ later ▁ version . STRNEWLINE STRNEWLINE GNU ▁ Classpath ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but STRNEWLINE WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU STRNEWLINE General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE STRNEWLINE You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE along ▁ with ▁ GNU ▁ Classpath ; ▁ see ▁ the ▁ file ▁ COPYING . ▁ If ▁ not , ▁ write ▁ to ▁ the STRNEWLINE Free ▁ Software ▁ Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , ▁ Boston , ▁ MA STRNEWLINE 02110-1301 ▁ USA . STRNEWLINE STRNEWLINE Linking ▁ this ▁ library ▁ statically ▁ or ▁ dynamically ▁ with ▁ other ▁ modules ▁ is STRNEWLINE making ▁ a ▁ combined ▁ work ▁ based ▁ on ▁ this ▁ library . ▁ Thus , ▁ the ▁ terms ▁ and STRNEWLINE conditions ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ cover ▁ the ▁ whole STRNEWLINE combination . STRNEWLINE STRNEWLINE As ▁ a ▁ special ▁ exception , ▁ the ▁ copyright ▁ holders ▁ of ▁ this ▁ library ▁ give ▁ you STRNEWLINE permission ▁ to ▁ link ▁ this ▁ library ▁ with ▁ independent ▁ modules ▁ to ▁ produce ▁ an STRNEWLINE executable , ▁ regardless ▁ of ▁ the ▁ license ▁ terms ▁ of ▁ these ▁ independent STRNEWLINE modules , ▁ and ▁ to ▁ copy ▁ and ▁ distribute ▁ the ▁ resulting ▁ executable ▁ under STRNEWLINE terms ▁ of ▁ your ▁ choice , ▁ provided ▁ that ▁ you ▁ also ▁ meet , ▁ for ▁ each ▁ linked STRNEWLINE independent ▁ module , ▁ the ▁ terms ▁ and ▁ conditions ▁ of ▁ the ▁ license ▁ of ▁ that STRNEWLINE module . ▁ An ▁ independent ▁ module ▁ is ▁ a ▁ module ▁ which ▁ is ▁ not ▁ derived ▁ from STRNEWLINE or ▁ based ▁ on ▁ this ▁ library . ▁ If ▁ you ▁ modify ▁ this ▁ library , ▁ you ▁ may ▁ extend STRNEWLINE this ▁ exception ▁ to ▁ your ▁ version ▁ of ▁ the ▁ library , ▁ but ▁ you ▁ are ▁ not STRNEWLINE obligated ▁ to ▁ do ▁ so . ▁ If ▁ you ▁ do ▁ not ▁ wish ▁ to ▁ do ▁ so , ▁ delete ▁ this STRNEWLINE exception ▁ statement ▁ from ▁ your ▁ version . ▁ */ package gnu . java . net . protocol . jar ; import gnu . java . lang . CPStringBuilder ; import gnu . java . net . URLParseError ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLConnection ; import java . net . URLStreamHandler ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . StringTokenizer ; /* * STRNEWLINE ▁ * ▁ @ author ▁ Kresten ▁ Krab ▁ Thorup ▁ ( krab @ gnu . org ) STRNEWLINE ▁ */ public class Handler extends URLStreamHandler { /* * STRNEWLINE ▁ * ▁ A ▁ do ▁ nothing ▁ constructor STRNEWLINE ▁ */ public Handler ( ) { } /* * STRNEWLINE ▁ * ▁ This ▁ method ▁ returs ▁ a ▁ new ▁ JarURLConnection ▁ for ▁ the ▁ specified ▁ URL STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ url ▁ The ▁ URL ▁ to ▁ return ▁ a ▁ connection ▁ for STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ The ▁ URLConnection STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ exception ▁ IOException ▁ If ▁ an ▁ error ▁ occurs STRNEWLINE ▁ */ protected URLConnection openConnection ( URL url ) throws IOException { return new Connection ( url ) ; } /* * STRNEWLINE ▁ * ▁ This ▁ method ▁ overrides ▁ URLStreamHandler ' s ▁ for ▁ parsing ▁ url ▁ of ▁ protocol ▁ " jar " STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ url ▁ The ▁ URL ▁ object ▁ in ▁ which ▁ to ▁ store ▁ the ▁ results STRNEWLINE ▁ * ▁ @ param ▁ url _ string ▁ The ▁ String - ized ▁ URL ▁ to ▁ parse STRNEWLINE ▁ * ▁ @ param ▁ start ▁ The ▁ position ▁ in ▁ the ▁ string ▁ to ▁ start ▁ scanning ▁ from STRNEWLINE ▁ * ▁ @ param ▁ end ▁ The ▁ position ▁ in ▁ the ▁ string ▁ to ▁ stop ▁ scanning STRNEWLINE ▁ */ protected void parseURL ( URL url , String url_string , int start , int end ) { // ▁ This ▁ method ▁ does ▁ not ▁ throw ▁ an ▁ exception ▁ or ▁ return ▁ a ▁ value . ▁ Thus ▁ our ENDCOM // ▁ strategy ▁ when ▁ we ▁ encounter ▁ an ▁ error ▁ in ▁ parsing ▁ is ▁ to ▁ return ▁ without ENDCOM // ▁ doing ▁ anything . ENDCOM String file = url . getFile ( ) ; if ( ! file . equals ( " " ) ) { // has ▁ context ▁ url ENDCOM url_string = url_string . substring ( start , end ) ; if ( url_string . startsWith ( " / " ) ) { // url ▁ string ▁ is ▁ an ▁ absolute ▁ path ENDCOM int idx = file . lastIndexOf ( " ! / " ) ; if ( idx < 0 ) throw new URLParseError ( " no ▁ ! / ▁ in ▁ spec " ) ; file = file . substring ( 0 , idx + 1 ) + url_string ; } else if ( url_string . length ( ) > 0 ) { int idx = file . lastIndexOf ( " / " ) ; if ( idx == - 1 ) // context ▁ path ▁ is ▁ weird ENDCOM file = " / " + url_string ; else if ( idx == ( file . length ( ) - 1 ) ) // just ▁ concatenate ▁ two ▁ parts ENDCOM file = file + url_string ; else // ▁ according ▁ to ▁ Java ▁ API ▁ Documentation , ▁ here ▁ is ▁ a ▁ little ▁ different ENDCOM // ▁ with ▁ URLStreamHandler . parseURL ENDCOM // ▁ but ▁ JDK ▁ seems ▁ doesn ' t ▁ handle ▁ it ▁ well ENDCOM file = file . substring ( 0 , idx + 1 ) + url_string ; } setURL ( url , " jar " , url . getHost ( ) , url . getPort ( ) , flat ( file ) , null ) ; return ; } // ▁ Bunches ▁ of ▁ things ▁ should ▁ be ▁ true . ▁ Make ▁ sure . ENDCOM if ( end < start ) return ; if ( end - start < 2 ) return ; if ( start > url_string . length ( ) ) return ; // ▁ Skip ▁ remains ▁ of ▁ protocol ENDCOM url_string = url_string . substring ( start , end ) ; int jar_stop ; if ( ( jar_stop = url_string . indexOf ( " ! / " ) ) < 0 ) throw new URLParseError ( " no ▁ ! / ▁ in ▁ spec " ) ; try { new URL ( url_string . substring ( 0 , jar_stop ) ) ; } catch ( MalformedURLException e ) { throw new URLParseError ( " invalid ▁ inner ▁ URL : ▁ " + e . getMessage ( ) ) ; } if ( ! url . getProtocol ( ) . equals ( " jar " ) ) throw new URLParseError ( " unexpected ▁ protocol ▁ " + url . getProtocol ( ) ) ; setURL ( url , " jar " , url . getHost ( ) , url . getPort ( ) , url_string , null ) ; } /* * STRNEWLINE ▁ * ▁ Makes ▁ the ▁ given ▁ jar ▁ url ▁ string ▁ ' flat ' ▁ by ▁ removing ▁ any ▁ . ▁ and ▁ . . ▁ from STRNEWLINE ▁ * ▁ jar ▁ file ▁ path ▁ because ▁ ZipFile ▁ entries ▁ can ▁ only ▁ handle ▁ flat ▁ paths . STRNEWLINE ▁ * ▁ Inside ▁ jar ▁ files ▁ ' / ' ▁ is ▁ always ▁ the ▁ path ▁ separator . STRNEWLINE ▁ */ private static String flat ( String url_string ) { int jar_stop = url_string . indexOf ( " ! / " ) ; String jar_path = url_string . substring ( jar_stop + 1 , url_string . length ( ) ) ; if ( jar_path . indexOf ( " / . " ) < 0 ) return url_string ; ArrayList < String > tokens = new ArrayList < String > ( ) ; StringTokenizer st = new StringTokenizer ( jar_path , " / " ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( token . equals ( " . " ) ) continue ; else if ( token . equals ( " . . " ) ) { if ( ! tokens . isEmpty ( ) ) tokens . remove ( tokens . size ( ) - 1 ) ; } else tokens . add ( token ) ; } CPStringBuilder path = new CPStringBuilder ( url_string . length ( ) ) ; path . append ( url_string . substring ( 0 , jar_stop + 1 ) ) ; Iterator < String > it = tokens . iterator ( ) ; while ( it . hasNext ( ) ) path . append ( ' / ' ) . append ( it . next ( ) ) ; return path . toString ( ) ; } /* * STRNEWLINE ▁ * ▁ This ▁ method ▁ converts ▁ a ▁ Jar ▁ URL ▁ object ▁ into ▁ a ▁ String . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ url ▁ The ▁ URL ▁ object ▁ to ▁ convert STRNEWLINE ▁ */ protected String toExternalForm ( URL url ) { String file = url . getFile ( ) ; String ref = url . getRef ( ) ; // ▁ return ▁ " jar : " ▁ + ▁ file ; ENDCOM // ▁ Performance ! ! : ENDCOM // ▁ Do ▁ the ▁ concatenation ▁ manually ▁ to ▁ avoid ▁ resize ▁ StringBuffer ' s ENDCOM // ▁ internal ▁ buffer . ▁ The ▁ length ▁ of ▁ ref ▁ is ▁ not ▁ taken ▁ into ▁ consideration ENDCOM // ▁ as ▁ it ' s ▁ a ▁ rare ▁ path . ENDCOM CPStringBuilder sb = new CPStringBuilder ( file . length ( ) + 5 ) ; sb . append ( " jar : " ) ; sb . append ( file ) ; if ( ref != null ) sb . append ( ' # ' ) . append ( ref ) ; return sb . toString ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="innerverse/libjitsi/tree/master/src/org/jitsi/util/xml/DOMElementWriter.java"> /* STRNEWLINE ▁ * ▁ Jitsi , ▁ the ▁ OpenSource ▁ Java ▁ VoIP ▁ and ▁ Instant ▁ Messaging ▁ client . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Distributable ▁ under ▁ LGPL ▁ license . STRNEWLINE ▁ * ▁ See ▁ terms ▁ of ▁ license ▁ at ▁ gnu . org . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ The ▁ code ▁ in ▁ this ▁ class ▁ was ▁ borrowed ▁ from ▁ the ▁ ant ▁ libs ▁ and ▁ included ▁ the STRNEWLINE ▁ * ▁ following ▁ copyright ▁ notice : STRNEWLINE STRNEWLINE ▁ * ▁ Copyright ▁ 2000-2004 ▁ The ▁ Apache ▁ Software ▁ Foundation STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ package org . jitsi . util . xml ; import java . io . * ; import org . w3c . dom . * ; /* * STRNEWLINE ▁ * ▁ Writes ▁ a ▁ DOM ▁ tree ▁ to ▁ a ▁ given ▁ Writer . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ < p > Utility ▁ class ▁ used ▁ by ▁ { @ link ▁ XMLUtils } ▁ and STRNEWLINE ▁ * ▁ { @ link ▁ net . java . sip . communicator . slick . runner . SipCommunicatorSlickRunner } . STRNEWLINE ▁ * ▁ < / p > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ author ▁ Lubomir ▁ Marinov STRNEWLINE ▁ */ public class DOMElementWriter { /* * STRNEWLINE ▁ * ▁ The ▁ system - specific ▁ line ▁ separator ▁ as ▁ defined ▁ by ▁ the ▁ well - known ▁ system STRNEWLINE ▁ * ▁ property . STRNEWLINE ▁ */ private static final String lSep = System . getProperty ( " line . separator " ) ; /* * STRNEWLINE ▁ * ▁ Decodes ▁ an ▁ XML ▁ ( element ) ▁ name ▁ according ▁ to STRNEWLINE ▁ * ▁ http : // www . w3 . org / TR / xml / # NT - Name . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ name ▁ the ▁ XML ▁ ( element ) ▁ name ▁ to ▁ be ▁ decoded STRNEWLINE ▁ * ▁ @ return ▁ a ▁ < tt > String < / tt > ▁ which ▁ represents ▁ < tt > name < / tt > ▁ decoded STRNEWLINE ▁ * ▁ according ▁ to ▁ http : // www . w3 . org / TR / xml / # NT - Name STRNEWLINE ▁ */ public static String decodeName ( String name ) { int length = name . length ( ) ; StringBuilder value = new StringBuilder ( length ) ; for ( int i = 0 ; i < length ; ) { int start = name . indexOf ( ' _ ' , i ) ; /* STRNEWLINE ▁ * ▁ If ▁ there ' s ▁ nothing ▁ else ▁ to ▁ decode , ▁ append ▁ whatever ' s ▁ left ▁ and STRNEWLINE ▁ * ▁ finish . STRNEWLINE ▁ */ if ( start == - 1 ) { value . append ( name , i , length ) ; break ; } /* STRNEWLINE ▁ * ▁ We ▁ may ▁ have ▁ to ▁ decode ▁ from ▁ start ▁ ( inclusive ) . ▁ Append ▁ from ▁ i ▁ to STRNEWLINE ▁ * ▁ start ▁ ( exclusive ) . STRNEWLINE ▁ */ if ( i != start ) value . append ( name , i , start ) ; // ▁ Determine ▁ whether ▁ we ' ll ▁ actually ▁ decode . ENDCOM int end = start + 6 /* ▁ xHHHH _ ▁ */ ; if ( ( end < length ) && ( name . charAt ( start + 1 ) == ' x ' ) && ( name . charAt ( end ) == ' _ ' ) && isHexDigit ( name . charAt ( start + 2 ) ) && isHexDigit ( name . charAt ( start + 3 ) ) && isHexDigit ( name . charAt ( start + 4 ) ) && isHexDigit ( name . charAt ( start + 5 ) ) ) { char c = ( char ) Integer . parseInt ( name . substring ( start + 2 , end ) , 16 ) ; /* STRNEWLINE ▁ * ▁ We ' ve ▁ decoded ▁ a ▁ character . ▁ But ▁ is ▁ it ▁ really ▁ a ▁ character ▁ we ' d STRNEWLINE ▁ * ▁ have ▁ encoded ▁ in ▁ the ▁ first ▁ place ? ▁ We ▁ don ' t ▁ want ▁ to STRNEWLINE ▁ * ▁ accidentally ▁ decode ▁ a ▁ string ▁ just ▁ because ▁ it ▁ looked ▁ like ▁ an STRNEWLINE ▁ * ▁ encoded ▁ character . STRNEWLINE ▁ */ if ( ( start == 0 ) ? ! isNameStartChar ( c ) : ! isNameChar ( c ) ) { value . append ( c ) ; i = end + 1 ; continue ; } } // ▁ We ▁ didn ' t ▁ really ▁ have ▁ to ▁ decode ▁ and ▁ the ▁ string ▁ was ▁ a ▁ literal . ENDCOM value . append ( name . charAt ( start ) ) ; i = start + 1 ; } return value . toString ( ) ; } /* * STRNEWLINE ▁ * ▁ Encodes ▁ a ▁ specific ▁ < tt > String < / tt > ▁ so ▁ that ▁ it ▁ is ▁ a ▁ valid ▁ XML ▁ ( element ) STRNEWLINE ▁ * ▁ name ▁ according ▁ to ▁ http : // www . w3 . org / TR / xml / # NT - Name . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ value ▁ the ▁ < tt > String < / tt > ▁ to ▁ be ▁ encoded ▁ so ▁ that ▁ it ▁ is ▁ a ▁ valid ▁ XML STRNEWLINE ▁ * ▁ name STRNEWLINE ▁ * ▁ @ return ▁ a ▁ < tt > String < / tt > ▁ which ▁ represents ▁ < tt > value < / tt > ▁ encoded ▁ so ▁ that STRNEWLINE ▁ * ▁ it ▁ is ▁ a ▁ valid ▁ XML ▁ ( element ) ▁ name STRNEWLINE ▁ */ public static String encodeName ( String value ) { int length = value . length ( ) ; StringBuilder name = new StringBuilder ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char c = value . charAt ( i ) ; if ( i == 0 ) { if ( isNameStartChar ( c ) ) { name . append ( c ) ; continue ; } } else if ( isNameChar ( c ) ) { name . append ( c ) ; continue ; } name . append ( " _ x " ) ; if ( c <= 0x000F ) name . append ( "000" ) ; else if ( c <= 0x00FF ) name . append ( "00" ) ; else if ( c <= 0x0FFF ) name . append ( '0' ) ; name . append ( Integer . toHexString ( c ) . toUpperCase ( ) ) ; name . append ( ' _ ' ) ; } return name . toString ( ) ; } /* * STRNEWLINE ▁ * ▁ Determines ▁ whether ▁ a ▁ specific ▁ character ▁ represents ▁ a ▁ hex ▁ digit . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ c ▁ the ▁ character ▁ to ▁ be ▁ checked ▁ whether ▁ it ▁ represents ▁ a ▁ hex ▁ digit STRNEWLINE ▁ * ▁ @ return ▁ < tt > true < / tt > ▁ if ▁ the ▁ specified ▁ character ▁ represents ▁ a ▁ hex ▁ digit ; STRNEWLINE ▁ * ▁ otherwise , ▁ < tt > false < / tt > STRNEWLINE ▁ */ private static boolean isHexDigit ( char c ) { return ( ( '0' <= c ) && ( c <= '9' ) ) || ( ( ' A ' <= c ) && ( c <= ' F ' ) ) || ( ( ' a ' <= c ) && ( c <= ' f ' ) ) ; } /* * STRNEWLINE ▁ * ▁ Determines ▁ whether ▁ a ▁ specific ▁ characters ▁ is ▁ a ▁ < tt > NameChar < / tt > ▁ as STRNEWLINE ▁ * ▁ defined ▁ by ▁ http : // www . w3 . org / TR / xml / # NT - Name . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ c ▁ the ▁ character ▁ which ▁ is ▁ to ▁ be ▁ determines ▁ whether ▁ it ▁ is ▁ a STRNEWLINE ▁ * ▁ < tt > NameChar < / tt > STRNEWLINE ▁ * ▁ @ return ▁ < tt > true < / tt > ▁ if ▁ the ▁ specified ▁ character ▁ is ▁ a ▁ < tt > NameChar < / tt > ; STRNEWLINE ▁ * ▁ otherwise , ▁ < tt > false < / tt > STRNEWLINE ▁ */ private static boolean isNameChar ( char c ) { if ( isNameStartChar ( c ) ) return true ; else if ( ( c == ' - ' ) || ( c == ' . ' ) ) return true ; else if ( ( '0' <= c ) && ( c <= '9' ) ) return true ; else if ( c == 0xB7 ) return true ; else if ( c < 0x0300 ) return false ; else if ( c <= 0x036F ) return true ; else if ( c < 0x203F ) return false ; else if ( c <= 0x2040 ) return true ; else return false ; } /* * STRNEWLINE ▁ * ▁ Determines ▁ whether ▁ a ▁ specific ▁ characters ▁ is ▁ a ▁ < tt > NameStartChar < / tt > ▁ as STRNEWLINE ▁ * ▁ defined ▁ by ▁ http : // www . w3 . org / TR / xml / # NT - Name . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ c ▁ the ▁ character ▁ to ▁ be ▁ determined ▁ whether ▁ it ▁ is ▁ a STRNEWLINE ▁ * ▁ < tt > NameStartChar < / tt > STRNEWLINE ▁ * ▁ @ return ▁ < tt > true < / tt > ▁ if ▁ the ▁ specified ▁ character ▁ is ▁ a STRNEWLINE ▁ * ▁ < tt > NameStartChar < / tt > ; ▁ otherwise , ▁ < tt > false < / tt > STRNEWLINE ▁ */ private static boolean isNameStartChar ( char c ) { if ( ( c == ' : ' ) || ( c == ' _ ' ) ) return true ; else if ( ( ' A ' <= c ) && ( c <= ' Z ' ) ) return true ; else if ( ( ' a ' <= c ) && ( c <= ' z ' ) ) return true ; else if ( c < 0xC0 ) return false ; else if ( c <= 0xD6 ) return true ; else if ( c < 0xD8 ) return false ; else if ( c <= 0xF6 ) return true ; else if ( c < 0xF8 ) return false ; else if ( c <= 0x2FF ) return true ; else if ( c < 0x370 ) return false ; else if ( c <= 0x37D ) return true ; else if ( c < 0x37F ) return false ; else if ( c <= 0x1FFF ) return true ; else if ( c < 0x200C ) return false ; else if ( c <= 0x200D ) return true ; else if ( c < 0x2070 ) return false ; else if ( c <= 0x218F ) return true ; else if ( c < 0x2C00 ) return false ; else if ( c <= 0x2FEF ) return true ; else if ( c < 0x3001 ) return false ; else if ( c <= 0xD7FF ) return true ; else if ( c < 0xF900 ) return false ; else if ( c <= 0xFDCF ) return true ; else if ( c < 0xFDF0 ) return false ; else if ( c <= 0xFFFD ) return true ; // ▁ else ▁ if ▁ ( c ▁ < ▁ 0x10000 ) ENDCOM // ▁ return ▁ false ; ENDCOM // ▁ else ▁ if ▁ ( c ▁ < = ▁ 0xEFFFF ) ENDCOM // ▁ return ▁ true ; ENDCOM else return false ; } /* * STRNEWLINE ▁ * ▁ Don ' t ▁ try ▁ to ▁ be ▁ too ▁ smart ▁ but ▁ at ▁ least ▁ recognize ▁ the ▁ predefined STRNEWLINE ▁ * ▁ entities . STRNEWLINE ▁ */ protected String [ ] knownEntities = { " gt " , " amp " , " lt " , " apos " , " quot " } ; /* * STRNEWLINE ▁ * ▁ Writes ▁ a ▁ DOM ▁ tree ▁ to ▁ a ▁ stream ▁ in ▁ UTF8 ▁ encoding . ▁ Note ▁ that STRNEWLINE ▁ * ▁ it ▁ prepends ▁ the ▁ & lt ; ? xml ▁ version = ' 1.0 ' ▁ encoding = ' UTF - 8 ' ? & gt ; . STRNEWLINE ▁ * ▁ The ▁ indent ▁ number ▁ is ▁ set ▁ to ▁ 0 ▁ and ▁ a ▁ 2 - space ▁ indent . STRNEWLINE ▁ * ▁ @ param ▁ root ▁ the ▁ root ▁ element ▁ of ▁ the ▁ DOM ▁ tree . STRNEWLINE ▁ * ▁ @ param ▁ out ▁ the ▁ outputstream ▁ to ▁ write ▁ to . STRNEWLINE ▁ * ▁ @ throws ▁ IOException ▁ if ▁ an ▁ error ▁ happens ▁ while ▁ writing ▁ to ▁ the ▁ stream . STRNEWLINE ▁ */ public void write ( Element root , OutputStream out ) throws IOException { Writer wri = new OutputStreamWriter ( out , " UTF - 8" ) ; wri . write ( " < ? xml ▁ version = \ " 1.0\ " ▁ encoding = \ " UTF - 8\ " ? > " + lSep ) ; write ( root , wri , 0 , " ▁ ▁ " ) ; wri . flush ( ) ; } /* * STRNEWLINE ▁ * ▁ Writes ▁ a ▁ DOM ▁ tree ▁ to ▁ a ▁ stream . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ element ▁ the ▁ Root ▁ DOM ▁ element ▁ of ▁ the ▁ tree STRNEWLINE ▁ * ▁ @ param ▁ out ▁ where ▁ to ▁ send ▁ the ▁ output STRNEWLINE ▁ * ▁ @ param ▁ indent ▁ number ▁ of STRNEWLINE ▁ * ▁ @ param ▁ indentWith ▁ string ▁ that ▁ should ▁ be ▁ used ▁ to ▁ indent ▁ the ▁ corresponding ▁ tag . STRNEWLINE ▁ * ▁ @ throws ▁ IOException ▁ if ▁ an ▁ error ▁ happens ▁ while ▁ writing ▁ to ▁ the ▁ stream . STRNEWLINE ▁ */ public void write ( Node element , Writer out , int indent , String indentWith ) throws IOException { // ▁ Write ▁ indent ▁ characters ENDCOM for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } if ( element . getNodeType ( ) == Node . COMMENT_NODE ) { out . write ( " < ! - - " ) ; out . write ( encode ( element . getNodeValue ( ) ) ) ; out . write ( " - - > " ) ; } else { // ▁ Write ▁ element ENDCOM out . write ( " < " ) ; out . write ( ( ( Element ) element ) . getTagName ( ) ) ; // ▁ Write ▁ attributes ENDCOM NamedNodeMap attrs = element . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; out . write ( " ▁ " ) ; out . write ( attr . getName ( ) ) ; out . write ( " = \ " " ) ; out . write ( encode ( attr . getValue ( ) ) ) ; out . write ( " \ " " ) ; } out . write ( " > " ) ; } // ▁ Write ▁ child ▁ elements ▁ and ▁ text ENDCOM boolean hasChildren = false ; NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; element . hasChildNodes ( ) && i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . ELEMENT_NODE : case Node . COMMENT_NODE : if ( ! hasChildren ) { out . write ( lSep ) ; hasChildren = true ; } write ( child , out , indent + 1 , indentWith ) ; break ; case Node . TEXT_NODE : // if ▁ this ▁ is ▁ a ▁ new ▁ line ▁ don ' t ▁ print ▁ it ▁ as ▁ we ▁ print ▁ our ▁ own . ENDCOM if ( child . getNodeValue ( ) != null && ( child . getNodeValue ( ) . indexOf ( " \n " ) == - 1 || child . getNodeValue ( ) . trim ( ) . length ( ) != 0 ) ) out . write ( encode ( child . getNodeValue ( ) ) ) ; break ; case Node . CDATA_SECTION_NODE : out . write ( " < ! [ CDATA [ " ) ; out . write ( encodedata ( ( ( Text ) child ) . getData ( ) ) ) ; out . write ( " ] ] > " ) ; break ; case Node . ENTITY_REFERENCE_NODE : out . write ( ' & ' ) ; out . write ( child . getNodeName ( ) ) ; out . write ( ' ; ' ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : out . write ( " < ? " ) ; out . write ( child . getNodeName ( ) ) ; String data = child . getNodeValue ( ) ; if ( data != null && data . length ( ) > 0 ) { out . write ( ' ▁ ' ) ; out . write ( data ) ; } out . write ( " ? > " ) ; break ; } } // ▁ If ▁ we ▁ had ▁ child ▁ elements , ▁ we ▁ need ▁ to ▁ indent ▁ before ▁ we ▁ close ENDCOM // ▁ the ▁ element , ▁ otherwise ▁ we ' re ▁ on ▁ the ▁ same ▁ line ▁ and ▁ don ' t ▁ need ENDCOM // ▁ to ▁ indent ENDCOM if ( hasChildren ) { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } } // ▁ Write ▁ element ▁ close ENDCOM if ( element . getNodeType ( ) == Node . ELEMENT_NODE ) { out . write ( " < / " ) ; out . write ( ( ( Element ) element ) . getTagName ( ) ) ; out . write ( " > " ) ; } out . write ( lSep ) ; out . flush ( ) ; } /* * STRNEWLINE ▁ * ▁ Escape ▁ & lt ; , ▁ & gt ; ▁ & amp ; ▁ & apos ; , ▁ & quot ; ▁ as ▁ their ▁ entities ▁ and STRNEWLINE ▁ * ▁ drop ▁ characters ▁ that ▁ are ▁ illegal ▁ in ▁ XML ▁ documents . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ value ▁ the ▁ value ▁ to ▁ encode STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ a ▁ String ▁ containing ▁ the ▁ encoded ▁ element . STRNEWLINE ▁ */ public String encode ( String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case ' < ' : sb . append ( " & lt ; " ) ; break ; case ' > ' : sb . append ( " & gt ; " ) ; break ; case ' \ ' ' : sb . append ( " & apos ; " ) ; break ; case ' \ " ' : sb . append ( " & quot ; " ) ; break ; case ' & ' : int nextSemi = value . indexOf ( " ; " , i ) ; if ( ( nextSemi < 0 ) || ! isReference ( value . substring ( i , nextSemi + 1 ) ) ) sb . append ( " & amp ; " ) ; else sb . append ( ' & ' ) ; break ; default : if ( isLegalCharacter ( c ) ) sb . append ( c ) ; break ; } } return sb . substring ( 0 ) ; } /* * STRNEWLINE ▁ * ▁ Drop ▁ characters ▁ that ▁ are ▁ illegal ▁ in ▁ XML ▁ documents . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ < p > Also ▁ ensure ▁ that ▁ we ▁ are ▁ not ▁ including ▁ an ▁ < tt > ] ] & gt ; < / tt > STRNEWLINE ▁ * ▁ marker ▁ by ▁ replacing ▁ that ▁ sequence ▁ with STRNEWLINE ▁ * ▁ < tt > & amp ; # x5d ; & amp ; # x5d ; & amp ; gt ; < / tt > . < / p > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ < p > See ▁ XML ▁ 1.0 ▁ 2.2 ▁ < a STRNEWLINE ▁ * ▁ href = " http : // www . w3 . org / TR / 1998 / REC - xml - 19980210 # charsets " > http : // www . w3 . org / TR / 1998 / REC - xml - 19980210 # charsets < / a > ▁ and STRNEWLINE ▁ * ▁ 2.7 ▁ < a STRNEWLINE ▁ * ▁ href = " http : // www . w3 . org / TR / 1998 / REC - xml - 19980210 # sec - cdata - sect " > http : // www . w3 . org / TR / 1998 / REC - xml - 19980210 # sec - cdata - sect < / a > . < / p > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ value ▁ the ▁ value ▁ to ▁ encode STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ a ▁ String ▁ containing ▁ the ▁ encoded ▁ value . STRNEWLINE ▁ */ public String encodedata ( final String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) { char c = value . charAt ( i ) ; if ( isLegalCharacter ( c ) ) { sb . append ( c ) ; } } String result = sb . substring ( 0 ) ; int cdEnd = result . indexOf ( " ] ] > " ) ; while ( cdEnd != - 1 ) { sb . setLength ( cdEnd ) ; sb . append ( " & # x5d ; & # x5d ; & gt ; " ) . append ( result . substring ( cdEnd + 3 ) ) ; result = sb . substring ( 0 ) ; cdEnd = result . indexOf ( " ] ] > " ) ; } return result ; } /* * STRNEWLINE ▁ * ▁ Is ▁ the ▁ given ▁ argument ▁ a ▁ character ▁ or ▁ entity ▁ reference ? STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ ent ▁ the ▁ string ▁ whose ▁ nature ▁ we ▁ need ▁ to ▁ determine . STRNEWLINE ▁ * ▁ @ return ▁ < tt > true < / tt > ▁ if ▁ < tt > ent < / tt > ▁ is ▁ an ▁ entity ▁ reference ▁ and STRNEWLINE ▁ * ▁ < tt > false < / tt > ▁ otherwise . STRNEWLINE ▁ */ public boolean isReference ( String ent ) { if ( ! ( ent . charAt ( 0 ) == ' & ' ) || ! ent . endsWith ( " ; " ) ) return false ; if ( ent . charAt ( 1 ) == ' # ' ) { if ( ent . charAt ( 2 ) == ' x ' ) { try { Integer . parseInt ( ent . substring ( 3 , ent . length ( ) - 1 ) , 16 ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } else { try { Integer . parseInt ( ent . substring ( 2 , ent . length ( ) - 1 ) ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } } String name = ent . substring ( 1 , ent . length ( ) - 1 ) ; for ( int i = 0 ; i < knownEntities . length ; i ++ ) { if ( name . equals ( knownEntities [ i ] ) ) { return true ; } } return false ; } /* * STRNEWLINE ▁ * ▁ Is ▁ the ▁ given ▁ character ▁ allowed ▁ inside ▁ an ▁ XML ▁ document ? STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ < p > See ▁ XML ▁ 1.0 ▁ 2.2 ▁ < a STRNEWLINE ▁ * ▁ href = " http : // www . w3 . org / TR / 1998 / REC - xml - 19980210 # charsets " > STRNEWLINE ▁ * ▁ http : // www . w3 . org / TR / 1998 / REC - xml - 19980210 # charsets < / a > . < / p > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ since ▁ 1.10 , ▁ Ant ▁ 1.5 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ c ▁ the ▁ character ▁ whose ▁ nature ▁ we ' d ▁ like ▁ to ▁ determine . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ true ▁ if ▁ c ▁ is ▁ a ▁ legal ▁ character ▁ and ▁ false ▁ otherwise STRNEWLINE ▁ */ public boolean isLegalCharacter ( char c ) { if ( c == 0x9 || c == 0xA || c == 0xD ) { return true ; } else if ( c < 0x20 ) { return false ; } else if ( c <= 0xD7FF ) { return true ; } else if ( c < 0xE000 ) { return false ; } else if ( c <= 0xFFFD ) { return true ; } return false ; } } </DOCUMENT>
<DOCUMENT_ID="Metaswitch/jitsi/tree/master/src/net/java/sip/communicator/impl/protocol/rss/ContactGroupRssImpl.java"> /* STRNEWLINE ▁ * ▁ Jitsi , ▁ the ▁ OpenSource ▁ Java ▁ VoIP ▁ and ▁ Instant ▁ Messaging ▁ client . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Distributable ▁ under ▁ LGPL ▁ license . STRNEWLINE ▁ * ▁ See ▁ terms ▁ of ▁ license ▁ at ▁ gnu . org . STRNEWLINE ▁ */ package net . java . sip . communicator . impl . protocol . rss ; import java . util . * ; import net . java . sip . communicator . service . protocol . * ; /* * STRNEWLINE ▁ * ▁ A ▁ simple , ▁ straightforward ▁ implementation ▁ of ▁ a ▁ rss ▁ ContactGroup . ▁ Since STRNEWLINE ▁ * ▁ the ▁ Rss ▁ protocol ▁ is ▁ not ▁ a ▁ real ▁ one , ▁ we ▁ simply ▁ store ▁ all ▁ group ▁ details STRNEWLINE ▁ * ▁ in ▁ class ▁ fields . ▁ You ▁ should ▁ know ▁ that ▁ when ▁ implementing ▁ a ▁ real ▁ protocol , STRNEWLINE ▁ * ▁ the ▁ contact ▁ group ▁ implementation ▁ would ▁ rather ▁ encapsulate ▁ group ▁ objects ▁ from STRNEWLINE ▁ * ▁ the ▁ protocol ▁ stack ▁ and ▁ group ▁ property ▁ values ▁ should ▁ be ▁ returned ▁ by ▁ consulting STRNEWLINE ▁ * ▁ the ▁ encapsulated ▁ object . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ author ▁ Emil ▁ Ivov STRNEWLINE ▁ */ public class ContactGroupRssImpl implements ContactGroup { /* * STRNEWLINE ▁ * ▁ The ▁ name ▁ of ▁ this ▁ Rss ▁ contact ▁ group . STRNEWLINE ▁ */ private String groupName = null ; /* * STRNEWLINE ▁ * ▁ The ▁ list ▁ of ▁ this ▁ group ' s ▁ members . STRNEWLINE ▁ */ private Vector < Contact > contacts = new Vector < Contact > ( ) ; /* * STRNEWLINE ▁ * ▁ The ▁ list ▁ of ▁ sub ▁ groups ▁ belonging ▁ to ▁ this ▁ group . STRNEWLINE ▁ */ private Vector < ContactGroup > subGroups = new Vector < ContactGroup > ( ) ; /* * STRNEWLINE ▁ * ▁ The ▁ group ▁ that ▁ this ▁ group ▁ belongs ▁ to ▁ ( or ▁ null ▁ if ▁ this ▁ is ▁ the ▁ root ▁ group ) . STRNEWLINE ▁ */ private ContactGroupRssImpl parentGroup = null ; /* * STRNEWLINE ▁ * ▁ Determines ▁ whether ▁ this ▁ group ▁ is ▁ really ▁ in ▁ the ▁ contact ▁ list ▁ or ▁ whether STRNEWLINE ▁ * ▁ it ▁ is ▁ here ▁ only ▁ temporarily ▁ and ▁ will ▁ be ▁ gone ▁ next ▁ time ▁ we ▁ restart . STRNEWLINE ▁ */ private boolean isPersistent = true ; /* * STRNEWLINE ▁ * ▁ The ▁ protocol ▁ provider ▁ that ▁ created ▁ us . STRNEWLINE ▁ */ private ProtocolProviderServiceRssImpl parentProvider = null ; /* * STRNEWLINE ▁ * ▁ Determines ▁ whether ▁ this ▁ group ▁ has ▁ been ▁ resolved ▁ on ▁ the ▁ server . STRNEWLINE ▁ * ▁ Unresolved ▁ groups ▁ are ▁ groups ▁ that ▁ were ▁ available ▁ on ▁ previous ▁ runs ▁ and STRNEWLINE ▁ * ▁ that ▁ the ▁ meta ▁ contact ▁ list ▁ has ▁ stored . ▁ During ▁ all ▁ next ▁ runs , ▁ when STRNEWLINE ▁ * ▁ bootstrapping , ▁ the ▁ meta ▁ contact ▁ list ▁ would ▁ create ▁ these ▁ groups ▁ as STRNEWLINE ▁ * ▁ unresolved . ▁ Once ▁ a ▁ protocol ▁ provider ▁ implementation ▁ confirms ▁ that ▁ the STRNEWLINE ▁ * ▁ groups ▁ are ▁ still ▁ on ▁ the ▁ server , ▁ it ▁ would ▁ issue ▁ an ▁ event ▁ indicating ▁ that STRNEWLINE ▁ * ▁ the ▁ groups ▁ are ▁ now ▁ resolved . STRNEWLINE ▁ */ private boolean isResolved = true ; /* * STRNEWLINE ▁ * ▁ An ▁ id ▁ uniquely ▁ identifying ▁ the ▁ group . ▁ For ▁ many ▁ protocols ▁ this ▁ could ▁ be STRNEWLINE ▁ * ▁ the ▁ group ▁ name ▁ itself . STRNEWLINE ▁ */ private String uid = null ; private static final String UID_SUFFIX = " . uid " ; /* * STRNEWLINE ▁ * ▁ Creates ▁ a ▁ ContactGroupRssImpl ▁ with ▁ the ▁ specified ▁ name . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ groupName ▁ the ▁ name ▁ of ▁ the ▁ group . STRNEWLINE ▁ * ▁ @ param ▁ parentProvider ▁ the ▁ protocol ▁ provider ▁ that ▁ created ▁ this ▁ group . STRNEWLINE ▁ */ public ContactGroupRssImpl ( String groupName , ProtocolProviderServiceRssImpl parentProvider ) { this . groupName = groupName ; this . uid = groupName + UID_SUFFIX ; this . parentProvider = parentProvider ; } /* * STRNEWLINE ▁ * ▁ Determines ▁ whether ▁ the ▁ group ▁ may ▁ contain ▁ subgroups ▁ or ▁ not . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ always ▁ true ▁ in ▁ this ▁ implementation . STRNEWLINE ▁ */ public boolean canContainSubgroups ( ) { return true ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ protocol ▁ provider ▁ that ▁ this ▁ group ▁ belongs ▁ to . STRNEWLINE ▁ * ▁ @ return ▁ a ▁ regerence ▁ to ▁ the ▁ ProtocolProviderService ▁ instance ▁ that ▁ this STRNEWLINE ▁ * ▁ ContactGroup ▁ belongs ▁ to . STRNEWLINE ▁ */ public ProtocolProviderService getProtocolProvider ( ) { return parentProvider ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ an ▁ Iterator ▁ over ▁ all ▁ contacts , ▁ member ▁ of ▁ this STRNEWLINE ▁ * ▁ < tt > ContactGroup < / tt > . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ a ▁ java . util . Iterator ▁ over ▁ all ▁ contacts ▁ inside ▁ this STRNEWLINE ▁ * ▁ < tt > ContactGroup < / tt > STRNEWLINE ▁ */ public Iterator < Contact > contacts ( ) { return contacts . iterator ( ) ; } /* * STRNEWLINE ▁ * ▁ Adds ▁ the ▁ specified ▁ contact ▁ to ▁ this ▁ group . STRNEWLINE ▁ * ▁ @ param ▁ contactToAdd ▁ the ▁ ContactRssImpl ▁ to ▁ add ▁ to ▁ this ▁ group . STRNEWLINE ▁ */ public void addContact ( ContactRssImpl contactToAdd ) { this . contacts . add ( contactToAdd ) ; contactToAdd . setParentGroup ( this ) ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ number ▁ of ▁ < tt > Contact < / tt > ▁ members ▁ of ▁ this STRNEWLINE ▁ * ▁ < tt > ContactGroup < / tt > STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ an ▁ int ▁ indicating ▁ the ▁ number ▁ of ▁ < tt > Contact < / tt > s , ▁ members ▁ of STRNEWLINE ▁ * ▁ this ▁ < tt > ContactGroup < / tt > . STRNEWLINE ▁ */ public int countContacts ( ) { return contacts . size ( ) ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ number ▁ of ▁ subgroups ▁ contained ▁ by ▁ this STRNEWLINE ▁ * ▁ < tt > ContactGroup < / tt > . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ the ▁ number ▁ of ▁ subGroups ▁ currently ▁ added ▁ to ▁ this ▁ group . STRNEWLINE ▁ */ public int countSubgroups ( ) { return subGroups . size ( ) ; } /* * STRNEWLINE ▁ * ▁ Adds ▁ the ▁ specified ▁ contact ▁ group ▁ to ▁ the ▁ contained ▁ by ▁ this ▁ group . STRNEWLINE ▁ * ▁ @ param ▁ subgroup ▁ the ▁ ContactGroupRssImpl ▁ to ▁ add ▁ as ▁ a ▁ subgroup ▁ to ▁ this ▁ group . STRNEWLINE ▁ */ public void addSubgroup ( ContactGroupRssImpl subgroup ) { this . subGroups . add ( subgroup ) ; subgroup . setParentGroup ( this ) ; } /* * STRNEWLINE ▁ * ▁ Sets ▁ the ▁ group ▁ that ▁ is ▁ the ▁ new ▁ parent ▁ of ▁ this ▁ group STRNEWLINE ▁ * ▁ @ param ▁ parent ▁ ContactGroupRssImpl STRNEWLINE ▁ */ void setParentGroup ( ContactGroupRssImpl parent ) { this . parentGroup = parent ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ contact ▁ group ▁ that ▁ currently ▁ contains ▁ this ▁ group ▁ or ▁ null ▁ if STRNEWLINE ▁ * ▁ this ▁ is ▁ the ▁ root ▁ contact ▁ group . STRNEWLINE ▁ * ▁ @ return ▁ the ▁ contact ▁ group ▁ that ▁ currently ▁ contains ▁ this ▁ group ▁ or ▁ null ▁ if STRNEWLINE ▁ * ▁ this ▁ is ▁ the ▁ root ▁ contact ▁ group . STRNEWLINE ▁ */ public ContactGroup getParentContactGroup ( ) { return this . parentGroup ; } /* * STRNEWLINE ▁ * ▁ Removes ▁ the ▁ specified ▁ contact ▁ group ▁ from ▁ the ▁ this ▁ group ' s ▁ subgroups . STRNEWLINE ▁ * ▁ @ param ▁ subgroup ▁ the ▁ ContactGroupRssImpl ▁ subgroup ▁ to ▁ remove . STRNEWLINE ▁ */ public void removeSubGroup ( ContactGroupRssImpl subgroup ) { this . subGroups . remove ( subgroup ) ; subgroup . setParentGroup ( null ) ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ group ▁ that ▁ is ▁ parent ▁ of ▁ the ▁ specified ▁ rssGroup ▁ or ▁ null STRNEWLINE ▁ * ▁ if ▁ no ▁ parent ▁ was ▁ found . STRNEWLINE ▁ * ▁ @ param ▁ rssGroup ▁ the ▁ group ▁ whose ▁ parent ▁ we ' re ▁ looking ▁ for . STRNEWLINE ▁ * ▁ @ return ▁ the ▁ ContactGroupRssImpl ▁ instance ▁ that ▁ rssGroup STRNEWLINE ▁ * ▁ belongs ▁ to ▁ or ▁ null ▁ if ▁ no ▁ parent ▁ was ▁ found . STRNEWLINE ▁ */ public ContactGroupRssImpl findGroupParent ( ContactGroupRssImpl rssGroup ) { if ( subGroups . contains ( rssGroup ) ) return this ; Iterator < ContactGroup > subGroupsIter = subgroups ( ) ; while ( subGroupsIter . hasNext ( ) ) { ContactGroupRssImpl subgroup = ( ContactGroupRssImpl ) subGroupsIter . next ( ) ; ContactGroupRssImpl parent = subgroup . findGroupParent ( rssGroup ) ; if ( parent != null ) return parent ; } return null ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ group ▁ that ▁ is ▁ parent ▁ of ▁ the ▁ specified ▁ rssContact ▁ or STRNEWLINE ▁ * ▁ null ▁ if ▁ no ▁ parent ▁ was ▁ found . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ rssContact ▁ the ▁ contact ▁ whose ▁ parent ▁ we ' re ▁ looking ▁ for . STRNEWLINE ▁ * ▁ @ return ▁ the ▁ ContactGroupRssImpl ▁ instance ▁ that ▁ rssContact STRNEWLINE ▁ * ▁ belongs ▁ to ▁ or ▁ < tt > null < / tt > ▁ if ▁ no ▁ parent ▁ was ▁ found . STRNEWLINE ▁ */ public ContactGroupRssImpl findContactParent ( ContactRssImpl rssContact ) { if ( contacts . contains ( rssContact ) ) return this ; Iterator < ContactGroup > subGroupsIter = subgroups ( ) ; while ( subGroupsIter . hasNext ( ) ) { ContactGroupRssImpl subgroup = ( ContactGroupRssImpl ) subGroupsIter . next ( ) ; ContactGroupRssImpl parent = subgroup . findContactParent ( rssContact ) ; if ( parent != null ) return parent ; } return null ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ < tt > Contact < / tt > ▁ with ▁ the ▁ specified ▁ address ▁ or ▁ identifier . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ id ▁ the ▁ addres ▁ or ▁ identifier ▁ of ▁ the ▁ < tt > Contact < / tt > ▁ we ▁ are STRNEWLINE ▁ * ▁ looking ▁ for . STRNEWLINE ▁ * ▁ @ return ▁ the ▁ < tt > Contact < / tt > ▁ with ▁ the ▁ specified ▁ id ▁ or ▁ address . STRNEWLINE ▁ */ public Contact getContact ( String id ) { Iterator < Contact > contactsIter = contacts ( ) ; while ( contactsIter . hasNext ( ) ) { ContactRssImpl contact = ( ContactRssImpl ) contactsIter . next ( ) ; if ( contact . getAddress ( ) . equals ( id ) ) return contact ; } return null ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ subgroup ▁ with ▁ the ▁ specified ▁ index . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ index ▁ the ▁ index ▁ of ▁ the ▁ < tt > ContactGroup < / tt > ▁ to ▁ retrieve . STRNEWLINE ▁ * ▁ @ return ▁ the ▁ < tt > ContactGroup < / tt > ▁ with ▁ the ▁ specified ▁ index . STRNEWLINE ▁ */ public ContactGroup getGroup ( int index ) { return subGroups . get ( index ) ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ subgroup ▁ with ▁ the ▁ specified ▁ name . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ groupName ▁ the ▁ name ▁ of ▁ the ▁ < tt > ContactGroup < / tt > ▁ to ▁ retrieve . STRNEWLINE ▁ * ▁ @ return ▁ the ▁ < tt > ContactGroup < / tt > ▁ with ▁ the ▁ specified ▁ index . STRNEWLINE ▁ */ public ContactGroup getGroup ( String groupName ) { Iterator < ContactGroup > groupsIter = subgroups ( ) ; while ( groupsIter . hasNext ( ) ) { ContactGroupRssImpl contactGroup = ( ContactGroupRssImpl ) groupsIter . next ( ) ; if ( contactGroup . getGroupName ( ) . equals ( groupName ) ) return contactGroup ; } return null ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ name ▁ of ▁ this ▁ group . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ a ▁ String ▁ containing ▁ the ▁ name ▁ of ▁ this ▁ group . STRNEWLINE ▁ */ public String getGroupName ( ) { return this . groupName ; } /* * STRNEWLINE ▁ * ▁ Sets ▁ this ▁ group ▁ a ▁ new ▁ name . STRNEWLINE ▁ * ▁ @ param ▁ newGrpName ▁ a ▁ String ▁ containing ▁ the ▁ new ▁ name ▁ of ▁ this ▁ group . STRNEWLINE ▁ */ public void setGroupName ( String newGrpName ) { this . groupName = newGrpName ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ an ▁ iterator ▁ over ▁ the ▁ sub ▁ groups ▁ that ▁ this STRNEWLINE ▁ * ▁ < tt > ContactGroup < / tt > ▁ contains . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ a ▁ java . util . Iterator ▁ over ▁ the ▁ < tt > ContactGroup < / tt > ▁ children STRNEWLINE ▁ * ▁ of ▁ this ▁ group ▁ ( i . e . ▁ subgroups ) . STRNEWLINE ▁ */ public Iterator < ContactGroup > subgroups ( ) { return subGroups . iterator ( ) ; } /* * STRNEWLINE ▁ * ▁ Removes ▁ the ▁ specified ▁ contact ▁ from ▁ this ▁ group . STRNEWLINE ▁ * ▁ @ param ▁ contact ▁ the ▁ ContactRssImpl ▁ to ▁ remove ▁ from ▁ this ▁ group STRNEWLINE ▁ */ public void removeContact ( ContactRssImpl contact ) { this . contacts . remove ( contact ) ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ contact ▁ with ▁ the ▁ specified ▁ id ▁ or ▁ null ▁ if ▁ no ▁ such ▁ contact STRNEWLINE ▁ * ▁ exists . STRNEWLINE ▁ * ▁ @ param ▁ id ▁ the ▁ id ▁ of ▁ the ▁ contact ▁ we ' re ▁ looking ▁ for . STRNEWLINE ▁ * ▁ @ return ▁ ContactRssImpl STRNEWLINE ▁ */ public ContactRssImpl findContactByID ( String id ) { // first ▁ go ▁ through ▁ the ▁ contacts ▁ that ▁ are ▁ direct ▁ children . ENDCOM Iterator < Contact > contactsIter = contacts ( ) ; while ( contactsIter . hasNext ( ) ) { ContactRssImpl mContact = ( ContactRssImpl ) contactsIter . next ( ) ; if ( mContact . getAddress ( ) . equals ( id ) ) return mContact ; } // if ▁ we ▁ didn ' t ▁ find ▁ it ▁ here , ▁ let ' s ▁ try ▁ in ▁ the ▁ subougroups ENDCOM Iterator < ContactGroup > groupsIter = subgroups ( ) ; while ( groupsIter . hasNext ( ) ) { ContactGroupRssImpl mGroup = ( ContactGroupRssImpl ) groupsIter . next ( ) ; ContactRssImpl mContact = mGroup . findContactByID ( id ) ; if ( mContact != null ) return mContact ; } return null ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ a ▁ String ▁ representation ▁ of ▁ this ▁ group ▁ and ▁ the ▁ contacts ▁ it STRNEWLINE ▁ * ▁ contains ▁ ( may ▁ turn ▁ out ▁ to ▁ be ▁ a ▁ relatively ▁ long ▁ string ) . STRNEWLINE ▁ * ▁ @ return ▁ a ▁ String ▁ representing ▁ this ▁ group ▁ and ▁ its ▁ child ▁ contacts . STRNEWLINE ▁ */ @ Override public String toString ( ) { StringBuffer buff = new StringBuffer ( getGroupName ( ) ) ; buff . append ( " . subGroups = " + countSubgroups ( ) + " : \n " ) ; Iterator < ContactGroup > subGroups = subgroups ( ) ; while ( subGroups . hasNext ( ) ) { ContactGroupRssImpl group = ( ContactGroupRssImpl ) subGroups . next ( ) ; buff . append ( group . toString ( ) ) ; if ( subGroups . hasNext ( ) ) buff . append ( " \n " ) ; } buff . append ( " \n ChildContacts = " + countContacts ( ) + " : [ " ) ; Iterator < Contact > contacts = contacts ( ) ; while ( contacts . hasNext ( ) ) { ContactRssImpl contact = ( ContactRssImpl ) contacts . next ( ) ; buff . append ( contact . toString ( ) ) ; if ( contacts . hasNext ( ) ) buff . append ( " , ▁ " ) ; } return buff . append ( " ] " ) . toString ( ) ; } public void getRssURLList ( List < ContactRssImpl > rssURLList ) { Iterator < ContactGroup > subGroups = subgroups ( ) ; while ( subGroups . hasNext ( ) ) { ContactGroupRssImpl group = ( ContactGroupRssImpl ) subGroups . next ( ) ; group . getRssURLList ( rssURLList ) ; } Iterator < Contact > contacts = contacts ( ) ; while ( contacts . hasNext ( ) ) { ContactRssImpl contact = ( ContactRssImpl ) contacts . next ( ) ; rssURLList . add ( contact ) ; } } /* * STRNEWLINE ▁ * ▁ Specifies ▁ whether ▁ or ▁ not ▁ this ▁ contact ▁ group ▁ is ▁ being ▁ stored ▁ by ▁ the ▁ server . STRNEWLINE ▁ * ▁ Non ▁ persistent ▁ contact ▁ groups ▁ are ▁ common ▁ in ▁ the ▁ case ▁ of ▁ simple , STRNEWLINE ▁ * ▁ non - persistent ▁ presence ▁ operation ▁ sets . ▁ They ▁ could ▁ however ▁ also ▁ be ▁ seen STRNEWLINE ▁ * ▁ in ▁ persistent ▁ presence ▁ operation ▁ sets ▁ when ▁ for ▁ example ▁ we ▁ have ▁ received STRNEWLINE ▁ * ▁ an ▁ event ▁ from ▁ someone ▁ not ▁ on ▁ our ▁ contact ▁ list ▁ and ▁ the ▁ contact ▁ that ▁ we STRNEWLINE ▁ * ▁ associated ▁ with ▁ that ▁ user ▁ is ▁ placed ▁ in ▁ a ▁ non ▁ persistent ▁ group . ▁ Non STRNEWLINE ▁ * ▁ persistent ▁ contact ▁ groups ▁ are ▁ volatile ▁ even ▁ when ▁ coming ▁ from ▁ a ▁ persistent STRNEWLINE ▁ * ▁ presence ▁ op . ▁ set . ▁ They ▁ would ▁ only ▁ exist ▁ until ▁ the ▁ application ▁ is ▁ closed STRNEWLINE ▁ * ▁ and ▁ will ▁ not ▁ be ▁ there ▁ next ▁ time ▁ it ▁ is ▁ loaded . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ isPersistent ▁ true ▁ if ▁ the ▁ contact ▁ group ▁ is ▁ to ▁ be ▁ persistent ▁ and STRNEWLINE ▁ * ▁ false ▁ otherwise . STRNEWLINE ▁ */ public void setPersistent ( boolean isPersistent ) { this . isPersistent = isPersistent ; } /* * STRNEWLINE ▁ * ▁ Determines ▁ whether ▁ or ▁ not ▁ this ▁ contact ▁ group ▁ is ▁ being ▁ stored ▁ by ▁ the STRNEWLINE ▁ * ▁ server . ▁ Non ▁ persistent ▁ contact ▁ groups ▁ exist ▁ for ▁ the ▁ sole ▁ purpose ▁ of STRNEWLINE ▁ * ▁ containing ▁ non ▁ persistent ▁ contacts . STRNEWLINE ▁ * ▁ @ return ▁ true ▁ if ▁ the ▁ contact ▁ group ▁ is ▁ persistent ▁ and ▁ false ▁ otherwise . STRNEWLINE ▁ */ public boolean isPersistent ( ) { return isPersistent ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ null ▁ as ▁ no ▁ persistent ▁ data ▁ is ▁ required ▁ and ▁ the ▁ contact ▁ address ▁ is STRNEWLINE ▁ * ▁ sufficient ▁ for ▁ restoring ▁ the ▁ contact . STRNEWLINE ▁ * ▁ < p > STRNEWLINE ▁ * ▁ @ return ▁ null ▁ as ▁ no ▁ such ▁ data ▁ is ▁ needed . STRNEWLINE ▁ */ public String getPersistentData ( ) { return null ; } /* * STRNEWLINE ▁ * ▁ Determines ▁ whether ▁ or ▁ not ▁ this ▁ contact ▁ has ▁ been ▁ resolved ▁ against ▁ the STRNEWLINE ▁ * ▁ server . ▁ Unresolved ▁ contacts ▁ are ▁ used ▁ when ▁ initially ▁ loading ▁ a ▁ contact STRNEWLINE ▁ * ▁ list ▁ that ▁ has ▁ been ▁ stored ▁ in ▁ a ▁ local ▁ file ▁ until ▁ the ▁ presence ▁ operation STRNEWLINE ▁ * ▁ set ▁ has ▁ managed ▁ to ▁ retrieve ▁ all ▁ the ▁ contact ▁ list ▁ from ▁ the ▁ server ▁ and ▁ has STRNEWLINE ▁ * ▁ properly ▁ mapped ▁ contacts ▁ to ▁ their ▁ on - line ▁ buddies . STRNEWLINE ▁ * ▁ @ return ▁ true ▁ if ▁ the ▁ contact ▁ has ▁ been ▁ resolved ▁ ( mapped ▁ against ▁ a ▁ buddy ) STRNEWLINE ▁ * ▁ and ▁ false ▁ otherwise . STRNEWLINE ▁ */ public boolean isResolved ( ) { return isResolved ; } /* * STRNEWLINE ▁ * ▁ Makes ▁ the ▁ group ▁ resolved ▁ or ▁ unresolved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ param ▁ resolved ▁ true ▁ to ▁ make ▁ the ▁ group ▁ resolved ; ▁ false ▁ to STRNEWLINE ▁ * ▁ make ▁ it ▁ unresolved STRNEWLINE ▁ */ public void setResolved ( boolean resolved ) { this . isResolved = resolved ; } /* * STRNEWLINE ▁ * ▁ Returns ▁ a ▁ < tt > String < / tt > ▁ that ▁ uniquely ▁ represnets ▁ the ▁ group ▁ inside STRNEWLINE ▁ * ▁ the ▁ current ▁ protocol . ▁ The ▁ string ▁ MUST ▁ be ▁ persistent ▁ ( it ▁ must ▁ not ▁ change STRNEWLINE ▁ * ▁ across ▁ connections ▁ or ▁ runs ▁ of ▁ the ▁ application ) . ▁ In ▁ many ▁ cases ▁ ( Jabber , STRNEWLINE ▁ * ▁ ICQ ) ▁ the ▁ string ▁ may ▁ match ▁ the ▁ name ▁ of ▁ the ▁ group ▁ as ▁ these ▁ protocols STRNEWLINE ▁ * ▁ only ▁ allow ▁ a ▁ single ▁ level ▁ of ▁ contact ▁ groups ▁ and ▁ there ▁ is ▁ no ▁ danger ▁ of STRNEWLINE ▁ * ▁ having ▁ the ▁ same ▁ name ▁ twice ▁ in ▁ the ▁ same ▁ contact ▁ list . ▁ Other ▁ protocols STRNEWLINE ▁ * ▁ ( no ▁ examples ▁ come ▁ to ▁ mind ▁ but ▁ that ▁ doesn ' t ▁ bother ▁ me ▁ ; ) ▁ ) ▁ may ▁ be STRNEWLINE ▁ * ▁ supporting ▁ mutilple ▁ levels ▁ of ▁ grooups ▁ so ▁ it ▁ might ▁ be ▁ possible ▁ for ▁ group STRNEWLINE ▁ * ▁ A ▁ and ▁ group ▁ B ▁ to ▁ both ▁ contain ▁ groups ▁ named ▁ C . ▁ In ▁ such ▁ cases ▁ the STRNEWLINE ▁ * ▁ implementation ▁ must ▁ find ▁ a ▁ way ▁ to ▁ return ▁ a ▁ unique ▁ identifier ▁ in ▁ this STRNEWLINE ▁ * ▁ method ▁ and ▁ this ▁ UID ▁ should ▁ never ▁ change ▁ for ▁ a ▁ given ▁ group . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ @ return ▁ a ▁ String ▁ representing ▁ this ▁ group ▁ in ▁ a ▁ unique ▁ and ▁ persistent STRNEWLINE ▁ * ▁ way . STRNEWLINE ▁ */ public String getUID ( ) { return uid ; } /* * STRNEWLINE ▁ * ▁ Ugly ▁ but ▁ tricky ▁ conversion ▁ method . STRNEWLINE ▁ * ▁ @ param ▁ uid ▁ the ▁ uid ▁ we ' d ▁ like ▁ to ▁ get ▁ a ▁ name ▁ from STRNEWLINE ▁ * ▁ @ return ▁ the ▁ name ▁ of ▁ the ▁ group ▁ with ▁ the ▁ specified ▁ < tt > uid < / tt > . STRNEWLINE ▁ */ static String createNameFromUID ( String uid ) { return uid . substring ( 0 , uid . length ( ) - ( UID_SUFFIX . length ( ) ) ) ; } /* * STRNEWLINE ▁ * ▁ Indicates ▁ whether ▁ some ▁ other ▁ object ▁ is ▁ " equal ▁ to " ▁ this ▁ one ▁ which ▁ in ▁ terms STRNEWLINE ▁ * ▁ of ▁ contact ▁ groups ▁ translates ▁ to ▁ having ▁ the ▁ equal ▁ names ▁ and ▁ matching STRNEWLINE ▁ * ▁ subgroups ▁ and ▁ child ▁ contacts . ▁ The ▁ resolved ▁ status ▁ of ▁ contactgroups ▁ and STRNEWLINE ▁ * ▁ contacts ▁ is ▁ deliberately ▁ ignored ▁ so ▁ that ▁ groups ▁ and / or ▁ contacts ▁ would STRNEWLINE ▁ * ▁ be ▁ assumed ▁ equal ▁ even ▁ if ▁ it ▁ differs . STRNEWLINE ▁ * ▁ < p > STRNEWLINE ▁ * ▁ @ param ▁ obj ▁ the ▁ reference ▁ object ▁ with ▁ which ▁ to ▁ compare . STRNEWLINE ▁ * ▁ @ return ▁ < code > true < / code > ▁ if ▁ this ▁ contact ▁ group ▁ has ▁ the ▁ equal ▁ child STRNEWLINE ▁ * ▁ contacts ▁ and ▁ subgroups ▁ to ▁ those ▁ of ▁ the ▁ < code > obj < / code > ▁ argument . STRNEWLINE ▁ */ @ Override public boolean equals ( Object obj ) { if ( obj == null || ! ( obj instanceof ContactGroupRssImpl ) ) return false ; ContactGroupRssImpl rssGroup = ( ContactGroupRssImpl ) obj ; if ( ! rssGroup . getGroupName ( ) . equals ( getGroupName ( ) ) || ! rssGroup . getUID ( ) . equals ( getUID ( ) ) || rssGroup . countContacts ( ) != countContacts ( ) || rssGroup . countSubgroups ( ) != countSubgroups ( ) ) return false ; // traverse ▁ child ▁ contacts ENDCOM Iterator < Contact > theirContacts = rssGroup . contacts ( ) ; while ( theirContacts . hasNext ( ) ) { ContactRssImpl theirContact = ( ContactRssImpl ) theirContacts . next ( ) ; ContactRssImpl ourContact = ( ContactRssImpl ) getContact ( theirContact . getAddress ( ) ) ; if ( ourContact == null || ! ourContact . equals ( theirContact ) ) return false ; } // traverse ▁ subgroups ENDCOM Iterator < ContactGroup > theirSubgroups = rssGroup . subgroups ( ) ; while ( theirSubgroups . hasNext ( ) ) { ContactGroupRssImpl theirSubgroup = ( ContactGroupRssImpl ) theirSubgroups . next ( ) ; ContactGroupRssImpl ourSubgroup = ( ContactGroupRssImpl ) getGroup ( theirSubgroup . getGroupName ( ) ) ; if ( ourSubgroup == null || ! ourSubgroup . equals ( theirSubgroup ) ) return false ; } return true ; } } </DOCUMENT>
<DOCUMENT_ID="skyHALud/codenameone/tree/master/Ports/iOSPort/xmlvm/apache-harmony-6.0-src-r991881/classlib/modules/luni/src/test/api/common/org/apache/harmony/luni/tests/java/lang/ThreadTest.java"> /*  STRNEWLINE ▁ * ▁ Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ ( ASF ) ▁ under ▁ one ▁ or ▁ more STRNEWLINE ▁ * ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file ▁ distributed ▁ with STRNEWLINE ▁ * ▁ this ▁ work ▁ for ▁ additional ▁ information ▁ regarding ▁ copyright ▁ ownership .  STRNEWLINE ▁ * ▁ The ▁ ASF ▁ licenses ▁ this ▁ file ▁ to ▁ You ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 STRNEWLINE ▁ * ▁ ( the ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with STRNEWLINE ▁ * ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS ,  STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied .  STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License .  STRNEWLINE ▁ */ package org . apache . harmony . luni . tests . java . lang ; import java . lang . Thread . UncaughtExceptionHandler ; import java . security . Permission ; import java . util . Map ; public class ThreadTest extends junit . framework . TestCase { static class SimpleThread implements Runnable { int delay ; public void run ( ) { try { synchronized ( this ) { this . notify ( ) ; this . wait ( delay ) ; } } catch ( InterruptedException e ) { return ; } } public SimpleThread ( int d ) { if ( d >= 0 ) delay = d ; } } static class YieldThread implements Runnable { volatile int delay ; public void run ( ) { int x = 0 ; while ( true ) { ++ x ; } } public YieldThread ( int d ) { if ( d >= 0 ) delay = d ; } } static class ResSupThread implements Runnable { Thread parent ; volatile int checkVal = - 1 ; public void run ( ) { try { synchronized ( this ) { this . notify ( ) ; } while ( true ) { checkVal ++ ; zz ( ) ; Thread . sleep ( 100 ) ; } } catch ( InterruptedException e ) { return ; } catch ( BogusException e ) { try { // ▁ Give ▁ parent ▁ a ▁ chance ▁ to ▁ sleep ENDCOM Thread . sleep ( 500 ) ; } catch ( InterruptedException x ) { } parent . interrupt ( ) ; while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { // ▁ Don ' t ▁ hog ▁ the ▁ CPU ENDCOM try { Thread . sleep ( 50 ) ; } catch ( InterruptedException x ) { // ▁ This ▁ is ▁ what ▁ we ' ve ▁ been ▁ waiting ▁ for . . . don ' t ▁ throw ▁ it ENDCOM // ▁ away !  ENDCOM break ; } } } } public void zz ( ) throws BogusException { } public ResSupThread ( Thread t ) { parent = t ; } public synchronized int getCheckVal ( ) { return checkVal ; } } static class BogusException extends Throwable { private static final long serialVersionUID = 1L ; public BogusException ( String s ) { super ( s ) ; } } Thread st , ct , spinner ; static boolean calledMySecurityManager = false ; /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # Thread ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_Constructor ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . Thread ( )  ENDCOM Thread t ; SecurityManager m = new SecurityManager ( ) { @ Override public ThreadGroup getThreadGroup ( ) { calledMySecurityManager = true ; return Thread . currentThread ( ) . getThreadGroup ( ) ; } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } ; try { // ▁ To ▁ see ▁ if ▁ it ▁ checks ▁ Thread ▁ creation ▁ with ▁ our ▁ SecurityManager ENDCOM System . setSecurityManager ( m ) ; t = new Thread ( ) ; } finally { // ▁ restore ▁ original , ▁ no ▁ side - effects ENDCOM System . setSecurityManager ( null ) ; } assertTrue ( " Did ▁ not ▁ call ▁ SecurityManager . getThreadGroup ▁ ( ) " , calledMySecurityManager ) ; t . start ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # Thread ( java . lang . Runnable )  STRNEWLINE TABSYMBOL ▁ */ public void test_ConstructorLjava_lang_Runnable ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . Thread ( java . lang . Runnable )  ENDCOM ct = new Thread ( new SimpleThread ( 10 ) ) ; ct . start ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # Thread ( java . lang . Runnable , ▁ java . lang . String )  STRNEWLINE TABSYMBOL ▁ */ public void test_ConstructorLjava_lang_RunnableLjava_lang_String ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . Thread ( java . lang . Runnable ,  ENDCOM // ▁ java . lang . String )  ENDCOM Thread st1 = new Thread ( new SimpleThread ( 1 ) , " SimpleThread1" ) ; assertEquals ( " Constructed ▁ thread ▁ with ▁ incorrect ▁ thread ▁ name " , " SimpleThread1" , st1 . getName ( ) ) ; st1 . start ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # Thread ( java . lang . String )  STRNEWLINE TABSYMBOL ▁ */ public void test_ConstructorLjava_lang_String ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . Thread ( java . lang . String )  ENDCOM Thread t = new Thread ( " Testing " ) ; assertEquals ( " Created ▁ tread ▁ with ▁ incorrect ▁ name " , " Testing " , t . getName ( ) ) ; t . start ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # Thread ( java . lang . ThreadGroup , ▁ java . lang . Runnable )  STRNEWLINE TABSYMBOL ▁ */ public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_Runnable ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . Thread ( java . lang . ThreadGroup ,  ENDCOM // ▁ java . lang . Runnable )  ENDCOM ThreadGroup tg = new ThreadGroup ( " Test ▁ Group1" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread2" ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ group " , st . getThreadGroup ( ) == tg ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # Thread ( java . lang . ThreadGroup , ▁ java . lang . Runnable ,  STRNEWLINE TABSYMBOL ▁ * ▁ java . lang . String )  STRNEWLINE TABSYMBOL ▁ */ public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_RunnableLjava_lang_String ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . Thread ( java . lang . ThreadGroup ,  ENDCOM // ▁ java . lang . Runnable , ▁ java . lang . String )  ENDCOM ThreadGroup tg = new ThreadGroup ( " Test ▁ Group2" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread3" ) ; assertTrue ( " Constructed ▁ incorrect ▁ thread " , ( st . getThreadGroup ( ) == tg ) && st . getName ( ) . equals ( " SimpleThread3" ) ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; Runnable r = new Runnable ( ) { public void run ( ) { } } ; ThreadGroup foo = null ; try { new Thread ( foo = new ThreadGroup ( " foo " ) , r , null ) ; // ▁ Should ▁ not ▁ get ▁ here ENDCOM fail ( " Null ▁ cannot ▁ be ▁ accepted ▁ as ▁ Thread ▁ name " ) ; } catch ( NullPointerException npe ) { assertTrue ( " Null ▁ cannot ▁ be ▁ accepted ▁ as ▁ Thread ▁ name " , true ) ; foo . destroy ( ) ; } } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # Thread ( java . lang . ThreadGroup , ▁ java . lang . String )  STRNEWLINE TABSYMBOL ▁ */ public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_String ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . Thread ( java . lang . ThreadGroup ,  ENDCOM // ▁ java . lang . String )  ENDCOM st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread4" ) ; assertEquals ( " Returned ▁ incorrect ▁ thread ▁ name " , " SimpleThread4" , st . getName ( ) ) ; st . start ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # activeCount ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_activeCount ( ) { // ▁ Test ▁ for ▁ method ▁ int ▁ java . lang . Thread . activeCount ( )  ENDCOM Thread t = new Thread ( new SimpleThread ( 10 ) ) ; int active = 0 ; synchronized ( t ) { t . start ( ) ; active = Thread . activeCount ( ) ; } assertTrue ( " Incorrect ▁ activeCount ▁ for ▁ current ▁ group : ▁ " + active , active > 1 ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { } } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # checkAccess ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_checkAccess ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . checkAccess ( )  ENDCOM ThreadGroup tg = new ThreadGroup ( " Test ▁ Group3" ) ; try { st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread5" ) ; st . checkAccess ( ) ; assertTrue ( " CheckAccess ▁ passed " , true ) ; } catch ( SecurityException e ) { fail ( " CheckAccess ▁ failed ▁ : ▁ " + e . getMessage ( ) ) ; } st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; } /* *  STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # countStackFrames ( )  STRNEWLINE ▁ */ @ SuppressWarnings ( " deprecation " ) public void test_countStackFrames ( ) { /*  STRNEWLINE ▁ * ▁ Thread . countStackFrames ( ) ▁ is ▁ unpredictable , ▁ so ▁ we ▁ just ▁ test ▁ that ▁ it STRNEWLINE ▁ * ▁ doesn ' t ▁ throw ▁ an ▁ exception .  STRNEWLINE ▁ */ Thread . currentThread ( ) . countStackFrames ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # currentThread ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_currentThread ( ) { assertNotNull ( Thread . currentThread ( ) ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # destroy ( )  STRNEWLINE TABSYMBOL ▁ */ @ SuppressWarnings ( " deprecation " ) public void test_destroy ( ) { try { new Thread ( ) . destroy ( ) ; // ▁ FIXME ▁ uncomment ▁ when ▁ IBM ▁ VME ▁ is ▁ updated ENDCOM // fail ( " NoSuchMethodError ▁ was ▁ not ▁ thrown " ) ;  ENDCOM } catch ( NoSuchMethodError e ) { } } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # enumerate ( java . lang . Thread [ ] )  STRNEWLINE TABSYMBOL ▁ */ public void test_enumerate$Ljava_lang_Thread ( ) { // ▁ Test ▁ for ▁ method ▁ int ▁ java . lang . Thread . enumerate ( java . lang . Thread ▁ [ ] )  ENDCOM // ▁ The ▁ test ▁ has ▁ been ▁ updated ▁ according ▁ to ▁ HARMONY - 1974 ▁ JIRA ▁ issue .  ENDCOM class MyThread extends Thread { MyThread ( ThreadGroup tg , String name ) { super ( tg , name ) ; } boolean failed = false ; String failMessage = null ; public void run ( ) { SimpleThread st1 = null ; SimpleThread st2 = null ; ThreadGroup mytg = null ; Thread firstOne = null ; Thread secondOne = null ; try { int arrayLength = 10 ; Thread [ ] tarray = new Thread [ arrayLength ] ; st1 = new SimpleThread ( - 1 ) ; st2 = new SimpleThread ( - 1 ) ; mytg = new ThreadGroup ( " jp " ) ; firstOne = new Thread ( mytg , st1 , " firstOne2" ) ; secondOne = new Thread ( mytg , st2 , " secondOne1" ) ; int count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned1" , 1 , count ) ; synchronized ( st1 ) { firstOne . start ( ) ; try { st1 . wait ( ) ; } catch ( InterruptedException e ) { } } count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned2" , 2 , count ) ; synchronized ( st2 ) { secondOne . start ( ) ; try { st2 . wait ( ) ; } catch ( InterruptedException e ) { } } count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned3" , 3 , count ) ; } catch ( junit . framework . AssertionFailedError e ) { failed = true ; failMessage = e . getMessage ( ) ; } finally { synchronized ( st1 ) { firstOne . interrupt ( ) ; } synchronized ( st2 ) { secondOne . interrupt ( ) ; } try { firstOne . join ( ) ; secondOne . join ( ) ; } catch ( InterruptedException e ) { } mytg . destroy ( ) ; } } } ; ThreadGroup tg = new ThreadGroup ( " tg " ) ; MyThread t = new MyThread ( tg , " top " ) ; t . start ( ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt " ) ; } finally { tg . destroy ( ) ; } assertFalse ( t . failMessage , t . failed ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # getContextClassLoader ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_getContextClassLoader ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . ClassLoader ENDCOM // ▁ java . lang . Thread . getContextClassLoader ( )  ENDCOM Thread t = new Thread ( ) ; assertTrue ( " Incorrect ▁ class ▁ loader ▁ returned " , t . getContextClassLoader ( ) == Thread . currentThread ( ) . getContextClassLoader ( ) ) ; t . start ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # getName ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_getName ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . String ▁ java . lang . Thread . getName ( )  ENDCOM st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread6" ) ; assertEquals ( " Returned ▁ incorrect ▁ thread ▁ name " , " SimpleThread6" , st . getName ( ) ) ; st . start ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # getPriority ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_getPriority ( ) { // ▁ Test ▁ for ▁ method ▁ int ▁ java . lang . Thread . getPriority ( )  ENDCOM st = new Thread ( new SimpleThread ( 1 ) ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ priority " , st . getPriority ( ) == Thread . MAX_PRIORITY ) ; st . start ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # getThreadGroup ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_getThreadGroup ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . ThreadGroup ENDCOM // ▁ java . lang . Thread . getThreadGroup ( )  ENDCOM ThreadGroup tg = new ThreadGroup ( " Test ▁ Group4" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread8" ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ group " , st . getThreadGroup ( ) == tg ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } assertNull ( " group ▁ should ▁ be ▁ null " , st . getThreadGroup ( ) ) ; assertNotNull ( " toString ( ) ▁ should ▁ not ▁ be ▁ null " , st . toString ( ) ) ; tg . destroy ( ) ; final Object lock = new Object ( ) ; Thread t = new Thread ( ) { @ Override public void run ( ) { synchronized ( lock ) { lock . notifyAll ( ) ; } } } ; synchronized ( lock ) { t . start ( ) ; try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } int running = 0 ; while ( t . isAlive ( ) ) running ++ ; ThreadGroup group = t . getThreadGroup ( ) ; assertNull ( " ThreadGroup ▁ is ▁ not ▁ null " , group ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # interrupt ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_interrupt ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . interrupt ( )  ENDCOM final Object lock = new Object ( ) ; class ChildThread1 extends Thread { Thread parent ; boolean sync ; @ Override public void run ( ) { if ( sync ) { synchronized ( lock ) { lock . notify ( ) ; try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } } parent . interrupt ( ) ; } public ChildThread1 ( Thread p , String name , boolean sync ) { super ( name ) ; parent = p ; this . sync = sync ; } } boolean interrupted = false ; try { ct = new ChildThread1 ( Thread . currentThread ( ) , " Interrupt ▁ Test1" , false ) ; synchronized ( lock ) { ct . start ( ) ; lock . wait ( ) ; } } catch ( InterruptedException e ) { interrupted = true ; } assertTrue ( " Failed ▁ to ▁ Interrupt ▁ thread1" , interrupted ) ; interrupted = false ; try { ct = new ChildThread1 ( Thread . currentThread ( ) , " Interrupt ▁ Test2" , true ) ; synchronized ( lock ) { ct . start ( ) ; lock . wait ( ) ; lock . notify ( ) ; } Thread . sleep ( 20000 ) ; } catch ( InterruptedException e ) { interrupted = true ; } assertTrue ( " Failed ▁ to ▁ Interrupt ▁ thread2" , interrupted ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # interrupted ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_interrupted ( ) { assertFalse ( " Interrupted ▁ returned ▁ true ▁ for ▁ non - interrupted ▁ thread " , Thread . interrupted ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; assertTrue ( " Interrupted ▁ returned ▁ true ▁ for ▁ non - interrupted ▁ thread " , Thread . interrupted ( ) ) ; assertFalse ( " Failed ▁ to ▁ clear ▁ interrupted ▁ flag " , Thread . interrupted ( ) ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # isAlive ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_isAlive ( ) { // ▁ Test ▁ for ▁ method ▁ boolean ▁ java . lang . Thread . isAlive ( )  ENDCOM SimpleThread simple ; st = new Thread ( simple = new SimpleThread ( 500 ) ) ; assertFalse ( " A ▁ thread ▁ that ▁ wasn ' t ▁ started ▁ is ▁ alive . " , st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; try { simple . wait ( ) ; } catch ( InterruptedException e ) { } } assertTrue ( " Started ▁ thread ▁ returned ▁ false " , st . isAlive ( ) ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { fail ( " Thread ▁ did ▁ not ▁ die " ) ; } assertTrue ( " Stopped ▁ thread ▁ returned ▁ true " , ! st . isAlive ( ) ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # isDaemon ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_isDaemon ( ) { // ▁ Test ▁ for ▁ method ▁ boolean ▁ java . lang . Thread . isDaemon ( )  ENDCOM st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread10" ) ; assertTrue ( " Non - Daemon ▁ thread ▁ returned ▁ true " , ! st . isDaemon ( ) ) ; st . setDaemon ( true ) ; assertTrue ( " Daemon ▁ thread ▁ returned ▁ false " , st . isDaemon ( ) ) ; st . start ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # isInterrupted ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_isInterrupted ( ) { // ▁ Test ▁ for ▁ method ▁ boolean ▁ java . lang . Thread . isInterrupted ( )  ENDCOM class SpinThread implements Runnable { public volatile boolean done = false ; public void run ( ) { while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) ; while ( ! done ) ; } } SpinThread spin = new SpinThread ( ) ; spinner = new Thread ( spin ) ; spinner . start ( ) ; Thread . yield ( ) ; try { assertTrue ( " Non - Interrupted ▁ thread ▁ returned ▁ true " , ! spinner . isInterrupted ( ) ) ; spinner . interrupt ( ) ; assertTrue ( " Interrupted ▁ thread ▁ returned ▁ false " , spinner . isInterrupted ( ) ) ; spin . done = true ; } finally { spinner . interrupt ( ) ; spin . done = true ; } } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # join ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_join ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . join ( )  ENDCOM SimpleThread simple ; try { st = new Thread ( simple = new SimpleThread ( 100 ) ) ; // ▁ cause ▁ isAlive ( ) ▁ to ▁ be ▁ compiled ▁ by ▁ the ▁ JIT , ▁ as ▁ it ▁ must ▁ be ▁ called ENDCOM // ▁ within ▁ 100ms ▁ below .  ENDCOM assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ " ) ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! st . isAlive ( ) ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { th . join ( ) ; } catch ( InterruptedException e ) { result = false ; } assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # join ( long )  STRNEWLINE TABSYMBOL ▁ */ public void test_joinJ ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . join ( long )  ENDCOM SimpleThread simple ; try { st = new Thread ( simple = new SimpleThread ( 1000 ) , " SimpleThread12" ) ; // ▁ cause ▁ isAlive ( ) ▁ to ▁ be ▁ compiled ▁ by ▁ the ▁ JIT , ▁ as ▁ it ▁ must ▁ be ▁ called ENDCOM // ▁ within ▁ 100ms ▁ below .  ENDCOM assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( 10 ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ " ) ; } assertTrue ( " Join ▁ failed ▁ to ▁ timeout " , st . isAlive ( ) ) ; st . interrupt ( ) ; try { st = new Thread ( simple = new SimpleThread ( 100 ) , " SimpleThread13" ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( 1000 ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ : ▁ " + e . getMessage ( ) ) ; return ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! st . isAlive ( ) ) ; final Object lock = new Object ( ) ; final Thread main = Thread . currentThread ( ) ; Thread killer = new Thread ( new Runnable ( ) { public void run ( ) { try { synchronized ( lock ) { lock . notify ( ) ; } Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { return ; } main . interrupt ( ) ; } } ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { synchronized ( lock ) { killer . start ( ) ; lock . wait ( ) ; } th . join ( 200 ) ; } catch ( InterruptedException e ) { result = false ; } killer . interrupt ( ) ; assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # join ( long , ▁ int )  STRNEWLINE TABSYMBOL ▁ */ public void test_joinJI ( ) throws Exception { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . join ( long , ▁ int )  ENDCOM SimpleThread simple ; st = new Thread ( simple = new SimpleThread ( 1000 ) , " Squawk1" ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } long firstRead = System . currentTimeMillis ( ) ; st . join ( 100 , 999999 ) ; long secondRead = System . currentTimeMillis ( ) ; assertTrue ( " Did ▁ not ▁ join ▁ by ▁ appropriate ▁ time : ▁ " + secondRead + " - " + firstRead + " = " + ( secondRead - firstRead ) , secondRead - firstRead <= 300 ) ; assertTrue ( " Joined ▁ thread ▁ is ▁ not ▁ alive " , st . isAlive ( ) ) ; st . interrupt ( ) ; final Object lock = new Object ( ) ; final Thread main = Thread . currentThread ( ) ; Thread killer = new Thread ( new Runnable ( ) { public void run ( ) { try { synchronized ( lock ) { lock . notify ( ) ; } Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { return ; } main . interrupt ( ) ; } } ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { synchronized ( lock ) { killer . start ( ) ; lock . wait ( ) ; } th . join ( 200 , 20 ) ; } catch ( InterruptedException e ) { result = false ; } killer . interrupt ( ) ; assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # resume ( )  STRNEWLINE TABSYMBOL ▁ */ @ SuppressWarnings ( " deprecation " ) public void test_resume ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . resume ( )  ENDCOM int orgval ; ResSupThread t ; try { t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { ct = new Thread ( t , " Interrupt ▁ Test2" ) ; ct . start ( ) ; t . wait ( ) ; } ct . suspend ( ) ; // ▁ Wait ▁ to ▁ be ▁ sure ▁ the ▁ suspend ▁ has ▁ occurred ENDCOM Thread . sleep ( 500 ) ; orgval = t . getCheckVal ( ) ; // ▁ Wait ▁ to ▁ be ▁ sure ▁ the ▁ thread ▁ is ▁ suspended ENDCOM Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ suspend ▁ thread " , orgval == t . getCheckVal ( ) ) ; ct . resume ( ) ; // ▁ Wait ▁ to ▁ be ▁ sure ▁ the ▁ resume ▁ has ▁ occurred .  ENDCOM Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ resume ▁ thread " , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred ▁ : ▁ " + e . getMessage ( ) ) ; } } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # run ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_run ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . run ( )  ENDCOM class RunThread implements Runnable { boolean didThreadRun = false ; public void run ( ) { didThreadRun = true ; } } RunThread rt = new RunThread ( ) ; Thread t = new Thread ( rt ) ; try { t . start ( ) ; int count = 0 ; while ( ! rt . didThreadRun && count < 20 ) { Thread . sleep ( 100 ) ; count ++ ; } assertTrue ( " Thread ▁ did ▁ not ▁ run " , rt . didThreadRun ) ; t . join ( ) ; } catch ( InterruptedException e ) { assertTrue ( " Joined ▁ thread ▁ was ▁ interrupted " , true ) ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! t . isAlive ( ) ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # setDaemon ( boolean )  STRNEWLINE TABSYMBOL ▁ */ public void test_setDaemonZ ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . setDaemon ( boolean )  ENDCOM st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread14" ) ; st . setDaemon ( true ) ; assertTrue ( " Failed ▁ to ▁ set ▁ thread ▁ as ▁ daemon ▁ thread " , st . isDaemon ( ) ) ; st . start ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # setName ( java . lang . String )  STRNEWLINE TABSYMBOL ▁ */ public void test_setNameLjava_lang_String ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . setName ( java . lang . String )  ENDCOM st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread15" ) ; st . setName ( " Bogus ▁ Name " ) ; assertEquals ( " Failed ▁ to ▁ set ▁ thread ▁ name " , " Bogus ▁ Name " , st . getName ( ) ) ; try { st . setName ( null ) ; fail ( " Null ▁ should ▁ not ▁ be ▁ accepted ▁ as ▁ a ▁ valid ▁ name " ) ; } catch ( NullPointerException e ) { // ▁ success ENDCOM assertTrue ( " Null ▁ should ▁ not ▁ be ▁ accepted ▁ as ▁ a ▁ valid ▁ name " , true ) ; } st . start ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # setPriority ( int )  STRNEWLINE TABSYMBOL ▁ */ public void test_setPriorityI ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . setPriority ( int )  ENDCOM st = new Thread ( new SimpleThread ( 1 ) ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; assertTrue ( " Failed ▁ to ▁ set ▁ priority " , st . getPriority ( ) == Thread . MAX_PRIORITY ) ; st . start ( ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # sleep ( long )  STRNEWLINE TABSYMBOL ▁ */ public void test_sleepJ ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . sleep ( long )  ENDCOM // ▁ TODO ▁ : ▁ Test ▁ needs ▁ enhancing .  ENDCOM long stime = 0 , ftime = 0 ; try { stime = System . currentTimeMillis ( ) ; Thread . sleep ( 1000 ) ; ftime = System . currentTimeMillis ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } assertTrue ( " Failed ▁ to ▁ sleep ▁ long ▁ enough " , ( ftime - stime ) >= 800 ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # sleep ( long , ▁ int )  STRNEWLINE TABSYMBOL ▁ */ public void test_sleepJI ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . sleep ( long , ▁ int )  ENDCOM // ▁ TODO ▁ : ▁ Test ▁ needs ▁ revisiting .  ENDCOM long stime = 0 , ftime = 0 ; try { stime = System . currentTimeMillis ( ) ; Thread . sleep ( 1000 , 999999 ) ; ftime = System . currentTimeMillis ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } long result = ftime - stime ; assertTrue ( " Failed ▁ to ▁ sleep ▁ long ▁ enough : ▁ " + result , result >= 900 && result <= 1100 ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # start ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_start ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . start ( )  ENDCOM try { ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { ct = new Thread ( t , " Interrupt ▁ Test4" ) ; ct . start ( ) ; t . wait ( ) ; } assertTrue ( " Thread ▁ is ▁ not ▁ running1" , ct . isAlive ( ) ) ; // ▁ Let ▁ the ▁ child ▁ thread ▁ get ▁ going .  ENDCOM int orgval = t . getCheckVal ( ) ; Thread . sleep ( 150 ) ; assertTrue ( " Thread ▁ is ▁ not ▁ running2" , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred " ) ; } } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # stop ( )  STRNEWLINE TABSYMBOL ▁ */ @ SuppressWarnings ( " deprecation " ) public void test_stop ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . stop ( )  ENDCOM try { Runnable r = new ResSupThread ( null ) ; synchronized ( r ) { st = new Thread ( r , " Interupt ▁ Test5" ) ; st . start ( ) ; r . wait ( ) ; } } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } st . stop ( ) ; try { st . join ( 10000 ) ; } catch ( InterruptedException e1 ) { st . interrupt ( ) ; fail ( " Failed ▁ to ▁ stopThread ▁ before ▁ 10000 ▁ timeout " ) ; } assertTrue ( " Failed ▁ to ▁ stopThread " , ! st . isAlive ( ) ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # stop ( )  STRNEWLINE TABSYMBOL ▁ */ @ SuppressWarnings ( " deprecation " ) public void test_stop_subtest0 ( ) { Thread t = new Thread ( " t " ) ; class MySecurityManager extends SecurityManager { public boolean intest = false ; @ Override public void checkAccess ( Thread t ) { if ( intest ) { fail ( " checkAccess ▁ called " ) ; } } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } MySecurityManager sm = new MySecurityManager ( ) ; System . setSecurityManager ( sm ) ; try { sm . intest = true ; try { t . stop ( ) ; // ▁ Ignore ▁ any ▁ SecurityExceptions , ▁ may ▁ not ▁ have ▁ stopThread ENDCOM // ▁ permission ENDCOM } catch ( SecurityException e ) { } sm . intest = false ; t . start ( ) ; try { t . join ( 2000 ) ; } catch ( InterruptedException e ) { } sm . intest = true ; try { t . stop ( ) ; // ▁ Ignore ▁ any ▁ SecurityExceptions , ▁ may ▁ not ▁ have ▁ stopThread ENDCOM // ▁ permission ENDCOM } catch ( SecurityException e ) { } sm . intest = false ; } finally { System . setSecurityManager ( null ) ; } } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # stop ( java . lang . Throwable )  STRNEWLINE TABSYMBOL ▁ */ @ SuppressWarnings ( " deprecation " ) public void test_stopLjava_lang_Throwable_subtest0 ( ) { Thread t = new Thread ( " t " ) ; class MySecurityManager extends SecurityManager { public boolean intest = false ; public boolean checkAccess = false ; @ Override public void checkAccess ( Thread t ) { if ( intest ) { checkAccess = true ; } } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } MySecurityManager sm = new MySecurityManager ( ) ; System . setSecurityManager ( sm ) ; try { sm . intest = true ; try { t . stop ( new ThreadDeath ( ) ) ; // ▁ Ignore ▁ any ▁ SecurityExceptions , ▁ may ▁ not ▁ have ▁ stopThread ENDCOM // ▁ permission ENDCOM } catch ( SecurityException e ) { } sm . intest = false ; assertTrue ( " no ▁ checkAccess ▁ 1" , sm . checkAccess ) ; t . start ( ) ; try { t . join ( 2000 ) ; } catch ( InterruptedException e ) { } sm . intest = true ; sm . checkAccess = false ; try { t . stop ( new ThreadDeath ( ) ) ; // ▁ Ignore ▁ any ▁ SecurityExceptions , ▁ may ▁ not ▁ have ▁ stopThread ENDCOM // ▁ permission ENDCOM } catch ( SecurityException e ) { } assertTrue ( " no ▁ checkAccess ▁ 2" , sm . checkAccess ) ; sm . intest = false ; } finally { System . setSecurityManager ( null ) ; } } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # stop ( java . lang . Throwable )  STRNEWLINE TABSYMBOL ▁ */ @ SuppressWarnings ( " deprecation " ) public void test_stopLjava_lang_Throwable ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . stop ( java . lang . Throwable )  ENDCOM ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { st = new Thread ( t , " StopThread " ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; st . start ( ) ; try { t . wait ( ) ; } catch ( InterruptedException e ) { } } try { st . stop ( new BogusException ( " Bogus " ) ) ; Thread . sleep ( 20000 ) ; } catch ( InterruptedException e ) { assertTrue ( " Stopped ▁ child ▁ with ▁ exception ▁ not ▁ alive " , st . isAlive ( ) ) ; st . interrupt ( ) ; return ; } st . interrupt ( ) ; fail ( " Stopped ▁ child ▁ did ▁ not ▁ throw ▁ exception " ) ; } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # suspend ( )  STRNEWLINE TABSYMBOL ▁ */ @ SuppressWarnings ( " deprecation " ) public void test_suspend ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . suspend ( )  ENDCOM int orgval ; ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; try { synchronized ( t ) { ct = new Thread ( t , " Interupt ▁ Test6" ) ; ct . start ( ) ; t . wait ( ) ; } ct . suspend ( ) ; // ▁ Wait ▁ to ▁ be ▁ sure ▁ the ▁ suspend ▁ has ▁ occurred ENDCOM Thread . sleep ( 500 ) ; orgval = t . getCheckVal ( ) ; // ▁ Wait ▁ to ▁ be ▁ sure ▁ the ▁ thread ▁ is ▁ suspended ENDCOM Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ suspend ▁ thread " , orgval == t . getCheckVal ( ) ) ; ct . resume ( ) ; // ▁ Wait ▁ to ▁ be ▁ sure ▁ the ▁ resume ▁ has ▁ occurred .  ENDCOM Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ resume ▁ thread " , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred " ) ; } final Object notify = new Object ( ) ; Thread t1 = new Thread ( new Runnable ( ) { public void run ( ) { synchronized ( notify ) { notify . notify ( ) ; } Thread . currentThread ( ) . suspend ( ) ; } } ) ; try { synchronized ( notify ) { t1 . start ( ) ; notify . wait ( ) ; } // ▁ wait ▁ for ▁ Thread ▁ to ▁ suspend ENDCOM Thread . sleep ( 500 ) ; assertTrue ( " Thread ▁ should ▁ be ▁ alive " , t1 . isAlive ( ) ) ; t1 . resume ( ) ; t1 . join ( ) ; } catch ( InterruptedException e ) { } } /* *  STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # toString ( )  STRNEWLINE TABSYMBOL ▁ */ public void test_toString ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . String ▁ java . lang . Thread . toString ( )  ENDCOM ThreadGroup tg = new ThreadGroup ( " Test ▁ Group5" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread17" ) ; final String stString = st . toString ( ) ; final String expected = " Thread [ SimpleThread17,5 , Test ▁ Group5 ] " ; assertTrue ( " Returned ▁ incorrect ▁ string : ▁ " + stString + " \t ( expecting ▁ : " + expected + " ) " , stString . equals ( expected ) ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; } /* *  STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # getAllStackTraces ( )  STRNEWLINE ▁ */ public void test_getAllStackTraces ( ) { Map < Thread , StackTraceElement [ ] > stMap = Thread . getAllStackTraces ( ) ; assertNotNull ( stMap ) ; // TODO ▁ add ▁ security - based ▁ tests ENDCOM } /* *  STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # getDefaultUncaughtExceptionHandler STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # setDefaultUncaughtExceptionHandler STRNEWLINE ▁ */ public void test_get_setDefaultUncaughtExceptionHandler ( ) { class Handler implements UncaughtExceptionHandler { public void uncaughtException ( Thread thread , Throwable ex ) { } } final Handler handler = new Handler ( ) ; Thread . setDefaultUncaughtExceptionHandler ( handler ) ; assertSame ( handler , Thread . getDefaultUncaughtExceptionHandler ( ) ) ; Thread . setDefaultUncaughtExceptionHandler ( null ) ; assertNull ( Thread . getDefaultUncaughtExceptionHandler ( ) ) ; // TODO ▁ add ▁ security - based ▁ tests ENDCOM } /* *  STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # getStackTrace ( )  STRNEWLINE ▁ */ public void test_getStackTrace ( ) { StackTraceElement [ ] stackTrace = Thread . currentThread ( ) . getStackTrace ( ) ; assertNotNull ( stackTrace ) ; stack_trace_loop : { for ( int i = 0 ; i < stackTrace . length ; i ++ ) { StackTraceElement e = stackTrace [ i ] ; if ( getClass ( ) . getName ( ) . equals ( e . getClassName ( ) ) ) { if ( " test _ getStackTrace " . equals ( e . getMethodName ( ) ) ) { break stack_trace_loop ; } } } fail ( " class ▁ and ▁ method ▁ not ▁ found ▁ in ▁ stack ▁ trace " ) ; } // TODO ▁ add ▁ security - based ▁ tests ENDCOM } /* *  STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # getState ( )  STRNEWLINE ▁ */ public void test_getState ( ) { Thread . State state = Thread . currentThread ( ) . getState ( ) ; assertNotNull ( state ) ; assertEquals ( Thread . State . RUNNABLE , state ) ; // TODO ▁ add ▁ additional ▁ state ▁ tests ENDCOM } /* *  STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # getUncaughtExceptionHandler STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # setUncaughtExceptionHandler STRNEWLINE ▁ */ public void test_get_setUncaughtExceptionHandler ( ) { class Handler implements UncaughtExceptionHandler { public void uncaughtException ( Thread thread , Throwable ex ) { } } final Handler handler = new Handler ( ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( handler ) ; assertSame ( handler , Thread . currentThread ( ) . getUncaughtExceptionHandler ( ) ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( null ) ; // TODO ▁ add ▁ security - based ▁ tests ENDCOM } /* *  STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # getId ( )  STRNEWLINE ▁ */ public void test_getId ( ) { assertTrue ( " current ▁ thread ' s ▁ ID ▁ is ▁ not ▁ positive " , Thread . currentThread ( ) . getId ( ) > 0 ) ; // check ▁ all ▁ the ▁ current ▁ threads ▁ for ▁ positive ▁ IDs ENDCOM Map < Thread , StackTraceElement [ ] > stMap = Thread . getAllStackTraces ( ) ; for ( Thread thread : stMap . keySet ( ) ) { assertTrue ( " thread ' s ▁ ID ▁ is ▁ not ▁ positive : ▁ " + thread . getName ( ) , thread . getId ( ) > 0 ) ; } } @ Override protected void tearDown ( ) { try { if ( st != null ) st . interrupt ( ) ; } catch ( Exception e ) { } try { if ( spinner != null ) spinner . interrupt ( ) ; } catch ( Exception e ) { } try { if ( ct != null ) ct . interrupt ( ) ; } catch ( Exception e ) { } try { spinner = null ; st = null ; ct = null ; System . runFinalization ( ) ; } catch ( Exception e ) { } } } </DOCUMENT>
